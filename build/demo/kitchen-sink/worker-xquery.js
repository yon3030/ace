"no use strict";

var console = {
    log: function(msg) {
        postMessage({type: "log", data: msg});
    }
};
var window = {
    console: console
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative requires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        var moduleName = base + "/" + moduleName;
        
        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            var moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    
    return moduleName;
};

var require = function(parentId, id) {
    var id = normalizeModule(parentId, id);
    
    var module = require.modules[id];
    if (module) {
        if (!module.initialized) {
            module.exports = module.factory().exports;
            module.initialized = true;
        }
        return module.exports;
    }
    
    var chunks = id.split("/");
    chunks[0] = require.tlns[chunks[0]] || chunks[0];
    var path = chunks.join("/") + ".js";
    
    require.id = id;
    importScripts(path);
    return require(parentId, id);    
};

require.modules = {};
require.tlns = {};

var define = function(id, deps, factory) {
    if (arguments.length == 2) {
        factory = deps;
    } else if (arguments.length == 1) {
        factory = id;
        id = require.id;
    }

    if (id.indexOf("text!") === 0) 
        return;
    
    var req = function(deps, factory) {
        return require(id, deps, factory);
    };

    require.modules[id] = {
        factory: function() {
            var module = {
                exports: {}
            };
            var returnExports = factory(req, module.exports, module);
            if (returnExports)
                module.exports = returnExports;
            return module;
        }
    };
};

function initBaseUrls(topLevelNamespaces) {
    require.tlns = topLevelNamespaces;
}

function initSender() {

    var EventEmitter = require(null, "ace/lib/event_emitter").EventEmitter;
    var oop = require(null, "ace/lib/oop");
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: "call",
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: "event",
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
}

var main;
var sender;

onmessage = function(e) {
    var msg = e.data;
    if (msg.command) {
        main[msg.command].apply(main, msg.args);
    }
    else if (msg.init) {        
        initBaseUrls(msg.tlns);
        require(null, "ace/lib/fixoldbrowsers");
        sender = initSender();
        var clazz = require(null, msg.module)[msg.classname];
        main = new clazz(sender);
    } 
    else if (msg.event && sender) {
        sender._emit(msg.event, msg.data);
    }
};
// vim:set ts=4 sts=4 sw=4 st:
// -- kriskowal Kris Kowal Copyright (C) 2009-2010 MIT License
// -- tlrobinson Tom Robinson Copyright (C) 2009-2010 MIT License (Narwhal Project)
// -- dantman Daniel Friesen Copyright(C) 2010 XXX No License Specified
// -- fschaefer Florian Schäfer Copyright (C) 2010 MIT License
// -- Irakli Gozalishvili Copyright (C) 2010 MIT License

/*!
    Copyright (c) 2009, 280 North Inc. http://280north.com/
    MIT License. http://github.com/280north/narwhal/blob/master/README.md
*/

define('ace/lib/fixoldbrowsers', ['require', 'exports', 'module' , 'ace/lib/regexp', 'ace/lib/es5-shim'], function(require, exports, module) {
"use strict";

require("./regexp");
require("./es5-shim");

});/**
 *  Based on code from:
 *
 * XRegExp 1.5.0
 * (c) 2007-2010 Steven Levithan
 * MIT License
 * <http://xregexp.com>
 * Provides an augmented, extensible, cross-browser implementation of regular expressions,
 * including support for additional syntax, flags, and methods
 */
 
define('ace/lib/regexp', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

    //---------------------------------
    //  Private variables
    //---------------------------------

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    //---------------------------------
    //  Overriden native methods
    //---------------------------------

    // Adds named capture support (with backreferences returned as `result.name`), and fixes two
    // cross-browser issues per ES3:
    // - Captured values for nonparticipating capturing groups should be returned as `undefined`,
    //   rather than the empty string.
    // - `lastIndex` should not be incremented after zero-length matches.
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            // Fix browsers whose `exec` methods don't consistently return `undefined` for
            // nonparticipating capturing groups
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
                // matching due to characters outside the match
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            // Attach named capture properties
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };

    // Don't override `test` if it won't change anything
    if (!compliantLastIndexIncrement) {
        // Fix browser bug in native method
        RegExp.prototype.test = function (str) {
            // Use the native `exec` to skip some processing overhead, even though the overriden
            // `exec` would take care of the `lastIndex` fix
            var match = real.exec.call(this, str);
            // Fix browsers that increment `lastIndex` after zero-length matches
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    //---------------------------------
    //  Private helper functions
    //---------------------------------

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    };

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    };

});
// vim: ts=4 sts=4 sw=4 expandtab
// -- kriskowal Kris Kowal Copyright (C) 2009-2011 MIT License
// -- tlrobinson Tom Robinson Copyright (C) 2009-2010 MIT License (Narwhal Project)
// -- dantman Daniel Friesen Copyright (C) 2010 XXX TODO License or CLA
// -- fschaefer Florian Schäfer Copyright (C) 2010 MIT License
// -- Gozala Irakli Gozalishvili Copyright (C) 2010 MIT License
// -- kitcambridge Kit Cambridge Copyright (C) 2011 MIT License
// -- kossnocorp Sasha Koss XXX TODO License or CLA
// -- bryanforbes Bryan Forbes XXX TODO License or CLA
// -- killdream Quildreen Motta Copyright (C) 2011 MIT Licence
// -- michaelficarra Michael Ficarra Copyright (C) 2011 3-clause BSD License
// -- sharkbrainguy Gerard Paapu Copyright (C) 2011 MIT License
// -- bbqsrc Brendan Molloy (C) 2011 Creative Commons Zero (public domain)
// -- iwyg XXX TODO License or CLA
// -- DomenicDenicola Domenic Denicola Copyright (C) 2011 MIT License
// -- xavierm02 Montillet Xavier XXX TODO License or CLA
// -- Raynos Raynos XXX TODO License or CLA
// -- samsonjs Sami Samhuri Copyright (C) 2010 MIT License
// -- rwldrn Rick Waldron Copyright (C) 2011 MIT License
// -- lexer Alexey Zakharov XXX TODO License or CLA

/*!
    Copyright (c) 2009, 280 North Inc. http://280north.com/
    MIT License. http://github.com/280north/narwhal/blob/master/README.md
*/

define('ace/lib/es5-shim', ['require', 'exports', 'module' ], function(require, exports, module) {

/**
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 *
 * @module
 */

/*whatsupdoc*/

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (typeof target != "function")
            throw new TypeError(); // TODO message
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var bound = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal 
                //   method of target providing args as the arguments.

                var F = function(){};
                F.prototype = target.prototype;
                var self = new F;

                var result = target.apply(
                    self,
                    args.concat(slice.call(arguments))
                );
                if (result !== null && Object(result) === result)
                    return result;
                return self;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the 
                //   list boundArgs in the same order followed by the same 
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method 
                //   of target providing boundThis as the this value and 
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        // XXX bound.length is never writable, so don't even try
        //
        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is 
        //       larger.
        // 16. Else set the length own property of F to 0.
        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.
        
        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with 
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and 
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with 
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower, 
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not 
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    };
}

// Shortcut to an often accessed properties, in order to avoid multiple
// dereference that costs universally.
// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
// us it in defining shortcuts.
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);

// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return toString(obj) == "[object Array]";
    };
}

// The IsCallable() check in the Array functions
// has been replaced with a strict check on the
// internal class of the object to trap cases where
// the provided function was actually a regular
// expression literal, which in V8 and
// JavaScriptCore is a typeof "function".  Only in
// V8 are regular expression literals permitted as
// reduce parameters, so it is desirable in the
// general case for the shim to match the more
// strict and common behavior of rejecting regular
// expressions.

// ES5 15.4.4.18
// http://es5.github.com/#x15.4.4.18
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var self = toObject(this),
            thisp = arguments[1],
            i = 0,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object context
                fun.call(thisp, self[i], i, self);
            }
            i++;
        }
    };
}

// ES5 15.4.4.19
// http://es5.github.com/#x15.4.4.19
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var self = toObject(this),
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, self);
        }
        return result;
    };
}

// ES5 15.4.4.20
// http://es5.github.com/#x15.4.4.20
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            result = [],
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, self))
                result.push(self[i]);
        }
        return result;
    };
}

// ES5 15.4.4.16
// http://es5.github.com/#x15.4.4.16
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, self))
                return false;
        }
        return true;
    };
}

// ES5 15.4.4.17
// http://es5.github.com/#x15.4.4.17
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var self = toObject(this),
            length = self.length >>> 0,
            thisp = arguments[1];

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, self))
                return true;
        }
        return false;
    };
}

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var self = toObject(this),
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        // no value to return if no initial value and an empty array
        if (!length && arguments.length == 1)
            throw new TypeError(); // TODO message

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }

                // if array contains no values, no initial value to return
                if (++i >= length)
                    throw new TypeError(); // TODO message
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self)
                result = fun.call(void 0, result, self[i], i, self);
        }

        return result;
    };
}

// ES5 15.4.4.22
// http://es5.github.com/#x15.4.4.22
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var self = toObject(this),
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        // no value to return if no initial value, empty array
        if (!length && arguments.length == 1)
            throw new TypeError(); // TODO message

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }

                // if array contains no values, no initial value to return
                if (--i < 0)
                    throw new TypeError(); // TODO message
            } while (true);
        }

        do {
            if (i in this)
                result = fun.call(void 0, result, self[i], i, self);
        } while (i--);

        return result;
    };
}

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = toObject(this),
            length = self.length >>> 0;

        if (!length)
            return -1;

        var i = 0;
        if (arguments.length > 1)
            i = toInteger(arguments[1]);

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}

// ES5 15.4.4.15
// http://es5.github.com/#x15.4.4.15
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
if (!Array.prototype.lastIndexOf) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = toObject(this),
            length = self.length >>> 0;

        if (!length)
            return -1;
        var i = length - 1;
        if (arguments.length > 1)
            i = Math.min(i, toInteger(arguments[1]));
        // handle negative indices
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i])
                return i;
        }
        return -1;
    };
}

//
// Object
// ======
//

// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
if (!Object.getPrototypeOf) {
    // https://github.com/kriskowal/es5-shim/issues#issue/2
    // http://ejohn.org/blog/objectgetprototypeof/
    // recommended by fschaefer on github
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        // If object does not owns property return undefined immediately.
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;

        // If object has a property then it's for sure both `enumerable` and
        // `configurable`.
        descriptor =  { enumerable: true, configurable: true };

        // If JS engine supports accessor properties then property may be a
        // getter or setter.
        if (supportsAccessors) {
            // Unfortunately `__lookupGetter__` will return a getter even
            // if object has own non getter property along with a same named
            // inherited getter. To avoid misbehavior we temporary remove
            // `__proto__` so that `__lookupGetter__` will return getter only
            // if it's owned by an object.
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);

            // Once we have getter and setter we can put values back.
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;

                // If it was accessor property we're done and return here
                // in order to avoid adding `value` to the descriptor.
                return descriptor;
            }
        }

        // If we got this far we know that object has an own property that is
        // not an accessor so we set it as a value and return descriptor.
        descriptor.value = object[property];
        return descriptor;
    };
}

// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}

// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
if (!Object.create) {
    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = { "__proto__": null };
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            // IE has no built-in implementation of `Object.getPrototypeOf`
            // neither `__proto__`, but this manually setting `__proto__` will
            // guarantee that `Object.getPrototypeOf` will work as expected with
            // objects created using `Object.create`
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/kriskowal/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
        // returns falsy
    }
}

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);

        // make a valiant attempt to use the real defineProperty
        // for I8's DOM elements.
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        // If it's a data property.
        if (owns(descriptor, "value")) {
            // fail silently if "writable", "enumerable", or "configurable"
            // are requested but not supported
            /*
            // alternate approach:
            if ( // can't implement these features; allow false but not true
                !(owns(descriptor, "writable") ? descriptor.writable : true) ||
                !(owns(descriptor, "enumerable") ? descriptor.enumerable : true) ||
                !(owns(descriptor, "configurable") ? descriptor.configurable : true)
            )
                throw new RangeError(
                    "This implementation of Object.defineProperty does not " +
                    "support configurable, enumerable, or writable."
                );
            */

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                // As accessors are supported only on engines implementing
                // `__proto__` we can safely override `__proto__` while defining
                // a property to make sure that we don't hit an inherited
                // accessor.
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                // Deleting a property anyway since getter / setter may be
                // defined on object itself.
                delete object[property];
                object[property] = descriptor.value;
                // Setting original `__proto__` back now.
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            // If we got that far then getters and setters can be defined !!
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}

// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
if (!Object.seal) {
    Object.seal = function seal(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// detect a Rhino bug and patch it
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}

// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}

// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}

// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        // 1. If Type(O) is not Object throw a TypeError exception.
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}

// ES5 15.2.3.14
// http://es5.github.com/#x15.2.3.14
if (!Object.keys) {
    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null})
        hasDontEnumBug = false;

    Object.keys = function keys(object) {

        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError("Object.keys called on a non-object");

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }

        return keys;
    };

}

//
// Date
// ====
//

// ES5 15.9.5.43
// http://es5.github.com/#x15.9.5.43
// This function returns a String value represent the instance in time 
// represented by this Date object. The format of the String is the Date Time 
// string format defined in 15.9.1.15. All fields are present in the String. 
// The time zone is always UTC, denoted by the suffix Z. If the time value of 
// this object is not a finite Number a RangeError exception is thrown.
if (!Date.prototype.toISOString || (new Date(-62198755200000).toISOString().indexOf('-000001') === -1)) {
    Date.prototype.toISOString = function toISOString() {
        var result, length, value, year;
        if (!isFinite(this))
            throw new RangeError;

        // the date time string format is specified in 15.9.1.15.
        result = [this.getUTCMonth() + 1, this.getUTCDate(),
            this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
        year = this.getUTCFullYear();
        year = (year < 0 ? '-' : (year > 9999 ? '+' : '')) + ('00000' + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6);

        length = result.length;
        while (length--) {
            value = result[length];
            // pad months, days, hours, minutes, and seconds to have two digits.
            if (value < 10)
                result[length] = "0" + value;
        }
        // pad milliseconds to have three digits.
        return year + "-" + result.slice(0, 2).join("-") + "T" + result.slice(2).join(":") + "." +
            ("000" + this.getUTCMilliseconds()).slice(-3) + "Z";
    }
}

// ES5 15.9.4.4
// http://es5.github.com/#x15.9.4.4
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// ES5 15.9.5.44
// http://es5.github.com/#x15.9.5.44
// This function provides a String representation of a Date object for use by 
// JSON.stringify (15.12.3).
if (!Date.prototype.toJSON) {
    Date.prototype.toJSON = function toJSON(key) {
        // When the toJSON method is called with argument key, the following 
        // steps are taken:

        // 1.  Let O be the result of calling ToObject, giving it the this
        // value as its argument.
        // 2. Let tv be ToPrimitive(O, hint Number).
        // 3. If tv is a Number and is not finite, return null.
        // XXX
        // 4. Let toISO be the result of calling the [[Get]] internal method of
        // O with argument "toISOString".
        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
        if (typeof this.toISOString != "function")
            throw new TypeError(); // TODO message
        // 6. Return the result of calling the [[Call]] internal method of
        //  toISO with O as the this value and an empty argument list.
        return this.toISOString();

        // NOTE 1 The argument is ignored.

        // NOTE 2 The toJSON function is intentionally generic; it does not
        // require that its this value be a Date object. Therefore, it can be
        // transferred to other kinds of objects for use as a method. However,
        // it does require that any such object have a toISOString method. An
        // object is free to use the argument key to filter its
        // stringification.
    };
}

// ES5 15.9.4.2
// http://es5.github.com/#x15.9.4.2
// based on work shared by Daniel Friesen (dantman)
// http://gist.github.com/303249
if (Date.parse("+275760-09-13T00:00:00.000Z") !== 8.64e15) {
    // XXX global assignment won't work in embeddings that use
    // an alternate object for the context.
    Date = (function(NativeDate) {

        // Date.length === 7
        var Date = function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            if (this instanceof NativeDate) {
                var date = length == 1 && String(Y) === Y ? // isString(Y)
                    // We explicitly pass it through parse:
                    new NativeDate(Date.parse(Y)) :
                    // We have to manually make calls depending on argument
                    // length here
                    length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) :
                    length >= 6 ? new NativeDate(Y, M, D, h, m, s) :
                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
                    length >= 4 ? new NativeDate(Y, M, D, h) :
                    length >= 3 ? new NativeDate(Y, M, D) :
                    length >= 2 ? new NativeDate(Y, M) :
                    length >= 1 ? new NativeDate(Y) :
                                  new NativeDate();
                // Prevent mixups with unfixed Date object
                date.constructor = Date;
                return date;
            }
            return NativeDate.apply(this, arguments);
        };

        // 15.9.1.15 Date Time String Format.
        var isoDateExpression = new RegExp("^" +
            "(\\d{4}|[\+\-]\\d{6})" + // four-digit year capture or sign + 6-digit extended year
            "(?:-(\\d{2})" + // optional month capture
            "(?:-(\\d{2})" + // optional day capture
            "(?:" + // capture hours:minutes:seconds.milliseconds
                "T(\\d{2})" + // hours capture
                ":(\\d{2})" + // minutes capture
                "(?:" + // optional :seconds.milliseconds
                    ":(\\d{2})" + // seconds capture
                    "(?:\\.(\\d{3}))?" + // milliseconds capture
                ")?" +
            "(?:" + // capture UTC offset component
                "Z|" + // UTC capture
                "(?:" + // offset specifier +/-hours:minutes
                    "([-+])" + // sign capture
                    "(\\d{2})" + // hours offset capture
                    ":(\\d{2})" + // minutes offset capture
                ")" +
            ")?)?)?)?" +
        "$");

        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate)
            Date[key] = NativeDate[key];

        // Copy "native" methods explicitly; they may be non-enumerable
        Date.now = NativeDate.now;
        Date.UTC = NativeDate.UTC;
        Date.prototype = NativeDate.prototype;
        Date.prototype.constructor = Date;

        // Upgrade Date.parse to handle simplified ISO 8601 strings
        Date.parse = function parse(string) {
            var match = isoDateExpression.exec(string);
            if (match) {
                match.shift(); // kill match[0], the full match
                // parse months, days, hours, minutes, seconds, and milliseconds
                for (var i = 1; i < 7; i++) {
                    // provide default values if necessary
                    match[i] = +(match[i] || (i < 3 ? 1 : 0));
                    // match[1] is the month. Months are 0-11 in JavaScript
                    // `Date` objects, but 1-12 in ISO notation, so we
                    // decrement.
                    if (i == 1)
                        match[i]--;
                }

                // parse the UTC offset component
                var minuteOffset = +match.pop(), hourOffset = +match.pop(), sign = match.pop();

                // compute the explicit time zone offset if specified
                var offset = 0;
                if (sign) {
                    // detect invalid offsets and return early
                    if (hourOffset > 23 || minuteOffset > 59)
                        return NaN;

                    // express the provided time zone offset in minutes. The offset is
                    // negative for time zones west of UTC; positive otherwise.
                    offset = (hourOffset * 60 + minuteOffset) * 6e4 * (sign == "+" ? -1 : 1);
                }

                // Date.UTC for years between 0 and 99 converts year to 1900 + year
                // The Gregorian calendar has a 400-year cycle, so 
                // to Date.UTC(year + 400, .... ) - 12622780800000 == Date.UTC(year, ...),
                // where 12622780800000 - number of milliseconds in Gregorian calendar 400 years
                var year = +match[0];
                if (0 <= year && year <= 99) {
                    match[0] = year + 400;
                    return NativeDate.UTC.apply(this, match) + offset - 12622780800000;
                }

                // compute a new UTC date value, accounting for the optional offset
                return NativeDate.UTC.apply(this, match) + offset;
            }
            return NativeDate.parse.apply(this, arguments);
        };

        return Date;
    })(Date);
}

//
// String
// ======
//

// ES5 15.5.4.20
// http://es5.github.com/#x15.5.4.20
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer
var toInteger = function (n) {
    n = +n;
    if (n !== n) // isNaN
        n = 0;
    else if (n !== 0 && n !== (1/0) && n !== -(1/0))
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    return n;
};

var prepareString = "a"[0] != "a",
    // ES5 9.9
    // http://es5.github.com/#x9.9
    toObject = function (o) {
        if (o == null) { // this matches both null and undefined
            throw new TypeError(); // TODO message
        }
        // If the implementation doesn't support by-index access of
        // string characters (ex. IE < 7), split the string
        if (prepareString && typeof o == "string" && o) {
            return o.split("");
        }
        return Object(o);
    };
});/* vim:ts=4:sts=4:sw=4:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *      Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)
 *      Mike de Boer <mike AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/event_emitter', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var EventEmitter = {};

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry = this._eventRegistry || {};
    this._defaultHandlers = this._defaultHandlers || {};

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    e = e || {};
    e.type = eventName;
    
    if (!e.stopPropagation) {
        e.stopPropagation = function() {
            this.propagationStopped = true;
        };
    }
    
    if (!e.preventDefault) {
        e.preventDefault = function() {
            this.defaultPrevented = true;
        };
    }

    for (var i=0; i<listeners.length; i++) {
        listeners[i](e);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        defaultHandler(e);
};

EventEmitter.setDefaultHandler = function(eventName, callback) {
    this._defaultHandlers = this._defaultHandlers || {};
    
    if (this._defaultHandlers[eventName])
        throw new Error("The default handler for '" + eventName + "' is already set");
        
    this._defaultHandlers[eventName] = callback;
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        var listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners.push(callback);
};

EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/oop', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

exports.inherits = (function() {
    var tempCtor = function() {};
    return function(ctor, superCtor) {
        tempCtor.prototype = superCtor.prototype;
        ctor.super_ = superCtor.prototype;
        ctor.prototype = new tempCtor();
        ctor.prototype.constructor = ctor;
    };
}());

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
 
define('ace/mode/xquery_worker', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/worker/mirror', 'ace/mode/xquery/xquery'], function(require, exports, module) {
"use strict";
    
var oop = require("../lib/oop");
var Mirror = require("../worker/mirror").Mirror;
var xquery = require("../mode/xquery/xquery");

window.addEventListener = function() {};


var XQueryWorker = exports.XQueryWorker = function(sender) {
    Mirror.call(this, sender);
    this.setTimeout(200);
};

oop.inherits(XQueryWorker, Mirror);

(function() {
    
  this.onUpdate = function() {
    var value = this.doc.getValue();    
    var parser = xquery.getParser(value);
    var ast = parser.p_Module();
    if(parser.hasErrors()) {
		  var errors = parser.getErrors();
	    var i = 0;
      for(i in errors) {
	      var error = errors[i];
	      this.sender.emit("error", {
	        row: error.line,
          column: error.column,
	        text: error.message,
	        type: "error"
       });
      }	
      var tokens = parser.highlighter.getTokens();
      this.sender.emit("highlight", tokens);
      return;
    }
    var tokens = parser.highlighter.getTokens();
    this.sender.emit("highlight", tokens);
    this.sender.emit("ok");
  };
    
}).call(XQueryWorker.prototype);

});
define('ace/worker/mirror', ['require', 'exports', 'module' , 'ace/document', 'ace/lib/lang'], function(require, exports, module) {
"use strict";

var Document = require("../document").Document;
var lang = require("../lib/lang");
    
var Mirror = exports.Mirror = function(sender) {
    this.sender = sender;
    var doc = this.doc = new Document("");
    
    var deferredUpdate = this.deferredUpdate = lang.deferredCall(this.onUpdate.bind(this));
    
    var _self = this;
    sender.on("change", function(e) {
        doc.applyDeltas([e.data]);        
        deferredUpdate.schedule(_self.$timeout);
    });
};

(function() {
    
    this.$timeout = 500;
    
    this.setTimeout = function(timeout) {
        this.$timeout = timeout;
    };
    
    this.setValue = function(value) {
        this.doc.setValue(value);
        this.deferredUpdate.schedule(this.$timeout);
    };
    
    this.getValue = function(callbackId) {
        this.sender.callback(this.doc.getValue(), callbackId);
    };
    
    this.onUpdate = function() {
        // abstract method
    };
    
}).call(Mirror.prototype);

});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/document', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter', 'ace/range', 'ace/anchor'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(text) {
    this.$lines = [];

    if (Array.isArray(text)) {
        this.insertLines(0, text);
    }
    // There has to be one line at least in the document. If you pass an empty
    // string to the insert function, nothing will happen. Workaround.
    else if (text.length == 0) {
        this.$lines = [""];
    } else {
        this.insert({row: 0, column:0}, text);
    }
};

(function() {

    oop.implement(this, EventEmitter);

    this.setValue = function(text) {
        var len = this.getLength();
        this.remove(new Range(0, 0, len, this.getLine(len-1).length));
        this.insert({row: 0, column:0}, text);
    };

    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };

    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };

    // check for IE split bug
    if ("aaa".split(/a/).length == 0)
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        }
    else
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };

    this.getNewLineCharacter = function() {
      switch (this.$newLineMode) {
          case "windows":
              return "\r\n";

          case "unix":
              return "\n";

          case "auto":
              return this.$autoNewLine;
      }
    };

    this.$autoNewLine = "\n";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
    };

    this.getNewLineMode = function() {
        return this.$newLineMode;
    };

    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };

    /**
     * Get a verbatim copy of the given line as it is in the document
     */
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };

    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };

    /**
     * Returns all lines in the document as string array. Warning: The caller
     * should not modify this array!
     */
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };

    this.getLength = function() {
        return this.$lines.length;
    };

    this.getTextRange = function(range) {
        if (range.start.row == range.end.row) {
            return this.$lines[range.start.row].substring(range.start.column,
                                                         range.end.column);
        }
        else {
            var lines = [];
            lines.push(this.$lines[range.start.row].substring(range.start.column));
            lines.push.apply(lines, this.getLines(range.start.row+1, range.end.row-1));
            lines.push(this.$lines[range.end.row].substring(0, range.end.column));
            return lines.join(this.getNewLineCharacter());
        }
    };

    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length-1).length;
        }
        return position;
    };

    this.insert = function(position, text) {
        if (!text || text.length === 0)
            return position;

        position = this.$clipPosition(position);

        // only detect new lines if the document has no line break yet
        if (this.getLength() <= 1)
            this.$detectNewLine(text);

        var lines = this.$split(text);
        var firstLine = lines.splice(0, 1)[0];
        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];

        position = this.insertInLine(position, firstLine);
        if (lastLine !== null) {
            position = this.insertNewLine(position); // terminate first line
            position = this.insertLines(position.row, lines);
            position = this.insertInLine(position, lastLine || "");
        }
        return position;
    };

    this.insertLines = function(row, lines) {
        if (lines.length == 0)
            return {row: row, column: 0};

        var args = [row, 0];
        args.push.apply(args, lines);
        this.$lines.splice.apply(this.$lines, args);

        var range = new Range(row, 0, row + lines.length, 0);
        var delta = {
            action: "insertLines",
            range: range,
            lines: lines
        };
        this._emit("change", { data: delta });
        return range.end;
    };

    this.insertNewLine = function(position) {
        position = this.$clipPosition(position);
        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column);
        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));

        var end = {
            row : position.row + 1,
            column : 0
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: this.getNewLineCharacter()
        };
        this._emit("change", { data: delta });

        return end;
    };

    this.insertInLine = function(position, text) {
        if (text.length == 0)
            return position;

        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column) + text
                + line.substring(position.column);

        var end = {
            row : position.row,
            column : position.column + text.length
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: text
        };
        this._emit("change", { data: delta });

        return end;
    };

    this.remove = function(range) {
        // clip to document
        range.start = this.$clipPosition(range.start);
        range.end = this.$clipPosition(range.end);

        if (range.isEmpty())
            return range.start;

        var firstRow = range.start.row;
        var lastRow = range.end.row;

        if (range.isMultiLine()) {
            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
            var lastFullRow = lastRow - 1;

            if (range.end.column > 0)
                this.removeInLine(lastRow, 0, range.end.column);

            if (lastFullRow >= firstFullRow)
                this.removeLines(firstFullRow, lastFullRow);

            if (firstFullRow != firstRow) {
                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
                this.removeNewLine(range.start.row);
            }
        }
        else {
            this.removeInLine(firstRow, range.start.column, range.end.column);
        }
        return range.start;
    };

    this.removeInLine = function(row, startColumn, endColumn) {
        if (startColumn == endColumn)
            return;

        var range = new Range(row, startColumn, row, endColumn);
        var line = this.getLine(row);
        var removed = line.substring(startColumn, endColumn);
        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
        this.$lines.splice(row, 1, newLine);

        var delta = {
            action: "removeText",
            range: range,
            text: removed
        };
        this._emit("change", { data: delta });
        return range.start;
    };

    /**
     * Removes a range of full lines
     *
     * @param firstRow {Integer} The first row to be removed
     * @param lastRow {Integer} The last row to be removed
     * @return {String[]} The removed lines
     */
    this.removeLines = function(firstRow, lastRow) {
        var range = new Range(firstRow, 0, lastRow + 1, 0);
        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);

        var delta = {
            action: "removeLines",
            range: range,
            nl: this.getNewLineCharacter(),
            lines: removed
        };
        this._emit("change", { data: delta });
        return removed;
    };

    this.removeNewLine = function(row) {
        var firstLine = this.getLine(row);
        var secondLine = this.getLine(row+1);

        var range = new Range(row, firstLine.length, row+1, 0);
        var line = firstLine + secondLine;

        this.$lines.splice(row, 2, line);

        var delta = {
            action: "removeText",
            range: range,
            text: this.getNewLineCharacter()
        };
        this._emit("change", { data: delta });
    };

    this.replace = function(range, text) {
        if (text.length == 0 && range.isEmpty())
            return range.start;

        // Shortcut: If the text we want to insert is the same as it is already
        // in the document, we don't have to replace anything.
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        if (text) {
            var end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }

        return end;
    };

    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            var delta = deltas[i];
            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this.insertLines(range.start.row, delta.lines);
            else if (delta.action == "insertText")
                this.insert(range.start, delta.text);
            else if (delta.action == "removeLines")
                this.removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "removeText")
                this.remove(range);
        }
    };

    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            var delta = deltas[i];

            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this.removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "insertText")
                this.remove(range);
            else if (delta.action == "removeLines")
                this.insertLines(range.start.row, delta.lines);
            else if (delta.action == "removeText")
                this.insert(range.start, delta.text);
        }
    };

}).call(Document.prototype);

exports.Document = Document;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/range', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row == range.start.row &&
            this.end.row == range.end.row &&
            this.start.column == range.start.column &&
            this.end.column == range.end.column
    };

    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };

    /**
     * Compares this range (A) with another range (B), where B is the passed in
     * range.
     *
     * Return values:
     *  -2: (B) is infront of (A) and doesn't intersect with (A)
     *  -1: (B) begins before (A) but ends inside of (A)
     *   0: (B) is completly inside of (A) OR (A) is complety inside of (B)
     *  +1: (B) begins inside of (A) but ends outside of (A)
     *  +2: (B) is after (A) and doesn't intersect with (A)
     *
     *  42: FTW state: (B) ends in (A) but starts outside of (A)
     */
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    }

    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    }

    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    }

    this.intersectsRange = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    }

    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    }

    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    }

    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    }

    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    }

    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }

    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            };
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };

    /**
     * Like .compare(), but if isStart is true, return -1;
     */
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    /**
     * Like .compare(), but if isEnd is true, return 1;
     */
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    }

    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    }

    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow) {
            var end = {
                row: lastRow+1,
                column: 0
            };
        }

        if (this.start.row > lastRow) {
            var start = {
                row: lastRow+1,
                column: 0
            };
        }

        if (this.start.row < firstRow) {
            var start = {
                row: firstRow,
                column: 0
            };
        }

        if (this.end.row < firstRow) {
            var end = {
                row: firstRow,
                column: 0
            };
        }
        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.fixOrientation = function() {
        if (
            this.start.row < this.end.row 
            || (this.start.row == this.end.row && this.start.column < this.end.column)
        ) {
            return false;
        }
        
        var temp = this.start;
        this.end = this.start;
        this.start = temp;
        return true;
    };


    this.isEmpty = function() {
        return (this.start.row == this.end.row && this.start.column == this.end.column);
    };

    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };

    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };

    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
        else
            return new Range(this.start.row, 0, this.end.row, 0)
    };

    this.toScreenRange = function(session) {
        var screenPosStart =
            session.documentToScreenPosition(this.start);
        var screenPosEnd =
            session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };

}).call(Range.prototype);


Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};

exports.Range = Range;
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/anchor', ['require', 'exports', 'module' , 'ace/lib/oop', 'ace/lib/event_emitter'], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

/**
 * An Anchor is a floating pointer in the document. Whenever text is inserted or
 * deleted before the cursor, the position of the cursor is updated
 */
var Anchor = exports.Anchor = function(doc, row, column) {
    this.document = doc;
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);

    this.$onChange = this.onChange.bind(this);
    doc.on("change", this.$onChange);
};

(function() {

    oop.implement(this, EventEmitter);
    
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    
    this.getDocument = function() {
        return this.document;
    };
    
    this.onChange = function(e) {
        var delta = e.data;
        var range = delta.range;
            
        if (range.start.row == range.end.row && range.start.row != this.row)
            return;
            
        if (range.start.row > this.row)
            return;
            
        if (range.start.row == this.row && range.start.column > this.column)
            return;
    
        var row = this.row;
        var column = this.column;
        
        if (delta.action === "insertText") {
            if (range.start.row === row && range.start.column <= column) {
                if (range.start.row === range.end.row) {
                    column += range.end.column - range.start.column;
                }
                else {
                    column -= range.start.column;
                    row += range.end.row - range.start.row;
                }
            }
            else if (range.start.row !== range.end.row && range.start.row < row) {
                row += range.end.row - range.start.row;
            }
        } else if (delta.action === "insertLines") {
            if (range.start.row <= row) {
                row += range.end.row - range.start.row;
            }
        }
        else if (delta.action == "removeText") {
            if (range.start.row == row && range.start.column < column) {
                if (range.end.column >= column)
                    column = range.start.column;
                else
                    column = Math.max(0, column - (range.end.column - range.start.column));
                
            } else if (range.start.row !== range.end.row && range.start.row < row) {
                if (range.end.row == row) {
                    column = Math.max(0, column - range.end.column) + range.start.column;
                }
                row -= (range.end.row - range.start.row);
            }
            else if (range.end.row == row) {
                row -= range.end.row - range.start.row;
                column = Math.max(0, column - range.end.column) + range.start.column;
            }
        } else if (delta.action == "removeLines") {
            if (range.start.row <= row) {
                if (range.end.row <= row)
                    row -= range.end.row - range.start.row;
                else {
                    row = range.start.row;
                    column = 0;
                }
            }
        }

        this.setPosition(row, column, true);
    };

    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        }
        else {
            pos = this.$clipPositionToDocument(row, column);
        }
        
        if (this.row == pos.row && this.column == pos.column)
            return;
            
        var old = {
            row: this.row,
            column: this.column
        };
        
        this.row = pos.row;
        this.column = pos.column;
        this._emit("change", {
            old: old,
            value: pos
        });
    };
    
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};
    
        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        
        if (column < 0)
            pos.column = 0;
            
        return pos;
    };
    
}).call(Anchor.prototype);

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      Fabian Jakobs <fabian AT ajax DOT org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

define('ace/lib/lang', ['require', 'exports', 'module' ], function(require, exports, module) {
"use strict";

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
     return new Array(count + 1).join(string);
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject( array[i] );
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function (obj) {
    if (typeof obj != "object") {
        return obj;
    }
    
    var copy = obj.constructor();
    for (var key in obj) {
        if (typeof obj[key] == "object") {
            copy[key] = this.deepCopy(obj[key]);
        } else {
            copy[key] = obj[key];
        }
    }
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

/**
 * splice out of 'array' anything that === 'value'
 */
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.deferredCall = function(fcn) {

    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };

    return deferred;
};

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
 
define('ace/mode/xquery/xquery', ['require', 'exports', 'module' , 'ace/mode/xquery/antlr3-all', 'ace/mode/xquery/XQueryLexer', 'ace/mode/xquery/XQueryParser'], function(require, exports, module) {

  var antlr = require("./antlr3-all");
  var org =  antlr.org;
  var NewLazyTokenStream = antlr.NewLazyTokenStream;
  var XQueryLexer   = require("./XQueryLexer").XQueryLexer;
  var XQueryParser  = require("./XQueryParser").XQueryParser;

  exports.getParser = function(code) {
    var cstream = new org.antlr.runtime.ANTLRStringStream(code);
    var lexer = new XQueryLexer(cstream);
    var tstream = new NewLazyTokenStream(lexer);
    tstream.jumpToFirstValidToken();
    var parser = new XQueryParser(tstream);
    parser.setSource(cstream);
    return parser;
  };
});
/*
Copyright (c) 2003-2008 Terence Parr. All rights reserved.
Code licensed under the BSD License:
http://www.antlr.org/license.html

Some parts of the ANTLR class:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
*/
/*
Some portions:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.5.1
*/
define('ace/mode/xquery/antlr3-all', ['require', 'exports', 'module' ], function(require, exports, module) {
var NewLazyTokenStream = exports.NewLazyTokenStream = function(tokenSource) {

  this.tokenSource = tokenSource;
  this.tokens = [];
  this.isWsExplicit = false;
  this.p = 0;
  this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
  
  this.LT = function(k) {
    if (k == 0)
      return null;
    if (k < 0)
      return this.readReverseNthGoodToken(-k);

    return this.readNthGoodToken(k);
  };

  this.get = function(i) {
    if (i >= this.tokens.length)
      return org.antlr.runtime.Token.EOF_TOKEN;
    else
      return this.tokens[i];
  };

  this.getTokenSource = function() {
    return this.tokenSource;
  };

  this.toString = function(start, stop) {
     if(start == undefined) {
       return this.toString(0, this.tokens.length - 1);
     } else
     if(start instanceof org.antlr.runtime.Token) {
       return this.toString(start.getTokenIndex(), stop.getTokenIndex());
     } else {
      if (start < 0)
        start = 0;
      if (this.p <= stop) {
        this.readNTokens(stop - this.p + 1);
      }

          var sb = "";
          for (var i = start; i <= stop && i < this.tokens.length; i++) {
              sb += this.tokens[i].getText();
          }
          return sb;
      }
    };

    this.LA = function(i) {
        return this.LT(i).getType();
    };

    this.done = false;

    this.consume = function() {
        if (this.done) {
          return;
        }
        this.p++;
        if (!this.isWsExplicit) {
            this.jumpToFirstValidToken();
        }
    };

    this.getSourceName = function() {
      return this.getTokenSource().getSourceName();
    };

    this.index = function() {
        return this.p;
    };

    this.mark = function() {
        this.lastMarker = this.index();
        return this.lastMarker;
    };

    this.release = function(marker) {
    };

    this.rewind = function(marker) {
      if(arguments.length == 1) {
        this.seek(marker);
      } else {
        this.seek(this.lastMarker);
      }
    };

    this.seek = function(index) {
        this.p = index;
        this.done = false;
    };

    this.size = function() {
        return this.tokens.length;
    };

    this.setTokenSource = function(source) {
        this.tokenSource = source;
        this.setWsExplicit(source.isWsExplicit);
        // un-read the unused tokens
        // they are different for the new source
        if (this.p < this.tokens.length) {
            var rIndex = this.p > 0 ? this.tokens[this.p - 1].getStopIndex() : 0;
            this.tokenSource.rewindToIndex(rIndex + 1);
            for (var i = this.tokens.length - 1; i >= this.p; i--) {
                this.tokens.splice(i, 1);
            }
        }

        // if we ignore WS, jump to next token
        if (!this.isWsExplicit) {
            this.jumpToFirstValidToken();
        }
    };

    this.setWsExplicit = function(explicit) {
        this.isWsExplicit = explicit;
        if (!explicit) {
          this.jumpToFirstValidToken();
        }
    };

    this.readNthGoodToken = function(n) {
        var count = this.tokens.length;
        // number of buffered tokens available
        var avt = count - this.p;
        // i counts good tokens, j counts all tokens
        var i = 1, j = 0;
        var t = null;
        while (i <= n) {
            if (j < avt) // read from buffer
                t = this.tokens[this.p + j];
            else { // read from source
                t = this.tokenSource.nextToken();
                if (t == org.antlr.runtime.Token.EOF_TOKEN) {
                    return t;
                }
                t.setTokenIndex(count++);
                this.tokens.push(t);
            }
            if (this.isWsExplicit || t.getChannel() == this.channel) {
               i++;
            }
            j++;
        }
        return t;
    };

    this.readReverseNthGoodToken = function(n) {
        if (n == 0 || (this.p - n) < 0)
            return null;

        // i counts good tokens, j counts all tokens
        var i = 1, j = 0;
        var t = null;
        while (this.p - 1 - j >= 0) {
            t = this.get(this.p - 1 - j);

            if (this.isWsExplicit || t.getChannel() == this.channel) {
                if (i++ == n)
                    return t;
            }
            j++;
        }
        return null;
    };

    this.readNTokens = function(n) {
        var t = null;
        for (var i = 0; i < n; i++) {
            if (this.tokens.length > this.p + i)
                continue;

            t = this.tokenSource.nextToken();
            if (t == org.antlr.runtime.Token.EOF_TOKEN)
                return;
            
            t.setTokenIndex(this.p + i);
            this.tokens.push(t);
        }
    };

    this.jumpToFirstValidToken = function() {
        var t = this.LT(1);
        if (t != org.antlr.runtime.Token.EOF_TOKEN) {
            this.done = false;
            this.p = t.getTokenIndex();
        }
    }; 
};

// create org.antlr module
if (typeof org == "undefined" || !org) {
    var org = {};
}
if (typeof org.antlr == "undefined" || !org.antlr) {
    /**
     * The org.antlr global namespace object.  If antlr is already defined, the
     * existing antlr object will not be overwritten so that defined
     * namespaces are preserved.
     * @namespace org.antlr
     */
    org.antlr = {};
}

/**
 * The global JavaScript object.
 */
org.antlr.global = (function() {
    return this;
}).call(null);

/**
 * Returns the namespace specified and creates it if it doesn't exist.
 *
 * Be careful when naming packages. Reserved words may work in some browsers
 * and not others. For instance, the following will fail in Safari:
 * <pre>
 * org.antlr.namespace("really.long.nested.namespace");
 * </pre>
 * This fails because "long" is a future reserved word in ECMAScript
 *
 * @static
 * @param  {String*} arguments 1-n namespaces to create 
 * @return {Object}  A reference to the last namespace object created
 * @example
 * org.antlr.namespace("org.antlr.property.package");
 */
org.antlr.namespace = function() {
    var a=arguments, o=null, i, j, d;
    for (i=0; i<a.length; i=i+1) {
        d=a[i].split(".");
        o=org.antlr.global;

        // ANTLR is implied, so it is ignored if it is included
        for (j=0; j<d.length; j=j+1) {
            o[d[j]]=o[d[j]] || {};
            o=o[d[j]];
        }
    }

    return o;
};

/**
 * org.antlr.env is used to keep track of what is known about the library and
 * the browsing environment
 * @namespace org.antlr.env
 */
org.antlr.env = org.antlr.env || {};

/**
 * JavaScript runtime library code.
 * @name org.antlr.runtime
 * @namespace
 */
/**
 * JavaScript runtime library tree parser code.
 * @name org.antlr.runtime.tree
 * @namespace
 */
org.antlr.namespace("org.antlr.runtime.tree");

/**
 * Provides the language utilites and extensions used by the library
 * @namespace org.antlr.lang
 */
org.antlr.lang = org.antlr.lang || /** @lends org.antlr.lang */ {
    /**
     * Determines whether or not the provided object is an array.
     * Testing typeof/instanceof/constructor of arrays across frame 
     * boundaries isn't possible in Safari unless you have a reference
     * to the other frame to test against its Array prototype.  To
     * handle this case, we test well-known array properties instead.
     * properties.
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isArray: function(o) { 
        if (o) {
           var l = org.antlr.lang;
           return l.isNumber(o.length) && l.isFunction(o.splice);
        }
        return false;
    },

    /**
     * Determines whether or not the provided object is a boolean
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isBoolean: function(o) {
        return typeof o === 'boolean';
    },
    
    /**
     * Determines whether or not the provided object is a function
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isFunction: function(o) {
        return typeof o === 'function';
    },
        
    /**
     * Determines whether or not the provided object is null
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isNull: function(o) {
        return o === null;
    },
        
    /**
     * Determines whether or not the provided object is a legal number
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isNumber: function(o) {
        return typeof o === 'number' && isFinite(o);
    },
      
    /**
     * Determines whether or not the provided object is of type object
     * or function
     * @param {any} o The object being testing
     * @return {boolean} the result
     */  
    isObject: function(o) {
return (o && (typeof o === 'object' || org.antlr.lang.isFunction(o))) || false;
    },
        
    /**
     * Determines whether or not the provided object is a string
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isString: function(o) {
        return typeof o === 'string';
    },
        
    /**
     * Determines whether or not the provided object is undefined
     * @param {any} o The object being testing
     * @return {boolean} the result
     */
    isUndefined: function(o) {
        return typeof o === 'undefined';
    },
    
    /**
     * IE will not enumerate native functions in a derived object even if the
     * function was overridden.  This is a workaround for specific functions 
     * we care about on the Object prototype. 
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @private
     */
    _IEEnumFix: function(r, s) {
        if (false) {
            var add=["toString", "valueOf"], i;
            for (i=0;i<add.length;i=i+1) {
                var fname=add[i],f=s[fname];
                if (org.antlr.lang.isFunction(f) && f!=Object.prototype[fname]) {
                    r[fname]=f;
                }
            }
        }
    },
       
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} [overrides]  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass 
     *                              if present.
     */
    extend: function(subc, superc, overrides) {
        if (!superc||!subc) {
            throw new Error("org.antlr.lang.extend failed, please check that " +
                            "all dependencies are included.");
        }
        var F = function() {};
        F.prototype=superc.prototype;
        subc.prototype=new F();
        subc.prototype.constructor=subc;
        subc.superclass=superc.prototype;
        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor=superc;
        }
    
        if (overrides) {
            for (var i in overrides) {
                subc.prototype[i]=overrides[i];
            }

            org.antlr.lang._IEEnumFix(subc.prototype, overrides);
        }
    },
   
    /**
     * Applies all properties in the supplier to the receiver if the
     * receiver does not have these properties yet.  Optionally, one or 
     * more methods/properties can be specified (as additional 
     * parameters).  This option will overwrite the property if receiver 
     * has it already.  If true is passed as the third parameter, all 
     * properties will be applied and _will_ overwrite properties in 
     * the receiver.
     *
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @param {String*|boolean}  [arguments] zero or more properties methods 
     *        to augment the receiver with.  If none specified, everything
     *        in the supplier will be used unless it would
     *        overwrite an existing property in the receiver. If true
     *        is specified as the third parameter, all properties will
     *        be applied and will overwrite an existing property in
     *        the receiver
     */
    augmentObject: function(r, s) {
        if (!s||!r) {
            throw new Error("Absorb failed, verify dependencies.");
        }
        var a=arguments, i, p, override=a[2];
        if (override && override!==true) { // only absorb the specified properties
            for (i=2; i<a.length; i=i+1) {
                r[a[i]] = s[a[i]];
            }
        } else { // take everything, overwriting only if the third parameter is true
            for (p in s) { 
                if (override || !r[p]) {
                    r[p] = s[p];
                }
            }
            
            org.antlr.lang._IEEnumFix(r, s);
        }
    },
 
    /**
     * Same as org.antlr.lang.augmentObject, except it only applies prototype properties
     * @see org.antlr.lang.augmentObject
     * @param {Function} r  the object to receive the augmentation
     * @param {Function} s  the object that supplies the properties to augment
     * @param {String*|boolean}  [arguments] zero or more properties methods 
     *        to augment the receiver with.  If none specified, everything 
     *        in the supplier will be used unless it would overwrite an existing 
     *        property in the receiver.  if true is specified as the third 
     *        parameter, all properties will be applied and will overwrite an 
     *        existing property in the receiver
     */
    augmentProto: function(r, s) {
        if (!s||!r) {
            throw new Error("Augment failed, verify dependencies.");
        }
        //var a=[].concat(arguments);
        var a=[r.prototype,s.prototype];
        for (var i=2;i<arguments.length;i=i+1) {
            a.push(arguments[i]);
        }
        org.antlr.lang.augmentObject.apply(this, a);
    },

    /**
     * Returns a new object containing all of the properties of
     * all the supplied objects.  The properties from later objects
     * will overwrite those in earlier objects.
     * @param arguments {Object*} the objects to merge
     * @return the new merged object
     */
    merge: function() {
        var o={}, a=arguments;
        for (var i=0, l=a.length; i<l; i=i+1) {
            org.antlr.lang.augmentObject(o, a[i], true);
        }
        return o;
    },

    /**
     * A convenience method for detecting a legitimate non-null value.
     * Returns false for null/undefined/NaN, true for other values, 
     * including 0/false/''
     * @param o {any} the item to test
     * @return {boolean} true if it is not null/undefined/NaN || false
     */
    isValue: function(o) {
        var l = org.antlr.lang;
return (l.isObject(o) || l.isString(o) || l.isNumber(o) || l.isBoolean(o));
    },

    /** @namespace org.antlr.lang.array Array convenience methods. */
    array: /** @lends org.antlr.lang.array */ {
        /**
         * Retrieve the last element of an array. Throws an error if a is not
         * an array or empty.
         * @param a {Array} the array stack to peek in
         * @return the last element of the array
         */
         peek: function(a) {
            if (!org.antlr.lang.isArray(a)) {
                throw new Error("org.antlr.lang.array.peek: a is not an array.");
            }
            var l = a.length;
            if (l<=0) {
                throw new Error("org.antlr.lang.array.peek: a is empty.");
            }
            return a[l-1];
        }
    }
};
/** The set of fields needed by an abstract recognizer to recognize input
 *  and recover from errors etc...  As a separate state object, it can be
 *  shared among multiple grammars; e.g., when one grammar imports another.
 *
 *  These fields are publically visible but the actual state pointer per
 *  parser is protected.
 */
org.antlr.runtime = {};
org.antlr.runtime.RecognizerSharedState = function() {
    /** Track the set of token types that can follow any rule invocation.
     *  Stack grows upwards.  When it hits the max, it grows 2x in size
     *  and keeps going.
     */
    this.following = [];

    this._fsp = -1;

    /** This is true when we see an error and before having successfully
     *  matched a token.  Prevents generation of more than one error message
     *  per error.
     */
    this.errorRecovery = false;

    /** The index into the input stream where the last error occurred.
     *  This is used to prevent infinite loops where an error is found
     *  but no token is consumed during recovery...another error is found,
     *  ad naseum.  This is a failsafe mechanism to guarantee that at least
     *  one token/tree node is consumed for two errors.
     */
    this.lastErrorIndex = -1;

    /** In lieu of a return value, this indicates that a rule or token
     *  has failed to match.  Reset to false upon valid token match.
     */
    this.failed = false;

    /** Did the recognizer encounter a syntax error?  Track how many. */
    this.syntaxErrors = 0;

    /** If 0, no backtracking is going on.  Safe to exec actions etc...
     *  If >0 then it's the level of backtracking.
     */
    this.backtracking = 0;

    /** An array[size num rules] of Map<Integer,Integer> that tracks
     *  the stop token index for each rule.  ruleMemo[ruleIndex] is
     *  the memoization table for ruleIndex.  For key ruleStartIndex, you
     *  get back the stop token for associated rule or MEMO_RULE_FAILED.
     *
     *  This is only used if rule memoization is on (which it is by default).
     */
    this.ruleMemo = null;


    // LEXER FIELDS (must be in same state object to avoid casting
    //               constantly in generated code and Lexer object) :(


    /** The goal of all lexer rules/methods is to create a token object.
     *  This is an instance variable as multiple rules may collaborate to
     *  create a single token.  nextToken will return this object after
     *  matching lexer rule(s).  If you subclass to allow multiple token
     *  emissions, then set this to the last token to be matched or
     *  something nonnull so that the auto token emit mechanism will not
     *  emit another token.
     */
    this.token = null;

    /** What character index in the stream did the current token start at?
     *  Needed, for example, to get the text for current token.  Set at
     *  the start of nextToken.
     */
    this.tokenStartCharIndex = -1;

    /** The line on which the first character of the token resides */
    // this.tokenStartLine;

    /** The character position of first character within the line */
    // this.tokenStartCharPositionInLine;

    /** The channel number for the current token */
    // this.channel;

    /** The token type for the current token */
    // this.type;

    /** You can set the text for the current token to override what is in
     *  the input char buffer.  Use setText() or can set this instance var.
     */
    this.text = null;
};
org.antlr.runtime.IndexOutOfBoundsException = function(m) {
    org.antlr.runtime.IndexOutOfBoundsException.superclass.constructor.call(this, m);
};

org.antlr.lang.extend(org.antlr.runtime.IndexOutOfBoundsException, Error, {
    name: "org.antlr.runtime.IndexOutOfBoundsException"
});
/** The root of the ANTLR exception hierarchy.
 *
 *  <p>To avoid English-only error messages and to generally make things
 *  as flexible as possible, these exceptions are not created with strings,
 *  but rather the information necessary to generate an error.  Then
 *  the various reporting methods in Parser and Lexer can be overridden
 *  to generate a localized error message.  For example, MismatchedToken
 *  exceptions are built with the expected token type.
 *  So, don't expect getMessage() to return anything.</p>
 *
 *  <p>ANTLR generates code that throws exceptions upon recognition error and
 *  also generates code to catch these exceptions in each rule.  If you
 *  want to quit upon first error, you can turn off the automatic error
 *  handling mechanism using rulecatch action, but you still need to
 *  override methods mismatch and recoverFromMismatchSet.</p>
 *
 *  <p>In general, the recognition exceptions can track where in a grammar a
 *  problem occurred and/or what was the expected input.  While the parser
 *  knows its state (such as current input symbol and line info) that
 *  state can change before the exception is reported so current token index
 *  is computed and stored at exception time.  From this info, you can
 *  perhaps print an entire line of input not just a single token, for example.
 *  Better to just say the recognizer had a problem and then let the parser
 *  figure out a fancy report.</p>
 *
 *  @class
 *  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
 *  @extends Error
 *
 */
org.antlr.runtime.RecognitionException = function(input) {
    org.antlr.runtime.RecognitionException.superclass.constructor.call(this);
    this.input = input;
    this.index = input.index();
    if ( input instanceof NewLazyTokenStream ) {//org.antlr.runtime.CommonTokenStream ) {
        this.token = input.LT(1);
        this.line = this.token.getLine();
        this.charPositionInLine = this.token.getCharPositionInLine();
    }
    if ( input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
        this.extractInformationFromTreeNodeStream(input);
    }
    else if ( input instanceof org.antlr.runtime.ANTLRStringStream ) {
        // Note: removed CharStream from hierarchy in JS port so checking for
        // StringStream instead
        this.c = input.LA(1);
        this.line = input.getLine();
        this.charPositionInLine = input.getCharPositionInLine();
    }
    else {
        this.c = input.LA(1);
    }

    this.message = this.toString();
};

org.antlr.lang.extend(org.antlr.runtime.RecognitionException, Error,
/** @lends org.antlr.runtime.RecognitionException.prototype */
{
	/**
     * What input stream did the error occur in?
     */
    input: null,

    /** What is index of token/char were we looking at when the error occurred?
     *  @type Number
     */
	index: null,

	/** The current Token when an error occurred.  Since not all streams
	 *  can retrieve the ith Token, we have to track the Token object.
	 *  For parsers.  Even when it's a tree parser, token might be set.
     *  @type org.antlr.runtime.CommonToken
	 */
	token: null,

	/** If this is a tree parser exception, node is set to the node with
	 *  the problem.
     *  @type Object
	 */
	node: null,

	/** The current char when an error occurred. For lexers.
     *  @type Number
     */
	c: null,

	/** Track the line at which the error occurred in case this is
	 *  generated from a lexer.  We need to track this since the
	 *  unexpected char doesn't carry the line info.
     *  @type Number
	 */
	line: null,

    /** The exception's class name.
     *  @type String
     */
    name: "org.antlr.runtime.RecognitionException",

    /** Position in the line where exception occurred.
     *  @type Number
     */
	charPositionInLine: null,

	/** If you are parsing a tree node stream, you will encounter som
	 *  imaginary nodes w/o line/col info.  We now search backwards looking
	 *  for most recent token with line/col info, but notify getErrorHeader()
	 *  that info is approximate.
     *  @type Boolean
	 */
	approximateLineInfo: null,

    /** Gather exception information from input stream.
     *  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
     */
	extractInformationFromTreeNodeStream: function(input) {
		var nodes = input,
            priorNode,
            priorPayLoad,
            type,
            text,
            i;

		this.node = nodes.LT(1);
		var adaptor = nodes.getTreeAdaptor(),
		    payload = adaptor.getToken(this.node);
		if ( payload ) {
			this.token = payload;
			if ( payload.getLine()<= 0 ) {
				// imaginary node; no line/pos info; scan backwards
				i = -1;
				priorNode = nodes.LT(i);
				while ( priorNode ) {
					priorPayload = adaptor.getToken(priorNode);
					if ( priorPayload && priorPayload.getLine()>0 ) {
						// we found the most recent real line / pos info
						this.line = priorPayload.getLine();
						this.charPositionInLine = priorPayload.getCharPositionInLine();
						this.approximateLineInfo = true;
						break;
					}
					--i;
					priorNode = nodes.LT(i);
				}
			}
			else { // node created from real token
				this.line = payload.getLine();
				this.charPositionInLine = payload.getCharPositionInLine();
			}
		}
		else if ( this.node instanceof org.antlr.runtime.tree.CommonTree) {
			this.line = this.node.getLine();
			this.charPositionInLine = this.node.getCharPositionInLine();
			if ( this.node instanceof org.antlr.runtime.tree.CommonTree) {
				this.token = this.node.token;
			}
		}
		else {
			type = adaptor.getType(this.node);
			text = adaptor.getText(this.node);
			this.token = new org.antlr.runtime.CommonToken(type, text);
		}
	},

	/** Return the token type or char of the unexpected input element
     *  @return {Number} type of the unexpected input element.
     */
    getUnexpectedType: function() {
		if ( this.input instanceof NewLazyTokenStream) {//org.antlr.runtime.CommonTokenStream ) {
			return this.token.getType();
		}
		else if ( this.input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
			var nodes = this.input;
			var adaptor = nodes.getTreeAdaptor();
			return adaptor.getType(this.node);
		}
		else {
			return this.c;
		}
	}
});
org.antlr.runtime.MismatchedTokenException = function(expecting, input) {
    if (arguments.length===0) {
        this.expecting = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
    } else {
        org.antlr.runtime.MismatchedTokenException.superclass.constructor.call(
                this, input);
        this.expecting = expecting;
    }
};

org.antlr.lang.extend(
    org.antlr.runtime.MismatchedTokenException,
    org.antlr.runtime.RecognitionException, {
    toString: function() {
        return "MismatchedTokenException(" +
                this.getUnexpectedType() + "!=" + this.expecting + ")";
    },
    name: "org.antlr.runtime.MismatchedTokenException"
});
/** An extra token while parsing a TokenStream */
org.antlr.runtime.UnwantedTokenException = function(expecting, input) {
    if (arguments.length>0) {
        org.antlr.runtime.UnwantedTokenException.superclass.constructor.call(
                this, expecting, input);
    }
};

org.antlr.lang.extend(
    org.antlr.runtime.UnwantedTokenException,
    org.antlr.runtime.MismatchedTokenException, {
    getUnexpectedToken: function() {
        return this.token;
    },
    toString: function() {
        var exp = ", expected "+this.expecting;
        if ( this.expecting===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
            exp = "";
        }
        if ( !org.antlr.lang.isValue(this.token) ) {
            return "UnwantedTokenException(found="+exp+")";
        }
        return "UnwantedTokenException(found="+this.token.getText()+exp+")";
    },
    name: "org.antlr.runtime.UnwantedTokenException"
});
org.antlr.runtime.MissingTokenException = function(expecting, input, inserted) {
    if (arguments.length>0) {
        org.antlr.runtime.MissingTokenException.superclass.constructor.call(
                this, expecting, input);
        this.inserted = inserted;
    }
};

org.antlr.lang.extend(
    org.antlr.runtime.MissingTokenException,
    org.antlr.runtime.MismatchedTokenException, {
    getMissingType: function() {
        return this.expecting;
    },

    toString: function() {
        if (org.antlr.lang.isValue(this.inserted) &&
            org.antlr.lang.isValue(this.token))
        {
            return "MissingTokenException(inserted "+this.inserted+" at "+this.token.getText()+")";
        }
        if ( org.antlr.lang.isValue(this.token) ) {
            return "MissingTokenException(at "+this.token.getText()+")";
        }
        return "MissingTokenException";
    },
    name: "org.antlr.runtime.MissingTokenException"
});
org.antlr.runtime.NoViableAltException = function(grammarDecisionDescription,
                                            decisionNumber,
                                            stateNumber,
                                            input)
{
    org.antlr.runtime.NoViableAltException.superclass.constructor.call(this, input);
    this.grammarDecisionDescription = grammarDecisionDescription;
    this.decisionNumber = decisionNumber;
    this.stateNumber = stateNumber;
};

org.antlr.lang.extend(
    org.antlr.runtime.NoViableAltException,
    org.antlr.runtime.RecognitionException, {
    toString: function() {
        if ( this.input instanceof org.antlr.runtime.ANTLRStringStream ) {
            return "NoViableAltException('"+this.getUnexpectedType()+"'@["+this.grammarDecisionDescription+"])";
        }
        else {
            return "NoViableAltException("+this.getUnexpectedType()+"@["+this.grammarDecisionDescription+"])";
        }
    },
    name: "org.antlr.runtime.NoViableAltException"
});
/** The recognizer did not match anything for a ()+ loop.
 *
 *  @class
 *  @param {Number} decisionNumber
 *  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
 *  @extends org.antlr.runtime.RecognitionException
 */
org.antlr.runtime.EarlyExitException = function(decisionNumber, input) {
    org.antlr.runtime.EarlyExitException.superclass.constructor.call(
            this, input);
    this.decisionNumber = decisionNumber;
};

org.antlr.lang.extend(
    org.antlr.runtime.EarlyExitException,
    org.antlr.runtime.RecognitionException,
/** @lends org.antlr.runtime.EarlyExitException.prototype */
{
    /** Name of this class.
     *  @type String
     */
    name: "org.antlr.runtime.EarlyExitException"
});
org.antlr.runtime.MismatchedSetException = function(expecting, input) {
    org.antlr.runtime.MismatchedSetException.superclass.constructor.call(
            this, input);
    this.expecting = expecting;
};

org.antlr.lang.extend(
    org.antlr.runtime.MismatchedSetException,
    org.antlr.runtime.RecognitionException, {
    toString: function() {
        return "MismatchedSetException(" +
                this.getUnexpectedType() + "!=" + this.expecting + ")";
    },
    name: "org.antlr.runtime.MismatchedSetException"
});
org.antlr.runtime.MismatchedNotSetException = function(expecting, input) {
    org.antlr.runtime.MismatchedNotSetException.superclass.constructor.call(this, expecting, input);
};

org.antlr.lang.extend(
    org.antlr.runtime.MismatchedNotSetException,
    org.antlr.runtime.MismatchedSetException, {
    toString: function() {
        return "MismatchedNotSetException(" +
                this.getUnexpectedType() + "!=" + this.expecting + ")";
    },
    name: "org.antlr.runtime.MismatchedNotSetException"
});
org.antlr.runtime.MismatchedRangeException = function(a, b, input) {
    if (arguments.length===0) {
        return this;
    }

    org.antlr.runtime.MismatchedRangeException.superclass.constructor.call(
            this, input);
    this.a = a;
    this.b = b;
};

org.antlr.lang.extend(
    org.antlr.runtime.MismatchedRangeException,
    org.antlr.runtime.RecognitionException, {
    toString: function() {
        return "MismatchedRangeException(" +
                this.getUnexpectedType()+" not in ["+this.a+","+this.b+"])";
    },
    name: "org.antlr.runtime.MismatchedRangeException"
});
/** A semantic predicate failed during validation.  Validation of predicates
 *  occurs when normally parsing the alternative just like matching a token.
 *  Disambiguating predicate evaluation occurs when we hoist a predicate into
 *  a prediction decision.
 *
 *  @class
 *  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
 *  @param {String} ruleName name of the rule in which the exception occurred.
 *  @param {String} predicateText the predicate that failed.
 *  @extends org.antlr.runtime.RecognitionException
 */
org.antlr.runtime.FailedPredicateException = function(input, ruleName, predicateText){
    org.antlr.runtime.FailedPredicateException.superclass.constructor.call(this, input);
    this.ruleName = ruleName;
    this.predicateText = predicateText;
};

org.antlr.lang.extend(
    org.antlr.runtime.FailedPredicateException,
    org.antlr.runtime.RecognitionException,
/** @lends org.antlr.runtime.FailedPredicateException.prototype */
{
    /** Create a string representation of this exception.
     *  @returns {String}
     */ 
    toString: function() {
        return "FailedPredicateException("+this.ruleName+",{"+this.predicateText+"}?)";
    },

    /** Name of this class.
     *  @type String
     */
    name: "org.antlr.runtime.FailedPredicateException"
});
/**
 * A BitSet similar to java.util.BitSet.
 *
 * <p>JavaScript Note: There is no good way to implement something like this in 
 * JavaScript.  JS has no true int type, arrays are usually implemented as
 * hashes, etc.  This class should probably be nixed for something that is
 * similarly (in)efficient, but more clear.</p>
 *
 * @class
 * @param {Number|Array} [bits] a 32 bit number or array of 32 bit numbers
 *                              representing the bitset.  These are typically
 *                              generated by the ANTLR Tool.
 */
org.antlr.runtime.BitSet = function(bits) {
    if (!bits) {
        bits = org.antlr.runtime.BitSet.BITS;
    }

    if (org.antlr.lang.isArray(bits)) {
        /**
         * An array of Numbers representing the BitSet.
         * @type Array
         */
        this.bits = bits;
    } else if(org.antlr.lang.isNumber(bits)) {
        this.bits = [];
    }
};

org.antlr.lang.augmentObject(org.antlr.runtime.BitSet, {
    /**
     * Number of bits in each number.
     * @constant
     * @memberOf org.antlr.runtime.BitSet
     */
    BITS: 32,

    /**
     * Log (base 2) of the number of bits in each number.
     * @constant
     * @memberOf org.antlr.runtime.BitSet
     */
    LOG_BITS: 5,  // 2^5 == 32 

    /**
     * We will often need to do a mod operator (i mod nbits).  Its
     * turns out that, for powers of two, this mod operation is
     * same as (i & (nbits-1)).  Since mod is slow, we use a
     * precomputed mod mask to do the mod instead.
     * @constant
     * @memberOf org.antlr.runtime.BitSet
     */
    MOD_MASK: 31, // BITS - 1

    /**
     * Create mask for bit modded to fit in a single word.
     * @example
     * bitmask(35) => 00000000000000000000000000000100
     * bitmask(3)  => 00000000000000000000000000000100
     * @param {Number} bitNumber the bit to create a mask for.
     * @returns {Number} the bitmask.
     * @memberOf org.antlr.runtime.BitSet
     * @private
     */
    bitMask: function(bitNumber) {
        var bitPosition = bitNumber & org.antlr.runtime.BitSet.MOD_MASK;
        return 1 << bitPosition;
    },

    /**
     * Calculate the minimum number of bits needed to represent el.
     * @param {Number} el a number to be included in the BitSet.
     * @returns {Number} the number of bits need to create a BitSet with member
     *                   el.
     * @memberOf org.antlr.runtime.BitSet
     * @private
     */
    numWordsToHold: function(el) {
        return (el >> org.antlr.runtime.BitSet.LOG_BITS) + 1;
    },

    /**
     * @param {Number} bit a number to be included in the BitSet
     * @returns {Number} the index of the word in the field bits that would
     *                   hold bit.
     * @memberOf org.antlr.runtime.BitSet
     * @private
     */
    wordNumber: function(bit) {
        return bit >> org.antlr.runtime.BitSet.LOG_BITS; // bit / BITS
    },

    /**
     * BitSet factory method.
     * 
     * <p>Operates in a number of modes:
     * <ul>
     * <li>If el is a number create the BitSet containing that number.</li>
     * <li>If el is an array create the BitSet containing each number in the
     * array.</li>
     * <li>If el is a BitSet return el.</li>
     * <li>If el is an Object create the BitSet containing each numeric value
     * in el.</li>
     * <li>If el is a number and el2 is a number return a BitSet containing
     * the numbers between el and el2 (inclusive).</li>
     * </ul>
     * </p>
     * @param {Number|Array|org.antlr.runtime.BitSet|Object} el
     * @param {Number} el2
     * @returns {org.antlr.runtime.BitSet}
     * @memberOf org.antlr.runtime.BitSet
     */
    of: function(el, el2) {
        var i, n, s, keys;

        if (org.antlr.lang.isNumber(el)) {
            if (org.antlr.lang.isNumber(el2)) {
                s = new org.antlr.runtime.BitSet(el2 + 1);
                for (i = el; i <= el2; i++) {
                    n = org.antlr.runtime.BitSet.wordNumber(i);
                    s.bits[n] |= org.antlr.runtime.BitSet.bitMask(i);
                }
                return s;
            } else {
                s = new org.antlr.runtime.BitSet(el + 1);
                s.add(el);
                return s;
            }
        } else if(org.antlr.lang.isArray(el)) {
            s = new org.antlr.runtime.BitSet();
            for (i=el.length-1; i>=0; i--) {
                s.add(el[i]);
            }
            return s;
        } else if (el instanceof org.antlr.runtime.BitSet) {
            if (!el) {
                return null;
            }
            return el;
        } else if (el instanceof org.antlr.runtime.IntervalSet) {
            if (!el) {
                return null;
            }
            s = new org.antlr.runtime.BitSet();
            s.addAll(el);
            return s;
        } else if (org.antlr.lang.isObject(el)) {
            keys = [];
            for (i in el) {
                if (org.antlr.lang.isNumber(i)) {
                    keys.push(i);
                }
            }
            return org.antlr.runtime.BitSet.of(keys);
        }
    }
});



org.antlr.runtime.BitSet.prototype = {
    /**
     * Add el into this set.
     * @param {Number} el the number to add to the set.
     */
    add: function(el) {
        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) {
            this.growToInclude(el);
        }
        this.bits[n] |= org.antlr.runtime.BitSet.bitMask(el);
    },

    /**
     * Add multiple elements into this set.
     * @param {Array|org.antlr.runtime.BitSet} elements the elements to be added to
     *                                           this set.
     */
    addAll: function(elements) {
        var other,
            i,
            e;

        if ( elements instanceof org.antlr.runtime.BitSet ) {
            this.orInPlace(elements);
        }
		else if ( elements instanceof org.antlr.runtime.IntervalSet ) {
			other = elements;
			// walk set and add each interval
            /* @todo after implementing intervalset
			for (Iterator iter = other.intervals.iterator(); iter.hasNext();) {
				Interval I = (Interval) iter.next();
				this.orInPlace(BitSet.range(I.a,I.b));
			}*/
		} else if (org.antlr.lang.isArray(elements)) {
    		for (i = 0; i < elements.length; i++) {
	    		e = elements[i];
		    	this.add(e);
    		}
        } else {
            return;
        }
	},

    /**
     * Clone this BitSet and then {@link #andInPlace} with a.
     * @param {org.antlr.runtime.BitSet} a a bit set.
     * @returns {org.antlr.runtime.BitSet}
     */
    and: function(a) {
        var s = this.clone();
        s.andInPlace(a);
        return s;
    },

    /**
     * Perform a logical AND of this target BitSet with the argument BitSet.
     *
     * This bit set is modified so that each bit in it has the value true if 
     * and only if it both initially had the value true and the corresponding 
     * bit in the bit set argument also had the value true. 
     * @param {org.antlr.runtime.BitSet} a a bit set.
     * @returns {org.antlr.runtime.BitSet}
     */
    andInPlace: function(a) {
        var min = Math.min(this.bits.length, a.bits.length),
            i;
        for (i = min - 1; i >= 0; i--) {
            this.bits[i] &= a.bits[i];
        }
        // clear all bits in this not present in a (if this bigger than a).
        for (i = min; i < this.bits.length; i++) {
            this.bits[i] = 0;
        }
    },

    /**
     * Clear all bits or a specific bit.
     *
     * If no arguments given, sets all of the bits in this BitSet to false.
     * If one argument given, sets the bit specified by the index to false.
     * @param {Number} [el] the index of the bit to be cleared.
     */
    clear: function(el) {
        if (arguments.length===0) {
            var i;
            for (i = this.bits.length - 1; i >= 0; i--) {
                this.bits[i] = 0;
            }
            return;
        }

        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) {	// grow as necessary to accommodate
            this.growToInclude(el);
        }
        this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
    },

    /**
     * Cloning this BitSet produces a new BitSet  that is equal to it. 
     *
     * The clone of the bit set is another bit set that has exactly the same
     * bit set to true as this bit set. 
     * @returns {org.antlr.runtime.BitSet} a clone of this BitSet.
     */
    clone: function() {
        var i, len, b=[];
        for (i=0, len=this.bits.length; i<len; i++) {
            b[i] = this.bits[i];
        }
        return new org.antlr.runtime.BitSet(b);
    },

    /**
     * Returns the number of bits of space actually in use by this BitSet to 
     * represent bit values.
     *
     * The maximum element in the set is the size - 1st element. 
     * @returns {Number} the number of bits currently in this bit set.
     */
    size: function() {
        var deg = 0, i, word, bit;
        for (i = this.bits.length - 1; i >= 0; i--) {
            word = this.bits[i];
            if (word !== 0) {
                for (bit = org.antlr.runtime.BitSet.BITS - 1; bit >= 0; bit--) {
                    if ((word & (1 << bit)) !== 0) {
                        deg++;
                    }
                }
            }
        }
        return deg;
    },

    /**
     * Compares this object against the specified object.
     *
     * The result is true if and only if the argument is not null and is a
     * BitSet object that has exactly the same set of bits set to true as
     * this bit set. That is, for every nonnegative int index k,
     * <pre><code>
     * ((BitSet)obj).get(k) == this.get(k)
     * </code></pre>
     * must be true. The current sizes of the two bit sets are not compared.
     * @param {Object} other the object to compare with.
     * @returns {Boolean} if the objects are the same; false otherwise.
     */
    equals: function(other) {
        if ( !other || !(other instanceof org.antlr.runtime.BitSet) ) {
            return false;
        }

        var otherSet = other,
            i,
            n = Math.min(this.bits.length, otherSet.bits.length);

        // for any bits in common, compare
        for (i=0; i<n; i++) {
            if (this.bits[i] != otherSet.bits[i]) {
                return false;
            }
        }

        // make sure any extra bits are off

        if (this.bits.length > n) {
            for (i = n+1; i<this.bits.length; i++) {
                if (this.bits[i] !== 0) {
                    return false;
                }
            }
        }
        else if (otherSet.bits.length > n) {
            for (i = n+1; i<otherSet.bits.length; i++) {
                if (otherSet.bits[i] !== 0) {
                    return false;
                }
            }
        }

        return true;
    },

    /**
     * Grows the set to a larger number of bits.
     * @param {Number} bit element that must fit in set
     * @private
     */
    growToInclude: function(bit) {
        var newSize = Math.max(this.bits.length << 1, org.antlr.runtime.BitSet.numWordsToHold(bit)),
            newbits = [], //new Array(newSize),
            i;
        for (i=0, len=this.bits.length; i<len; i++) {
            newbits[i] = this.bits[i];
        }
        this.bits = newbits;
    },

    /**
     * Returns the value of the bit with the specified index.
     *
     * The value is true if the bit with the index el is currently set 
     * in this BitSet; otherwise, the result is false.
     * @param {Number} el the bit index.
     * @returns {Boolean} the value of the bit with the specified index.
     */
    member: function(el) {
        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) { return false; }
        return (this.bits[n] & org.antlr.runtime.BitSet.bitMask(el)) !== 0;
    },

    /**
     * Returns the index of the first bit that is set to true.
     * If no such bit exists then -1 is returned.
     * @returns {Number} the index of the next set bit.
     */
    getSingleElement: function() {
        var i;
        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                return i;
            }
        }
        return -1; //Label.INVALID;
    },

    /**
     * Returns true if this BitSet contains no bits that are set to true.
     * @returns {Boolean} boolean indicating whether this BitSet is empty.
     */
    isNil: function() {
        var i;
        for (i = this.bits.length - 1; i >= 0; i--) {
            if (this.bits[i] !== 0) {
                return false;
            }
        }
        return true;
    },

    /**
     * If a bit set argument is passed performs a {@link #subtract} of this bit
     * set with the argument bit set.  If no argument is passed, clone this bit
     * set and {@link #notInPlace}.
     * @param {org.antlr.runtime.BitSet} [set]
     * @returns {org.antlr.runtime.BitSet}
     */
    complement: function(set) {
        if (set) {
            return set.subtract(this);
        } else {
            var s = this.clone();
            s.notInPlace();
            return s;
        }
    },

    /**
     * If no arguments are passed sets all bits to the complement of their
     * current values.  If one argument is passed sets each bit from the
     * beginning of the bit set to index1 (inclusive) to the complement of its
     * current value.  If two arguments are passed sets each bit from the
     * specified index1 (inclusive) to the sepcified index2 (inclusive) to the
     * complement of its current value.
     * @param {Number} index1
     * @param {Number} index2
     */
    notInPlace: function() {
        var minBit, maxBit, i, n;
        if (arguments.length===0) {
            for (i = this.bits.length - 1; i >= 0; i--) {
                this.bits[i] = ~this.bits[i];
            }
        } else {
            if (arguments.length===1) {
                minBit = 0;
                maxBit = arguments[0];
            } else {
                minBit = arguments[0];
                maxBit = arguments[1];
            }
            // make sure that we have room for maxBit
            this.growToInclude(maxBit);
            for (i = minBit; i <= maxBit; i++) {
                n = org.antlr.runtime.BitSet.wordNumber(i);
                this.bits[n] ^= org.antlr.runtime.BitSet.bitMask(i);
            }
        }

    },

    /**
     * Performs a logical OR of this bit set with the bit set argument.
     * If no argument is passed, return this bit set.  Otherwise a clone of
     * this bit set is modified so that a bit in it has the value true if and
     * only if it either already had the value true or the corresponding bit
     * in the bit set argument has the value true.
     * @param {org.antlr.runtime.BitSet} [a] a bit set.
     * @returns {org.antlr.runtime.BitSet}
     */
    or: function(a) {
		if ( !a ) {
			return this;
		}
        var s = this.clone();
        s.orInPlace(a);
        return s;
    },

    /**
     * Performs a logical {@link #or} in place.
     * @param {org.antlr.runtime.BitSet} [a]
     * @returns {org.antlr.runtime.BitSet}
     */
    orInPlace: function(a) {
		if ( !a ) {
			return;
		}
        // If this is smaller than a, grow this first
        if (a.bits.length > this.bits.length) {
            this.setSize(a.bits.length);
        }
        var min = Math.min(this.bits.length, a.bits.length),
            i;
        for (i = min - 1; i >= 0; i--) {
            this.bits[i] |= a.bits[i];
        }
    },

    /**
     * Sets the bit specified by the index to false.
     * @param {Number} bitIndex the index of the bit to be cleared.
     */
    remove: function(el) {
        var n = org.antlr.runtime.BitSet.wordNumber(el);
        if (n >= this.bits.length) {
            this.growToInclude(el);
        }
        this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
    },

    /**
     * Grows the internal bits array to include at least nwords numbers.
     * @private
     * @param {Number} nwords how many words the new set should be
     * @private
     */
    setSize: function(nwords) {
        var n = nwords - this.bits.length;
        while (n>=0) {
            this.bits.push(0);
            n--;
        }
    },

    /**
     * Returns the number of bits capable of being represented by this bit set
     * given its current size.
     * @returns {Number} the maximum number of bits that can be represented at
     *                   the moment.
     * @private
     */
    numBits: function() {
        return this.bits.length << org.antlr.runtime.BitSet.LOG_BITS; // num words * bits per word
    },

    /**
     * Return how much space is being used by the bits array not
     * how many actually have member bits on.
     * @returns {Number} the length of the internal bits array.
     * @private
     */
    lengthInLongWords: function() {
        return this.bits.length;
    },

    /**
     * Is this bit set contained within a?
     * @param {org.antlr.runtime.BitSet} a bit set
     * @returns {Boolean} true if and only if a is a subset of this bit set.
     */
    subset: function(a) {
        if (!a) { return false; }
        return this.and(a).equals(this);
    },

    /**
     * Subtract the elements of the argument bit set from this bit set in place.
     * That is, for each set bit in the argument bit set, set the corresponding
     * bit in this bit set to false.
     * @param {org.antlr.runtime.BitSet} a bit set.
     */
    subtractInPlace: function(a) {
        if (!a) { return; }
        // for all words of 'a', turn off corresponding bits of 'this'
        var i;
        for (i = 0; i < this.bits.length && i < a.bits.length; i++) {
            this.bits[i] &= ~a.bits[i];
        }
    },

    /**
     * Perform a {@link #subtractInPlace} on a clone of this bit set.
     * @param {org.antlr.runtime.BitSet} a bit set.
     * @returns {org.antlr.runtime.BitSet} the new bit set.
     */
    subtract: function(a) {
        if (!a || !(a instanceof org.antlr.runtime.BitSet)) { return null; }

        var s = this.clone();
        s.subtractInPlace(a);
        return s;
    },

    /* antlr-java needs this to make its class hierarchy happy . . .
    toList: function() {
		throw new Error("BitSet.toList() unimplemented");
	},
    */

    /**
     * Creates an array of the indexes of each bit set in this bit set.
     * @returns {Array}
     */
    toArray: function() {
        var elems = [], //new Array(this.size()),
            i,
            en = 0;
        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                elems[en++] = i;
            }
        }
        return elems;
    },

    /**
     * Returns the internal representation of this bit set.
     * This representation is an array of numbers, each representing 32 bits.
     * @returns {Array}
     */
    toPackedArray: function() {
        return this.bits;
    },

    /**
     * Returns a string representation of this bit set.
     * <p>For every index for which this BitSet contains a bit in the set state,
     * the decimal representation of that index is included in the result.
     * Such indices are listed in order from lowest to highest, separated by
     * ", " (a comma and a space) and surrounded by braces, resulting in the
     * usual mathematical notation for a set of integers.</p>
     * 
     * <p>If a grammar g is passed, print g.getTokenDisplayName(i) for each set
     * index instead of the numerical index.</p>
     *
     * <>If two arguments are passed, the first will be used as a custom
     * separator string.  The second argument is an array whose i-th element
     * will be added if the corresponding bit is set.</p>
     *
     * @param {Object|String} [arg1] an Object with function property
     *      getTokenDispalyName or a String that will be used as a list
     *      separator.
     * @param {Array} [vocabulary] array from which the i-th value will be
     *      drawn if the corresponding bit is set.  Must pass a string as the
     *      first argument if using this option.
     * @return A commma-separated list of values
     */
    toString: function() {
        if (arguments.length===0) {
            return this.toString1(null);
        } else {
            if (org.antlr.lang.isString(arguments[0])) {
                if (!org.antlr.lang.isValue(arguments[1])) {
                    return this.toString1(null);
                } else {
                    return this.toString2(arguments[0], arguments[1]);
                }
            } else {
                return this.toString1(arguments[0]);
            }
        }
    },

    /**
     * Transform a bit set into a string by formatting each element as an
     * integer separator The string to put in between elements
     * @private
     * @return A commma-separated list of values
     */
    toString1: function(g) {
        var buf = "{",
            separator = ",",
            i,
		    havePrintedAnElement = false;

        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                if (i > 0 && havePrintedAnElement ) {
                    buf += separator;
                }
                if ( g ) {
                    buf += g.getTokenDisplayName(i);
                }
                else {
                    buf += i.toString();
                }
				havePrintedAnElement = true;
            }
        }
        return buf + "}";
    },

    /**
     * Create a string representation where instead of integer elements, the
     * ith element of vocabulary is displayed instead.  Vocabulary is a Vector
     * of Strings.
     * separator The string to put in between elements
     * @private
     * @return A commma-separated list of character constants.
     */
    toString2: function(separator, vocabulary) {
        var str = "",
            i;
        for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
            if (this.member(i)) {
                if (str.length > 0) {
                    str += separator;
                }
                if (i >= vocabulary.size()) {
                    str += "'" + i + "'";
                }
                else if (!org.antlr.lang.isValue(vocabulary.get(i))) {
                    str += "'" + i + "'";
                }
                else {
                    str += vocabulary.get(i);
                }
            }
        }
        return str;
    }

    /*
     * Dump a comma-separated list of the words making up the bit set.
     * Split each 32 bit number into two more manageable 16 bit numbers.
     * @returns {String} comma separated list view of the this.bits property.
     *
    toStringOfHalfWords: function() {
        var s = "",
            tmp,
            i;
        for (i = 0; i < this.bits.length; i++) {
            if (i !== 0) {
                s+=", ";
            }
            tmp = this.bits[i];
            tmp &= 0xFFFF;
            s += tmp + "UL, ";
            tmp = this.bits[i] >> 16;
            tmp &= 0xFFFF;
            s += tmp+"UL";
        }
		return s;
    },
    */

    /*
     * Dump a comma-separated list of the words making up the bit set.
     * This generates a comma-separated list of Java-like long int constants.
     *
    toStringOfWords: function() {
        var s="",
            i;
        for (i = 0; i < this.bits.length; i++) {
            if (i !== 0) {
                s+=", ";
            }
            s += this.bits[i]+"L";
        }
        return s;
    },

    toStringWithRanges: function() {
        return this.toString();
    }
    */
};

/*
 *
 *
org.antlr.runtime.IntervalSet = function() {
        throw new Error("not implemented");
};
*/
org.antlr.runtime.CharStream = {
    EOF: -1
};
org.antlr.runtime.CommonToken = function() {
    var oldToken;

    this.charPositionInLine = -1; // set to invalid position
    this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
    this.index = -1;

    if (arguments.length == 1) {
        if (org.antlr.lang.isNumber(arguments[0])) {
            this.type = arguments[0];
        } else {
            oldToken = arguments[0];
            this.text = oldToken.getText();
            this.type = oldToken.getType();
            this.line = oldToken.getLine();
            this.index = oldToken.getTokenIndex();
            this.charPositionInLine = oldToken.getCharPositionInLine();
            this.channel = oldToken.getChannel();
            if ( oldToken instanceof org.antlr.runtime.CommonToken ) {
                this.start = oldToken.start;
                this.stop = oldToken.stop;
            }
        }
    } else if (arguments.length == 2) {
        this.type = arguments[0];
        this.text = arguments[1];
        this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
    } else if (arguments.length == 5) {
        this.input = arguments[0];
        this.type = arguments[1];
        this.channel = arguments[2];
        this.start = arguments[3];
        this.stop = arguments[4];
    }
};

org.antlr.runtime.CommonToken.prototype = {
    getType: function() {
        return this.type;
    },

    setLine: function(line) {
        this.line = line;
    },

    getText: function() {
        if ( org.antlr.lang.isString(this.text) ) {
            return this.text;
        }
        if ( !this.input ) {
            return null;
        }
        this.text = this.input.substring(this.start,this.stop);
        return this.text;
    },

    /** Override the text for this token.  getText() will return this text
     *  rather than pulling from the buffer.  Note that this does not mean
     *  that start/stop indexes are not valid.  It means that that input
     *  was converted to a new string in the token object.
     */
    setText: function(text) {
        this.text = text;
    },

    getLine: function() {
        return this.line;
    },

    getCharPositionInLine: function() {
        return this.charPositionInLine;
    },

    setCharPositionInLine: function(charPositionInLine) {
        this.charPositionInLine = charPositionInLine;
    },

    getChannel: function() {
        return this.channel;
    },

    setChannel: function(channel) {
        this.channel = channel;
    },

    setType: function(type) {
        this.type = type;
    },

    getStartIndex: function() {
        return this.start;
    },

    setStartIndex: function(start) {
        this.start = start;
    },

    getStopIndex: function() {
        return this.stop;
    },

    setStopIndex: function(stop) {
        this.stop = stop;
    },

    getTokenIndex: function() {
        return this.index;
    },

    setTokenIndex: function(index) {
        this.index = index;
    },

    getInputStream: function() {
        return this.input;
    },

    setInputStream: function(input) {
        this.input = input;
    },

    toString: function() {
        var channelStr = "";
        if ( this.channel>0 ) {
            channelStr=",channel="+this.channel;
        }
        var txt = this.getText();
        if ( !org.antlr.lang.isNull(txt) ) {
            txt = txt.replace(/\n/g,"\\\\n");
            txt = txt.replace(/\r/g,"\\\\r");
            txt = txt.replace(/\t/g,"\\\\t");
        }
        else {
            txt = "<no text>";
        }
        return "[@"+this.getTokenIndex()+","+this.start+":"+this.stop+"='"+txt+"',<"+this.type+">"+channelStr+","+this.line+":"+this.getCharPositionInLine()+"]";
    }
};
// NB: Because Token has static members of type CommonToken, the Token dummy
// constructor is defined in CommonToken.  All methods and vars of Token are
// defined here.  Token is an interface, not a subclass in the Java runtime.

/**
 * @class Abstract base class of all token types.
 * @name Token
 * @memberOf org.antlr.runtime
 */
org.antlr.runtime.Token = function() {};
org.antlr.lang.augmentObject(org.antlr.runtime.Token, /** @lends Token */ {
    EOR_TOKEN_TYPE: 1,

    /** imaginary tree navigation type; traverse "get child" link */
    DOWN: 2,
    /** imaginary tree navigation type; finish with a child list */
    UP: 3,

    MIN_TOKEN_TYPE: 4, // UP+1,

    EOF: org.antlr.runtime.CharStream.EOF,
    EOF_TOKEN: new org.antlr.runtime.CommonToken(org.antlr.runtime.CharStream.EOF),

    INVALID_TOKEN_TYPE: 0,
    INVALID_TOKEN: new org.antlr.runtime.CommonToken(0),

    /** In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
     *  will avoid creating a token for this symbol and try to fetch another.
     */
    SKIP_TOKEN: new org.antlr.runtime.CommonToken(0),

    /** All tokens go to the parser (unless skip() is called in that rule)
     *  on a particular "channel".  The parser tunes to a particular channel
     *  so that whitespace etc... can go to the parser on a "hidden" channel.
     */
    DEFAULT_CHANNEL: 0,

    /** Anything on different channel than DEFAULT_CHANNEL is not parsed
     *  by parser.
     */
    HIDDEN_CHANNEL: 99
});

org.antlr.lang.augmentObject(org.antlr.runtime.CommonToken, org.antlr.runtime.Token);
org.antlr.runtime.tree = {};
org.antlr.runtime.tree.RewriteCardinalityException = function(elementDescription) {
    this.elementDescription = elementDescription;
};

/** Base class for all exceptions thrown during AST rewrite construction.
 *  This signifies a case where the cardinality of two or more elements
 *  in a subrule are different: (ID INT)+ where |ID|!=|INT|
 */
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteCardinalityException, Error, {
    getMessage: function() {
		if ( org.antlr.lang.isString(this.elementDescription) ) {
			return this.elementDescription;
		}
		return null;
	},
    name: function() {
        return "org.antlr.runtime.tree.RewriteCardinalityException";
    }
});
/** Ref to ID or expr but no tokens in ID stream or subtrees in expr stream */
org.antlr.runtime.tree.RewriteEmptyStreamException = function(elementDescription) {
    var sup = org.antlr.runtime.tree.RewriteEmptyStreamException.superclass; 
    sup.constructor.call(this, elementDescription);
};

org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEmptyStreamException,
                  org.antlr.runtime.tree.RewriteCardinalityException, {
    name: function() {
        return "org.antlr.runtime.tree.RewriteEmptyStreamException";
    }
});
/** No elements within a (...)+ in a rewrite rule */
org.antlr.runtime.tree.RewriteEarlyExitException = function(elementDescription) {
    var sup = org.antlr.runtime.tree.RewriteEarlyExitException.superclass;
    if (org.antlr.lang.isUndefined(elementDescription)) {
        elementDescription = null;
    }
    sup.constructor.call(this, elementDescription);
};

org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEarlyExitException,
                  org.antlr.runtime.tree.RewriteCardinalityException, {
    name: function() {
        return "org.antlr.runtime.tree.RewriteEarlyExitException";
    }    
});
org.antlr.runtime.MismatchedTreeNodeException = function(expecting, input) {
    if (expecting && input) {
        org.antlr.runtime.MismatchedTreeNodeException.superclass.constructor.call(
                this, input);
        this.expecting = expecting;
    }
};

org.antlr.lang.extend(
    org.antlr.runtime.MismatchedTreeNodeException,
    org.antlr.runtime.RecognitionException, {
    toString: function() {
        return "MismatchedTreeNodeException(" +
                this.getUnexpectedType() + "!=" + this.expecting + ")";
    },
    name: "org.antlr.runtime.MismatchedTreeNodeException"
});
/** A generic tree implementation with no payload.  You must subclass to
 *  actually have any user data.  ANTLR v3 uses a list of children approach
 *  instead of the child-sibling approach in v2.  A flat tree (a list) is
 *  an empty node whose children represent the list.  An empty, but
 *  non-null node is called "nil".
 */
org.antlr.runtime.tree.BaseTree = function() {};

org.antlr.runtime.tree.BaseTree.prototype = {
    getChild: function(i) {
        if ( !this.children || i>=this.children.length ) {
            return null;
        }
        return this.children[i];
    },

    /** Get the children internal List; note that if you directly mess with
     *  the list, do so at your own risk.
     */
    getChildren: function() {
        return this.children;
    },

    getFirstChildWithType: function(type) {
        var i, t;
        for (i = 0; this.children && i < this.children.length; i++) {
            t = this.children[i];
            if ( t.getType()===type ) {
                return t;
            }
        }    
        return null;
    },

    getChildCount: function() {
        if ( !this.children ) {
            return 0;
        }
        return this.children.length;
    },

    /** Add t as child of this node.
     *
     *  Warning: if t has no children, but child does
     *  and child isNil then this routine moves children to t via
     *  t.children = child.children; i.e., without copying the array.
     */
    addChild: function(t) {
        if ( !org.antlr.lang.isValue(t) ) {
            return; // do nothing upon addChild(null)
        }
        var childTree = t, n, i, c;
        if ( childTree.isNil() ) { // t is an empty node possibly with children
            if ( this.children && this.children == childTree.children ) {
                throw new Error("attempt to add child list to itself");
            }
            // just add all of childTree's children to this
            if ( childTree.children ) {
                if ( this.children ) { // must copy, this has children already
                    n = childTree.children.length;
                    for (i = 0; i < n; i++) {
                        c = childTree.children[i];
                        this.children.push(c);
                        // handle double-link stuff for each child of nil root
                        c.setParent(this);
                        c.setChildIndex(this.children.length-1);
                    }
                }
                else {
                    // no children for this but t has children; just set pointer
                    // call general freshener routine
                    this.children = childTree.children;
                    this.freshenParentAndChildIndexes();
                }
            }
        }
        else { // child is not nil (don't care about children)
            if ( !this.children ) {
                this.children = this.createChildrenList(); // create children list on demand
            }
            this.children.push(t);
            childTree.setParent(this);
            childTree.setChildIndex(this.children.length-1);
        }
    },

    /** Add all elements of kids list as children of this node */
    addChildren: function(kids) {
        var i, t;
        for (i = 0; i < kids.length; i++) {
            t = kids[i];
            this.addChild(t);
        }
    },

    setChild: function(i, t) {
        if ( !t ) {
            return;
        }
        if ( t.isNil() ) {
            throw new Error("Can't set single child to a list");
        }
        if ( !this.children ) {
            this.children = this.createChildrenList();
        }
        this.children[i] = t;
        t.setParent(this);
        t.setChildIndex(i);
    },

    deleteChild: function(i) {
        if ( !this.children ) {
            return null;
        }
        if (i<0 || i>=this.children.length) {
            throw new Error("Index out of bounds.");
        }
        var killed = this.children.splice(i, 1)[0];
        // walk rest and decrement their child indexes
        this.freshenParentAndChildIndexes(i);
        return killed;
    },

    /** Delete children from start to stop and replace with t even if t is
     *  a list (nil-root tree).  num of children can increase or decrease.
     *  For huge child lists, inserting children can force walking rest of
     *  children to set their childindex; could be slow.
     */
    replaceChildren: function(startChildIndex, stopChildIndex, t) {
        if ( !this.children ) {
            throw new Error("indexes invalid; no children in list");
        }
        var replacingHowMany = stopChildIndex - startChildIndex + 1;
        var replacingWithHowMany;
        var newTree = t;
        var newChildren = null;
        // normalize to a list of children to add: newChildren
        if ( newTree.isNil() ) {
            newChildren = newTree.children;
        }
        else {
            newChildren = [];
            newChildren.push(newTree);
        }
        replacingWithHowMany = newChildren.length;
        var numNewChildren = newChildren.length;
        var delta = replacingHowMany - replacingWithHowMany;
        var j, i, child, indexToDelete, c, killed, numToInsert;
        // if same number of nodes, do direct replace
        if ( delta === 0 ) {
            j = 0; // index into new children
            for (i=startChildIndex; i<=stopChildIndex; i++) {
                child = newChildren[j];
                this.children[i] = child;
                child.setParent(this);
                child.setChildIndex(i);
                j++;
            }
        }
        else if ( delta > 0 ) { // fewer new nodes than there were
            // set children and then delete extra
            for (j=0; j<numNewChildren; j++) {
                this.children[startChildIndex+j] = newChildren[j];
            }
            indexToDelete = startChildIndex+numNewChildren;
            for (c=indexToDelete; c<=stopChildIndex; c++) {
                // delete same index, shifting everybody down each time
                killed = this.children.splice(indexToDelete, 1)[0];
            }
            this.freshenParentAndChildIndexes(startChildIndex);
        }
        else { // more new nodes than were there before
            // fill in as many children as we can (replacingHowMany) w/o moving data
            for (j=0; j<replacingHowMany; j++) {
                this.children[startChildIndex+j] = newChildren[j];
            }
            numToInsert = replacingWithHowMany-replacingHowMany;
            for (j=replacingHowMany; j<replacingWithHowMany; j++) {
                this.children.splice(startChildIndex+j, 0, newChildren[j]);
            }
            this.freshenParentAndChildIndexes(startChildIndex);
        }
    },

    /** Override in a subclass to change the impl of children list */
    createChildrenList: function() {
        return [];
    },

    isNil: function() {
        return false;
    },

    freshenParentAndChildIndexes: function(offset) {
        if (!org.antlr.lang.isNumber(offset)) {
            offset = 0;
        }
        var n = this.getChildCount(),
            c,
            child;
        for (c = offset; c < n; c++) {
            child = this.getChild(c);
            child.setChildIndex(c);
            child.setParent(this);
        }
    },

    sanityCheckParentAndChildIndexes: function(parent, i) {
        if (arguments.length===0) {
            parent = null;
            i = -1;
        }

        if ( parent!==this.getParent() ) {
            throw new Error("parents don't match; expected "+parent+" found "+this.getParent());
        }
        if ( i!==this.getChildIndex() ) {
            throw new Error("child indexes don't match; expected "+i+" found "+this.getChildIndex());
        }
        var n = this.getChildCount(),
            c,
            child;
        for (c = 0; c < n; c++) {
            child = this.getChild(c);
            child.sanityCheckParentAndChildIndexes(this, c);
        }
    },

    /** BaseTree doesn't track child indexes. */
    getChildIndex: function() {
        return 0;
    },
    setChildIndex: function(index) {
    },

    /** BaseTree doesn't track parent pointers. */
    getParent: function() {
        return null;
    },
    setParent: function(t) {
    },

    getTree: function() {
        return this;
    },

    /** Print out a whole tree not just a node */
    toStringTree: function() {
        if ( !this.children || this.children.length===0 ) {
            return this.toString();
        }
        var buf = "",
            i,
            t;
        if ( !this.isNil() ) {
            buf += "(";
            buf += this.toString();
            buf += ' ';
        }
        for (i = 0; this.children && i < this.children.length; i++) {
            t = this.children[i];
            if ( i>0 ) {
                buf += ' ';
            }
            buf += t.toStringTree();
        }
        if ( !this.isNil() ) {
            buf += ")";
        }
        return buf;
    },

    getLine: function() {
        return 0;
    },

    getCharPositionInLine: function() {
        return 0;
    }
};
/** A tree node that is wrapper for a Token object.  After 3.0 release
 *  while building tree rewrite stuff, it became clear that computing
 *  parent and child index is very difficult and cumbersome.  Better to
 *  spend the space in every tree node.  If you don't want these extra
 *  fields, it's easy to cut them out in your own BaseTree subclass.
 */
org.antlr.runtime.tree.CommonTree = function(node) {
    /** What token indexes bracket all tokens associated with this node
     *  and below?
     */
    this.startIndex = -1;
    this.stopIndex = -1;

    /** What index is this node in the child list? Range: 0..n-1 */
    this.childIndex = -1;

    /** Who is the parent node of this node; if null, implies node is root */
    this.parent = null;

    /** A single token is the payload */
    this.token = null;

    if (node instanceof org.antlr.runtime.tree.CommonTree) {
        org.antlr.runtime.tree.CommonTree.superclass.constructor.call(this, node);
        this.token = node.token;
        this.startIndex = node.startIndex;
        this.stopIndex = node.stopIndex;
    } else if (node instanceof org.antlr.runtime.CommonToken) {
        this.token = node;
    }
};

/** A tree node that is wrapper for a Token object. */
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTree, org.antlr.runtime.tree.BaseTree, {
    getToken: function() {
        return this.token;
    },

    dupNode: function() {
        return new org.antlr.runtime.tree.CommonTree(this);
    },

    isNil: function() {
        return !this.token;
    },

    getType: function() {
        if ( !this.token ) {
            return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
        }
        return this.token.getType();
    },

    getText: function() {
        if ( !this.token ) {
            return null;
        }
        return this.token.getText();
    },

    getLine: function() {
        if ( !this.token || this.token.getLine()===0 ) {
            if ( this.getChildCount()>0 ) {
                return this.getChild(0).getLine();
            }
            return 0;
        }
        return this.token.getLine();
    },

    getCharPositionInLine: function() {
        if ( !this.token || this.token.getCharPositionInLine()===-1 ) {
            if ( this.getChildCount()>0 ) {
                return this.getChild(0).getCharPositionInLine();
            }
            return 0;
        }
        return this.token.getCharPositionInLine();
    },

    getTokenStartIndex: function() {
        if ( this.token ) {
            return this.token.getTokenIndex();
        }
        return this.startIndex;
    },

    setTokenStartIndex: function(index) {
        this.startIndex = index;
    },

    getTokenStopIndex: function() {
        if ( this.token ) {
            return this.token.getTokenIndex();
        }
        return this.stopIndex;
    },

    setTokenStopIndex: function(index) {
        this.stopIndex = index;
    },

    getChildIndex: function() {
        return this.childIndex;
    },

    getParent: function() {
        return this.parent;
    },

    setParent: function(t) {
        this.parent = t;
    },

    setChildIndex: function(index) {
        this.childIndex = index;
    },

    toString: function() {
        if ( this.isNil() ) {
            return "nil";
        }
        if ( this.getType()===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
            return "<errornode>";
        }
        if ( !this.token ) {
            return null;
        }
        return this.token.getText();
    }
});
/** What does a tree look like?  ANTLR has a number of support classes
 *  such as CommonTreeNodeStream that work on these kinds of trees.  You
 *  don't have to make your trees implement this interface, but if you do,
 *  you'll be able to use more support code.
 *
 *  NOTE: When constructing trees, ANTLR can build any kind of tree; it can
 *  even use Token objects as trees if you add a child list to your tokens.
 *
 *  This is a tree node without any payload; just navigation and factory stuff.
 */
org.antlr.runtime.tree.Tree = {
    INVALID_NODE: new org.antlr.runtime.tree.CommonTree(org.antlr.runtime.Token.INVALID_TOKEN)
};
org.antlr.runtime.tree.CommonErrorNode = function(input, start, stop, e) {
    if ( !stop ||
            (stop.getTokenIndex() < start.getTokenIndex() &&
             stop.getType()!=org.antlr.runtime.Token.EOF) )
    {
        // sometimes resync does not consume a token (when LT(1) is
        // in follow set.  So, stop will be 1 to left to start. adjust.
        // Also handle case where start is the first token and no token
        // is consumed during recovery; LT(-1) will return null.
        stop = start;
    }
    this.input = input;
    this.start = start;
    this.stop = stop;
    this.trappedException = e;
};

org.antlr.lang.extend(org.antlr.runtime.tree.CommonErrorNode, org.antlr.runtime.tree.CommonTree, {
    isNil: function() {
        return false;
    },

    getType: function() {
        return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
    },

    getText: function() {
        var badText = null;
        if ( this.start instanceof org.antlr.runtime.CommonToken ) {
            var i = this.start.getTokenIndex();
            var j = this.stop.getTokenIndex();
            if ( this.stop.getType() === org.antlr.runtime.Token.EOF ) {
                j = this.input.size();
            }
            badText = this.input.toString(i, j);
        }
        else if ( this.start instanceof org.antlr.runtime.tree.CommonTree ) {
            badText = this.input.toString(this.start, this.stop);
        }
        else {
            // people should subclass if they alter the tree type so this
            // next one is for sure correct.
            badText = "<unknown>";
        }
        return badText;
    },

    toString: function() {
        if ( this.trappedException instanceof org.antlr.runtime.MissingTokenException ) {
            return "<missing type: "+
                   this.trappedException.getMissingType()+
                   ">";
        }
        else if ( this.trappedException instanceof org.antlr.runtime.UnwantedTokenException ) {
            return "<extraneous: "+
                   this.trappedException.getUnexpectedToken()+
                   ", resync="+this.getText()+">";
        }
        else if ( this.trappedException instanceof org.antlr.runtime.MismatchedTokenException ) {
            return "<mismatched token: "+this.trappedException.token+", resync="+this.getText()+">";
        }
        else if ( this.trappedException instanceof org.antlr.runtime.NoViableAltException ) {
            return "<unexpected: "+this.trappedException.token+
                   ", resync="+this.getText()+">";
        }
        return "<error: "+this.getText()+">";
    }
});
/** A TreeAdaptor that works with any Tree implementation. */
org.antlr.runtime.tree.BaseTreeAdaptor = function() {
    this.uniqueNodeID = 1;
};

org.antlr.runtime.tree.BaseTreeAdaptor.prototype = {
    nil: function() {
        return this.create(null);
    },

    /** create tree node that holds the start and stop tokens associated
     *  with an error.
     *
     *  If you specify your own kind of tree nodes, you will likely have to
     *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
     *  if no token payload but you might have to set token type for diff
     *  node type.
     */
    errorNode: function(input, start, stop, e) {
        var t = new org.antlr.runtime.tree.CommonErrorNode(input, start, stop, e);
        return t;
    },

    isNil: function(tree) {
        return tree.isNil();
    },

    /** This is generic in the sense that it will work with any kind of
     *  tree (not just Tree interface).  It invokes the adaptor routines
     *  not the tree node routines to do the construction.  
     */
    dupTree: function(t, parent) {
        if (arguments.length===1) {
            parent = null;
        }
        if ( !t ) {
            return null;
        }
        var newTree = this.dupNode(t);
        // ensure new subtree root has parent/child index set
        this.setChildIndex(newTree, this.getChildIndex(t)); // same index in new tree
        this.setParent(newTree, parent);
        var n = this.getChildCount(t),
            i, child, newSubTree;
        for (i = 0; i < n; i++) {
            child = this.getChild(t, i);
            newSubTree = this.dupTree(child, t);
            this.addChild(newTree, newSubTree);
        }
        return newTree;
    },

    /** Add a child to the tree t.  If child is a flat tree (a list), make all
     *  in list children of t.  Warning: if t has no children, but child does
     *  and child isNil then you can decide it is ok to move children to t via
     *  t.children = child.children; i.e., without copying the array.  Just
     *  make sure that this is consistent with have the user will build
     *  ASTs.
     */
    addChild: function(t, child) {
        if ( t && org.antlr.lang.isValue(child) ) {
            t.addChild(child);
        }
    },

    /** If oldRoot is a nil root, just copy or move the children to newRoot.
     *  If not a nil root, make oldRoot a child of newRoot.
     *
     *    old=^(nil a b c), new=r yields ^(r a b c)
     *    old=^(a b c), new=r yields ^(r ^(a b c))
     *
     *  If newRoot is a nil-rooted single child tree, use the single
     *  child as the new root node.
     *
     *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
     *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
     *
     *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
     *
     *    old=null, new=r yields r
     *    old=null, new=^(nil r) yields ^(nil r)
     *
     *  Return newRoot.  Throw an exception if newRoot is not a
     *  simple node or nil root with a single child node--it must be a root
     *  node.  If newRoot is ^(nil x) return x as newRoot.
     *
     *  Be advised that it's ok for newRoot to point at oldRoot's
     *  children; i.e., you don't have to copy the list.  We are
     *  constructing these nodes so we should have this control for
     *  efficiency.
     */
    becomeRoot: function(newRoot, oldRoot) {
        if (newRoot instanceof org.antlr.runtime.CommonToken || !newRoot) {
            newRoot = this.create(newRoot);
        }

        var newRootTree = newRoot,
            oldRootTree = oldRoot;
        if ( !oldRoot ) {
            return newRoot;
        }
        // handle ^(nil real-node)
        if ( newRootTree.isNil() ) {
            if ( newRootTree.getChildCount()>1 ) {
                // TODO: make tree run time exceptions hierarchy
                throw new Error("more than one node as root (TODO: make exception hierarchy)");
            }
            newRootTree = newRootTree.getChild(0);
        }
        // add oldRoot to newRoot; addChild takes care of case where oldRoot
        // is a flat list (i.e., nil-rooted tree).  All children of oldRoot
        // are added to newRoot.
        newRootTree.addChild(oldRootTree);
        return newRootTree;
    },

    /** Transform ^(nil x) to x */
    rulePostProcessing: function(root) {
        var r = root;
        if ( r && r.isNil() ) {
            if ( r.getChildCount()===0 ) {
                r = null;
            }
            else if ( r.getChildCount()===1 ) {
                r = r.getChild(0);
                // whoever invokes rule will set parent and child index
                r.setParent(null);
                r.setChildIndex(-1);
            }
        }
        return r;
    },

    create: function(tokenType, fromToken) {
        var text, t;
        if (arguments.length===2) {
            if (org.antlr.lang.isString(arguments[1])) {
                text = arguments[1];
                fromToken = this.createToken(tokenType, text);
                t = this.create(fromToken);
                return t;
            } else {
                fromToken = this.createToken(fromToken);
                fromToken.setType(tokenType);
                t = this.create(fromToken);
                return t;
            }
        } else if (arguments.length===3) {
            text = arguments[2];
            fromToken = this.createToken(fromToken);
            fromToken.setType(tokenType);
            fromToken.setText(text);
            t = this.create(fromToken);
            return t;
        }
    },

    getType: function(t) {
        t.getType();
        return 0;
    },

    setType: function(t, type) {
        throw new Error("don't know enough about Tree node");
    },

    getText: function(t) {
        return t.getText();
    },

    setText: function(t, text) {
        throw new Error("don't know enough about Tree node");
    },

    getChild: function(t, i) {
        return t.getChild(i);
    },

    setChild: function(t, i, child) {
        t.setChild(i, child);
    },

    deleteChild: function(t, i) {
        return t.deleteChild(i);
    },

    getChildCount: function(t) {
        return t.getChildCount();
    },

    getUniqueID: function(node) {
        if ( !this.treeToUniqueIDMap ) {
             this.treeToUniqueIDMap = {};
        }
        var prevID = this.treeToUniqueIDMap[node];
        if ( org.antlr.lang.isValue(prevID) ) {
            return prevID;
        }
        var ID = this.uniqueNodeID;
        this.treeToUniqueIDMap[node] = ID;
        this.uniqueNodeID++;
        return ID;
        // GC makes these nonunique:
        // return System.identityHashCode(node);
    }
};
/** A TreeAdaptor that works with any Tree implementation.  It provides
 *  really just factory methods; all the work is done by BaseTreeAdaptor.
 *  If you would like to have different tokens created than ClassicToken
 *  objects, you need to override this and then set the parser tree adaptor to
 *  use your subclass.
 *
 *  To get your parser to build nodes of a different type, override
 *  create(Token).
 */
org.antlr.runtime.tree.CommonTreeAdaptor = function() {};

org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeAdaptor,
                  org.antlr.runtime.tree.BaseTreeAdaptor, {
    /** Duplicate a node.  This is part of the factory;
     *    override if you want another kind of node to be built.
     *
     *  I could use reflection to prevent having to override this
     *  but reflection is slow.
     */
    dupNode: function(t) {
        if ( !org.antlr.lang.isValue(t) ) {
            return null;
        }
        return t.dupNode();
    },

    create: function(payload) {
        if (arguments.length>1) {
            return org.antlr.runtime.tree.CommonTreeAdaptor.superclass.create.apply(this, arguments);
        }
        return new org.antlr.runtime.tree.CommonTree(payload);
    },

    /** Tell me how to create a token for use with imaginary token nodes.
     *  For example, there is probably no input symbol associated with imaginary
     *  token DECL, but you need to create it as a payload or whatever for
     *  the DECL node as in ^(DECL type ID).
     *
     *  If you care what the token payload objects' type is, you should
     *  override this method and any other createToken variant.
     *
     * Tell me how to create a token for use with imaginary token nodes.
     *  For example, there is probably no input symbol associated with imaginary
     *  token DECL, but you need to create it as a payload or whatever for
     *  the DECL node as in ^(DECL type ID).
     *
     *  This is a variant of createToken where the new token is derived from
     *  an actual real input token.  Typically this is for converting '{'
     *  tokens to BLOCK etc...  You'll see
     *
     *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
     *
     *  If you care what the token payload objects' type is, you should
     *  override this method and any other createToken variant.
     */
    createToken: function(fromToken) {
        if (arguments.length===2) {
            return new org.antlr.runtime.CommonToken(arguments[0], arguments[1]);
        } else {
            return new org.antlr.runtime.CommonToken(arguments[0]);
        }
    },

    /** Track start/stop token for subtree root created for a rule.
     *  Only works with Tree nodes.  For rules that match nothing,
     *  seems like this will yield start=i and stop=i-1 in a nil node.
     *  Might be useful info so I'll not force to be i..i.
     */
    setTokenBoundaries: function(t, startToken, stopToken) {
        if ( !org.antlr.lang.isValue(t) ) {
            return;
        }
        var start = 0,
            stop = 0;
        if ( org.antlr.lang.isValue(startToken) ) {
            if (startToken.getTokenIndex) {
                start = startToken.getTokenIndex();
            } else if (startToken.getStartIndex) {
                start = startToken.getStartIndex();
            } else {
                start = startToken.getTokenStartIndex();
            }
        }
        if ( org.antlr.lang.isValue(stopToken) ) {
            if (stop.getTokenIndex) {
                stop = stopToken.getTokenIndex();
            } else if (stopToken.getStopIndex) {
                stop = stopToken.getStopIndex();
            } else {
                stop = stopToken.getTokenStopIndex();
            }
        }
        t.setTokenStartIndex(start);
        t.setTokenStopIndex(stop);
    },

    getTokenStartIndex: function(t) {
        if (!t) {
            return -1;
        }
        return t.getTokenStartIndex();
    },

    getTokenStopIndex: function(t) {
        if (!t) {
            return -1;
        }
        return t.getTokenStopIndex();
    },

    getText: function(t) {
        if (!t) {
            return null;
        }
        return t.getText();
    },

    getType: function(t) {
        if (!t) {
            return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
        }
        return t.getType();
    },

    /** What is the Token associated with this node?  If
     *  you are not using CommonTree, then you must
     *  override this in your own adaptor.
     */
    getToken: function(t) {
        if ( t instanceof org.antlr.runtime.tree.CommonTree ) {
            return t.getToken();
        }
        return null; // no idea what to do
    },

    getChild: function(t, i) {
        if (!t) {
            return null;
        }
        return t.getChild(i);
    },

    getChildCount: function(t) {
        if (!t) {
            return 0;
        }
        return t.getChildCount();
    },

    getParent: function(t) {
        return t.getParent();
    },

    setParent: function(t, parent) {
        t.setParent(parent);
    },

    getChildIndex: function(t) {
        return t.getChildIndex();
    },

    setChildIndex: function(t, index) {
        t.setChildIndex(index);
    },

    replaceChildren: function(parent, startChildIndex, stopChildIndex, t) {
        if ( parent ) {
            parent.replaceChildren(startChildIndex, stopChildIndex, t);
        }
    }
});
/**
 * A stream of characters created from a JavaScript string that in turn gets
 * fed to a lexer.
 * @class
 * @param {String} data the string from which this stream will be created.
 */
org.antlr.runtime.ANTLRStringStream = function(data) {
    /**
     * Location in the stream.
     * Ranges from 0 to (stream length - 1).
     * @private
     * @type Number
     */
    this.p = 0;

    /**
     * The current line in the input.
     * Ranges from 1 to (number of lines).
     * @private
     * @type Number
     */
    this.line = 1;

    /**
     * The index of the character relative to the beginning of the line.
     * Ranges from 0 to (length of line - 1).
     * @private
     * @type Number
     */
    this.charPositionInLine = 0;

    /**
     * Tracks how deep mark() calls are nested
     * @private
     * @type Number
     */
    this.markDepth = 0;

    /**
     * An Array of objects that tracks the stream state
     * values line, charPositionInLine, and p that can change as you
     * move through the input stream.  Indexed from 1..markDepth.
     * A null is kept at index 0.  Created upon first call to mark().
     * @private
     * @type Array
     */
    this.markers = null;

    /**
     * Track the last mark() call result value for use in rewind().
     * @private
     * @type Number
     */
    this.lastMarker = null;

    /**
     * The data being scanned.
     * @private
     * @type String
     */
    this.data = data;

    /**
     * The number of characters in the stream.
     * @private
     * @type Number
     */
    this.n = data.length;
};

org.antlr.runtime.ANTLRStringStream.prototype = {
    /**
     * Reset the stream so that it's in the same state it was
     * when the object was created *except* the data array is not
     * touched.
     */
    reset: function() {
       this.p = 0;
       this.line = 1;
       this.charPositionInLine = 0;
       this.markDepth = 0;
    },

    /**
     * Consume the next character of data in the stream.
     */
    consume: function() {
        //console.log("prev p="+ this.p +", c="+ this.data.charAt(this.p));
        if ( this.p < this.n ) {
            this.charPositionInLine++;
            if ( this.data.charAt(this.p)==="\n" ) {
                this.line++;
                this.charPositionInLine=0;
            }
            this.p++;
            //console.log("p moves to " + this.p + " (c='"+ this.data.charAt(this.p) +"')");
        }
    },

    /**
     * Get character at current input pointer + i ahead where i=1 is next int.
     * Negative indexes are allowed.  LA(-1) is previous token (token
     * just matched).  LA(-i) where i is before first token should
     * yield -1, invalid char / EOF.
     * @param {Number} i non-zero amount of lookahead or lookback
     * @returns {String|Number} The charcter at the specified position or -1 if
     *      you fell off either end of the stream.
     */
    LA: function(i) {
        if ( i<0 ) {
            i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]
        }

        var new_pos = this.p+i-1;
        if (new_pos>=this.n || new_pos<0) {
            return org.antlr.runtime.CharStream.EOF;
        }
        return this.data.charAt(new_pos);
    },


    /**
     * Return the current input symbol index 0..n where n indicates the
     * last symbol has been read.  The index is the index of char to
     * be returned from LA(1) (i.e. the one about to be consumed).
     * @returns {Number} the index of the current input symbol
     */
    index: function() {
        return this.p;
    },

    /**
     * The length of this stream.
     * @returns {Number} the length of this stream.
     */
    size: function() {
        return this.n;
    },

    /**
     * Tell the stream to start buffering if it hasn't already.  Return
     * current input position, index(), or some other marker so that
     * when passed to rewind() you get back to the same spot.
     * rewind(mark()) should not affect the input cursor.  The Lexer
     * tracks line/col info as well as input index so its markers are
     * not pure input indexes.  Same for tree node streams.
     *
     * <p>Marking is a mechanism for storing the current position of a stream
     * in a stack.  This corresponds with the predictive look-ahead mechanism
     * used in Lexers.</p>
     * @returns {Number} the current size of the mark stack.
     */
    mark: function() {
        if ( !this.markers ) {
            this.markers = [];
            this.markers.push(null); // depth 0 means no backtracking, leave blank
        }
        this.markDepth++;
        var state = null;
        if ( this.markDepth>=this.markers.length ) {
            state = {};
            this.markers.push(state);
        }
        else {
            state = this.markers[this.markDepth];
        }
        state.p = this.p;
        state.line = this.line;
        state.charPositionInLine = this.charPositionInLine;
        this.lastMarker = this.markDepth;
        return this.markDepth;
    },

    /**
     * Rewind to the input position of the last marker.
     * Used currently only after a cyclic DFA and just
     * before starting a sem/syn predicate to get the
     * input position back to the start of the decision.
     * Do not "pop" the marker off the state.  mark(i)
     * and rewind(i) should balance still. It is
     * like invoking rewind(last marker) but it should not "pop"
     * the marker off.  It's like seek(last marker's input position).
     * @param {Number} [m] the index in the mark stack to load instead of the
     *      last.
     */
    rewind: function(m) {
        if (!org.antlr.lang.isNumber(m)) {
            m = this.lastMarker;
        }

        var state = this.markers[m];
        // restore stream state
        this.seek(state.p);
        this.line = state.line;
        this.charPositionInLine = state.charPositionInLine;
        this.release(m);
    },

    /**
     * You may want to commit to a backtrack but don't want to force the
     * stream to keep bookkeeping objects around for a marker that is
     * no longer necessary.  This will have the same behavior as
     * rewind() except it releases resources without the backward seek.
     * This must throw away resources for all markers back to the marker
     * argument.  So if you're nested 5 levels of mark(), and then release(2)
     * you have to release resources for depths 2..5.
     * @param {Number} marker the mark depth above which all mark states will
     *      be released.
     */
    release: function(marker) {
        // unwind any other markers made after m and release m
        this.markDepth = marker;
        // release this marker
        this.markDepth--;
    },

    /**
     * Set the input cursor to the position indicated by index.  This is
     * normally used to seek ahead in the input stream.  No buffering is
     * required to do this unless you know your stream will use seek to
     * move backwards such as when backtracking.
     *
     * <p>This is different from rewind in its multi-directional
     * requirement and in that its argument is strictly an input cursor
     * (index).</p>
     *
     * <p>For char streams, seeking forward must update the stream state such
     * as line number.  For seeking backwards, you will be presumably
     * backtracking using the mark/rewind mechanism that restores state and
     * so this method does not need to update state when seeking backwards.</p>
     *
     * <p>Currently, this method is only used for efficient backtracking using
     * memoization, but in the future it may be used for incremental
     * parsing.</p>
     *
     * <p>The index is 0..n-1.  A seek to position i means that LA(1) will
     * return the ith symbol.  So, seeking to 0 means LA(1) will return the
     * first element in the stream.</p>
     *
     * <p>Esentially this method method moves the input position,
     * {@link #consume}-ing data if necessary.</p>
     *
     * @param {Number} index the position to seek to.
     */
    seek: function(index) {
        if ( index<=this.p ) {
            this.p = index; // just jump; don't update stream state (line, ...)
            return;
        }
        // seek forward, consume until p hits index
        while ( this.p<index ) {
            this.consume();
        }
    },

    /**
     * Retrieve a substring from this stream.
     * @param {Number} start the starting index of the substring (inclusive).
     * @param {Number} stop the last index of the substring (inclusive).
     * @returns {String}
     */
    substring: function(start, stop) {
        return this.data.substr(start,stop-start+1);
    },

    /**
     * Return the current line position in the stream.
     * @returns {Number} the current line position in the stream (1..numlines).
     */
    getLine: function() {
        return this.line;
    },

    /**
     * Get the index of the character relative to the beginning of the line.
     * Ranges from 0 to (length of line - 1).
     * @returns {Number}
     */
    getCharPositionInLine: function() {
        return this.charPositionInLine;
    },

    /**
     * Set the current line in the input stream.
     * This is used internally when performing rewinds.
     * @param {Number} line
     * @private
     */
    setLine: function(line) {
        this.line = line;
    },

    /**
     * Set the index of the character relative to the beginning of the line.
     * Ranges from 0 to (length of line - 1).
     * @param {Number} pos
     * @private
     */
    setCharPositionInLine: function(pos) {
        this.charPositionInLine = pos;
    },

    /** Where are you getting symbols from? Normally, implementations will
     *  pass the buck all the way to the lexer who can ask its input stream
     *  for the file name or whatever.
     */
    getSourceName: function() {
        return null;
    }
};

/**
 * Alias for {@link #LA}.
 * @methodOf org.antlr.runtime.ANTLRStringStream.prototype
 * @name LT
 */
org.antlr.runtime.ANTLRStringStream.LT = org.antlr.runtime.ANTLRStringStream.LA;
/** The most common stream of tokens is one where every token is buffered up
 *  and tokens are prefiltered for a certain channel (the parser will only
 *  see these tokens and cannot change the filter channel number during the
 *  parse).
 *
 *  TODO: how to access the full token stream?  How to track all tokens matched per rule?
 */
org.antlr.runtime.CommonTokenStream = function(tokenSource, channel) {
    this.p = -1;
    this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
    this.v_discardOffChannelTokens = false;

    this.tokens = [];
    if (arguments.length >= 2) {
        this.channel = channel;
    } else if (arguments.length === 1) {
        this.tokenSource = tokenSource;
    }
};

org.antlr.runtime.CommonTokenStream.prototype = {
    /** Reset this token stream by setting its token source. */
    setTokenSource: function(tokenSource) {
        this.tokenSource = tokenSource;
        this.tokens = [];
        this.p = -1;
        this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
    },

    /** Load all tokens from the token source and put in tokens.
     *  This is done upon first LT request because you might want to
     *  set some token type / channel overrides before filling buffer.
     */
    fillBuffer: function() {
        var index = 0,
            t = this.tokenSource.nextToken(),
            discard,
            channelI;
        while ( org.antlr.lang.isValue(t) && 
                t.getType()!=org.antlr.runtime.CharStream.EOF )
        {
            discard = false;
            // is there a channel override for token type?
            if ( this.channelOverrideMap ) {
                channelI = this.channelOverrideMap[t.getType()];
                if ( org.antlr.lang.isValue(channelI) ) {
                    t.setChannel(channelI);
                }
            }
            if ( this.discardSet && this.discardSet[t.getType()] )
            {
                discard = true;
            }
            else if ( this.v_discardOffChannelTokens &&
                    t.getChannel()!=this.channel )
            {
                discard = true;
            }
            if ( !discard )    {
                t.setTokenIndex(index);
                this.tokens.push(t);
                index++;
            }
            t = this.tokenSource.nextToken();
        }
        // leave p pointing at first token on channel
        this.p = 0;
        this.p = this.skipOffTokenChannels(this.p);
    },

    /** Move the input pointer to the next incoming token.  The stream
     *  must become active with LT(1) available.  consume() simply
     *  moves the input pointer so that LT(1) points at the next
     *  input symbol. Consume at least one token.
     *
     *  Walk past any token not on the channel the parser is listening to.
     */
    consume: function() {
        if ( this.p<this.tokens.length ) {
            this.p++;
            this.p = this.skipOffTokenChannels(this.p); // leave p on valid token
        }
    },

    /** Given a starting index, return the index of the first on-channel
     *  token.
     */
    skipOffTokenChannels: function(i) {
        var n = this.tokens.length;
        while ( i<n && (this.tokens[i]).getChannel()!=this.channel ) {
            i++;
        }
        return i;
    },

    skipOffTokenChannelsReverse: function(i) {
        while ( i>=0 && (this.tokens[i]).getChannel()!=this.channel ) {
            i--;
        }
        return i;
    },

    /** A simple filter mechanism whereby you can tell this token stream
     *  to force all tokens of type ttype to be on channel.  For example,
     *  when interpreting, we cannot exec actions so we need to tell
     *  the stream to force all WS and NEWLINE to be a different, ignored
     *  channel.
     */
    setTokenTypeChannel: function(ttype, channel) {
        if ( !this.channelOverrideMap ) {
            this.channelOverrideMap = {};
        }
        this.channelOverrideMap[ttype] = channel;
    },

    discardTokenType: function(ttype) {
        if ( !this.discardSet ) {
            this.discardSet = {};
        }
        this.discardSet[ttype] = true;
    },

    discardOffChannelTokens: function(b) {
        this.v_discardOffChannelTokens = b;
    },

    /** Given a start and stop index, return a List of all tokens in
     *  the token type BitSet.  Return null if no tokens were found.  This
     *  method looks at both on and off channel tokens.
     */
    getTokens: function(start, stop, types) {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }

        if (arguments.length===0) {
            return this.tokens;
        }

        if (org.antlr.lang.isArray(types)) {
            types = new org.antlr.runtime.BitSet(types);
        } else if (org.antlr.lang.isNumber(types)) {
            types = org.antlr.runtime.BitSet.of(types);
        }

        if ( stop>=this.tokens.length ) {
            stop=this.tokens.length-1;
        }
        if ( start<0 ) {
            start=0;
        }
        if ( start>stop ) {
            return null;
        }

        // list = tokens[start:stop]:{Token t, t.getType() in types}
        var filteredTokens = [],
            i,
            t;
        for (i=start; i<=stop; i++) {
            t = this.tokens[i];
            if ( !this.types || types.member(t.getType()) ) {
                filteredTokens.push(t);
            }
        }
        if ( filteredTokens.length===0 ) {
            filteredTokens = null;
        }
        return filteredTokens;
    },

    /** Get the ith token from the current position 1..n where k=1 is the
     *  first symbol of lookahead.
     */
    LT: function(k) {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }
        if ( k===0 ) {
            return null;
        }
        if ( k<0 ) {
            return this.LB(-1*k);
        }
        if ( (this.p+k-1) >= this.tokens.length ) {
            return org.antlr.runtime.Token.EOF_TOKEN;
        }
        var i = this.p,
            n = 1;
        // find k good tokens
        while ( n<k ) {
            // skip off-channel tokens
            i = this.skipOffTokenChannels(i+1); // leave p on valid token
            n++;
        }
        if ( i>=this.tokens.length ) {
            return org.antlr.runtime.Token.EOF_TOKEN;
        }
        return this.tokens[i];
    },

    /** Look backwards k tokens on-channel tokens */
    LB: function(k) {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }
        if ( k===0 ) {
            return null;
        }
        if ( (this.p-k)<0 ) {
            return null;
        }

        var i = this.p,
            n = 1;
        // find k good tokens looking backwards
        while ( n<=k ) {
            // skip off-channel tokens
            i = this.skipOffTokenChannelsReverse(i-1); // leave p on valid token
            n++;
        }
        if ( i<0 ) {
            return null;
        }
        return this.tokens[i];
    },

    /** Return absolute token i; ignore which channel the tokens are on;
     *  that is, count all tokens not just on-channel tokens.
     */
    get: function(i) {
        return this.tokens[i];
    },

    LA: function(i) {
        return this.LT(i).getType();
    },

    mark: function() {
        if ( this.p === -1 ) {
            this.fillBuffer();
        }
        this.lastMarker = this.index();
        return this.lastMarker;
    },

    release: function(marker) {
        // no resources to release
    },

    size: function() {
        return this.tokens.length;
    },

    index: function() {
        return this.p;
    },

    rewind: function(marker) {
        if (!org.antlr.lang.isNumber(marker)) {
            marker = this.lastMarker;
        }
        this.seek(marker);
    },

    reset: function() {
        this.p = -1;
        this.lastMarker = 0;
    },

    seek: function(index) {
        this.p = index;
    },

    getTokenSource: function() {
        return this.tokenSource;
    },

    getSourceName: function() {
        return this.getTokenSource().getSourceName();
    },

    toString: function(start, stop) {
        if (arguments.length===0) {
            if ( this.p === -1 ) {
                this.fillBuffer();
            }
            start = 0;
            stop = this.tokens.length-1;
        }

        if (!org.antlr.lang.isNumber(start) && !org.antlr.lang.isNumber(stop)) {
            if ( org.antlr.lang.isValue(start) && org.antlr.lang.isValue(stop) ) {
                start = start.getTokenIndex();
                stop = stop.getTokenIndex();
            } else {
                return null;
            }
        }

        var buf = "",
            i;
 
        if ( start<0 || stop<0 ) {
            return null;
        }
        if ( this.p == -1 ) {
            this.fillBuffer();
        }
        if ( stop>=this.tokens.length ) {
            stop = this.tokens.length-1;
        }
        for (i = start; i <= stop; i++) {
            t = this.tokens[i];
            buf = buf + this.tokens[i].getText();
        }
        return buf;
    }
};
/* Useful for dumping out the input stream after doing some
 *  augmentation or other manipulations.
 *
 *  You can insert stuff, replace, and delete chunks.  Note that the
 *  operations are done lazily--only if you convert the buffer to a
 *  String.  This is very efficient because you are not moving data around
 *  all the time.  As the buffer of tokens is converted to strings, the
 *  toString() method(s) check to see if there is an operation at the
 *  current index.  If so, the operation is done and then normal String
 *  rendering continues on the buffer.  This is like having multiple Turing
 *  machine instruction streams (programs) operating on a single input tape. :)
 *
 *  Since the operations are done lazily at toString-time, operations do not
 *  screw up the token index values.  That is, an insert operation at token
 *  index i does not change the index values for tokens i+1..n-1.
 *
 *  Because operations never actually alter the buffer, you may always get
 *  the original token stream back without undoing anything.  Since
 *  the instructions are queued up, you can easily simulate transactions and
 *  roll back any changes if there is an error just by removing instructions.
 *  For example,
 *
 *   CharStream input = new ANTLRFileStream("input");
 *   TLexer lex = new TLexer(input);
 *   TokenRewriteStream tokens = new TokenRewriteStream(lex);
 *   T parser = new T(tokens);
 *   parser.startRule();
 *
 *      Then in the rules, you can execute
 *      Token t,u;
 *      ...
 *      input.insertAfter(t, "text to put after t");}
 *         input.insertAfter(u, "text after u");}
 *         System.out.println(tokens.toString());
 *
 *  Actually, you have to cast the 'input' to a TokenRewriteStream. :(
 *
 *  You can also have multiple "instruction streams" and get multiple
 *  rewrites from a single pass over the input.  Just name the instruction
 *  streams and use that name again when printing the buffer.  This could be
 *  useful for generating a C file and also its header file--all from the
 *  same buffer:
 *
 *      tokens.insertAfter("pass1", t, "text to put after t");}
 *         tokens.insertAfter("pass2", u, "text after u");}
 *         System.out.println(tokens.toString("pass1"));
 *         System.out.println(tokens.toString("pass2"));
 *
 *  If you don't use named rewrite streams, a "default" stream is used as
 *  the first example shows.
 */

org.antlr.runtime.TokenRewriteStream = function() {
    var sup = org.antlr.runtime.TokenRewriteStream.superclass;

    /** You may have multiple, named streams of rewrite operations.
     *  I'm calling these things "programs."
     *  Maps String (name) -> rewrite (List)
     */
    this.programs = null;

    /** Map String (program name) -> Integer index */
    this.lastRewriteTokenIndexes = null;


    if (arguments.length===0) {
        this.init();
    } else {
        sup.constructor.apply(this, arguments);
        this.init();
    }
};

(function(){
var trs = org.antlr.runtime.TokenRewriteStream;

org.antlr.lang.augmentObject(trs, {
    DEFAULT_PROGRAM_NAME: "default",
    PROGRAM_INIT_SIZE: 100,
    MIN_TOKEN_INDEX: 0
});

//
// Define the rewrite operation hierarchy
//

trs.RewriteOperation = function(index, text) {
    this.index = index;
    this.text = text;
};

/** Execute the rewrite operation by possibly adding to the buffer.
 *  Return the index of the next token to operate on.
 */
trs.RewriteOperation.prototype = {
    execute: function(buf) {
        return this.index;
    },
    toString: function() {
        /*String opName = getClass().getName();
        int $index = opName.indexOf('$');
        opName = opName.substring($index+1, opName.length());
        return opName+"@"+index+'"'+text+'"';*/
        return this.text;
    }
};

trs.InsertBeforeOp = function(index, text) {
    trs.InsertBeforeOp.superclass.constructor.call(this, index, text);
};
org.antlr.lang.extend(trs.InsertBeforeOp, trs.RewriteOperation, {
    execute: function(buf) {
        buf.push(this.text);
        return this.index;
    }
});

/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
 *  instructions.
 */
trs.ReplaceOp = function(from, to, text) {
    trs.ReplaceOp.superclass.constructor.call(this, from, text); 
    this.lastIndex = to;
};
org.antlr.lang.extend(trs.ReplaceOp, trs.RewriteOperation, {
    execute: function(buf) {
        if (org.antlr.lang.isValue(this.text)) {
            buf.push(this.text);
        }
        return this.lastIndex+1;
    }
});

trs.DeleteOp = function(from, to) {
    trs.DeleteOp.superclass.constructor.call(this, from, to); 
};
org.antlr.lang.extend(trs.DeleteOp, trs.ReplaceOp);

org.antlr.lang.extend(trs, org.antlr.runtime.CommonTokenStream, {
    init: function() {
        this.programs = {};
        this.programs[trs.DEFAULT_PROGRAM_NAME] = [];
        this.lastRewriteTokenIndexes = {};
    },

    /** Rollback the instruction stream for a program so that
     *  the indicated instruction (via instructionIndex) is no
     *  longer in the stream.  UNTESTED!
     */
    rollback: function() {
        var programName,
            instructionIndex;

        if (arguments.length===1) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            instructionIndex = arguments[0];
        } else if (arguments.length===2) {
            programName = arguments[0];
            instructionIndex = arguments[1];
        }
        var is = this.programs[programName];
        if (is) {
            programs[programName] = is.slice(trs.MIN_TOKEN_INDEX, this.instructionIndex);
        }
    },

    /** Reset the program so that no instructions exist */
    deleteProgram: function(programName) {
        programName = programName || trs.DEFAULT_PROGRAM_NAME;
        this.rollback(programName, trs.MIN_TOKEN_INDEX);
    },

    /** Add an instruction to the rewrite instruction list ordered by
     *  the instruction number (use a binary search for efficiency).
     *  The list is ordered so that toString() can be done efficiently.
     *
     *  When there are multiple instructions at the same index, the instructions
     *  must be ordered to ensure proper behavior.  For example, a delete at
     *  index i must kill any replace operation at i.  Insert-before operations
     *  must come before any replace / delete instructions.  If there are
     *  multiple insert instructions for a single index, they are done in
     *  reverse insertion order so that "insert foo" then "insert bar" yields
     *  "foobar" in front rather than "barfoo".  This is convenient because
     *  I can insert new InsertOp instructions at the index returned by
     *  the binary search.  A ReplaceOp kills any previous replace op.  Since
     *  delete is the same as replace with null text, i can check for
     *  ReplaceOp and cover DeleteOp at same time. :)
     */
    addToSortedRewriteList: function() {
        var programName,
            op;
        if (arguments.length===1) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            op = arguments[0];
        } else if (arguments.length===2) {
            programName = arguments[0];
            op = arguments[1];
        }

        var rewrites = this.getProgram(programName);
        var len, pos, searchOp, replaced, prevOp, i;
        for (pos=0, len=rewrites.length; pos<len; pos++) {
            searchOp = rewrites[pos];
            if (searchOp.index===op.index) {
                // now pos is the index in rewrites of first op with op.index

                // an instruction operating already on that index was found;
                // make this one happen after all the others
                if (op instanceof trs.ReplaceOp) {
                    replaced = false;
                    // look for an existing replace
                    for (i=pos; i<rewrites.length; i++) {
                        prevOp = rewrites[pos];
                        if (prevOp.index!==op.index) {
                            break;
                        }
                        if (prevOp instanceof trs.ReplaceOp) {
                            rewrites[pos] = op; // replace old with new
                            replaced=true;
                            break;
                        }
                        // keep going; must be an insert
                    }
                    if ( !replaced ) {
                        // add replace op to the end of all the inserts
                        rewrites.splice(i, 0, op);
                    }
                } else {
                    // inserts are added in front of existing inserts
                    rewrites.splice(pos, 0, op);
                }
                break;
            } else if (searchOp.index > op.index) {
                rewrites.splice(pos, 0, op);
                break;
            }
        }
        if (pos===len) {
            rewrites.push(op);
        }
    },

    insertAfter: function() {
        var index, programName, text;
        if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            index = arguments[0];
            text = arguments[1];
        } else if (arguments.length===3) {
            programName = arguments[0];
            index = arguments[1];
            text = arguments[2];
        }

        if (index instanceof org.antlr.runtime.CommonToken) {
            // index is a Token, grab it's stream index
            index = index.index; // that's ugly
        }

        // insert after is the same as insert before the next index
        this.insertBefore(programName, index+1, text);
    },

    insertBefore: function() {
        var index, programName, text;
        if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            index = arguments[0];
            text = arguments[1];
        } else if (arguments.length===3) {
            programName = arguments[0];
            index = arguments[1];
            text = arguments[2];
        }

        if (index instanceof org.antlr.runtime.CommonToken) {
            // index is a Token, grab it's stream index
            index = index.index; // that's ugly
        }

        this.addToSortedRewriteList(
                programName,
                new trs.InsertBeforeOp(index,text)
                );
    },

    replace: function() {
        var programName, first, last, text;
        if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            first = arguments[0];
            last = arguments[0];
            text = arguments[1];
        } else if (arguments.length===3) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            first = arguments[0];
            last = arguments[1];
            text = arguments[2];
        } if (arguments.length===4) {
            programName = arguments[0];
            first = arguments[1];
            last = arguments[2];
            text = arguments[3];
        } 

        if (first instanceof org.antlr.runtime.CommonToken) {
            first = first.index;
        }

        if (last instanceof org.antlr.runtime.CommonToken) {
            last = last.index; // that's ugly
        }

        if ( first > last || last<0 || first<0 ) {
            return;
        }
        this.addToSortedRewriteList(
                programName,
                new trs.ReplaceOp(first, last, text));
    },

    // !!! API Break: delete is a JS keyword, so using remove instead.
    remove: function() {
        // convert arguments to a real array
        var args=[], i=arguments.length-1;
        while (i>=0) {
            args[i] = arguments[i];
            i--;
        }

        args.push("");
        this.replace.apply(this, args);
    },

    getLastRewriteTokenIndex: function(programName) {
        programName = programName || trs.DEFAULT_PROGRAM_NAME;
        return this.lastRewriteTokenIndexes[programName] || -1;
    },

    setLastRewriteTokenIndex: function(programName, i) {
        this.lastRewriteTokenIndexes[programName] = i;
    },

    getProgram: function(name) {
        var is = this.programs[name];
        if ( !is ) {
            is = this.initializeProgram(name);
        }
        return is;
    },

    initializeProgram: function(name) {
        var is = [];
        this.programs[name] = is;
        return is;
    },

    toOriginalString: function(start, end) {
        if (!org.antlr.lang.isNumber(start)) {
            start = trs.MIN_TOKEN_INDEX;
        }
        if (!org.antlr.lang.isNumber(end)) {
            end = this.size()-1;
        }

        var buf = [], i;
        for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
            buf.push(this.get(i).getText());
        }
        return buf.join("");
    },

    toString: function() {
        var programName, start, end;
        if (arguments.length===0) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            start = trs.MIN_TOKEN_INDEX;
            end = this.size() - 1;
        } else if (arguments.length===1) {
            programName = arguments[0];
            start = trs.MIN_TOKEN_INDEX;
            end = this.size() - 1;
        } else if (arguments.length===2) {
            programName = trs.DEFAULT_PROGRAM_NAME;
            start = arguments[0];
            end = arguments[1];
        }

        var rewrites = this.programs[programName];
        if ( !rewrites || rewrites.length===0 ) {
            return this.toOriginalString(start,end);
        }

        /// Index of first rewrite we have not done
        var rewriteOpIndex = 0,
            tokenCursor=start,
            buf = [],
            op;
        while ( tokenCursor>=trs.MIN_TOKEN_INDEX &&
                tokenCursor<=end &&
                tokenCursor<this.tokens.length )
        {
            // execute instructions associated with this token index
            if ( rewriteOpIndex<rewrites.length ) {
                op = rewrites[rewriteOpIndex];

                // skip all ops at lower index
                while (op.index<tokenCursor && rewriteOpIndex<rewrites.length) {
                    rewriteOpIndex++;
                    if ( rewriteOpIndex<rewrites.length ) {
                        op = rewrites[rewriteOpIndex];
                    }
                }

                // while we have ops for this token index, exec them
                while (tokenCursor===op.index && rewriteOpIndex<rewrites.length) {
                    //System.out.println("execute "+op+" at instruction "+rewriteOpIndex);
                    tokenCursor = op.execute(buf);
                    //System.out.println("after execute tokenCursor = "+tokenCursor);
                    rewriteOpIndex++;
                    if ( rewriteOpIndex<rewrites.length ) {
                        op = rewrites[rewriteOpIndex];
                    }
                }
            }
            // dump the token at this index
            if ( tokenCursor<=end ) {
                buf.push(this.get(tokenCursor).getText());
                tokenCursor++;
            }
        }
        // now see if there are operations (append) beyond last token index
        var opi;
        for (opi=rewriteOpIndex; opi<rewrites.length; opi++) {
            op = rewrites[opi];
            if ( op.index>=this.size() ) {
                op.execute(buf); // must be insertions if after last token
            }
        }

        return buf.join("");
    },

    toDebugString: function(start, end) {
        if (!org.antlr.lang.isNumber(start)) {
            start = trs.MIN_TOKEN_INDEX;
        }
        if (!org.antlr.lang.isNumber(end)) {
            end = this.size()-1;
        }

        var buf = [],
            i;
        for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
            buf.push(this.get(i));
        }
        return buf.join("");
    }
});

})();
/** A stream of tree nodes, accessing nodes from a tree of some kind */
org.antlr.runtime.tree.TreeNodeStream = function() {};
/** A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.
 *
 *  This node stream sucks all nodes out of the tree specified in
 *  the constructor during construction and makes pointers into
 *  the tree using an array of Object pointers. The stream necessarily
 *  includes pointers to DOWN and UP and EOF nodes.
 *
 *  This stream knows how to mark/release for backtracking.
 *
 *  This stream is most suitable for tree interpreters that need to
 *  jump around a lot or for tree parsers requiring speed (at cost of memory).
 *  There is some duplicated functionality here with UnBufferedTreeNodeStream
 *  but just in bookkeeping, not tree walking etc...
 *
 *  @see UnBufferedTreeNodeStream
 */
org.antlr.runtime.tree.CommonTreeNodeStream = function(adaptor,
                                                    tree,
                                                    initialBufferSize)
{
    if (arguments.length===1) {
        tree = adaptor;
        adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
    }
    if (arguments.length <= 2) {
        initialBufferSize =
            org.antlr.runtime.tree.CommonTreeNodeStream.DEFAULT_INITIAL_BUFFER_SIZE;
    }

    /** Reuse same DOWN, UP navigation nodes unless this is true */
    this.uniqueNavigationNodes = false;

    /** The index into the nodes list of the current node (next node
     *  to consume).  If -1, nodes array not filled yet.
     */
    this.p = -1;

    var Token = org.antlr.runtime.Token;
    this.root = tree;
    this.adaptor = adaptor;
    this.nodes = []; //new ArrayList(initialBufferSize);
    this.down = this.adaptor.create(Token.DOWN, "DOWN");
    this.up = this.adaptor.create(Token.UP, "UP");
    this.eof = this.adaptor.create(Token.EOF, "EOF");
};

org.antlr.lang.augmentObject(org.antlr.runtime.tree.CommonTreeNodeStream, {
    DEFAULT_INITIAL_BUFFER_SIZE: 100,
    INITIAL_CALL_STACK_SIZE: 10
});

org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeNodeStream,
                  org.antlr.runtime.tree.TreeNodeStream, 
{
    StreamIterator: function() {
        var i = 0,
            nodes = this.nodes,
            eof = this.eof;

        return {
            hasNext: function() {
                return i<nodes.length;
            },

            next: function() {
                var current = i;
                i++;
                if ( current < nodes.length ) {
                    return nodes[current];
                }
                return eof;
            },

            remove: function() {
                throw new Error("cannot remove nodes from stream");
            }
        };
    },

    /** Walk tree with depth-first-search and fill nodes buffer.
     *  Don't do DOWN, UP nodes if its a list (t is isNil).
     */
    fillBuffer: function(t) {
        var reset_p = false;
        if (org.antlr.lang.isUndefined(t)) {
            t = this.root;
            reset_p = true;
        }

        var nil = this.adaptor.isNil(t);
        if ( !nil ) {
            this.nodes.push(t); // add this node
        }
        // add DOWN node if t has children
        var n = this.adaptor.getChildCount(t);
        if ( !nil && n>0 ) {
            this.addNavigationNode(org.antlr.runtime.Token.DOWN);
        }
        // and now add all its children
        var c, child;
        for (c=0; c<n; c++) {
            child = this.adaptor.getChild(t,c);
            this.fillBuffer(child);
        }
        // add UP node if t has children
        if ( !nil && n>0 ) {
            this.addNavigationNode(org.antlr.runtime.Token.UP);
        }

        if (reset_p) {
            this.p = 0; // buffer of nodes intialized now
        }
    },

    getNodeIndex: function(node) {
        if ( this.p==-1 ) {
            this.fillBuffer();
        }
        var i, t;
        for (i=0; i<this.nodes.length; i++) {
            t = this.nodes[i];
            if ( t===node ) {
                return i;
            }
        }
        return -1;
    },

    /** As we flatten the tree, we use UP, DOWN nodes to represent
     *  the tree structure.  When debugging we need unique nodes
     *  so instantiate new ones when uniqueNavigationNodes is true.
     */
    addNavigationNode: function(ttype) {
        var navNode = null;
        if ( ttype===org.antlr.runtime.Token.DOWN ) {
            if ( this.hasUniqueNavigationNodes() ) {
                navNode = this.adaptor.create(org.antlr.runtime.Token.DOWN, "DOWN");
            }
            else {
                navNode = this.down;
            }
        }
        else {
            if ( this.hasUniqueNavigationNodes() ) {
                navNode = this.adaptor.create(org.antlr.runtime.Token.UP, "UP");
            }
            else {
                navNode = this.up;
            }
        }
        this.nodes.push(navNode);
    },

    get: function(i) {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        return this.nodes[i];
    },

    LT: function(k) {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        if ( k===0 ) {
            return null;
        }
        if ( k<0 ) {
            return this.LB(-1*k);
        }
        if ( (this.p+k-1) >= this.nodes.length ) {
            return this.eof;
        }
        return this.nodes[this.p+k-1];
    },

    getCurrentSymbol: function() { return this.LT(1); },

    /** Look backwards k nodes */
    LB: function(k) {
        if ( k===0 ) {
            return null;
        }
        if ( (this.p-k)<0 ) {
            return null;
        }
        return this.nodes[this.p-k];
    },

    getTreeSource: function() {
        return this.root;
    },

    getSourceName: function() {
        return this.getTokenStream().getSourceName();
    },

    getTokenStream: function() {
        return this.tokens;
    },

    setTokenStream: function(tokens) {
        this.tokens = tokens;
    },

    getTreeAdaptor: function() {
        return this.adaptor;
    },

    setTreeAdaptor: function(adaptor) {
        this.adaptor = adaptor;
    },

    hasUniqueNavigationNodes: function() {
        return this.uniqueNavigationNodes;
    },

    setUniqueNavigationNodes: function(uniqueNavigationNodes) {
        this.uniqueNavigationNodes = uniqueNavigationNodes;
    },

    consume: function() {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        this.p++;
    },

    LA: function(i) {
        return this.adaptor.getType(this.LT(i));
    },

    mark: function() {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        this.lastMarker = this.index();
        return this.lastMarker;
    },

    release: function(marker) {
        // no resources to release
    },

    index: function() {
        return this.p;
    },

    rewind: function(marker) {
        if (!org.antlr.lang.isNumber(marker)) {
            marker = this.lastMarker;
        }
        this.seek(marker);
    },

    seek: function(index) {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        this.p = index;
    },

    /** Make stream jump to a new location, saving old location.
     *  Switch back with pop().
     */
    push: function(index) {
        if ( !this.calls ) {
            this.calls = [];
        }
        this.calls.push(this.p); // save current index
        this.seek(index);
    },

    /** Seek back to previous index saved during last push() call.
     *  Return top of stack (return index).
     */
    pop: function() {
        var ret = this.calls.pop();
        this.seek(ret);
        return ret;
    },

    reset: function() {
        this.p = -1;
        this.lastMarker = 0;
        if (this.calls) {
            this.calls = [];
        }
    },

    size: function() {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        return this.nodes.length;
    },

    iterator: function() {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        return this.StreamIterator();
    },

    replaceChildren: function(parent, startChildIndex, stopChildIndex, t) {
        if ( parent ) {
            this.adaptor.replaceChildren(parent, startChildIndex, stopChildIndex, t);
        }
    },

    /** Debugging */
    toTokenString: function(start, stop) {
        if ( this.p===-1 ) {
            this.fillBuffer();
        }
        var buf='', i, t;
        for (i = start; i < this.nodes.length && i <= stop; i++) {
            t = this.nodes[i];
            buf += " "+this.adaptor.getToken(t);
        }
        return buf;
    },

    /** Used for testing, just return the token type stream */
    toString: function(start, stop) {
        var buf = "",
            text,
            t,
            i;
        if (arguments.length===0) {
            if ( this.p===-1 ) {
                this.fillBuffer();
            }
            for (i = 0; i < this.nodes.length; i++) {
                t = this.nodes[i];
                buf += " ";
                buf += this.adaptor.getType(t);
            }
            return buf;
        } else {
            if ( !org.antlr.lang.isNumber(start) || !org.antlr.lang.isNumber(stop) ) {
                return null;
            }
            if ( this.p===-1 ) {
                this.fillBuffer();
            }
            //System.out.println("stop: "+stop);
            if ( start instanceof org.antlr.runtime.tree.CommonTree ) {
                //System.out.print("toString: "+((CommonTree)start).getToken()+", ");
            } else {
                //System.out.println(start);
            }
            if ( stop instanceof org.antlr.runtime.tree.CommonTree ) {
                //System.out.println(((CommonTree)stop).getToken());
            } else {
                //System.out.println(stop);
            }
            // if we have the token stream, use that to dump text in order
            var beginTokenIndex,
                endTokenIndex;
            if ( this.tokens ) {
                beginTokenIndex = this.adaptor.getTokenStartIndex(start);
                endTokenIndex = this.adaptor.getTokenStopIndex(stop);
                // if it's a tree, use start/stop index from start node
                // else use token range from start/stop nodes
                if ( this.adaptor.getType(stop)===org.antlr.runtime.Token.UP ) {
                    endTokenIndex = this.adaptor.getTokenStopIndex(start);
                }
                else if ( this.adaptor.getType(stop)==org.antlr.runtime.Token.EOF )
                {
                    endTokenIndex = this.size()-2; // don't use EOF
                }
                return this.tokens.toString(beginTokenIndex, endTokenIndex);
            }
            // walk nodes looking for start
            t = null;
            i = 0;
            for (; i < this.nodes.length; i++) {
                t = this.nodes[i];
                if ( t===start ) {
                    break;
                }
            }
            // now walk until we see stop, filling string buffer with text
            buf = text = "";
            t = this.nodes[i];
            while ( t!==stop ) {
                text = this.adaptor.getText(t);
                if ( !org.antlr.lang.isString(text) ) {
                    text = " "+this.adaptor.getType(t).toString();
                }
                buf += text;
                i++;
                t = nodes[i];
            }
            // include stop node too
            text = this.adaptor.getText(stop);
            if ( !org.antlr.lang.isString(text) ) {
                text = " "+this.adaptor.getType(stop).toString();
            }
            buf += text;
            return buf;
        }
    }
});
/** A generic list of elements tracked in an alternative to be used in
 *  a -> rewrite rule.  We need to subclass to fill in the next() method,
 *  which returns either an AST node wrapped around a token payload or
 *  an existing subtree.
 *
 *  Once you start next()ing, do not try to add more elements.  It will
 *  break the cursor tracking I believe.
 *
 *  @see org.antlr.runtime.tree.RewriteRuleSubtreeStream
 *  @see org.antlr.runtime.tree.RewriteRuleTokenStream
 *
 *  TODO: add mechanism to detect/puke on modification after reading from stream
 */
org.antlr.runtime.tree.RewriteRuleElementStream = function(adaptor, elementDescription, el) {
    /** Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
     *  which bumps it to 1 meaning no more elements.
     */
    this.cursor = 0;

    /** Once a node / subtree has been used in a stream, it must be dup'd
     *  from then on.  Streams are reset after subrules so that the streams
     *  can be reused in future subrules.  So, reset must set a dirty bit.
     *  If dirty, then next() always returns a dup.
     *
     *  I wanted to use "naughty bit" here, but couldn't think of a way
     *  to use "naughty".
     */
    this.dirty = false;

    this.elementDescription = elementDescription;
    this.adaptor = adaptor;
    if (el) {
        if (org.antlr.lang.isArray(el)) {
            this.singleElement = null;
            this.elements = el;
        } else {
            this.add(el);
        }
    }
};

org.antlr.runtime.tree.RewriteRuleElementStream.prototype = {
    /** Reset the condition of this stream so that it appears we have
     *  not consumed any of its elements.  Elements themselves are untouched.
     *  Once we reset the stream, any future use will need duplicates.  Set
     *  the dirty bit.
     */
    reset: function() {
        this.cursor = 0;
        this.dirty = true;
    },

    add: function(el) {
        if ( !org.antlr.lang.isValue(el) ) {
            return;
        }
        if ( this.elements ) { // if in list, just add
            this.elements.push(el);
            return;
        }
        if ( !org.antlr.lang.isValue(this.singleElement) ) { // no elements yet, track w/o list
            this.singleElement = el;
            return;
        }
        // adding 2nd element, move to list
        this.elements = [];
        this.elements.push(this.singleElement);
        this.singleElement = null;
        this.elements.push(el);
    },

    /** Return the next element in the stream.  If out of elements, throw
     *  an exception unless size()==1.  If size is 1, then return elements[0].
     *  Return a duplicate node/subtree if stream is out of elements and
     *  size==1.  If we've already used the element, dup (dirty bit set).
     */
    nextTree: function() {
        var n = this.size(),
            el;
        if ( this.dirty || (this.cursor>=n && n==1) ) {
            // if out of elements and size is 1, dup
            el = this._next();
            return this.dup(el);
        }
        // test size above then fetch
        el = this._next();
        return el;
    },

    /** do the work of getting the next element, making sure that it's
     *  a tree node or subtree.  Deal with the optimization of single-
     *  element list versus list of size > 1.  Throw an exception
     *  if the stream is empty or we're out of elements and size>1.
     *  protected so you can override in a subclass if necessary.
     */
    _next: function() {
        var n = this.size();
        if (n===0) {
            throw new org.antlr.runtime.tree.RewriteEmptyStreamException(this.elementDescription);
        }
        if ( this.cursor>= n) { // out of elements?
            if ( n===1 ) {  // if size is 1, it's ok; return and we'll dup
                return this.toTree(this.singleElement);
            }
            // out of elements and size was not 1, so we can't dup
            throw new org.antlr.runtime.tree.RewriteCardinalityException(this.elementDescription);
        }
        // we have elements
        if ( org.antlr.lang.isValue(this.singleElement) ) {
            this.cursor++; // move cursor even for single element list
            return this.toTree(this.singleElement);
        }
        // must have more than one in list, pull from elements
        var o = this.toTree(this.elements[this.cursor]);
        this.cursor++;
        return o;
    },

    /** Ensure stream emits trees; tokens must be converted to AST nodes.
     *  AST nodes can be passed through unmolested.
     */
    toTree: function(el) {
        if (el && el.getTree) {
            return el.getTree();
        }
        return el;
    },

    hasNext: function() {
         return (org.antlr.lang.isValue(this.singleElement) && this.cursor < 1) ||
               (this.elements && this.cursor < this.elements.length);
    },

    size: function() {
        var n = 0;
        if ( org.antlr.lang.isValue(this.singleElement) ) {
            n = 1;
        }
        if ( this.elements ) {
            return this.elements.length;
        }
        return n;
    },

    getDescription: function() {
        return this.elementDescription;
    }
};
/** Queues up nodes matched on left side of -> in a tree parser. This is
 *  the analog of RewriteRuleTokenStream for normal parsers. 
 */
org.antlr.runtime.tree.RewriteRuleNodeStream = function(adaptor, elementDescription, el) {
    org.antlr.runtime.tree.RewriteRuleNodeStream.superclass.constructor.apply(this, arguments);
};

org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleNodeStream,
                  org.antlr.runtime.tree.RewriteRuleElementStream,
{
    nextNode: function() {
        return this._next();
    },

    toTree: function(el) {
        return this.adaptor.dupNode(el);
    },

    dup: function() {
        // we dup every node, so don't have to worry about calling dup; short-
        // circuited next() so it doesn't call.
        throw new Error("dup can't be called for a node stream.");
    }
});
org.antlr.runtime.tree.RewriteRuleTokenStream = function(adaptor, elementDescription, el) {
    var sup = org.antlr.runtime.tree.RewriteRuleTokenStream.superclass;
    sup.constructor.apply(this, arguments);
};

org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleTokenStream,
                  org.antlr.runtime.tree.RewriteRuleElementStream, {
    /** Get next token from stream and make a node for it */
    nextNode: function() {
        var t = this._next();
        return this.adaptor.create(t);
    },

    nextToken: function() {
        return this._next();
    },

    /** Don't convert to a tree unless they explicitly call nextTree.
     *  This way we can do hetero tree nodes in rewrite.
     */
    toTree: function(el) {
        return el;
    },

    dup: function(el) {
        throw new Error("dup can't be called for a token stream.");
    }
});
org.antlr.runtime.tree.RewriteRuleSubtreeStream = function() {
    var sup = org.antlr.runtime.tree.RewriteRuleSubtreeStream.superclass;
    sup.constructor.apply(this, arguments);
};

org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleSubtreeStream,
                  org.antlr.runtime.tree.RewriteRuleElementStream, {
	/** Treat next element as a single node even if it's a subtree.
	 *  This is used instead of next() when the result has to be a
	 *  tree root node.  Also prevents us from duplicating recently-added
	 *  children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
	 *  must dup the type node, but ID has been added.
	 *
	 *  Referencing a rule result twice is ok; dup entire tree as
	 *  we can't be adding trees as root; e.g., expr expr.
	 *
	 *  Hideous code duplication here with super.next().  Can't think of
	 *  a proper way to refactor.  This needs to always call dup node
	 *  and super.next() doesn't know which to call: dup node or dup tree.
	 */
    nextNode: function() {
		var n = this.size(),
            el;
		if ( this.dirty || (this.cursor>=n && n===1) ) {
			// if out of elements and size is 1, dup (at most a single node
			// since this is for making root nodes).
			el = this._next();
			return this.adaptor.dupNode(el);
		}
		// test size above then fetch
		el = this._next();
		return el;
	},

    dup: function(el) {
		return this.adaptor.dupTree(el);
	}
});/** A generic recognizer that can handle recognizers generated from
 *  lexer, parser, and tree grammars.  This is all the parsing
 *  support code essentially; most of it is error recovery stuff and
 *  backtracking.
 *
 *  <p>This class should not be instantiated directly.  Instead, use one of its
 *  subclasses.</p>
 *
 *  @class
 *  @param {org.antlr.runtime.RecognizerSharedState} [state] optional state object
 *      with which to initialize this recognizer.
 */
org.antlr.runtime.BaseRecognizer = function(state) {
    /** State of a lexer, parser, or tree parser are collected into a state
     *  object so the state can be shared.  This sharing is needed to
     *  have one grammar import others and share same error variables
     *  and other state variables.  It's a kind of explicit multiple
     *  inheritance via delegation of methods and shared state.
     */
    this.state = state || new org.antlr.runtime.RecognizerSharedState();
};

/* static vars, methods */
org.antlr.lang.augmentObject(org.antlr.runtime.BaseRecognizer, {
    MEMO_RULE_FAILED: -2,
    MEMO_RULE_UNKNOWN: -1,
    INITIAL_FOLLOW_STACK_SIZE: 100,
    MEMO_RULE_FAILED_I: -2,
    DEFAULT_TOKEN_CHANNEL: org.antlr.runtime.Token.DEFAULT_CHANNEL,
    HIDDEN: org.antlr.runtime.Token.HIDDEN_CHANNEL,
    NEXT_TOKEN_RULE_NAME: "nextToken"
});

org.antlr.runtime.BaseRecognizer.prototype = {
    /** Reset the parser's state.  Subclasses must rewinds the input stream */
    reset: function() {
        var i, len;

        // wack everything related to error recovery
        if (!this.state) {
            return; // no shared state work to do
        }
        this.state._fsp = -1;
        this.state.errorRecovery = false;
        this.state.lastErrorIndex = -1;
        this.state.failed = false;
        this.state.syntaxErrors = 0;
        // wack everything related to backtracking and memoization
        this.state.backtracking = 0;
        // wipe cache
        if (this.state.ruleMemo) {
            for (i=0, len=this.state.ruleMemo.length; i<len; i++) {
                this.state.ruleMemo[i] = null;
            }
        }
    },

    /** Match current input symbol against ttype.  Attempt
     *  single token insertion or deletion error recovery.  If
     *  that fails, throw {@link org.antlr.runtime.MismatchedTokenException}.
     *
     *  <p>To turn off single token insertion or deletion error
     *  recovery, override {@link #mismatchRecover} and have it call
     *  plain {@link #mismatch}, which does not recover.  Then any error
     *  in a rule will cause an exception and immediate exit from
     *  rule.  Rule would recover by resynchronizing to the set of
     *  symbols that can follow rule ref.</p>
     *
     *  @param {org.antlr.runtime.IntStream} input input stream to match against.
     *  @param {Number} ttype  input type to match.
     *  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
     *      matched token.
     *  @returns {Object} the matched symbol
     */
    match: function(input, ttype, follow) {
        var matchedSymbol = this.getCurrentInputSymbol(input);
        if ( input.LA(1)===ttype ) {
            input.consume();
            this.state.errorRecovery = false;
            this.state.failed = false;
            return matchedSymbol;
        }
        if ( this.state.backtracking>0 ) {
            this.state.failed = true;
            return matchedSymbol;
        }
        matchedSymbol = this.recoverFromMismatchedToken(input, ttype, follow);
        return matchedSymbol;
    },

    /**
     * Match any token.
     * @param {org.antlr.runtime.IntStream} input input stream to match against.
     */
    matchAny: function(input) {
        this.state.errorRecovery = false;
        this.state.failed = false;
        input.consume();
    },

    /**
     * Is the following token (LA(2)) the unwanted type (ttype)?
     * @param {org.antlr.runtime.IntStream} input input stream to match against.
     * @param {Number} ttype the undesired token type.
     * @returns {Boolean} true if and only if the following token is the
     *      unwanted type.
     */
    mismatchIsUnwantedToken: function(input, ttype) {
        return input.LA(2)===ttype;
    },

    /**
     * Does the stream appear to be missing a single token?
     * @param {org.antlr.runtime.IntStream} input input stream to match against.
     * @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
     *      matched token.
     * @returns {Boolean} true if and only if it appears that the stream is
     *      missing a single token.
     */
    mismatchIsMissingToken: function(input, follow) {
        if ( !follow ) {
            // we have no information about the follow; we can only consume
            // a single token and hope for the best
            return false;
        }
        // compute what can follow this grammar element reference
        if ( follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) ) {
            if ( this.state._fsp>=0 ) { // remove EOR if we're not the start symbol
                follow.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
            }
            var viableTokensFollowingThisRule = this.computeContextSensitiveRuleFOLLOW();
            follow = follow.or(this.viableTokensFollowingThisRule);
        }
        // if current token is consistent with what could come after set
        // then we know we're missing a token; error recovery is free to
        // "insert" the missing token

        // BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
        // in follow set to indicate that the fall of the start symbol is
        // in the set (EOF can follow).
        if ( follow.member(input.LA(1)) ||
             follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
        {
            return true;
        }
        return false;
    },

    /** Factor out what to do upon token mismatch so tree parsers can behave
     *  differently.  Override and call {@link #mismatchRecover}
     *  to get single token insertion and deletion.
     *
     *  @param {org.antlr.runtime.IntStream} input input stream to match against.
     *  @param {Number} ttype  input type to match.
     *  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
     *      matched token.
     */
    mismatch: function(input, ttype, follow) {
        if ( this.mismatchIsUnwantedToken(input, ttype) ) {
            throw new org.antlr.runtime.UnwantedTokenException(ttype, input);
        } else if ( this.mismatchIsMissingToken(input, follow) ) {
            throw new org.antlr.runtime.MissingTokenException(ttype, input, null);
        }
        throw new org.antlr.runtime.MismatchedTokenException(ttype, input);
    },

    /** Report a recognition problem.
     *
     *  <p>This method sets errorRecovery to indicate the parser is recovering
     *  not parsing.  Once in recovery mode, no errors are generated.
     *  To get out of recovery mode, the parser must successfully match
     *  a token (after a resync).  So it will go:</p>
     *  <ol>
     *      <li>error occurs</li>
     *      <li>enter recovery mode, report error</li>
     *      <li>consume until token found in resynch set</li>
     *      <li>try to resume parsing</li>
     *      <li>next match() will reset errorRecovery mode</li>
     *  </ol>
     *
     *  <p>If you override, make sure to update this.state.syntaxErrors if you
     *  care about that.</p>
     *  @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     */
    reportError: function(e) {
      if(this.input.size() != 0) {
        var token = this.input.get(e.index);
        var errorMessage = "";
        var column = 0;
        var line = 0;
        if(token.getType() == -1) {
          token = this.input.get(this.input.size() - 1);
        }
        errorMessage = this.getErrorMessage(e, this.getTokenNames());
        column = token.getStartIndex();
        line = token.getLine() - 1;

        var error = {
          line: line,
          message: errorMessage,
          column: column
        };
        this.addError(error);
      }
        // if we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        if ( this.state.errorRecovery ) {
            return;
        }
        this.state.syntaxErrors++;
        this.state.errorRecovery = true;

        this.displayRecognitionError(this.getTokenNames(), e);
    },

    /**
     * Assemble recognition error message.
     * @param {Array} tokenNames array of token names (strings).
     * @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     */
    displayRecognitionError: function(tokenNames, e) {
        var hdr = this.getErrorHeader(e),
            msg = this.getErrorMessage(e, tokenNames);
        this.emitErrorMessage(hdr+" "+msg);
    },

    /**
     * Create error header message.  Format is <q>line
     * lineNumber:positionInLine</q>.
     * @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     * @returns {String} The error header.
     */
    getErrorHeader: function(e) {
        /* handle null input */
        if (!org.antlr.lang.isNumber(e.line)) {
            e.line = 0;
        }
        return "line "+e.line+":"+e.charPositionInLine;
    },

    /**
     * Override this method to change where error messages go.
     * Defaults to "alert"-ing the error in browsers and "print"-ing the error
     * in other environments (e.g. Rhino, SpiderMonkey).
     * @param {String} msg the error message to be displayed.
     */
    emitErrorMessage: function(msg) {
      //throw msg;
      console.log(msg);
    },

    /** What error message should be generated for the various
     *  exception types?
     *
     *  <p>Not very object-oriented code, but I like having all error message
     *  generation within one method rather than spread among all of the
     *  exception classes. This also makes it much easier for the exception
     *  handling because the exception classes do not have to have pointers back
     *  to this object to access utility routines and so on. Also, changing
     *  the message for an exception type would be difficult because you
     *  would have to be subclassing exceptions, but then somehow get ANTLR
     *  to make those kinds of exception objects instead of the default.</p>
     *
     *  <p>For grammar debugging, you will want to override this to add
     *  more information such as the stack frame and no viable alts.</p>
     *
     *  <p>Override this to change the message generated for one or more
     *  exception types.</p>
     *
     * @param {Array} tokenNames array of token names (strings).
     * @param {org.antlr.runtime.RecognitionException} e the error to be reported.
     * @returns {String} the error message to be emitted.
     */
    getErrorMessage: function(e, tokenNames) {
        var msg = (e && e.getMessage) ? e.getMessage() : null,
            mte,
            tokenName;
        if ( e instanceof org.antlr.runtime.UnwantedTokenException ) {
            var ute = e;
            tokenName="<unknown>";
            if ( ute.expecting== org.antlr.runtime.Token.EOF ) {
                tokenName = "EOF";
            } else {
                tokenName = tokenNames[ute.expecting];
            }
            msg = "extraneous input "+this.getTokenErrorDisplay(ute.getUnexpectedToken())+
                " expecting "+tokenName;
        }
        else if ( e instanceof org.antlr.runtime.MissingTokenException ) {
            mte = e;
            tokenName="<unknown>";
            if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
                tokenName = "EOF";
            } else {
                tokenName = tokenNames[mte.expecting];
            }
            msg = "missing "+tokenName+" at "+this.getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
            mte = e;
            tokenName="<unknown>";
            if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
                tokenName = "EOF";
            }
            else {
                tokenName = tokenNames[mte.expecting];
            }
            msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
                " expecting "+tokenName;
        }
        else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
            msg = "no viable alternative at input "+this.getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
            msg = "required (...)+ loop did not match anything at input "+
                this.getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
            msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
                " expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
            msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
                " expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.FailedPredicateException ) {
            msg = "rule "+e.ruleName+" failed predicate: {"+
                e.predicateText+"}?";
        }
        return msg;
    },

    /** Get number of recognition errors (lexer, parser, tree parser).  Each
     *  recognizer tracks its own number.  So parser and lexer each have
     *  separate count.  Does not count the spurious errors found between
     *  an error and next valid token match
     *
     *  See also reportError()
     */
    getNumberOfSyntaxErrors: function() {
        return this.state.syntaxErrors;
    },

    /** How should a token be displayed in an error message? The default
     *  is to display just the text, but during development you might
     *  want to have a lot of information spit out.  Override in that case
     *  to use t.toString() (which, for CommonToken, dumps everything about
     *  the token). This is better than forcing you to override a method in
     *  your token objects because you don't have to go modify your lexer
     *  so that it creates a new Java type.
     */
    getTokenErrorDisplay: function(t) {
        var s = t.getText();
        if ( !org.antlr.lang.isValue(s) ) {
            if ( t.getType()==org.antlr.runtime.Token.EOF ) {
                s = "<EOF>";
            }
            else {
                s = "<"+t.getType()+">";
            }
        }
        s = s.replace(/\n/g,"\\n");
        s = s.replace(/\r/g,"\\r");
        s = s.replace(/\t/g,"\\t");
        return "'"+s+"'";
    },

    /** Recover from an error found on the input stream.  This is
     *  for NoViableAlt and mismatched symbol exceptions.  If you enable
     *  single token insertion and deletion, this will usually not
     *  handle mismatched symbol exceptions but there could be a mismatched
     *  token that the match() routine could not recover from.
     */
    recover: function(input, re) {
        if ( this.state.lastErrorIndex==input.index() ) {
            // uh oh, another error at same token index; must be a case
            // where LT(1) is in the recovery token set so nothing is
            // consumed; consume a single token so at least to prevent
            // an infinite loop; this is a failsafe.
            input.consume();
        }
        this.state.lastErrorIndex = input.index();
        var followSet = this.computeErrorRecoverySet();
        this.beginResync();
        this.consumeUntil(input, followSet);
        this.endResync();
    },

    /** A hook to listen in on the token consumption during error recovery.
     *  The DebugParser subclasses this to fire events to the listenter.
     */
    beginResync: function() {
    },

    endResync: function() {
    },

    /*  Compute the error recovery set for the current rule.  During
     *  rule invocation, the parser pushes the set of tokens that can
     *  follow that rule reference on the stack; this amounts to
     *  computing FIRST of what follows the rule reference in the
     *  enclosing rule. This local follow set only includes tokens
     *  from within the rule; i.e., the FIRST computation done by
     *  ANTLR stops at the end of a rule.
     *
     *  EXAMPLE
     *
     *  When you find a "no viable alt exception", the input is not
     *  consistent with any of the alternatives for rule r.  The best
     *  thing to do is to consume tokens until you see something that
     *  can legally follow a call to r *or* any rule that called r.
     *  You don't want the exact set of viable next tokens because the
     *  input might just be missing a token--you might consume the
     *  rest of the input looking for one of the missing tokens.
     *
     *  Consider grammar:
     *
     *  a : '[' b ']'
     *    | '(' b ')'
     *    ;
     *  b : c '^' INT ;
     *  c : ID
     *    | INT
     *    ;
     *
     *  At each rule invocation, the set of tokens that could follow
     *  that rule is pushed on a stack.  Here are the various "local"
     *  follow sets:
     *
     *  FOLLOW(b1_in_a) = FIRST(']') = ']'
     *  FOLLOW(b2_in_a) = FIRST(')') = ')'
     *  FOLLOW(c_in_b) = FIRST('^') = '^'
     *
     *  Upon erroneous input "[]", the call chain is
     *
     *  a -> b -> c
     *
     *  and, hence, the follow context stack is:
     *
     *  depth  local follow set     after call to rule
     *    0         <EOF>                    a (from main())
     *    1          ']'                     b
     *    3          '^'                     c
     *
     *  Notice that ')' is not included, because b would have to have
     *  been called from a different context in rule a for ')' to be
     *  included.
     *
     *  For error recovery, we cannot consider FOLLOW(c)
     *  (context-sensitive or otherwise).  We need the combined set of
     *  all context-sensitive FOLLOW sets--the set of all tokens that
     *  could follow any reference in the call chain.  We need to
     *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
     *  we resync'd to that token, we'd consume until EOF.  We need to
     *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
     *  In this case, for input "[]", LA(1) is in this set so we would
     *  not consume anything and after printing an error rule c would
     *  return normally.  It would not find the required '^' though.
     *  At this point, it gets a mismatched token error and throws an
     *  exception (since LA(1) is not in the viable following token
     *  set).  The rule exception handler tries to recover, but finds
     *  the same recovery set and doesn't consume anything.  Rule b
     *  exits normally returning to rule a.  Now it finds the ']' (and
     *  with the successful match exits errorRecovery mode).
     *
     *  So, you cna see that the parser walks up call chain looking
     *  for the token that was a member of the recovery set.
     *
     *  Errors are not generated in errorRecovery mode.
     *
     *  ANTLR's error recovery mechanism is based upon original ideas:
     *
     *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
     *
     *  and
     *
     *  "A note on error recovery in recursive descent parsers":
     *  http://portal.acm.org/citation.cfm?id=947902.947905
     *
     *  Later, Josef Grosch had some good ideas:
     *
     *  "Efficient and Comfortable Error Recovery in Recursive Descent
     *  Parsers":
     *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
     *
     *  Like Grosch I implemented local FOLLOW sets that are combined
     *  at run-time upon error to avoid overhead during parsing.
     */
    computeErrorRecoverySet: function() {
        return this.combineFollows(false);
    },


    /** Compute the context-sensitive FOLLOW set for current rule.
     *  This is set of token types that can follow a specific rule
     *  reference given a specific call chain.  You get the set of
     *  viable tokens that can possibly come next (lookahead depth 1)
     *  given the current call chain.  Contrast this with the
     *  definition of plain FOLLOW for rule r:
     *
     *   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
     *
     *  where x in T* and alpha, beta in V*; T is set of terminals and
     *  V is the set of terminals and nonterminals.  In other words,
     *  FOLLOW(r) is the set of all tokens that can possibly follow
     *  references to r in *any* sentential form (context).  At
     *  runtime, however, we know precisely which context applies as
     *  we have the call chain.  We may compute the exact (rather
     *  than covering superset) set of following tokens.
     *
     *  For example, consider grammar:
     *
     *  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
     *       | "return" expr '.'
     *       ;
     *  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
     *  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
     *       | '(' expr ')'
     *       ;
     *
     *  The FOLLOW sets are all inclusive whereas context-sensitive
     *  FOLLOW sets are precisely what could follow a rule reference.
     *  For input input "i=(3);", here is the derivation:
     *
     *  stat => ID '=' expr ';'
     *       => ID '=' atom ('+' atom)* ';'
     *       => ID '=' '(' expr ')' ('+' atom)* ';'
     *       => ID '=' '(' atom ')' ('+' atom)* ';'
     *       => ID '=' '(' INT ')' ('+' atom)* ';'
     *       => ID '=' '(' INT ')' ';'
     *
     *  At the "3" token, you'd have a call chain of
     *
     *    stat -> expr -> atom -> expr -> atom
     *
     *  What can follow that specific nested ref to atom?  Exactly ')'
     *  as you can see by looking at the derivation of this specific
     *  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
     *
     *  You want the exact viable token set when recovering from a
     *  token mismatch.  Upon token mismatch, if LA(1) is member of
     *  the viable next token set, then you know there is most likely
     *  a missing token in the input stream.  "Insert" one by just not
     *  throwing an exception.
     */
    computeContextSensitiveRuleFOLLOW: function() {
        return this.combineFollows(true);
    },

    combineFollows: function(exact) {
        var top = this.state._fsp,
            i,
            localFollowSet,
            followSet = new org.antlr.runtime.BitSet();
        for (i=top; i>=0; i--) {
            localFollowSet = this.state.following[i];
            followSet.orInPlace(localFollowSet);
            if ( exact ) {
                // can we see end of rule?
                if ( localFollowSet.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
                {
                    // Only leave EOR in set if at top (start rule); this lets
                    // us know if have to include follow(start rule); i.e., EOF
                    if ( i>0 ) {
                        followSet.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
                    }
                }
                else { // can't see end of rule, quit
                    break;
                }
            }
        }
        return followSet;
    },

    /** Attempt to recover from a single missing or extra token.
     *
     *  EXTRA TOKEN
     *
     *  LA(1) is not what we are looking for.  If LA(2) has the right token,
     *  however, then assume LA(1) is some extra spurious token.  Delete it
     *  and LA(2) as if we were doing a normal match(), which advances the
     *  input.
     *
     *  MISSING TOKEN
     *
     *  If current token is consistent with what could come after
     *  ttype then it is ok to "insert" the missing token, else throw
     *  exception For example, Input "i=(3;" is clearly missing the
     *  ')'.  When the parser returns from the nested call to expr, it
     *  will have call chain:
     *
     *    stat -> expr -> atom
     *
     *  and it will be trying to match the ')' at this point in the
     *  derivation:
     *
     *       => ID '=' '(' INT ')' ('+' atom)* ';'
     *                          ^
     *  match() will see that ';' doesn't match ')' and report a
     *  mismatched token error.  To recover, it sees that LA(1)==';'
     *  is in the set of tokens that can follow the ')' token
     *  reference in rule atom.  It can assume that you forgot the ')'.
     */
    recoverFromMismatchedToken: function(input,
                                         ttype,
                                         follow)
    {
        var e = null;
        // if next token is what we are looking for then "delete" this token
        if ( this.mismatchIsUnwantedToken(input, ttype) ) {
            e = new org.antlr.runtime.UnwantedTokenException(ttype, input);
            this.beginResync();
            input.consume(); // simply delete extra token
            this.endResync();
            this.reportError(e);  // report after consuming so AW sees the token in the exception
            // we want to return the token we're actually matching
            var matchedSymbol = this.getCurrentInputSymbol(input);
            input.consume(); // move past ttype token as if all were ok
            return matchedSymbol;
        }
        // can't recover with single token deletion, try insertion
        if ( this.mismatchIsMissingToken(input, follow) ) {
            var inserted = this.getMissingSymbol(input, e, ttype, follow);
            e = new org.antlr.runtime.MissingTokenException(ttype, input, inserted);
            this.reportError(e);  // report after inserting so AW sees the token in the exception
            return inserted;
        }
        // even that didn't work; must throw the exception
        e = new org.antlr.runtime.MismatchedTokenException(ttype, input);
        throw e;
    },

    recoverFromMismatchedSet: function(input,
                                       e,
                                       follow)
    {
        if ( this.mismatchIsMissingToken(input, follow) ) {
            // System.out.println("missing token");
            this.reportError(e);
            // we don't know how to conjure up a token for sets yet
            return this.getMissingSymbol(input, e, org.antlr.runtime.Token.INVALID_TOKEN_TYPE, follow);
        }
        throw e;
    },

    /** Match needs to return the current input symbol, which gets put
     *  into the label for the associated token ref; e.g., x=ID.  Token
     *  and tree parsers need to return different objects. Rather than test
     *  for input stream type or change the IntStream interface, I use
     *  a simple method to ask the recognizer to tell me what the current
     *  input symbol is.
     * 
     *  This is ignored for lexers.
     */
    getCurrentInputSymbol: function(input) { return null; },

    /** Conjure up a missing token during error recovery.
     *
     *  The recognizer attempts to recover from single missing
     *  symbols. But, actions might refer to that missing symbol.
     *  For example, x=ID {f($x);}. The action clearly assumes
     *  that there has been an identifier matched previously and that
     *  $x points at that token. If that token is missing, but
     *  the next token in the stream is what we want we assume that
     *  this token is missing and we keep going. Because we
     *  have to return some token to replace the missing token,
     *  we have to conjure one up. This method gives the user control
     *  over the tokens returned for missing tokens. Mostly,
     *  you will want to create something special for identifier
     *  tokens. For literals such as '{' and ',', the default
     *  action in the parser or tree parser works. It simply creates
     *  a CommonToken of the appropriate type. The text will be the token.
     *  If you change what tokens must be created by the lexer,
     *  override this method to create the appropriate tokens.
     */
    getMissingSymbol: function(input,
                               e,
                               expectedTokenType,
                               follow)
    {
        return null;
    },


    /** Consume tokens until one matches the given token set */
    consumeUntil: function(input, set) {
        var ttype = input.LA(1);
        while (ttype != org.antlr.runtime.Token.EOF && !set.member(ttype) ) {
            input.consume();
            ttype = input.LA(1);
        }
    },

    /** Push a rule's follow set using our own hardcoded stack */
    pushFollow: function(fset) {
        if ( (this.state._fsp +1)>=this.state.following.length ) {
            var f = [];
            var i;
            for (i=this.state.following.length-1; i>=0; i--) {
                f[i] = this.state.following[i];
            }
            this.state.following = f;
        }
        this.state._fsp++;
        this.state.following[this.state._fsp] = fset;
    },

    /** Return List<String> of the rules in your parser instance
     *  leading up to a call to this method.  You could override if
     *  you want more details such as the file/line info of where
     *  in the parser java code a rule is invoked.
     *
     *  This is very useful for error messages and for context-sensitive
     *  error recovery.
     *
     *  A more general version of getRuleInvocationStack where you can
     *  pass in, for example, a RecognitionException to get it's rule
     *  stack trace.  This routine is shared with all recognizers, hence,
     *  static.
     *
     *  TODO: move to a utility class or something; weird having lexer call this
     *
     *  Most JS interpreters can't do real stack reflection.  See this
     *  spidermonkey bug, for example:
     *  https://bugzilla.mozilla.org/show_bug.cgi?id=332104
     *
     *  JS is supposed to get real stack traces in v4, at which time it would
     *  be easy to implement this function.
     *
     *  Until then I'll leave this unimplemented.  If there is enough clamor
     *  it would be possible to keep track of the invocation stack using an
     *  auxillary array, but that will definitely be a performance hit.
     */
    getRuleInvocationStack: function(e, recognizerClassName)
    {
        throw new Error("Not implemented.");
    },

    getBacktrackingLevel: function() {
        return this.state.backtracking;
    },

    /** Used to print out token names like ID during debugging and
     *  error reporting.  The generated parsers implement a method
     *  that overrides this to point to their String[] tokenNames.
     */
    getTokenNames: function() {
        return null;
    },

    /** For debugging and other purposes, might want the grammar name.
     *  Have ANTLR generate an implementation for this method.
     */
    getGrammarFileName: function() {
        return null;
    },

    /** A convenience method for use most often with template rewrites.
     *  Convert a List<Token> to List<String>
     */
    toStrings: function(tokens) {
        if ( !tokens ) {
            return null;
        }
        var strings = [];
        var i;
        for (i=0; i<tokens.length; i++) {
            strings.push(tokens[i].getText());
        }
        return strings;
    },

    /** Given a rule number and a start token index number, return
     *  MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
     *  start index.  If this rule has parsed input starting from the
     *  start index before, then return where the rule stopped parsing.
     *  It returns the index of the last token matched by the rule.
     *
     *  For now we use a hashtable and just the slow Object-based one.
     *  Later, we can make a special one for ints and also one that
     *  tosses out data after we commit past input position i.
     */
    getRuleMemoization: function(ruleIndex, ruleStartIndex) {
        if ( !this.state.ruleMemo[ruleIndex] ) {
            this.state.ruleMemo[ruleIndex] = {};
        }
        var stopIndexI =
            this.state.ruleMemo[ruleIndex][ruleStartIndex];
        if ( !org.antlr.lang.isNumber(stopIndexI) ) {
            return org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN;
        }
        return stopIndexI;
    },

    /** Has this rule already parsed input at the current index in the
     *  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
     *  If we attempted but failed to parse properly before, return
     *  MEMO_RULE_FAILED.
     *
     *  This method has a side-effect: if we have seen this input for
     *  this rule and successfully parsed before, then seek ahead to
     *  1 past the stop token matched for this rule last time.
     */
    alreadyParsedRule: function(input, ruleIndex) {
        var stopIndex = this.getRuleMemoization(ruleIndex, input.index());
        if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN ) {
            return false;
        }
        if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED ) {
            //System.out.println("rule "+ruleIndex+" will never succeed");
            this.state.failed=true;
        }
        else {
            input.seek(stopIndex+1); // jump to one past stop token
        }
        return true;
    },

    /** Record whether or not this rule parsed the input at this position
     *  successfully.  Use a standard java hashtable for now.
     */
    memoize: function(input,
                      ruleIndex,
                      ruleStartIndex)
    {
        var stopTokenIndex = this.state.failed ? 
            org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED : input.index()-1;
        if ( !org.antlr.lang.isValue(this.state.ruleMemo) ) {
            throw new Error("!!!!!!!!! memo array is null for "+ this.getGrammarFileName());
        }
        if ( ruleIndex >= this.state.ruleMemo.length ) {
            throw new Error("!!!!!!!!! memo size is "+this.state.ruleMemo.length+", but rule index is "+ruleIndex);
        }
        if ( org.antlr.lang.isValue(this.state.ruleMemo[ruleIndex]) ) {
            this.state.ruleMemo[ruleIndex][ruleStartIndex] = stopTokenIndex;
        }
    },

    /** return how many rule/input-index pairs there are in total.
     *  TODO: this includes synpreds.
     */
    getRuleMemoizationCacheSize: function() {
        var n = 0, i;
        for (i = 0; this.state.ruleMemo && i < this.state.ruleMemo.length; i++) {
            var ruleMap = this.state.ruleMemo[i];
            if ( ruleMap ) {
                // @todo need to get size of rulemap?
                n += ruleMap.length; // how many input indexes are recorded?
            }
        }
        return n;
    },

    traceIn: function(ruleName, ruleIndex, inputSymbol)  {
        this.emitErrorMessage("enter "+ruleName+" "+inputSymbol);
        if ( this.state.failed ) {
            this.emitErrorMessage(" failed="+this.failed);
        }
        if ( this.state.backtracking>0 ) {
            this.emitErrorMessage(" backtracking="+this.state.backtracking);
        }
        // System.out.println();
    },

    traceOut: function(ruleName, ruleIndex, inputSymbol) {
        this.emitErrorMessage("exit "+ruleName+" "+inputSymbol);
        if ( this.state.failed ) {
            this.emitErrorMessage(" failed="+this.state.failed);
        }
        if ( this.state.backtracking>0 ) {
            this.emitErrorMessage(" backtracking="+this.state.backtracking);
        }
    }
};
/** A lexer is recognizer that draws input symbols from a character stream.
 *  lexer grammars result in a subclass of this object. A Lexer object
 *  uses simplified match() and error recovery mechanisms in the interest
 *  of speed.
 */
org.antlr.runtime.Lexer = function(input, state) {
    if (state) {
        org.antlr.runtime.Lexer.superclass.constructor.call(this, state);
    }
    if (input) {
        this.input = input;
    }
};

org.antlr.lang.extend(org.antlr.runtime.Lexer, org.antlr.runtime.BaseRecognizer, {
    reset: function() {
        // reset all recognizer state variables
        org.antlr.runtime.Lexer.superclass.reset.call(this);
        if ( org.antlr.lang.isValue(this.input) ) {
            this.input.seek(0); // rewind the input
        }
        if ( !org.antlr.lang.isValue(this.state) ) {
            return; // no shared state work to do
        }
        this.state.token = null;
        this.state.type = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
        this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
        this.state.tokenStartCharIndex = -1;
        this.state.tokenStartCharPositionInLine = -1;
        this.state.tokenStartLine = -1;
        this.state.text = null;
    },

    /** Return a token from this source; i.e., match a token on the char
     *  stream.
     */
    nextToken: function() {
        while (true) {
            this.state.token = null;
            this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
            this.state.tokenStartCharIndex = this.input.index();
            this.state.tokenStartCharPositionInLine = this.input.getCharPositionInLine();
            this.state.tokenStartLine = this.input.getLine();
            this.state.text = null;
            if ( this.input.LA(1)===org.antlr.runtime.CharStream.EOF ) {
                return org.antlr.runtime.Token.EOF_TOKEN;
            }
            try {
                this.mTokens();
                if ( !org.antlr.lang.isValue(this.state.token) ) {
                    this.emit();
                }
                else if ( this.state.token==org.antlr.runtime.Token.SKIP_TOKEN ) {
                    continue;
                }
                return this.state.token;
            }
            catch (re) {
                if (re instanceof org.antlr.runtime.NoViableAltException) {
                    this.reportError(re);
                    this.recover(re);
                } else if ( re instanceof org.antlr.runtime.RecognitionException ) {
                    this.reportError(re);
                } else {
                    throw re;
                }
            }
        }
    },

    /** Instruct the lexer to skip creating a token for current lexer rule
     *  and look for another token.  nextToken() knows to keep looking when
     *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
     *  if token==null at end of any token rule, it creates one for you
     *  and emits it.
     */
    skip: function() {
        this.state.token = org.antlr.runtime.Token.SKIP_TOKEN;
    },

    /** Set the char stream and reset the lexer */
    setCharStream: function(input) {
        this.input = null;
        this.reset();
        this.input = input;
    },

    getCharStream: function() {
        return this.input;
    },

    getSourceName: function() {
        return this.input.getSourceName();
    },

    /** Currently does not support multiple emits per nextToken invocation
     *  for efficiency reasons.  Subclass and override this method and
     *  nextToken (to push tokens into a list and pull from that list rather
     *  than a single variable as this implementation does).
     *
     *  The standard method called to automatically emit a token at the
     *  outermost lexical rule.  The token object should point into the
     *  char buffer start..stop.  If there is a text override in 'text',
     *  use that to set the token's text.  Override this method to emit
     *  custom Token objects.
     *
     *  If you are building trees, then you should also override
     *  Parser or TreeParser.getMissingSymbol().
     */
    emit: function() {
        if (arguments.length===0) {
            var t = new org.antlr.runtime.CommonToken(this.input, this.state.type, this.state.channel, this.state.tokenStartCharIndex, this.getCharIndex()-1);
            t.setLine(this.state.tokenStartLine);
            t.setText(this.state.text);
            t.setCharPositionInLine(this.state.tokenStartCharPositionInLine);
            this.state.token = t;
            return t;
        } else {
            this.state.token = arguments[0];
        }
    },

    match: function(s) {
        var i = 0,
            mte;

        if (org.antlr.lang.isString(s)) {
            while ( i<s.length ) {
                if ( this.input.LA(1)!=s.charAt(i) ) {
                    if ( this.state.backtracking>0 ) {
                        this.state.failed = true;
                        return;
                    }
                    mte = new org.antlr.runtime.MismatchedTokenException(s.charAt(i), this.input);
                    this.recover(mte);
                    throw mte;
                }
                i++;
                this.input.consume();
                this.state.failed = false;
            }
        } else if (org.antlr.lang.isNumber(s)) {
            if ( this.input.LA(1)!=s ) {
                if ( this.state.backtracking>0 ) {
                    this.state.failed = true;
                    return;
                }
                mte = new org.antlr.runtime.MismatchedTokenException(s, this.input);
                this.recover(mte);
                throw mte;
            }
            this.input.consume();
            this.state.failed = false;
        }
    },

    matchAny: function() {
        this.input.consume();
    },

    matchRange: function(a, b) {
        if ( this.input.LA(1)<a || this.input.LA(1)>b ) {
            if ( this.state.backtracking>0 ) {
                this.state.failed = true;
                return;
            }
            mre = new org.antlr.runtime.MismatchedRangeException(a,b,this.input);
            this.recover(mre);
            throw mre;
        }
        this.input.consume();
        this.state.failed = false;
    },

    getLine: function() {
        return this.input.getLine();
    },

    getCharPositionInLine: function() {
        return this.input.getCharPositionInLine();
    },

    /** What is the index of the current character of lookahead? */
    getCharIndex: function() {
        return this.input.index();
    },

    /** Return the text matched so far for the current token or any
     *  text override.
     */
    getText: function() {
        if ( org.antlr.lang.isString(this.state.text) ) {
            return this.state.text;
        }
        return this.input.substring(this.state.tokenStartCharIndex,this.getCharIndex()-1);
    },

    /** Set the complete text of this token; it wipes any previous
     *  changes to the text.
     */
    setText: function(text) {
        this.state.text = text;
    },

    reportError: function(e) {
        /** TODO: not thought about recovery in lexer yet.
         *
        // if we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        if ( errorRecovery ) {
            //System.err.print("[SPURIOUS] ");
            return;
        }
        errorRecovery = true;
         */

        this.displayRecognitionError(this.getTokenNames(), e);
    },

    getErrorMessage: function(e, tokenNames) {
        var msg = null;
        if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting "+this.getCharErrorDisplay(e.expecting);
        }
        else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
            msg = "no viable alternative at character "+this.getCharErrorDisplay(e.c);
        }
        else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
            msg = "required (...)+ loop did not match anything at character "+this.getCharErrorDisplay(e.c);
        }
        else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
        }
        else if ( e instanceof org.antlr.runtime.MismatchedRangeException ) {
            msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+
                this.getCharErrorDisplay(e.a)+".."+this.getCharErrorDisplay(e.b);
        }
        else {
            msg = org.antlr.runtime.Lexer.superclass.getErrorMessage.call(this, e, tokenNames);
        }
        return msg;
    },

    getCharErrorDisplay: function(c) {
        var s = c; //String.fromCharCode(c);
        switch ( s ) {
            case org.antlr.runtime.Token.EOF :
                s = "<EOF>";
                break;
            case "\n" :
                s = "\\n";
                break;
            case "\t" :
                s = "\\t";
                break;
            case "\r" :
                s = "\\r";
                break;
        }
        return "'"+s+"'";
    },

    /** Lexers can normally match any char in it's vocabulary after matching
     *  a token, so do the easy thing and just kill a character and hope
     *  it all works out.  You can instead use the rule invocation stack
     *  to do sophisticated error recovery if you are in a fragment rule.
     */
    recover: function(re) {
        this.input.consume();
    },

    traceIn: function(ruleName, ruleIndex)  {
        var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
        org.antlr.runtime.Lexer.superclass.traceIn.call(this, ruleName, ruleIndex, inputSymbol);
    },

    traceOut: function(ruleName, ruleIndex)  {
		var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
		org.antlr.runtime.Lexer.superclass.traceOut.call(this, ruleName, ruleIndex, inputSymbol);
	}
});
/** Rules that return more than a single value must return an object
 *  containing all the values.  Besides the properties defined in
 *  RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
 *  return values.  This class simply defines the minimum properties that
 *  are always defined and methods to access the others that might be
 *  available depending on output option such as template and tree.
 *
 *  Note text is not an actual property of the return value, it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */
org.antlr.runtime.ParserRuleReturnScope = function() {};

org.antlr.runtime.ParserRuleReturnScope.prototype = {
    getStart: function() { return this.start; },
    getStop: function() { return this.stop; }
};
/** This is identical to the ParserRuleReturnScope except that
 *  the start property is a tree nodes not Token object
 *  when you are parsing trees.  To be generic the tree node types
 *  have to be Object.
 */
org.antlr.runtime.tree.TreeRuleReturnScope = function(){};

org.antlr.runtime.tree.TreeRuleReturnScope.prototype = {
    getStart: function() { return this.start; }
};
/** A parser for TokenStreams.  "parser grammars" result in a subclass
 *  of this.
 */
org.antlr.runtime.Parser = function(input, state) {
    org.antlr.runtime.Parser.superclass.constructor.call(this, state);
    this.setTokenStream(input);
};

org.antlr.lang.extend(org.antlr.runtime.Parser, org.antlr.runtime.BaseRecognizer, {
    reset: function() {
        // reset all recognizer state variables
		org.antlr.runtime.Parser.superclass.reset.call(this);
		if ( org.antlr.lang.isValue(this.input) ) {
			this.input.seek(0); // rewind the input
		}
	},

    getCurrentInputSymbol: function(input) {
        return input.LT(1);
    },

    getMissingSymbol: function(input,
                               e,
                               expectedTokenType,
                               follow)
    {
        var tokenText =
            "<missing "+this.getTokenNames()[expectedTokenType]+">";
        var t = new org.antlr.runtime.CommonToken(expectedTokenType, tokenText);
        var current = input.LT(1);
        var old_current;
        if ( current.getType() === org.antlr.runtime.Token.EOF ) {
            old_current = current;
            current = input.LT(-1);
            // handle edge case where there are no good tokens in the stream
            if (!current) {
                current = old_current;
            }
        }
        t.line = current.getLine();
        t.charPositionInLine = current.getCharPositionInLine();
        t.channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
        return t;
    },


	/** Set the token stream and reset the parser */
    setTokenStream: function(input) {
		this.input = null;
		this.reset();
		this.input = input;
	},

    getTokenStream: function() {
		return this.input;
	},

    getSourceName: function() {
        return this.input.getSourceName();
    },

    traceIn: function(ruleName, ruleIndex)  {
		org.antlr.runtime.Parser.superclass.traceIn.call(
                this, ruleName, ruleIndex, this.input.LT(1));
	},

    traceOut: function(ruleName, ruleIndex)  {
		org.antlr.runtime.Parser.superclass.traceOut.call(
                this, ruleName, ruleIndex, this.input.LT(1));
	}
});
/** A DFA implemented as a set of transition tables.
 *
 *  Any state that has a semantic predicate edge is special; those states
 *  are generated with if-then-else structures in a specialStateTransition()
 *  which is generated by cyclicDFA template.
 *
 *  There are at most 32767 states (16-bit signed short).
 *  Could get away with byte sometimes but would have to generate different
 *  types and the simulation code too.  For a point of reference, the Java
 *  lexer's Tokens rule DFA has 326 states roughly.
 */
org.antlr.runtime.DFA = function() {};

org.antlr.runtime.DFA.prototype = {
    /** From the input stream, predict what alternative will succeed
     *  using this DFA (representing the covering regular approximation
     *  to the underlying CFL).  Return an alternative number 1..n.  Throw
     *  an exception upon error.
     */
    predict: function(input) {
        var mark = input.mark(), // remember where decision started in input
            s = 0, // we always start at s0
            specialState,
            c,
            snext;

        try {
            while ( true ) {
                specialState = this.special[s];
                if ( specialState>=0 ) {
                    s = this.specialStateTransition(specialState,input);
                    if (s===-1) {
                        this.noViableAlt(s, input);
                        return 0;
                    }
                    input.consume();
                    continue;
                }
                if ( this.accept[s] >= 1 ) {
                    return this.accept[s];
                }
                // look for a normal char transition
                c = input.LA(1); // -1 == \uFFFF, all tokens fit in 65000 space

                if (c===org.antlr.runtime.Token.EOF) {
                    c = -1;
                } else if (org.antlr.lang.isString(c)) {
                    c = c.charCodeAt(0);
                }

                if (c>=this.min[s] && c<=this.max[s]) {
                    snext = this.transition[s][c-this.min[s]]; // move to next state
                    if ( snext < 0 ) {
                        // was in range but not a normal transition
                        // must check EOT, which is like the else clause.
                        // eot[s]>=0 indicates that an EOT edge goes to another
                        // state.
                        if ( this.eot[s]>=0 ) {  // EOT Transition to accept state?
                            s = this.eot[s];
                            input.consume();
                            // TODO: I had this as return accept[eot[s]]
                            // which assumed here that the EOT edge always
                            // went to an accept...faster to do this, but
                            // what about predicated edges coming from EOT
                            // target?
                            continue;
                        }
                        this.noViableAlt(s,input);
                        return 0;
                    }
                    s = snext;
                    input.consume();
                    continue;
                }
                if ( this.eot[s]>=0 ) {  // EOT Transition?
                    s = this.eot[s];
                    input.consume();
                    continue;
                }
                if ( c==org.antlr.runtime.Token.EOF && this.eof[s]>=0 ) {  // EOF Transition to accept state?
                    return this.accept[this.eof[s]];
                }
                // not in range and not EOF/EOT, must be invalid symbol
                this.noViableAlt(s,input);
                return 0;
            }
        }
        finally {
            input.rewind(mark);
        }
    },

    noViableAlt: function(s, input) {
        if (this.recognizer.state.backtracking>0) {
            this.recognizer.state.failed=true;
            return;
        }
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(),
                                     this.decisionNumber,
                                     s,
                                     input);
        this.error(nvae);
        throw nvae;
    },

    /** A hook for debugging interface */
    error: function(nvae) { },

    specialStateTransition: function(s, input) {
        return -1;
    },

    getDescription: function() {
        return "n/a";
    }
};

org.antlr.lang.augmentObject(org.antlr.runtime.DFA, {
    /** Given a String that has a run-length-encoding of some unsigned shorts
     *  like "\1\2\3\9", convert to short[] {2,9,9,9}.
     */
    unpackEncodedString: function(encodedString) {
        // walk first to find how big it is.
        var i,
            data = [],
            di = 0,
            n,
            v,
            j;
        for (i=0; i<encodedString.length; i+=2) {
            n = encodedString.charCodeAt(i);
            v = encodedString.charCodeAt(i+1);
            if (v===0xffff) {
                v = -1; // overflow at 16 bits
            }
            // add v n times to data
            for (j=1; j<=n; j++) {
                data[di++] = v;
            }
        }
        return data;
    },

    // alias
    unpackEncodedStringToUnsignedChars: function(encodedString) {
        return org.antlr.runtime.DFA.unpackEncodedString(encodedString);
    }
});
/** A parser for a stream of tree nodes.  "tree grammars" result in a subclass
 *  of this.  All the error reporting and recovery is shared with Parser via
 *  the BaseRecognizer superclass.
*/
org.antlr.runtime.tree.TreeParser = function(input) {
    org.antlr.runtime.tree.TreeParser.superclass.constructor.call(this, arguments[1]);
    this.setTreeNodeStream(input);
};

(function(){
var TP = org.antlr.runtime.tree.TreeParser;

org.antlr.lang.augmentObject(TP, {
    DOWN: org.antlr.runtime.Token.DOWN,
    UP: org.antlr.runtime.Token.UP
});

org.antlr.lang.extend(TP, org.antlr.runtime.BaseRecognizer, {
    reset: function() {
        TP.superclass.reset.call(this); // reset all recognizer state variables
        if ( this.input ) {
            this.input.seek(0); // rewind the input
        }
    },

    /** Set the input stream */
    setTreeNodeStream: function(input) {
        this.input = input;
    },

    getTreeNodeStream: function() {
        return this.input;
    },

    getSourceName: function() {
        return this.input.getSourceName();
    },

    getCurrentInputSymbol: function(input) {
        return input.LT(1);
    },

    getMissingSymbol: function(input, e, expectedTokenType, follow) {
        var tokenText =
            "<missing "+this.getTokenNames()[expectedTokenType]+">";
        return new org.antlr.runtime.tree.CommonTree(new org.antlr.runtime.CommonToken(expectedTokenType, tokenText));
    },

    /** Match '.' in tree parser has special meaning.  Skip node or
     *  entire tree if node has children.  If children, scan until
     *  corresponding UP node.
     */
    matchAny: function(ignore) { // ignore stream, copy of this.input
        this.state.errorRecovery = false;
        this.state.failed = false;
        var look = this.input.LT(1);
        if ( this.input.getTreeAdaptor().getChildCount(look)===0 ) {
            this.input.consume(); // not subtree, consume 1 node and return
            return;
        }
        // current node is a subtree, skip to corresponding UP.
        // must count nesting level to get right UP
        var level=0,
            tokenType = this.input.getTreeAdaptor().getType(look);
        while ( tokenType!==org.antlr.runtime.Token.EOF &&
                !(tokenType===TP.UP && level===0) )
        {
            this.input.consume();
            look = this.input.LT(1);
            tokenType = this.input.getTreeAdaptor().getType(look);
            if ( tokenType === TP.DOWN ) {
                level++;
            }
            else if ( tokenType === TP.UP ) {
                level--;
            }
        }
        this.input.consume(); // consume UP
    },

    /** We have DOWN/UP nodes in the stream that have no line info; override.
     *  plus we want to alter the exception type.  Don't try to recover
     *       *  from tree parser errors inline...
     */
    mismatch: function(input, ttype, follow) {
        throw new org.antlr.runtime.MismatchedTreeNodeException(ttype, input);
    },

    /** Prefix error message with the grammar name because message is
     *  always intended for the programmer because the parser built
     *  the input tree not the user.
     */
    getErrorHeader: function(e) {
        return this.getGrammarFileName()+": node from "+
               (e.approximateLineInfo?"after ":"")+"line "+e.line+":"+e.charPositionInLine;
    },

    /** Tree parsers parse nodes they usually have a token object as
     *  payload. Set the exception token and do the default behavior.
     */
    getErrorMessage: function(e, tokenNames) {
        var adaptor;
        if ( this instanceof TP ) {
            adaptor = e.input.getTreeAdaptor();
            e.token = adaptor.getToken(e.node);
            if ( !org.antlr.lang.isValue(e.token) ) { // could be an UP/DOWN node
                e.token = new org.antlr.runtime.CommonToken(
                        adaptor.getType(e.node),
                        adaptor.getText(e.node));
            }
        }
        return TP.superclass.getErrorMessage.call(this, e, tokenNames);
    },

    traceIn: function(ruleName, ruleIndex) {
        TP.superclass.traceIn.call(this, ruleName, ruleIndex, this.input.LT(1));
    },

    traceOut: function(ruleName, ruleIndex) {
        TP.superclass.traceOut.call(this, ruleName, ruleIndex, this.input.LT(1));
    }
});

})();

exports.org = org;

});
define('ace/mode/xquery/XQueryLexer', ['require', 'exports', 'module' , 'ace/mode/xquery/antlr3-all', 'ace/mode/xquery/XQDTLexer'], function(require, exports, module) {
// $ANTLR 3.3 Nov 30, 2010 12:50:56 xquery/XQueryLexer.g 2012-04-18 21:05:06

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
var org =  require("./antlr3-all").org;
var XQDTLexer   = require("./XQDTLexer").XQDTLexer;


var XQueryLexer = function(input, state) {
// alternate constructor @todo
// public XQueryLexer(CharStream input)
// public XQueryLexer(CharStream input, RecognizerSharedState state) {
    if (!state) {
        state = new org.antlr.runtime.RecognizerSharedState();
    }

    (function(){


        this.inStr = false;

        // dummy list for warning elimination
        //List<Stack<Object>> dummy = new ArrayList<Stack<Object>>();

        // when we start, the '<' has already been eaten by the other lexer
        //boolean inStr = false;
        //
        //public boolean isInString()
        //{
        //   return inStr;
        //}


    }).call(this);

    this.dfa19 = new XQueryLexer.DFA19(this);
    XQueryLexer.superclass.constructor.call(this, input, state);


};

org.antlr.lang.augmentObject(XQueryLexer, {
    EOF: -1,
    L_QuotAttrContentChar: 4,
    L_AposAttrContentChar: 5,
    L_ElementContentChar: 6,
    L_CDataSection: 7,
    L_PredefinedEntityRef: 8,
    L_CharRef: 9,
    ESCAPE_LBRACKET: 10,
    ESCAPE_RBRACKET: 11,
    ESCAPE_APOS: 12,
    ESCAPE_QUOT: 13,
    CDATA_START: 14,
    CDATA_END: 15,
    ANCESTOR: 16,
    ANCESTOR_OR_SELF: 17,
    AND: 18,
    AS: 19,
    ASCENDING: 20,
    AT: 21,
    ATTRIBUTE: 22,
    BASE_URI: 23,
    BOUNDARY_SPACE: 24,
    BY: 25,
    CASE: 26,
    CAST: 27,
    CASTABLE: 28,
    CHILD: 29,
    COLLATION: 30,
    COMMENT: 31,
    CONSTRUCTION: 32,
    COPY_NAMESPACES: 33,
    DECLARE: 34,
    DEFAULT: 35,
    DESCENDANT: 36,
    DESCENDANT_OR_SELF: 37,
    DESCENDING: 38,
    DIV: 39,
    DOCUMENT: 40,
    DOCUMENT_NODE: 41,
    ELEMENT: 42,
    ELSE: 43,
    EMPTY: 44,
    EMPTY_SEQUENCE: 45,
    ENCODING: 46,
    EQ: 47,
    EVERY: 48,
    EXCEPT: 49,
    EXTERNAL: 50,
    FOLLOWING: 51,
    FOLLOWING_SIBLING: 52,
    FOR: 53,
    FUNCTION: 54,
    GE: 55,
    GREATEST: 56,
    GT: 57,
    IDIV: 58,
    IF: 59,
    IMPORT: 60,
    IN: 61,
    INHERIT: 62,
    INSTANCE: 63,
    INTERSECT: 64,
    IS: 65,
    ITEM: 66,
    LAX: 67,
    LE: 68,
    LEAST: 69,
    LET: 70,
    LT: 71,
    MOD: 72,
    MODULE: 73,
    NAMESPACE: 74,
    NE: 75,
    NO_INHERIT: 76,
    NO_PRESERVE: 77,
    NODE: 78,
    OF: 79,
    OPTION: 80,
    OR: 81,
    ORDER: 82,
    ORDERED: 83,
    ORDERING: 84,
    PARENT: 85,
    PRECEDING: 86,
    PRECEDING_SIBLING: 87,
    PRESERVE: 88,
    PROCESSING_INSTRUCTION: 89,
    RETURN: 90,
    SATISFIES: 91,
    SCHEMA: 92,
    SCHEMA_ATTRIBUTE: 93,
    SCHEMA_ELEMENT: 94,
    SELF: 95,
    SOME: 96,
    STABLE: 97,
    STRICT: 98,
    STRIP: 99,
    TEXT: 100,
    THEN: 101,
    TO: 102,
    TREAT: 103,
    TYPESWITCH: 104,
    UNION: 105,
    UNORDERED: 106,
    VALIDATE: 107,
    VARIABLE: 108,
    VERSION: 109,
    WHERE: 110,
    XQUERY: 111,
    ALLOWING: 112,
    CATCH: 113,
    CONTEXT: 114,
    COUNT: 115,
    DECIMAL_FORMAT: 116,
    DECIMAL_SEPARATOR: 117,
    DIGIT: 118,
    END: 119,
    GROUP: 120,
    GROUPING_SEPARATOR: 121,
    INFINITY: 122,
    MINUS_SIGN: 123,
    NAMESPACE_NODE: 124,
    NAN: 125,
    NEXT: 126,
    ONLY: 127,
    PATTERN_SEPARATOR: 128,
    PERCENT: 129,
    PER_MILLE: 130,
    PREVIOUS: 131,
    SLIDING: 132,
    START: 133,
    SWITCH: 134,
    TRY: 135,
    TUMBLING: 136,
    TYPE: 137,
    WHEN: 138,
    WINDOW: 139,
    ZERO_DIGIT: 140,
    AFTER: 141,
    BEFORE: 142,
    COPY: 143,
    DELETE: 144,
    FIRST: 145,
    INSERT: 146,
    INTO: 147,
    LAST: 148,
    MODIFY: 149,
    NODES: 150,
    RENAME: 151,
    REPLACE: 152,
    REVALIDATION: 153,
    SKIP: 154,
    UPDATING: 155,
    VALUE: 156,
    WITH: 157,
    ALL: 158,
    ANY: 159,
    CONTAINS: 160,
    CONTENT: 161,
    DIACRITICS: 162,
    DIFFERENT: 163,
    DISTANCE: 164,
    ENTIRE: 165,
    EXACTLY: 166,
    FROM: 167,
    FT_OPTION: 168,
    FTAND: 169,
    FTNOT: 170,
    FTOR: 171,
    INSENSITIVE: 172,
    LANGUAGE: 173,
    LEVELS: 174,
    LOWERCASE: 175,
    MOST: 176,
    NO: 177,
    NOT: 178,
    OCCURS: 179,
    PARAGRAPH: 180,
    PARAGRAPHS: 181,
    PHRASE: 182,
    RELATIONSHIP: 183,
    SAME: 184,
    SCORE: 185,
    SENSITIVE: 186,
    SENTENCE: 187,
    SENTENCES: 188,
    STEMMING: 189,
    STOP: 190,
    THESAURUS: 191,
    TIMES: 192,
    UPPERCASE: 193,
    USING: 194,
    WEIGHT: 195,
    WILDCARDS: 196,
    WITHOUT: 197,
    WORD: 198,
    WORDS: 199,
    BREAK: 200,
    CONTINUE: 201,
    EXIT: 202,
    LOOP: 203,
    RETURNING: 204,
    WHILE: 205,
    CHECK: 206,
    COLLECTION: 207,
    CONSTRAINT: 208,
    FOREACH: 209,
    FOREIGN: 210,
    INDEX: 211,
    INTEGRITY: 212,
    KEY: 213,
    ON: 214,
    UNIQUE: 215,
    BINARY: 216,
    AMP_ER: 217,
    APOS_ER: 218,
    QUOT_ER: 219,
    CONCAT: 220,
    LPAREN: 221,
    RPAREN: 222,
    DOLLAR: 223,
    LBRACKET: 224,
    RBRACKET: 225,
    LSQUARE: 226,
    RSQUARE: 227,
    EQUAL: 228,
    BIND: 229,
    NOTEQUAL: 230,
    ANN_PERCENT: 231,
    HASH: 232,
    AMP: 233,
    COMMA: 234,
    QUESTION: 235,
    STAR: 236,
    PLUS: 237,
    MINUS: 238,
    SMALLER: 239,
    GREATER: 240,
    SMALLEREQ: 241,
    GREATEREQ: 242,
    SMALLER_SMALLER: 243,
    GREATER_GREATER: 244,
    SLASH: 245,
    SLASH_SLASH: 246,
    DOT: 247,
    DOT_DOT: 248,
    COLON: 249,
    COLON_COLON: 250,
    EMPTY_CLOSE_TAG: 251,
    CLOSE_TAG: 252,
    SEMICOLON: 253,
    VBAR: 254,
    PRAGMA_START: 255,
    PRAGMA_END: 256,
    XML_COMMENT_START: 257,
    XML_COMMENT_END: 258,
    PI_START: 259,
    PI_END: 260,
    ATTR_SIGN: 261,
    CHARREF_DEC: 262,
    CHARREF_HEX: 263,
    APOS: 264,
    QUOT: 265,
    NCNameStartChar: 266,
    NCNameChar: 267,
    L_NCName: 268,
    Letter: 269,
    HexLetter: 270,
    Digit: 271,
    Digits: 272,
    S: 273,
    SU: 274,
    L_Pragma: 275,
    L_DirCommentConstructor: 276,
    L_DirPIConstructor: 277,
    L_IntegerLiteral: 278,
    L_DecimalLiteral: 279,
    L_DoubleLiteral: 280,
    L_Comment: 281,
    L_AnyChar: 282
});

(function(){
var HIDDEN = org.antlr.runtime.Token.HIDDEN_CHANNEL,
    EOF = org.antlr.runtime.Token.EOF;
org.antlr.lang.extend(XQueryLexer, XQDTLexer, {
    EOF : -1,
    L_QuotAttrContentChar : 4,
    L_AposAttrContentChar : 5,
    L_ElementContentChar : 6,
    L_CDataSection : 7,
    L_PredefinedEntityRef : 8,
    L_CharRef : 9,
    ESCAPE_LBRACKET : 10,
    ESCAPE_RBRACKET : 11,
    ESCAPE_APOS : 12,
    ESCAPE_QUOT : 13,
    CDATA_START : 14,
    CDATA_END : 15,
    ANCESTOR : 16,
    ANCESTOR_OR_SELF : 17,
    AND : 18,
    AS : 19,
    ASCENDING : 20,
    AT : 21,
    ATTRIBUTE : 22,
    BASE_URI : 23,
    BOUNDARY_SPACE : 24,
    BY : 25,
    CASE : 26,
    CAST : 27,
    CASTABLE : 28,
    CHILD : 29,
    COLLATION : 30,
    COMMENT : 31,
    CONSTRUCTION : 32,
    COPY_NAMESPACES : 33,
    DECLARE : 34,
    DEFAULT : 35,
    DESCENDANT : 36,
    DESCENDANT_OR_SELF : 37,
    DESCENDING : 38,
    DIV : 39,
    DOCUMENT : 40,
    DOCUMENT_NODE : 41,
    ELEMENT : 42,
    ELSE : 43,
    EMPTY : 44,
    EMPTY_SEQUENCE : 45,
    ENCODING : 46,
    EQ : 47,
    EVERY : 48,
    EXCEPT : 49,
    EXTERNAL : 50,
    FOLLOWING : 51,
    FOLLOWING_SIBLING : 52,
    FOR : 53,
    FUNCTION : 54,
    GE : 55,
    GREATEST : 56,
    GT : 57,
    IDIV : 58,
    IF : 59,
    IMPORT : 60,
    IN : 61,
    INHERIT : 62,
    INSTANCE : 63,
    INTERSECT : 64,
    IS : 65,
    ITEM : 66,
    LAX : 67,
    LE : 68,
    LEAST : 69,
    LET : 70,
    LT : 71,
    MOD : 72,
    MODULE : 73,
    NAMESPACE : 74,
    NE : 75,
    NO_INHERIT : 76,
    NO_PRESERVE : 77,
    NODE : 78,
    OF : 79,
    OPTION : 80,
    OR : 81,
    ORDER : 82,
    ORDERED : 83,
    ORDERING : 84,
    PARENT : 85,
    PRECEDING : 86,
    PRECEDING_SIBLING : 87,
    PRESERVE : 88,
    PROCESSING_INSTRUCTION : 89,
    RETURN : 90,
    SATISFIES : 91,
    SCHEMA : 92,
    SCHEMA_ATTRIBUTE : 93,
    SCHEMA_ELEMENT : 94,
    SELF : 95,
    SOME : 96,
    STABLE : 97,
    STRICT : 98,
    STRIP : 99,
    TEXT : 100,
    THEN : 101,
    TO : 102,
    TREAT : 103,
    TYPESWITCH : 104,
    UNION : 105,
    UNORDERED : 106,
    VALIDATE : 107,
    VARIABLE : 108,
    VERSION : 109,
    WHERE : 110,
    XQUERY : 111,
    ALLOWING : 112,
    CATCH : 113,
    CONTEXT : 114,
    COUNT : 115,
    DECIMAL_FORMAT : 116,
    DECIMAL_SEPARATOR : 117,
    DIGIT : 118,
    END : 119,
    GROUP : 120,
    GROUPING_SEPARATOR : 121,
    INFINITY : 122,
    MINUS_SIGN : 123,
    NAMESPACE_NODE : 124,
    NAN : 125,
    NEXT : 126,
    ONLY : 127,
    PATTERN_SEPARATOR : 128,
    PERCENT : 129,
    PER_MILLE : 130,
    PREVIOUS : 131,
    SLIDING : 132,
    START : 133,
    SWITCH : 134,
    TRY : 135,
    TUMBLING : 136,
    TYPE : 137,
    WHEN : 138,
    WINDOW : 139,
    ZERO_DIGIT : 140,
    AFTER : 141,
    BEFORE : 142,
    COPY : 143,
    DELETE : 144,
    FIRST : 145,
    INSERT : 146,
    INTO : 147,
    LAST : 148,
    MODIFY : 149,
    NODES : 150,
    RENAME : 151,
    REPLACE : 152,
    REVALIDATION : 153,
    SKIP : 154,
    UPDATING : 155,
    VALUE : 156,
    WITH : 157,
    ALL : 158,
    ANY : 159,
    CONTAINS : 160,
    CONTENT : 161,
    DIACRITICS : 162,
    DIFFERENT : 163,
    DISTANCE : 164,
    ENTIRE : 165,
    EXACTLY : 166,
    FROM : 167,
    FT_OPTION : 168,
    FTAND : 169,
    FTNOT : 170,
    FTOR : 171,
    INSENSITIVE : 172,
    LANGUAGE : 173,
    LEVELS : 174,
    LOWERCASE : 175,
    MOST : 176,
    NO : 177,
    NOT : 178,
    OCCURS : 179,
    PARAGRAPH : 180,
    PARAGRAPHS : 181,
    PHRASE : 182,
    RELATIONSHIP : 183,
    SAME : 184,
    SCORE : 185,
    SENSITIVE : 186,
    SENTENCE : 187,
    SENTENCES : 188,
    STEMMING : 189,
    STOP : 190,
    THESAURUS : 191,
    TIMES : 192,
    UPPERCASE : 193,
    USING : 194,
    WEIGHT : 195,
    WILDCARDS : 196,
    WITHOUT : 197,
    WORD : 198,
    WORDS : 199,
    BREAK : 200,
    CONTINUE : 201,
    EXIT : 202,
    LOOP : 203,
    RETURNING : 204,
    WHILE : 205,
    CHECK : 206,
    COLLECTION : 207,
    CONSTRAINT : 208,
    FOREACH : 209,
    FOREIGN : 210,
    INDEX : 211,
    INTEGRITY : 212,
    KEY : 213,
    ON : 214,
    UNIQUE : 215,
    BINARY : 216,
    AMP_ER : 217,
    APOS_ER : 218,
    QUOT_ER : 219,
    CONCAT : 220,
    LPAREN : 221,
    RPAREN : 222,
    DOLLAR : 223,
    LBRACKET : 224,
    RBRACKET : 225,
    LSQUARE : 226,
    RSQUARE : 227,
    EQUAL : 228,
    BIND : 229,
    NOTEQUAL : 230,
    ANN_PERCENT : 231,
    HASH : 232,
    AMP : 233,
    COMMA : 234,
    QUESTION : 235,
    STAR : 236,
    PLUS : 237,
    MINUS : 238,
    SMALLER : 239,
    GREATER : 240,
    SMALLEREQ : 241,
    GREATEREQ : 242,
    SMALLER_SMALLER : 243,
    GREATER_GREATER : 244,
    SLASH : 245,
    SLASH_SLASH : 246,
    DOT : 247,
    DOT_DOT : 248,
    COLON : 249,
    COLON_COLON : 250,
    EMPTY_CLOSE_TAG : 251,
    CLOSE_TAG : 252,
    SEMICOLON : 253,
    VBAR : 254,
    PRAGMA_START : 255,
    PRAGMA_END : 256,
    XML_COMMENT_START : 257,
    XML_COMMENT_END : 258,
    PI_START : 259,
    PI_END : 260,
    ATTR_SIGN : 261,
    CHARREF_DEC : 262,
    CHARREF_HEX : 263,
    APOS : 264,
    QUOT : 265,
    NCNameStartChar : 266,
    NCNameChar : 267,
    L_NCName : 268,
    Letter : 269,
    HexLetter : 270,
    Digit : 271,
    Digits : 272,
    S : 273,
    SU : 274,
    L_Pragma : 275,
    L_DirCommentConstructor : 276,
    L_DirPIConstructor : 277,
    L_IntegerLiteral : 278,
    L_DecimalLiteral : 279,
    L_DoubleLiteral : 280,
    L_Comment : 281,
    L_AnyChar : 282,
    getGrammarFileName: function() { return "xquery/XQueryLexer.g"; }
});
org.antlr.lang.augmentObject(XQueryLexer.prototype, {
    // $ANTLR start ANCESTOR
    mANCESTOR: function()  {
        try {
            var _type = this.ANCESTOR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:85:29: ( 'ancestor' )
            // xquery/XQueryLexer.g:85:31: 'ancestor'
            this.match("ancestor"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ANCESTOR",

    // $ANTLR start ANCESTOR_OR_SELF
    mANCESTOR_OR_SELF: function()  {
        try {
            var _type = this.ANCESTOR_OR_SELF;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:86:29: ( 'ancestor-or-self' )
            // xquery/XQueryLexer.g:86:31: 'ancestor-or-self'
            this.match("ancestor-or-self"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ANCESTOR_OR_SELF",

    // $ANTLR start AND
    mAND: function()  {
        try {
            var _type = this.AND;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:87:29: ( 'and' )
            // xquery/XQueryLexer.g:87:31: 'and'
            this.match("and"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "AND",

    // $ANTLR start AS
    mAS: function()  {
        try {
            var _type = this.AS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:88:29: ( 'as' )
            // xquery/XQueryLexer.g:88:31: 'as'
            this.match("as"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "AS",

    // $ANTLR start ASCENDING
    mASCENDING: function()  {
        try {
            var _type = this.ASCENDING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:89:29: ( 'ascending' )
            // xquery/XQueryLexer.g:89:31: 'ascending'
            this.match("ascending"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ASCENDING",

    // $ANTLR start AT
    mAT: function()  {
        try {
            var _type = this.AT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:90:29: ( 'at' )
            // xquery/XQueryLexer.g:90:31: 'at'
            this.match("at"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "AT",

    // $ANTLR start ATTRIBUTE
    mATTRIBUTE: function()  {
        try {
            var _type = this.ATTRIBUTE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:91:29: ( 'attribute' )
            // xquery/XQueryLexer.g:91:31: 'attribute'
            this.match("attribute"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ATTRIBUTE",

    // $ANTLR start BASE_URI
    mBASE_URI: function()  {
        try {
            var _type = this.BASE_URI;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:92:29: ( 'base-uri' )
            // xquery/XQueryLexer.g:92:31: 'base-uri'
            this.match("base-uri"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BASE_URI",

    // $ANTLR start BOUNDARY_SPACE
    mBOUNDARY_SPACE: function()  {
        try {
            var _type = this.BOUNDARY_SPACE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:93:29: ( 'boundary-space' )
            // xquery/XQueryLexer.g:93:31: 'boundary-space'
            this.match("boundary-space"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BOUNDARY_SPACE",

    // $ANTLR start BY
    mBY: function()  {
        try {
            var _type = this.BY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:94:29: ( 'by' )
            // xquery/XQueryLexer.g:94:31: 'by'
            this.match("by"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BY",

    // $ANTLR start CASE
    mCASE: function()  {
        try {
            var _type = this.CASE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:95:29: ( 'case' )
            // xquery/XQueryLexer.g:95:31: 'case'
            this.match("case"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CASE",

    // $ANTLR start CAST
    mCAST: function()  {
        try {
            var _type = this.CAST;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:96:29: ( 'cast' )
            // xquery/XQueryLexer.g:96:31: 'cast'
            this.match("cast"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CAST",

    // $ANTLR start CASTABLE
    mCASTABLE: function()  {
        try {
            var _type = this.CASTABLE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:97:29: ( 'castable' )
            // xquery/XQueryLexer.g:97:31: 'castable'
            this.match("castable"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CASTABLE",

    // $ANTLR start CHILD
    mCHILD: function()  {
        try {
            var _type = this.CHILD;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:98:29: ( 'child' )
            // xquery/XQueryLexer.g:98:31: 'child'
            this.match("child"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CHILD",

    // $ANTLR start COLLATION
    mCOLLATION: function()  {
        try {
            var _type = this.COLLATION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:99:29: ( 'collation' )
            // xquery/XQueryLexer.g:99:31: 'collation'
            this.match("collation"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COLLATION",

    // $ANTLR start COMMENT
    mCOMMENT: function()  {
        try {
            var _type = this.COMMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:100:29: ( 'comment' )
            // xquery/XQueryLexer.g:100:31: 'comment'
            this.match("comment"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COMMENT",

    // $ANTLR start CONSTRUCTION
    mCONSTRUCTION: function()  {
        try {
            var _type = this.CONSTRUCTION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:101:29: ( 'construction' )
            // xquery/XQueryLexer.g:101:31: 'construction'
            this.match("construction"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CONSTRUCTION",

    // $ANTLR start COPY_NAMESPACES
    mCOPY_NAMESPACES: function()  {
        try {
            var _type = this.COPY_NAMESPACES;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:102:29: ( 'copy-namespaces' )
            // xquery/XQueryLexer.g:102:31: 'copy-namespaces'
            this.match("copy-namespaces"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COPY_NAMESPACES",

    // $ANTLR start DECLARE
    mDECLARE: function()  {
        try {
            var _type = this.DECLARE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:103:29: ( 'declare' )
            // xquery/XQueryLexer.g:103:31: 'declare'
            this.match("declare"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DECLARE",

    // $ANTLR start DEFAULT
    mDEFAULT: function()  {
        try {
            var _type = this.DEFAULT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:104:29: ( 'default' )
            // xquery/XQueryLexer.g:104:31: 'default'
            this.match("default"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DEFAULT",

    // $ANTLR start DESCENDANT
    mDESCENDANT: function()  {
        try {
            var _type = this.DESCENDANT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:105:29: ( 'descendant' )
            // xquery/XQueryLexer.g:105:31: 'descendant'
            this.match("descendant"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DESCENDANT",

    // $ANTLR start DESCENDANT_OR_SELF
    mDESCENDANT_OR_SELF: function()  {
        try {
            var _type = this.DESCENDANT_OR_SELF;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:106:29: ( 'descendant-or-self' )
            // xquery/XQueryLexer.g:106:31: 'descendant-or-self'
            this.match("descendant-or-self"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DESCENDANT_OR_SELF",

    // $ANTLR start DESCENDING
    mDESCENDING: function()  {
        try {
            var _type = this.DESCENDING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:107:29: ( 'descending' )
            // xquery/XQueryLexer.g:107:31: 'descending'
            this.match("descending"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DESCENDING",

    // $ANTLR start DIV
    mDIV: function()  {
        try {
            var _type = this.DIV;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:108:29: ( 'div' )
            // xquery/XQueryLexer.g:108:31: 'div'
            this.match("div"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DIV",

    // $ANTLR start DOCUMENT
    mDOCUMENT: function()  {
        try {
            var _type = this.DOCUMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:109:29: ( 'document' )
            // xquery/XQueryLexer.g:109:31: 'document'
            this.match("document"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DOCUMENT",

    // $ANTLR start DOCUMENT_NODE
    mDOCUMENT_NODE: function()  {
        try {
            var _type = this.DOCUMENT_NODE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:110:29: ( 'document-node' )
            // xquery/XQueryLexer.g:110:31: 'document-node'
            this.match("document-node"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DOCUMENT_NODE",

    // $ANTLR start ELEMENT
    mELEMENT: function()  {
        try {
            var _type = this.ELEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:111:29: ( 'element' )
            // xquery/XQueryLexer.g:111:31: 'element'
            this.match("element"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ELEMENT",

    // $ANTLR start ELSE
    mELSE: function()  {
        try {
            var _type = this.ELSE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:112:29: ( 'else' )
            // xquery/XQueryLexer.g:112:31: 'else'
            this.match("else"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ELSE",

    // $ANTLR start EMPTY
    mEMPTY: function()  {
        try {
            var _type = this.EMPTY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:113:29: ( 'empty' )
            // xquery/XQueryLexer.g:113:31: 'empty'
            this.match("empty"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EMPTY",

    // $ANTLR start EMPTY_SEQUENCE
    mEMPTY_SEQUENCE: function()  {
        try {
            var _type = this.EMPTY_SEQUENCE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:114:29: ( 'empty-sequence' )
            // xquery/XQueryLexer.g:114:31: 'empty-sequence'
            this.match("empty-sequence"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EMPTY_SEQUENCE",

    // $ANTLR start ENCODING
    mENCODING: function()  {
        try {
            var _type = this.ENCODING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:115:29: ( 'encoding' )
            // xquery/XQueryLexer.g:115:31: 'encoding'
            this.match("encoding"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ENCODING",

    // $ANTLR start EQ
    mEQ: function()  {
        try {
            var _type = this.EQ;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:116:29: ( 'eq' )
            // xquery/XQueryLexer.g:116:31: 'eq'
            this.match("eq"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EQ",

    // $ANTLR start EVERY
    mEVERY: function()  {
        try {
            var _type = this.EVERY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:117:29: ( 'every' )
            // xquery/XQueryLexer.g:117:31: 'every'
            this.match("every"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EVERY",

    // $ANTLR start EXCEPT
    mEXCEPT: function()  {
        try {
            var _type = this.EXCEPT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:118:29: ( 'except' )
            // xquery/XQueryLexer.g:118:31: 'except'
            this.match("except"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EXCEPT",

    // $ANTLR start EXTERNAL
    mEXTERNAL: function()  {
        try {
            var _type = this.EXTERNAL;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:119:29: ( 'external' )
            // xquery/XQueryLexer.g:119:31: 'external'
            this.match("external"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EXTERNAL",

    // $ANTLR start FOLLOWING
    mFOLLOWING: function()  {
        try {
            var _type = this.FOLLOWING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:120:29: ( 'following' )
            // xquery/XQueryLexer.g:120:31: 'following'
            this.match("following"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FOLLOWING",

    // $ANTLR start FOLLOWING_SIBLING
    mFOLLOWING_SIBLING: function()  {
        try {
            var _type = this.FOLLOWING_SIBLING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:121:29: ( 'following-sibling' )
            // xquery/XQueryLexer.g:121:31: 'following-sibling'
            this.match("following-sibling"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FOLLOWING_SIBLING",

    // $ANTLR start FOR
    mFOR: function()  {
        try {
            var _type = this.FOR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:122:29: ( 'for' )
            // xquery/XQueryLexer.g:122:31: 'for'
            this.match("for"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FOR",

    // $ANTLR start FUNCTION
    mFUNCTION: function()  {
        try {
            var _type = this.FUNCTION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:123:29: ( 'function' )
            // xquery/XQueryLexer.g:123:31: 'function'
            this.match("function"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FUNCTION",

    // $ANTLR start GE
    mGE: function()  {
        try {
            var _type = this.GE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:124:29: ( 'ge' )
            // xquery/XQueryLexer.g:124:31: 'ge'
            this.match("ge"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GE",

    // $ANTLR start GREATEST
    mGREATEST: function()  {
        try {
            var _type = this.GREATEST;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:125:29: ( 'greatest' )
            // xquery/XQueryLexer.g:125:31: 'greatest'
            this.match("greatest"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GREATEST",

    // $ANTLR start GT
    mGT: function()  {
        try {
            var _type = this.GT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:126:29: ( 'gt' )
            // xquery/XQueryLexer.g:126:31: 'gt'
            this.match("gt"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GT",

    // $ANTLR start IDIV
    mIDIV: function()  {
        try {
            var _type = this.IDIV;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:127:29: ( 'idiv' )
            // xquery/XQueryLexer.g:127:31: 'idiv'
            this.match("idiv"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "IDIV",

    // $ANTLR start IF
    mIF: function()  {
        try {
            var _type = this.IF;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:128:29: ( 'if' )
            // xquery/XQueryLexer.g:128:31: 'if'
            this.match("if"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "IF",

    // $ANTLR start IMPORT
    mIMPORT: function()  {
        try {
            var _type = this.IMPORT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:129:29: ( 'import' )
            // xquery/XQueryLexer.g:129:31: 'import'
            this.match("import"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "IMPORT",

    // $ANTLR start IN
    mIN: function()  {
        try {
            var _type = this.IN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:130:29: ( 'in' )
            // xquery/XQueryLexer.g:130:31: 'in'
            this.match("in"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "IN",

    // $ANTLR start INHERIT
    mINHERIT: function()  {
        try {
            var _type = this.INHERIT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:131:29: ( 'inherit' )
            // xquery/XQueryLexer.g:131:31: 'inherit'
            this.match("inherit"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INHERIT",

    // $ANTLR start INSTANCE
    mINSTANCE: function()  {
        try {
            var _type = this.INSTANCE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:132:29: ( 'instance' )
            // xquery/XQueryLexer.g:132:31: 'instance'
            this.match("instance"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INSTANCE",

    // $ANTLR start INTERSECT
    mINTERSECT: function()  {
        try {
            var _type = this.INTERSECT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:133:29: ( 'intersect' )
            // xquery/XQueryLexer.g:133:31: 'intersect'
            this.match("intersect"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INTERSECT",

    // $ANTLR start IS
    mIS: function()  {
        try {
            var _type = this.IS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:134:29: ( 'is' )
            // xquery/XQueryLexer.g:134:31: 'is'
            this.match("is"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "IS",

    // $ANTLR start ITEM
    mITEM: function()  {
        try {
            var _type = this.ITEM;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:135:29: ( 'item' )
            // xquery/XQueryLexer.g:135:31: 'item'
            this.match("item"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ITEM",

    // $ANTLR start LAX
    mLAX: function()  {
        try {
            var _type = this.LAX;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:136:29: ( 'lax' )
            // xquery/XQueryLexer.g:136:31: 'lax'
            this.match("lax"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LAX",

    // $ANTLR start LE
    mLE: function()  {
        try {
            var _type = this.LE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:137:29: ( 'le' )
            // xquery/XQueryLexer.g:137:31: 'le'
            this.match("le"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LE",

    // $ANTLR start LEAST
    mLEAST: function()  {
        try {
            var _type = this.LEAST;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:138:29: ( 'least' )
            // xquery/XQueryLexer.g:138:31: 'least'
            this.match("least"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LEAST",

    // $ANTLR start LET
    mLET: function()  {
        try {
            var _type = this.LET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:139:29: ( 'let' )
            // xquery/XQueryLexer.g:139:31: 'let'
            this.match("let"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LET",

    // $ANTLR start LT
    mLT: function()  {
        try {
            var _type = this.LT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:140:29: ( 'lt' )
            // xquery/XQueryLexer.g:140:31: 'lt'
            this.match("lt"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LT",

    // $ANTLR start MOD
    mMOD: function()  {
        try {
            var _type = this.MOD;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:141:29: ( 'mod' )
            // xquery/XQueryLexer.g:141:31: 'mod'
            this.match("mod"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MOD",

    // $ANTLR start MODULE
    mMODULE: function()  {
        try {
            var _type = this.MODULE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:142:29: ( 'module' )
            // xquery/XQueryLexer.g:142:31: 'module'
            this.match("module"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MODULE",

    // $ANTLR start NAMESPACE
    mNAMESPACE: function()  {
        try {
            var _type = this.NAMESPACE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:143:29: ( 'namespace' )
            // xquery/XQueryLexer.g:143:31: 'namespace'
            this.match("namespace"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NAMESPACE",

    // $ANTLR start NE
    mNE: function()  {
        try {
            var _type = this.NE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:144:29: ( 'ne' )
            // xquery/XQueryLexer.g:144:31: 'ne'
            this.match("ne"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NE",

    // $ANTLR start NO_INHERIT
    mNO_INHERIT: function()  {
        try {
            var _type = this.NO_INHERIT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:145:29: ( 'no-inherit' )
            // xquery/XQueryLexer.g:145:31: 'no-inherit'
            this.match("no-inherit"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NO_INHERIT",

    // $ANTLR start NO_PRESERVE
    mNO_PRESERVE: function()  {
        try {
            var _type = this.NO_PRESERVE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:146:29: ( 'no-preserve' )
            // xquery/XQueryLexer.g:146:31: 'no-preserve'
            this.match("no-preserve"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NO_PRESERVE",

    // $ANTLR start NODE
    mNODE: function()  {
        try {
            var _type = this.NODE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:147:29: ( 'node' )
            // xquery/XQueryLexer.g:147:31: 'node'
            this.match("node"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NODE",

    // $ANTLR start OF
    mOF: function()  {
        try {
            var _type = this.OF;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:148:29: ( 'of' )
            // xquery/XQueryLexer.g:148:31: 'of'
            this.match("of"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "OF",

    // $ANTLR start OPTION
    mOPTION: function()  {
        try {
            var _type = this.OPTION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:149:29: ( 'option' )
            // xquery/XQueryLexer.g:149:31: 'option'
            this.match("option"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "OPTION",

    // $ANTLR start OR
    mOR: function()  {
        try {
            var _type = this.OR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:150:29: ( 'or' )
            // xquery/XQueryLexer.g:150:31: 'or'
            this.match("or"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "OR",

    // $ANTLR start ORDER
    mORDER: function()  {
        try {
            var _type = this.ORDER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:151:29: ( 'order' )
            // xquery/XQueryLexer.g:151:31: 'order'
            this.match("order"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ORDER",

    // $ANTLR start ORDERED
    mORDERED: function()  {
        try {
            var _type = this.ORDERED;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:152:29: ( 'ordered' )
            // xquery/XQueryLexer.g:152:31: 'ordered'
            this.match("ordered"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ORDERED",

    // $ANTLR start ORDERING
    mORDERING: function()  {
        try {
            var _type = this.ORDERING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:153:29: ( 'ordering' )
            // xquery/XQueryLexer.g:153:31: 'ordering'
            this.match("ordering"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ORDERING",

    // $ANTLR start PARENT
    mPARENT: function()  {
        try {
            var _type = this.PARENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:154:29: ( 'parent' )
            // xquery/XQueryLexer.g:154:31: 'parent'
            this.match("parent"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PARENT",

    // $ANTLR start PRECEDING
    mPRECEDING: function()  {
        try {
            var _type = this.PRECEDING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:155:29: ( 'preceding' )
            // xquery/XQueryLexer.g:155:31: 'preceding'
            this.match("preceding"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PRECEDING",

    // $ANTLR start PRECEDING_SIBLING
    mPRECEDING_SIBLING: function()  {
        try {
            var _type = this.PRECEDING_SIBLING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:156:29: ( 'preceding-sibling' )
            // xquery/XQueryLexer.g:156:31: 'preceding-sibling'
            this.match("preceding-sibling"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PRECEDING_SIBLING",

    // $ANTLR start PRESERVE
    mPRESERVE: function()  {
        try {
            var _type = this.PRESERVE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:157:29: ( 'preserve' )
            // xquery/XQueryLexer.g:157:31: 'preserve'
            this.match("preserve"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PRESERVE",

    // $ANTLR start PROCESSING_INSTRUCTION
    mPROCESSING_INSTRUCTION: function()  {
        try {
            var _type = this.PROCESSING_INSTRUCTION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:158:29: ( 'processing-instruction' )
            // xquery/XQueryLexer.g:158:31: 'processing-instruction'
            this.match("processing-instruction"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PROCESSING_INSTRUCTION",

    // $ANTLR start RETURN
    mRETURN: function()  {
        try {
            var _type = this.RETURN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:159:29: ( 'return' )
            // xquery/XQueryLexer.g:159:31: 'return'
            this.match("return"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RETURN",

    // $ANTLR start SATISFIES
    mSATISFIES: function()  {
        try {
            var _type = this.SATISFIES;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:160:29: ( 'satisfies' )
            // xquery/XQueryLexer.g:160:31: 'satisfies'
            this.match("satisfies"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SATISFIES",

    // $ANTLR start SCHEMA
    mSCHEMA: function()  {
        try {
            var _type = this.SCHEMA;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:161:29: ( 'schema' )
            // xquery/XQueryLexer.g:161:31: 'schema'
            this.match("schema"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SCHEMA",

    // $ANTLR start SCHEMA_ATTRIBUTE
    mSCHEMA_ATTRIBUTE: function()  {
        try {
            var _type = this.SCHEMA_ATTRIBUTE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:162:29: ( 'schema-attribute' )
            // xquery/XQueryLexer.g:162:31: 'schema-attribute'
            this.match("schema-attribute"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SCHEMA_ATTRIBUTE",

    // $ANTLR start SCHEMA_ELEMENT
    mSCHEMA_ELEMENT: function()  {
        try {
            var _type = this.SCHEMA_ELEMENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:163:29: ( 'schema-element' )
            // xquery/XQueryLexer.g:163:31: 'schema-element'
            this.match("schema-element"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SCHEMA_ELEMENT",

    // $ANTLR start SELF
    mSELF: function()  {
        try {
            var _type = this.SELF;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:164:29: ( 'self' )
            // xquery/XQueryLexer.g:164:31: 'self'
            this.match("self"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SELF",

    // $ANTLR start SOME
    mSOME: function()  {
        try {
            var _type = this.SOME;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:165:29: ( 'some' )
            // xquery/XQueryLexer.g:165:31: 'some'
            this.match("some"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SOME",

    // $ANTLR start STABLE
    mSTABLE: function()  {
        try {
            var _type = this.STABLE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:166:29: ( 'stable' )
            // xquery/XQueryLexer.g:166:31: 'stable'
            this.match("stable"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "STABLE",

    // $ANTLR start STRICT
    mSTRICT: function()  {
        try {
            var _type = this.STRICT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:167:29: ( 'strict' )
            // xquery/XQueryLexer.g:167:31: 'strict'
            this.match("strict"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "STRICT",

    // $ANTLR start STRIP
    mSTRIP: function()  {
        try {
            var _type = this.STRIP;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:168:29: ( 'strip' )
            // xquery/XQueryLexer.g:168:31: 'strip'
            this.match("strip"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "STRIP",

    // $ANTLR start TEXT
    mTEXT: function()  {
        try {
            var _type = this.TEXT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:169:29: ( 'text' )
            // xquery/XQueryLexer.g:169:31: 'text'
            this.match("text"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TEXT",

    // $ANTLR start THEN
    mTHEN: function()  {
        try {
            var _type = this.THEN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:170:29: ( 'then' )
            // xquery/XQueryLexer.g:170:31: 'then'
            this.match("then"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "THEN",

    // $ANTLR start TO
    mTO: function()  {
        try {
            var _type = this.TO;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:171:29: ( 'to' )
            // xquery/XQueryLexer.g:171:31: 'to'
            this.match("to"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TO",

    // $ANTLR start TREAT
    mTREAT: function()  {
        try {
            var _type = this.TREAT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:172:29: ( 'treat' )
            // xquery/XQueryLexer.g:172:31: 'treat'
            this.match("treat"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TREAT",

    // $ANTLR start TYPESWITCH
    mTYPESWITCH: function()  {
        try {
            var _type = this.TYPESWITCH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:173:29: ( 'typeswitch' )
            // xquery/XQueryLexer.g:173:31: 'typeswitch'
            this.match("typeswitch"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TYPESWITCH",

    // $ANTLR start UNION
    mUNION: function()  {
        try {
            var _type = this.UNION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:174:29: ( 'union' )
            // xquery/XQueryLexer.g:174:31: 'union'
            this.match("union"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "UNION",

    // $ANTLR start UNORDERED
    mUNORDERED: function()  {
        try {
            var _type = this.UNORDERED;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:175:29: ( 'unordered' )
            // xquery/XQueryLexer.g:175:31: 'unordered'
            this.match("unordered"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "UNORDERED",

    // $ANTLR start VALIDATE
    mVALIDATE: function()  {
        try {
            var _type = this.VALIDATE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:176:29: ( 'validate' )
            // xquery/XQueryLexer.g:176:31: 'validate'
            this.match("validate"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "VALIDATE",

    // $ANTLR start VARIABLE
    mVARIABLE: function()  {
        try {
            var _type = this.VARIABLE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:177:29: ( 'variable' )
            // xquery/XQueryLexer.g:177:31: 'variable'
            this.match("variable"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "VARIABLE",

    // $ANTLR start VERSION
    mVERSION: function()  {
        try {
            var _type = this.VERSION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:178:29: ( 'version' )
            // xquery/XQueryLexer.g:178:31: 'version'
            this.match("version"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "VERSION",

    // $ANTLR start WHERE
    mWHERE: function()  {
        try {
            var _type = this.WHERE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:179:29: ( 'where' )
            // xquery/XQueryLexer.g:179:31: 'where'
            this.match("where"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WHERE",

    // $ANTLR start XQUERY
    mXQUERY: function()  {
        try {
            var _type = this.XQUERY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:180:29: ( 'xquery' )
            // xquery/XQueryLexer.g:180:31: 'xquery'
            this.match("xquery"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "XQUERY",

    // $ANTLR start ALLOWING
    mALLOWING: function()  {
        try {
            var _type = this.ALLOWING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:182:29: ( 'allowing' )
            // xquery/XQueryLexer.g:182:31: 'allowing'
            this.match("allowing"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ALLOWING",

    // $ANTLR start CATCH
    mCATCH: function()  {
        try {
            var _type = this.CATCH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:183:29: ( 'catch' )
            // xquery/XQueryLexer.g:183:31: 'catch'
            this.match("catch"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CATCH",

    // $ANTLR start CONTEXT
    mCONTEXT: function()  {
        try {
            var _type = this.CONTEXT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:184:29: ( 'context' )
            // xquery/XQueryLexer.g:184:31: 'context'
            this.match("context"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CONTEXT",

    // $ANTLR start COUNT
    mCOUNT: function()  {
        try {
            var _type = this.COUNT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:185:29: ( 'count' )
            // xquery/XQueryLexer.g:185:31: 'count'
            this.match("count"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COUNT",

    // $ANTLR start DECIMAL_FORMAT
    mDECIMAL_FORMAT: function()  {
        try {
            var _type = this.DECIMAL_FORMAT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:186:29: ( 'decimal-format' )
            // xquery/XQueryLexer.g:186:31: 'decimal-format'
            this.match("decimal-format"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DECIMAL_FORMAT",

    // $ANTLR start DECIMAL_SEPARATOR
    mDECIMAL_SEPARATOR: function()  {
        try {
            var _type = this.DECIMAL_SEPARATOR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:187:29: ( 'decimal-separator' )
            // xquery/XQueryLexer.g:187:31: 'decimal-separator'
            this.match("decimal-separator"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DECIMAL_SEPARATOR",

    // $ANTLR start DIGIT
    mDIGIT: function()  {
        try {
            var _type = this.DIGIT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:188:29: ( 'digit' )
            // xquery/XQueryLexer.g:188:31: 'digit'
            this.match("digit"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DIGIT",

    // $ANTLR start END
    mEND: function()  {
        try {
            var _type = this.END;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:189:29: ( 'end' )
            // xquery/XQueryLexer.g:189:31: 'end'
            this.match("end"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "END",

    // $ANTLR start GROUP
    mGROUP: function()  {
        try {
            var _type = this.GROUP;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:190:29: ( 'group' )
            // xquery/XQueryLexer.g:190:31: 'group'
            this.match("group"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GROUP",

    // $ANTLR start GROUPING_SEPARATOR
    mGROUPING_SEPARATOR: function()  {
        try {
            var _type = this.GROUPING_SEPARATOR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:191:29: ( 'grouping-separator' )
            // xquery/XQueryLexer.g:191:31: 'grouping-separator'
            this.match("grouping-separator"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GROUPING_SEPARATOR",

    // $ANTLR start INFINITY
    mINFINITY: function()  {
        try {
            var _type = this.INFINITY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:192:29: ( 'infinity' )
            // xquery/XQueryLexer.g:192:31: 'infinity'
            this.match("infinity"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INFINITY",

    // $ANTLR start MINUS_SIGN
    mMINUS_SIGN: function()  {
        try {
            var _type = this.MINUS_SIGN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:193:29: ( 'minus-sign' )
            // xquery/XQueryLexer.g:193:31: 'minus-sign'
            this.match("minus-sign"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MINUS_SIGN",

    // $ANTLR start NAMESPACE_NODE
    mNAMESPACE_NODE: function()  {
        try {
            var _type = this.NAMESPACE_NODE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:194:29: ( 'namespace-node' )
            // xquery/XQueryLexer.g:194:31: 'namespace-node'
            this.match("namespace-node"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NAMESPACE_NODE",

    // $ANTLR start NAN
    mNAN: function()  {
        try {
            var _type = this.NAN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:195:29: ( 'NaN' )
            // xquery/XQueryLexer.g:195:31: 'NaN'
            this.match("NaN"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NAN",

    // $ANTLR start NEXT
    mNEXT: function()  {
        try {
            var _type = this.NEXT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:196:29: ( 'next' )
            // xquery/XQueryLexer.g:196:31: 'next'
            this.match("next"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NEXT",

    // $ANTLR start ONLY
    mONLY: function()  {
        try {
            var _type = this.ONLY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:197:29: ( 'only' )
            // xquery/XQueryLexer.g:197:31: 'only'
            this.match("only"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ONLY",

    // $ANTLR start PATTERN_SEPARATOR
    mPATTERN_SEPARATOR: function()  {
        try {
            var _type = this.PATTERN_SEPARATOR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:198:29: ( 'pattern-separator' )
            // xquery/XQueryLexer.g:198:31: 'pattern-separator'
            this.match("pattern-separator"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PATTERN_SEPARATOR",

    // $ANTLR start PERCENT
    mPERCENT: function()  {
        try {
            var _type = this.PERCENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:199:29: ( 'percent' )
            // xquery/XQueryLexer.g:199:31: 'percent'
            this.match("percent"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PERCENT",

    // $ANTLR start PER_MILLE
    mPER_MILLE: function()  {
        try {
            var _type = this.PER_MILLE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:200:29: ( 'per-mille' )
            // xquery/XQueryLexer.g:200:31: 'per-mille'
            this.match("per-mille"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PER_MILLE",

    // $ANTLR start PREVIOUS
    mPREVIOUS: function()  {
        try {
            var _type = this.PREVIOUS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:201:29: ( 'previous' )
            // xquery/XQueryLexer.g:201:31: 'previous'
            this.match("previous"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PREVIOUS",

    // $ANTLR start SLIDING
    mSLIDING: function()  {
        try {
            var _type = this.SLIDING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:202:29: ( 'sliding' )
            // xquery/XQueryLexer.g:202:31: 'sliding'
            this.match("sliding"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SLIDING",

    // $ANTLR start START
    mSTART: function()  {
        try {
            var _type = this.START;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:203:29: ( 'start' )
            // xquery/XQueryLexer.g:203:31: 'start'
            this.match("start"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "START",

    // $ANTLR start SWITCH
    mSWITCH: function()  {
        try {
            var _type = this.SWITCH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:204:29: ( 'switch' )
            // xquery/XQueryLexer.g:204:31: 'switch'
            this.match("switch"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SWITCH",

    // $ANTLR start TRY
    mTRY: function()  {
        try {
            var _type = this.TRY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:205:29: ( 'try' )
            // xquery/XQueryLexer.g:205:31: 'try'
            this.match("try"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TRY",

    // $ANTLR start TUMBLING
    mTUMBLING: function()  {
        try {
            var _type = this.TUMBLING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:206:29: ( 'tumbling' )
            // xquery/XQueryLexer.g:206:31: 'tumbling'
            this.match("tumbling"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TUMBLING",

    // $ANTLR start TYPE
    mTYPE: function()  {
        try {
            var _type = this.TYPE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:207:29: ( 'type' )
            // xquery/XQueryLexer.g:207:31: 'type'
            this.match("type"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TYPE",

    // $ANTLR start WHEN
    mWHEN: function()  {
        try {
            var _type = this.WHEN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:208:29: ( 'when' )
            // xquery/XQueryLexer.g:208:31: 'when'
            this.match("when"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WHEN",

    // $ANTLR start WINDOW
    mWINDOW: function()  {
        try {
            var _type = this.WINDOW;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:209:29: ( 'window' )
            // xquery/XQueryLexer.g:209:31: 'window'
            this.match("window"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WINDOW",

    // $ANTLR start ZERO_DIGIT
    mZERO_DIGIT: function()  {
        try {
            var _type = this.ZERO_DIGIT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:210:29: ( 'zero-digit' )
            // xquery/XQueryLexer.g:210:31: 'zero-digit'
            this.match("zero-digit"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ZERO_DIGIT",

    // $ANTLR start AFTER
    mAFTER: function()  {
        try {
            var _type = this.AFTER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:212:29: ( 'after' )
            // xquery/XQueryLexer.g:212:31: 'after'
            this.match("after"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "AFTER",

    // $ANTLR start BEFORE
    mBEFORE: function()  {
        try {
            var _type = this.BEFORE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:213:29: ( 'before' )
            // xquery/XQueryLexer.g:213:31: 'before'
            this.match("before"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BEFORE",

    // $ANTLR start COPY
    mCOPY: function()  {
        try {
            var _type = this.COPY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:214:29: ( 'copy' )
            // xquery/XQueryLexer.g:214:31: 'copy'
            this.match("copy"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COPY",

    // $ANTLR start DELETE
    mDELETE: function()  {
        try {
            var _type = this.DELETE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:215:29: ( 'delete' )
            // xquery/XQueryLexer.g:215:31: 'delete'
            this.match("delete"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DELETE",

    // $ANTLR start FIRST
    mFIRST: function()  {
        try {
            var _type = this.FIRST;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:216:29: ( 'first' )
            // xquery/XQueryLexer.g:216:31: 'first'
            this.match("first"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FIRST",

    // $ANTLR start INSERT
    mINSERT: function()  {
        try {
            var _type = this.INSERT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:217:29: ( 'insert' )
            // xquery/XQueryLexer.g:217:31: 'insert'
            this.match("insert"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INSERT",

    // $ANTLR start INTO
    mINTO: function()  {
        try {
            var _type = this.INTO;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:218:29: ( 'into' )
            // xquery/XQueryLexer.g:218:31: 'into'
            this.match("into"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INTO",

    // $ANTLR start LAST
    mLAST: function()  {
        try {
            var _type = this.LAST;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:219:29: ( 'last' )
            // xquery/XQueryLexer.g:219:31: 'last'
            this.match("last"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LAST",

    // $ANTLR start MODIFY
    mMODIFY: function()  {
        try {
            var _type = this.MODIFY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:220:29: ( 'modify' )
            // xquery/XQueryLexer.g:220:31: 'modify'
            this.match("modify"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MODIFY",

    // $ANTLR start NODES
    mNODES: function()  {
        try {
            var _type = this.NODES;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:221:29: ( 'nodes' )
            // xquery/XQueryLexer.g:221:31: 'nodes'
            this.match("nodes"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NODES",

    // $ANTLR start RENAME
    mRENAME: function()  {
        try {
            var _type = this.RENAME;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:222:29: ( 'rename' )
            // xquery/XQueryLexer.g:222:31: 'rename'
            this.match("rename"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RENAME",

    // $ANTLR start REPLACE
    mREPLACE: function()  {
        try {
            var _type = this.REPLACE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:223:29: ( 'replace' )
            // xquery/XQueryLexer.g:223:31: 'replace'
            this.match("replace"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "REPLACE",

    // $ANTLR start REVALIDATION
    mREVALIDATION: function()  {
        try {
            var _type = this.REVALIDATION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:224:29: ( 'revalidation' )
            // xquery/XQueryLexer.g:224:31: 'revalidation'
            this.match("revalidation"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "REVALIDATION",

    // $ANTLR start SKIP
    mSKIP: function()  {
        try {
            var _type = this.SKIP;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:225:29: ( 'skip' )
            // xquery/XQueryLexer.g:225:31: 'skip'
            this.match("skip"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SKIP",

    // $ANTLR start UPDATING
    mUPDATING: function()  {
        try {
            var _type = this.UPDATING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:226:29: ( 'updating' )
            // xquery/XQueryLexer.g:226:31: 'updating'
            this.match("updating"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "UPDATING",

    // $ANTLR start VALUE
    mVALUE: function()  {
        try {
            var _type = this.VALUE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:227:29: ( 'value' )
            // xquery/XQueryLexer.g:227:31: 'value'
            this.match("value"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "VALUE",

    // $ANTLR start WITH
    mWITH: function()  {
        try {
            var _type = this.WITH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:228:29: ( 'with' )
            // xquery/XQueryLexer.g:228:31: 'with'
            this.match("with"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WITH",

    // $ANTLR start ALL
    mALL: function()  {
        try {
            var _type = this.ALL;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:230:29: ( 'all' )
            // xquery/XQueryLexer.g:230:31: 'all'
            this.match("all"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ALL",

    // $ANTLR start ANY
    mANY: function()  {
        try {
            var _type = this.ANY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:231:29: ( 'any' )
            // xquery/XQueryLexer.g:231:31: 'any'
            this.match("any"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ANY",

    // $ANTLR start CONTAINS
    mCONTAINS: function()  {
        try {
            var _type = this.CONTAINS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:232:29: ( 'contains' )
            // xquery/XQueryLexer.g:232:31: 'contains'
            this.match("contains"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CONTAINS",

    // $ANTLR start CONTENT
    mCONTENT: function()  {
        try {
            var _type = this.CONTENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:233:29: ( 'content' )
            // xquery/XQueryLexer.g:233:31: 'content'
            this.match("content"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CONTENT",

    // $ANTLR start DIACRITICS
    mDIACRITICS: function()  {
        try {
            var _type = this.DIACRITICS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:234:29: ( 'diacritics' )
            // xquery/XQueryLexer.g:234:31: 'diacritics'
            this.match("diacritics"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DIACRITICS",

    // $ANTLR start DIFFERENT
    mDIFFERENT: function()  {
        try {
            var _type = this.DIFFERENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:235:29: ( 'different' )
            // xquery/XQueryLexer.g:235:31: 'different'
            this.match("different"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DIFFERENT",

    // $ANTLR start DISTANCE
    mDISTANCE: function()  {
        try {
            var _type = this.DISTANCE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:236:29: ( 'distance' )
            // xquery/XQueryLexer.g:236:31: 'distance'
            this.match("distance"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DISTANCE",

    // $ANTLR start ENTIRE
    mENTIRE: function()  {
        try {
            var _type = this.ENTIRE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:237:29: ( 'entire' )
            // xquery/XQueryLexer.g:237:31: 'entire'
            this.match("entire"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ENTIRE",

    // $ANTLR start EXACTLY
    mEXACTLY: function()  {
        try {
            var _type = this.EXACTLY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:238:29: ( 'exactly' )
            // xquery/XQueryLexer.g:238:31: 'exactly'
            this.match("exactly"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EXACTLY",

    // $ANTLR start FROM
    mFROM: function()  {
        try {
            var _type = this.FROM;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:239:29: ( 'from' )
            // xquery/XQueryLexer.g:239:31: 'from'
            this.match("from"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FROM",

    // $ANTLR start FT_OPTION
    mFT_OPTION: function()  {
        try {
            var _type = this.FT_OPTION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:240:29: ( 'ft-option' )
            // xquery/XQueryLexer.g:240:31: 'ft-option'
            this.match("ft-option"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FT_OPTION",

    // $ANTLR start FTAND
    mFTAND: function()  {
        try {
            var _type = this.FTAND;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:241:29: ( 'ftand' )
            // xquery/XQueryLexer.g:241:31: 'ftand'
            this.match("ftand"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FTAND",

    // $ANTLR start FTNOT
    mFTNOT: function()  {
        try {
            var _type = this.FTNOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:242:29: ( 'ftnot' )
            // xquery/XQueryLexer.g:242:31: 'ftnot'
            this.match("ftnot"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FTNOT",

    // $ANTLR start FTOR
    mFTOR: function()  {
        try {
            var _type = this.FTOR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:243:29: ( 'ftor' )
            // xquery/XQueryLexer.g:243:31: 'ftor'
            this.match("ftor"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FTOR",

    // $ANTLR start INSENSITIVE
    mINSENSITIVE: function()  {
        try {
            var _type = this.INSENSITIVE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:244:29: ( 'insensitive' )
            // xquery/XQueryLexer.g:244:31: 'insensitive'
            this.match("insensitive"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INSENSITIVE",

    // $ANTLR start LANGUAGE
    mLANGUAGE: function()  {
        try {
            var _type = this.LANGUAGE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:245:29: ( 'language' )
            // xquery/XQueryLexer.g:245:31: 'language'
            this.match("language"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LANGUAGE",

    // $ANTLR start LEVELS
    mLEVELS: function()  {
        try {
            var _type = this.LEVELS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:246:29: ( 'levels' )
            // xquery/XQueryLexer.g:246:31: 'levels'
            this.match("levels"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LEVELS",

    // $ANTLR start LOWERCASE
    mLOWERCASE: function()  {
        try {
            var _type = this.LOWERCASE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:247:29: ( 'lowercase' )
            // xquery/XQueryLexer.g:247:31: 'lowercase'
            this.match("lowercase"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LOWERCASE",

    // $ANTLR start MOST
    mMOST: function()  {
        try {
            var _type = this.MOST;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:248:29: ( 'most' )
            // xquery/XQueryLexer.g:248:31: 'most'
            this.match("most"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MOST",

    // $ANTLR start NO
    mNO: function()  {
        try {
            var _type = this.NO;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:249:29: ( 'no' )
            // xquery/XQueryLexer.g:249:31: 'no'
            this.match("no"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NO",

    // $ANTLR start NOT
    mNOT: function()  {
        try {
            var _type = this.NOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:250:29: ( 'not' )
            // xquery/XQueryLexer.g:250:31: 'not'
            this.match("not"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NOT",

    // $ANTLR start OCCURS
    mOCCURS: function()  {
        try {
            var _type = this.OCCURS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:251:29: ( 'occurs' )
            // xquery/XQueryLexer.g:251:31: 'occurs'
            this.match("occurs"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "OCCURS",

    // $ANTLR start PARAGRAPH
    mPARAGRAPH: function()  {
        try {
            var _type = this.PARAGRAPH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:252:29: ( 'paragraph' )
            // xquery/XQueryLexer.g:252:31: 'paragraph'
            this.match("paragraph"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PARAGRAPH",

    // $ANTLR start PARAGRAPHS
    mPARAGRAPHS: function()  {
        try {
            var _type = this.PARAGRAPHS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:253:29: ( 'paragraphs' )
            // xquery/XQueryLexer.g:253:31: 'paragraphs'
            this.match("paragraphs"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PARAGRAPHS",

    // $ANTLR start PHRASE
    mPHRASE: function()  {
        try {
            var _type = this.PHRASE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:254:29: ( 'phrase' )
            // xquery/XQueryLexer.g:254:31: 'phrase'
            this.match("phrase"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PHRASE",

    // $ANTLR start RELATIONSHIP
    mRELATIONSHIP: function()  {
        try {
            var _type = this.RELATIONSHIP;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:255:29: ( 'relationship' )
            // xquery/XQueryLexer.g:255:31: 'relationship'
            this.match("relationship"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RELATIONSHIP",

    // $ANTLR start SAME
    mSAME: function()  {
        try {
            var _type = this.SAME;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:256:29: ( 'same' )
            // xquery/XQueryLexer.g:256:31: 'same'
            this.match("same"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SAME",

    // $ANTLR start SCORE
    mSCORE: function()  {
        try {
            var _type = this.SCORE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:257:29: ( 'score' )
            // xquery/XQueryLexer.g:257:31: 'score'
            this.match("score"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SCORE",

    // $ANTLR start SENSITIVE
    mSENSITIVE: function()  {
        try {
            var _type = this.SENSITIVE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:258:29: ( 'sensitive' )
            // xquery/XQueryLexer.g:258:31: 'sensitive'
            this.match("sensitive"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SENSITIVE",

    // $ANTLR start SENTENCE
    mSENTENCE: function()  {
        try {
            var _type = this.SENTENCE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:259:29: ( 'sentence' )
            // xquery/XQueryLexer.g:259:31: 'sentence'
            this.match("sentence"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SENTENCE",

    // $ANTLR start SENTENCES
    mSENTENCES: function()  {
        try {
            var _type = this.SENTENCES;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:260:29: ( 'sentences' )
            // xquery/XQueryLexer.g:260:31: 'sentences'
            this.match("sentences"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SENTENCES",

    // $ANTLR start STEMMING
    mSTEMMING: function()  {
        try {
            var _type = this.STEMMING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:261:29: ( 'stemming' )
            // xquery/XQueryLexer.g:261:31: 'stemming'
            this.match("stemming"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "STEMMING",

    // $ANTLR start STOP
    mSTOP: function()  {
        try {
            var _type = this.STOP;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:262:29: ( 'stop' )
            // xquery/XQueryLexer.g:262:31: 'stop'
            this.match("stop"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "STOP",

    // $ANTLR start THESAURUS
    mTHESAURUS: function()  {
        try {
            var _type = this.THESAURUS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:263:29: ( 'thesaurus' )
            // xquery/XQueryLexer.g:263:31: 'thesaurus'
            this.match("thesaurus"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "THESAURUS",

    // $ANTLR start TIMES
    mTIMES: function()  {
        try {
            var _type = this.TIMES;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:264:29: ( 'times' )
            // xquery/XQueryLexer.g:264:31: 'times'
            this.match("times"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "TIMES",

    // $ANTLR start UPPERCASE
    mUPPERCASE: function()  {
        try {
            var _type = this.UPPERCASE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:265:29: ( 'uppercase' )
            // xquery/XQueryLexer.g:265:31: 'uppercase'
            this.match("uppercase"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "UPPERCASE",

    // $ANTLR start USING
    mUSING: function()  {
        try {
            var _type = this.USING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:266:29: ( 'using' )
            // xquery/XQueryLexer.g:266:31: 'using'
            this.match("using"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "USING",

    // $ANTLR start WEIGHT
    mWEIGHT: function()  {
        try {
            var _type = this.WEIGHT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:267:29: ( 'weight' )
            // xquery/XQueryLexer.g:267:31: 'weight'
            this.match("weight"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WEIGHT",

    // $ANTLR start WILDCARDS
    mWILDCARDS: function()  {
        try {
            var _type = this.WILDCARDS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:268:29: ( 'wildcards' )
            // xquery/XQueryLexer.g:268:31: 'wildcards'
            this.match("wildcards"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WILDCARDS",

    // $ANTLR start WITHOUT
    mWITHOUT: function()  {
        try {
            var _type = this.WITHOUT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:269:29: ( 'without' )
            // xquery/XQueryLexer.g:269:31: 'without'
            this.match("without"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WITHOUT",

    // $ANTLR start WORD
    mWORD: function()  {
        try {
            var _type = this.WORD;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:270:29: ( 'word' )
            // xquery/XQueryLexer.g:270:31: 'word'
            this.match("word"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WORD",

    // $ANTLR start WORDS
    mWORDS: function()  {
        try {
            var _type = this.WORDS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:271:29: ( 'words' )
            // xquery/XQueryLexer.g:271:31: 'words'
            this.match("words"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WORDS",

    // $ANTLR start BREAK
    mBREAK: function()  {
        try {
            var _type = this.BREAK;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:273:29: ( 'break' )
            // xquery/XQueryLexer.g:273:31: 'break'
            this.match("break"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BREAK",

    // $ANTLR start CONTINUE
    mCONTINUE: function()  {
        try {
            var _type = this.CONTINUE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:274:29: ( 'continue' )
            // xquery/XQueryLexer.g:274:31: 'continue'
            this.match("continue"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CONTINUE",

    // $ANTLR start EXIT
    mEXIT: function()  {
        try {
            var _type = this.EXIT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:275:29: ( 'exit' )
            // xquery/XQueryLexer.g:275:31: 'exit'
            this.match("exit"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EXIT",

    // $ANTLR start LOOP
    mLOOP: function()  {
        try {
            var _type = this.LOOP;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:276:29: ( 'loop' )
            // xquery/XQueryLexer.g:276:31: 'loop'
            this.match("loop"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LOOP",

    // $ANTLR start RETURNING
    mRETURNING: function()  {
        try {
            var _type = this.RETURNING;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:277:29: ( 'returning' )
            // xquery/XQueryLexer.g:277:31: 'returning'
            this.match("returning"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RETURNING",

    // $ANTLR start WHILE
    mWHILE: function()  {
        try {
            var _type = this.WHILE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:278:29: ( 'while' )
            // xquery/XQueryLexer.g:278:31: 'while'
            this.match("while"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "WHILE",

    // $ANTLR start CHECK
    mCHECK: function()  {
        try {
            var _type = this.CHECK;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:280:29: ( 'check' )
            // xquery/XQueryLexer.g:280:31: 'check'
            this.match("check"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CHECK",

    // $ANTLR start COLLECTION
    mCOLLECTION: function()  {
        try {
            var _type = this.COLLECTION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:281:29: ( 'collection' )
            // xquery/XQueryLexer.g:281:31: 'collection'
            this.match("collection"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COLLECTION",

    // $ANTLR start CONSTRAINT
    mCONSTRAINT: function()  {
        try {
            var _type = this.CONSTRAINT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:282:29: ( 'constraint' )
            // xquery/XQueryLexer.g:282:31: 'constraint'
            this.match("constraint"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CONSTRAINT",

    // $ANTLR start FOREACH
    mFOREACH: function()  {
        try {
            var _type = this.FOREACH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:283:29: ( 'foreach' )
            // xquery/XQueryLexer.g:283:31: 'foreach'
            this.match("foreach"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FOREACH",

    // $ANTLR start FOREIGN
    mFOREIGN: function()  {
        try {
            var _type = this.FOREIGN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:284:29: ( 'foreign' )
            // xquery/XQueryLexer.g:284:31: 'foreign'
            this.match("foreign"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "FOREIGN",

    // $ANTLR start INDEX
    mINDEX: function()  {
        try {
            var _type = this.INDEX;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:285:29: ( 'index' )
            // xquery/XQueryLexer.g:285:31: 'index'
            this.match("index"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INDEX",

    // $ANTLR start INTEGRITY
    mINTEGRITY: function()  {
        try {
            var _type = this.INTEGRITY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:286:29: ( 'integrity' )
            // xquery/XQueryLexer.g:286:31: 'integrity'
            this.match("integrity"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "INTEGRITY",

    // $ANTLR start KEY
    mKEY: function()  {
        try {
            var _type = this.KEY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:287:29: ( 'key' )
            // xquery/XQueryLexer.g:287:31: 'key'
            this.match("key"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "KEY",

    // $ANTLR start ON
    mON: function()  {
        try {
            var _type = this.ON;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:288:29: ( 'on' )
            // xquery/XQueryLexer.g:288:31: 'on'
            this.match("on"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ON",

    // $ANTLR start UNIQUE
    mUNIQUE: function()  {
        try {
            var _type = this.UNIQUE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:289:29: ( 'unique' )
            // xquery/XQueryLexer.g:289:31: 'unique'
            this.match("unique"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "UNIQUE",

    // $ANTLR start BINARY
    mBINARY: function()  {
        try {
            var _type = this.BINARY;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:291:29: ( 'binary' )
            // xquery/XQueryLexer.g:291:31: 'binary'
            this.match("binary"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BINARY",

    // $ANTLR start AMP_ER
    mAMP_ER: function()  {
        try {
            var _type = this.AMP_ER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:294:9: ( 'amp' )
            // xquery/XQueryLexer.g:294:11: 'amp'
            this.match("amp"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "AMP_ER",

    // $ANTLR start APOS_ER
    mAPOS_ER: function()  {
        try {
            var _type = this.APOS_ER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:295:9: ( 'apos' )
            // xquery/XQueryLexer.g:295:11: 'apos'
            this.match("apos"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "APOS_ER",

    // $ANTLR start QUOT_ER
    mQUOT_ER: function()  {
        try {
            var _type = this.QUOT_ER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:296:9: ( 'quot' )
            // xquery/XQueryLexer.g:296:11: 'quot'
            this.match("quot"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "QUOT_ER",

    // $ANTLR start CONCAT
    mCONCAT: function()  {
        try {
            var _type = this.CONCAT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:303:25: ( '||' )
            // xquery/XQueryLexer.g:303:27: '||'
            this.match("||"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CONCAT",

    // $ANTLR start LPAREN
    mLPAREN: function()  {
        try {
            var _type = this.LPAREN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:304:25: ( '(' )
            // xquery/XQueryLexer.g:304:27: '('
            this.match('('); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LPAREN",

    // $ANTLR start RPAREN
    mRPAREN: function()  {
        try {
            var _type = this.RPAREN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:305:25: ( ')' )
            // xquery/XQueryLexer.g:305:27: ')'
            this.match(')'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RPAREN",

    // $ANTLR start DOLLAR
    mDOLLAR: function()  {
        try {
            var _type = this.DOLLAR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:306:25: ( '$' )
            // xquery/XQueryLexer.g:306:27: '$'
            this.match('$'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DOLLAR",

    // $ANTLR start LBRACKET
    mLBRACKET: function()  {
        try {
            var _type = this.LBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:307:25: ( '{' )
            // xquery/XQueryLexer.g:307:27: '{'
            this.match('{'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LBRACKET",

    // $ANTLR start RBRACKET
    mRBRACKET: function()  {
        try {
            var _type = this.RBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:308:25: ( '}' )
            // xquery/XQueryLexer.g:308:27: '}'
            this.match('}'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RBRACKET",

    // $ANTLR start LSQUARE
    mLSQUARE: function()  {
        try {
            var _type = this.LSQUARE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:309:25: ( '[' )
            // xquery/XQueryLexer.g:309:27: '['
            this.match('['); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LSQUARE",

    // $ANTLR start RSQUARE
    mRSQUARE: function()  {
        try {
            var _type = this.RSQUARE;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:310:25: ( ']' )
            // xquery/XQueryLexer.g:310:27: ']'
            this.match(']'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RSQUARE",

    // $ANTLR start EQUAL
    mEQUAL: function()  {
        try {
            var _type = this.EQUAL;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:311:25: ( '=' )
            // xquery/XQueryLexer.g:311:27: '='
            this.match('='); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EQUAL",

    // $ANTLR start BIND
    mBIND: function()  {
        try {
            var _type = this.BIND;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:312:25: ( ':=' )
            // xquery/XQueryLexer.g:312:27: ':='
            this.match(":="); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "BIND",

    // $ANTLR start NOTEQUAL
    mNOTEQUAL: function()  {
        try {
            var _type = this.NOTEQUAL;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:313:25: ( '!=' )
            // xquery/XQueryLexer.g:313:27: '!='
            this.match("!="); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "NOTEQUAL",

    // $ANTLR start ANN_PERCENT
    mANN_PERCENT: function()  {
        try {
            var _type = this.ANN_PERCENT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:314:25: ( '%' )
            // xquery/XQueryLexer.g:314:27: '%'
            this.match('%'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ANN_PERCENT",

    // $ANTLR start HASH
    mHASH: function()  {
        try {
            var _type = this.HASH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:315:25: ( '#' )
            // xquery/XQueryLexer.g:315:27: '#'
            this.match('#'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "HASH",

    // $ANTLR start AMP
    mAMP: function()  {
        try {
            var _type = this.AMP;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:316:25: ( '&' )
            // xquery/XQueryLexer.g:316:27: '&'
            this.match('&'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "AMP",

    // $ANTLR start COMMA
    mCOMMA: function()  {
        try {
            var _type = this.COMMA;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:317:25: ( ',' )
            // xquery/XQueryLexer.g:317:27: ','
            this.match(','); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COMMA",

    // $ANTLR start QUESTION
    mQUESTION: function()  {
        try {
            var _type = this.QUESTION;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:318:25: ( '?' )
            // xquery/XQueryLexer.g:318:27: '?'
            this.match('?'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "QUESTION",

    // $ANTLR start STAR
    mSTAR: function()  {
        try {
            var _type = this.STAR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:319:25: ( '*' )
            // xquery/XQueryLexer.g:319:27: '*'
            this.match('*'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "STAR",

    // $ANTLR start PLUS
    mPLUS: function()  {
        try {
            var _type = this.PLUS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:320:25: ( '+' )
            // xquery/XQueryLexer.g:320:27: '+'
            this.match('+'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PLUS",

    // $ANTLR start MINUS
    mMINUS: function()  {
        try {
            var _type = this.MINUS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:321:25: ( '-' )
            // xquery/XQueryLexer.g:321:27: '-'
            this.match('-'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "MINUS",

    // $ANTLR start SMALLER
    mSMALLER: function()  {
        try {
            var _type = this.SMALLER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:322:25: ( '<' )
            // xquery/XQueryLexer.g:322:27: '<'
            this.match('<'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SMALLER",

    // $ANTLR start GREATER
    mGREATER: function()  {
        try {
            var _type = this.GREATER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:323:25: ( '>' )
            // xquery/XQueryLexer.g:323:27: '>'
            this.match('>'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GREATER",

    // $ANTLR start SMALLEREQ
    mSMALLEREQ: function()  {
        try {
            var _type = this.SMALLEREQ;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:324:25: ( '<=' )
            // xquery/XQueryLexer.g:324:27: '<='
            this.match("<="); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SMALLEREQ",

    // $ANTLR start GREATEREQ
    mGREATEREQ: function()  {
        try {
            var _type = this.GREATEREQ;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:325:25: ( '>=' )
            // xquery/XQueryLexer.g:325:27: '>='
            this.match(">="); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GREATEREQ",

    // $ANTLR start SMALLER_SMALLER
    mSMALLER_SMALLER: function()  {
        try {
            var _type = this.SMALLER_SMALLER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:326:25: ( '<<' )
            // xquery/XQueryLexer.g:326:27: '<<'
            this.match("<<"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SMALLER_SMALLER",

    // $ANTLR start GREATER_GREATER
    mGREATER_GREATER: function()  {
        try {
            var _type = this.GREATER_GREATER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:327:25: ( '>>' )
            // xquery/XQueryLexer.g:327:27: '>>'
            this.match(">>"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GREATER_GREATER",

    // $ANTLR start SLASH
    mSLASH: function()  {
        try {
            var _type = this.SLASH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:328:25: ( '/' )
            // xquery/XQueryLexer.g:328:27: '/'
            this.match('/'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SLASH",

    // $ANTLR start SLASH_SLASH
    mSLASH_SLASH: function()  {
        try {
            var _type = this.SLASH_SLASH;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:329:25: ( '//' )
            // xquery/XQueryLexer.g:329:27: '//'
            this.match("//"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SLASH_SLASH",

    // $ANTLR start DOT
    mDOT: function()  {
        try {
            var _type = this.DOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:330:25: ( '.' )
            // xquery/XQueryLexer.g:330:27: '.'
            this.match('.'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DOT",

    // $ANTLR start DOT_DOT
    mDOT_DOT: function()  {
        try {
            var _type = this.DOT_DOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:331:25: ( '..' )
            // xquery/XQueryLexer.g:331:27: '..'
            this.match(".."); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "DOT_DOT",

    // $ANTLR start COLON
    mCOLON: function()  {
        try {
            var _type = this.COLON;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:332:25: ( ':' )
            // xquery/XQueryLexer.g:332:27: ':'
            this.match(':'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COLON",

    // $ANTLR start COLON_COLON
    mCOLON_COLON: function()  {
        try {
            var _type = this.COLON_COLON;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:333:25: ( '::' )
            // xquery/XQueryLexer.g:333:27: '::'
            this.match("::"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COLON_COLON",

    // $ANTLR start EMPTY_CLOSE_TAG
    mEMPTY_CLOSE_TAG: function()  {
        try {
            var _type = this.EMPTY_CLOSE_TAG;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:334:25: ( '/>' )
            // xquery/XQueryLexer.g:334:27: '/>'
            this.match("/>"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EMPTY_CLOSE_TAG",

    // $ANTLR start CLOSE_TAG
    mCLOSE_TAG: function()  {
        try {
            var _type = this.CLOSE_TAG;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:335:25: ( '</' )
            // xquery/XQueryLexer.g:335:27: '</'
            this.match("</"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CLOSE_TAG",

    // $ANTLR start SEMICOLON
    mSEMICOLON: function()  {
        try {
            var _type = this.SEMICOLON;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:336:25: ( ';' )
            // xquery/XQueryLexer.g:336:27: ';'
            this.match(';'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SEMICOLON",

    // $ANTLR start VBAR
    mVBAR: function()  {
        try {
            var _type = this.VBAR;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:337:25: ( '|' )
            // xquery/XQueryLexer.g:337:27: '|'
            this.match('|'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "VBAR",

    // $ANTLR start PRAGMA_START
    mPRAGMA_START: function()  {
        try {
            var _type = this.PRAGMA_START;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:338:25: ( '(#' )
            // xquery/XQueryLexer.g:338:27: '(#'
            this.match("(#"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PRAGMA_START",

    // $ANTLR start PRAGMA_END
    mPRAGMA_END: function()  {
        try {
            var _type = this.PRAGMA_END;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:339:25: ( '#)' )
            // xquery/XQueryLexer.g:339:27: '#)'
            this.match("#)"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PRAGMA_END",

    // $ANTLR start XML_COMMENT_START
    mXML_COMMENT_START: function()  {
        try {
            var _type = this.XML_COMMENT_START;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:340:25: ( '<!--' )
            // xquery/XQueryLexer.g:340:27: '<!--'
            this.match("<!--"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "XML_COMMENT_START",

    // $ANTLR start XML_COMMENT_END
    mXML_COMMENT_END: function()  {
        try {
            var _type = this.XML_COMMENT_END;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:341:25: ( '-->' )
            // xquery/XQueryLexer.g:341:27: '-->'
            this.match("-->"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "XML_COMMENT_END",

    // $ANTLR start PI_START
    mPI_START: function()  {
        try {
            var _type = this.PI_START;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:342:25: ( '<?' )
            // xquery/XQueryLexer.g:342:27: '<?'
            this.match("<?"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PI_START",

    // $ANTLR start PI_END
    mPI_END: function()  {
        try {
            var _type = this.PI_END;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:343:25: ( '?>' )
            // xquery/XQueryLexer.g:343:27: '?>'
            this.match("?>"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "PI_END",

    // $ANTLR start ATTR_SIGN
    mATTR_SIGN: function()  {
        try {
            var _type = this.ATTR_SIGN;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:344:25: ( '@' )
            // xquery/XQueryLexer.g:344:27: '@'
            this.match('@'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ATTR_SIGN",

    // $ANTLR start CHARREF_DEC
    mCHARREF_DEC: function()  {
        try {
            var _type = this.CHARREF_DEC;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:345:25: ( '&#' )
            // xquery/XQueryLexer.g:345:27: '&#'
            this.match("&#"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CHARREF_DEC",

    // $ANTLR start CHARREF_HEX
    mCHARREF_HEX: function()  {
        try {
            var _type = this.CHARREF_HEX;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:346:25: ( '&#x' )
            // xquery/XQueryLexer.g:346:27: '&#x'
            this.match("&#x"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CHARREF_HEX",

    // $ANTLR start APOS
    mAPOS: function()  {
        try {
            var _type = this.APOS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:347:25: ( '\\'' )
            // xquery/XQueryLexer.g:347:27: '\\''
            this.match('\''); 
             if (!this.inStr) this.inStr = true; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "APOS",

    // $ANTLR start QUOT
    mQUOT: function()  {
        try {
            var _type = this.QUOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:348:25: ( '\"' )
            // xquery/XQueryLexer.g:348:27: '\"'
            this.match('\"'); 
             if (!this.inStr) this.inStr = true; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "QUOT",

    // $ANTLR start L_NCName
    mL_NCName: function()  {
        try {
            var _type = this.L_NCName;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:352:9: ( NCNameStartChar ( NCNameChar )* )
            // xquery/XQueryLexer.g:352:13: NCNameStartChar ( NCNameChar )*
            this.mNCNameStartChar(); 
            // xquery/XQueryLexer.g:352:29: ( NCNameChar )*
            loop1:
            do {
                var alt1=2;
                var LA1_0 = this.input.LA(1);

                if ( ((LA1_0>='-' && LA1_0<='.')||(LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) ) {
                    alt1=1;
                }


                switch (alt1) {
                case 1 :
                    // xquery/XQueryLexer.g:352:29: NCNameChar
                    this.mNCNameChar(); 


                    break;

                default :
                    break loop1;
                }
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_NCName",

    // $ANTLR start Letter
    mLetter: function()  {
        try {
            // xquery/XQueryLexer.g:355:29: ( 'a' .. 'z' | 'A' .. 'Z' )
            // xquery/XQueryLexer.g:
            if ( (this.input.LA(1)>='A' && this.input.LA(1)<='Z')||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "Letter",

    // $ANTLR start HexLetter
    mHexLetter: function()  {
        try {
            // xquery/XQueryLexer.g:356:29: ( 'a' .. 'f' | 'A' .. 'F' )
            // xquery/XQueryLexer.g:
            if ( (this.input.LA(1)>='A' && this.input.LA(1)<='F')||(this.input.LA(1)>='a' && this.input.LA(1)<='f') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "HexLetter",

    // $ANTLR start Digit
    mDigit: function()  {
        try {
            // xquery/XQueryLexer.g:357:29: ( '0' .. '9' )
            // xquery/XQueryLexer.g:357:31: '0' .. '9'
            this.matchRange('0','9'); 



        }
        finally {
        }
    },
    // $ANTLR end "Digit",

    // $ANTLR start Digits
    mDigits: function()  {
        try {
            // xquery/XQueryLexer.g:358:29: ( ( Digit )+ )
            // xquery/XQueryLexer.g:358:31: ( Digit )+
            // xquery/XQueryLexer.g:358:31: ( Digit )+
            var cnt2=0;
            loop2:
            do {
                var alt2=2;
                var LA2_0 = this.input.LA(1);

                if ( ((LA2_0>='0' && LA2_0<='9')) ) {
                    alt2=1;
                }


                switch (alt2) {
                case 1 :
                    // xquery/XQueryLexer.g:358:31: Digit
                    this.mDigit(); 


                    break;

                default :
                    if ( cnt2 >= 1 ) {
                        break loop2;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(2, this.input);
                        throw eee;
                }
                cnt2++;
            } while (true);




        }
        finally {
        }
    },
    // $ANTLR end "Digits",

    // $ANTLR start NCNameStartChar
    mNCNameStartChar: function()  {
        try {
            // xquery/XQueryLexer.g:360:29: ( Letter | '_' )
            // xquery/XQueryLexer.g:
            if ( (this.input.LA(1)>='A' && this.input.LA(1)<='Z')||this.input.LA(1)=='_'||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "NCNameStartChar",

    // $ANTLR start NCNameChar
    mNCNameChar: function()  {
        try {
            // xquery/XQueryLexer.g:361:29: ( Letter | Digit | '.' | '-' | '_' )
            // xquery/XQueryLexer.g:
            if ( (this.input.LA(1)>='-' && this.input.LA(1)<='.')||(this.input.LA(1)>='0' && this.input.LA(1)<='9')||(this.input.LA(1)>='A' && this.input.LA(1)<='Z')||this.input.LA(1)=='_'||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "NCNameChar",

    // $ANTLR start S
    mS: function()  {
        try {
            var _type = this.S;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:364:9: ( ( '\\t' | ' ' | '\\n' | '\\r' )+ )
            // xquery/XQueryLexer.g:364:11: ( '\\t' | ' ' | '\\n' | '\\r' )+
            // xquery/XQueryLexer.g:364:11: ( '\\t' | ' ' | '\\n' | '\\r' )+
            var cnt3=0;
            loop3:
            do {
                var alt3=2;
                var LA3_0 = this.input.LA(1);

                if ( ((LA3_0>='\t' && LA3_0<='\n')||LA3_0=='\r'||LA3_0==' ') ) {
                    alt3=1;
                }


                switch (alt3) {
                case 1 :
                    // xquery/XQueryLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||this.input.LA(1)==' ' ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt3 >= 1 ) {
                        break loop3;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(3, this.input);
                        throw eee;
                }
                cnt3++;
            } while (true);

             _channel = HIDDEN; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "S",

    // $ANTLR start SU
    mSU: function()  {
        try {
            // xquery/XQueryLexer.g:367:9: ( ( '\\t' | ' ' | '\\n' | '\\r' )+ )
            // xquery/XQueryLexer.g:367:11: ( '\\t' | ' ' | '\\n' | '\\r' )+
            // xquery/XQueryLexer.g:367:11: ( '\\t' | ' ' | '\\n' | '\\r' )+
            var cnt4=0;
            loop4:
            do {
                var alt4=2;
                var LA4_0 = this.input.LA(1);

                if ( ((LA4_0>='\t' && LA4_0<='\n')||LA4_0=='\r'||LA4_0==' ') ) {
                    alt4=1;
                }


                switch (alt4) {
                case 1 :
                    // xquery/XQueryLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||this.input.LA(1)==' ' ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt4 >= 1 ) {
                        break loop4;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(4, this.input);
                        throw eee;
                }
                cnt4++;
            } while (true);




        }
        finally {
        }
    },
    // $ANTLR end "SU",

    // $ANTLR start L_Pragma
    mL_Pragma: function()  {
        try {
            var _type = this.L_Pragma;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:378:9: ( PRAGMA_START ( SU )? L_NCName COLON L_NCName ( SU ( options {greedy=false; } : . )* )? PRAGMA_END )
            // xquery/XQueryLexer.g:378:11: PRAGMA_START ( SU )? L_NCName COLON L_NCName ( SU ( options {greedy=false; } : . )* )? PRAGMA_END
            this.mPRAGMA_START(); 
            // xquery/XQueryLexer.g:378:24: ( SU )?
            var alt5=2;
            var LA5_0 = this.input.LA(1);

            if ( ((LA5_0>='\t' && LA5_0<='\n')||LA5_0=='\r'||LA5_0==' ') ) {
                alt5=1;
            }
            switch (alt5) {
                case 1 :
                    // xquery/XQueryLexer.g:378:24: SU
                    this.mSU(); 


                    break;

            }

            this.mL_NCName(); 
            this.mCOLON(); 
            this.mL_NCName(); 
            // xquery/XQueryLexer.g:378:52: ( SU ( options {greedy=false; } : . )* )?
            var alt7=2;
            var LA7_0 = this.input.LA(1);

            if ( ((LA7_0>='\t' && LA7_0<='\n')||LA7_0=='\r'||LA7_0==' ') ) {
                alt7=1;
            }
            switch (alt7) {
                case 1 :
                    // xquery/XQueryLexer.g:378:53: SU ( options {greedy=false; } : . )*
                    this.mSU(); 
                    // xquery/XQueryLexer.g:378:56: ( options {greedy=false; } : . )*
                    loop6:
                    do {
                        var alt6=2;
                        var LA6_0 = this.input.LA(1);

                        if ( (LA6_0=='#') ) {
                            var LA6_1 = this.input.LA(2);

                            if ( (LA6_1==')') ) {
                                alt6=2;
                            }
                            else if ( ((LA6_1>='\u0000' && LA6_1<='(')||(LA6_1>='*' && LA6_1<='\uFFFF')) ) {
                                alt6=1;
                            }


                        }
                        else if ( ((LA6_0>='\u0000' && LA6_0<='\"')||(LA6_0>='$' && LA6_0<='\uFFFF')) ) {
                            alt6=1;
                        }


                        switch (alt6) {
                        case 1 :
                            // xquery/XQueryLexer.g:378:83: .
                            this.matchAny(); 


                            break;

                        default :
                            break loop6;
                        }
                    } while (true);



                    break;

            }

            this.mPRAGMA_END(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_Pragma",

    // $ANTLR start L_DirCommentConstructor
    mL_DirCommentConstructor: function()  {
        try {
            var _type = this.L_DirCommentConstructor;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:388:9: ( XML_COMMENT_START ( options {greedy=false; } : ( . )* ) XML_COMMENT_END )
            // xquery/XQueryLexer.g:388:11: XML_COMMENT_START ( options {greedy=false; } : ( . )* ) XML_COMMENT_END
            this.mXML_COMMENT_START(); 
            // xquery/XQueryLexer.g:388:29: ( options {greedy=false; } : ( . )* )
            // xquery/XQueryLexer.g:388:56: ( . )*
            // xquery/XQueryLexer.g:388:56: ( . )*
            loop8:
            do {
                var alt8=2;
                var LA8_0 = this.input.LA(1);

                if ( (LA8_0=='-') ) {
                    var LA8_1 = this.input.LA(2);

                    if ( (LA8_1=='-') ) {
                        var LA8_3 = this.input.LA(3);

                        if ( (LA8_3=='>') ) {
                            alt8=2;
                        }
                        else if ( ((LA8_3>='\u0000' && LA8_3<='=')||(LA8_3>='?' && LA8_3<='\uFFFF')) ) {
                            alt8=1;
                        }


                    }
                    else if ( ((LA8_1>='\u0000' && LA8_1<=',')||(LA8_1>='.' && LA8_1<='\uFFFF')) ) {
                        alt8=1;
                    }


                }
                else if ( ((LA8_0>='\u0000' && LA8_0<=',')||(LA8_0>='.' && LA8_0<='\uFFFF')) ) {
                    alt8=1;
                }


                switch (alt8) {
                case 1 :
                    // xquery/XQueryLexer.g:388:56: .
                    this.matchAny(); 


                    break;

                default :
                    break loop8;
                }
            } while (true);




            this.mXML_COMMENT_END(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_DirCommentConstructor",

    // $ANTLR start L_DirPIConstructor
    mL_DirPIConstructor: function()  {
        try {
            var _type = this.L_DirPIConstructor;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:397:9: ( PI_START ( SU )? L_NCName ( SU ( options {greedy=false; } : ( . )* ) )? PI_END )
            // xquery/XQueryLexer.g:397:11: PI_START ( SU )? L_NCName ( SU ( options {greedy=false; } : ( . )* ) )? PI_END
            this.mPI_START(); 
            // xquery/XQueryLexer.g:397:20: ( SU )?
            var alt9=2;
            var LA9_0 = this.input.LA(1);

            if ( ((LA9_0>='\t' && LA9_0<='\n')||LA9_0=='\r'||LA9_0==' ') ) {
                alt9=1;
            }
            switch (alt9) {
                case 1 :
                    // xquery/XQueryLexer.g:397:20: SU
                    this.mSU(); 


                    break;

            }

            this.mL_NCName(); 
            // xquery/XQueryLexer.g:397:33: ( SU ( options {greedy=false; } : ( . )* ) )?
            var alt11=2;
            var LA11_0 = this.input.LA(1);

            if ( ((LA11_0>='\t' && LA11_0<='\n')||LA11_0=='\r'||LA11_0==' ') ) {
                alt11=1;
            }
            switch (alt11) {
                case 1 :
                    // xquery/XQueryLexer.g:397:34: SU ( options {greedy=false; } : ( . )* )
                    this.mSU(); 
                    // xquery/XQueryLexer.g:397:36: ( options {greedy=false; } : ( . )* )
                    // xquery/XQueryLexer.g:397:63: ( . )*
                    // xquery/XQueryLexer.g:397:63: ( . )*
                    loop10:
                    do {
                        var alt10=2;
                        var LA10_0 = this.input.LA(1);

                        if ( (LA10_0=='?') ) {
                            var LA10_1 = this.input.LA(2);

                            if ( (LA10_1=='>') ) {
                                alt10=2;
                            }
                            else if ( ((LA10_1>='\u0000' && LA10_1<='=')||(LA10_1>='?' && LA10_1<='\uFFFF')) ) {
                                alt10=1;
                            }


                        }
                        else if ( ((LA10_0>='\u0000' && LA10_0<='>')||(LA10_0>='@' && LA10_0<='\uFFFF')) ) {
                            alt10=1;
                        }


                        switch (alt10) {
                        case 1 :
                            // xquery/XQueryLexer.g:397:63: .
                            this.matchAny(); 


                            break;

                        default :
                            break loop10;
                        }
                    } while (true);






                    break;

            }

            this.mPI_END(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_DirPIConstructor",

    // $ANTLR start L_IntegerLiteral
    mL_IntegerLiteral: function()  {
        try {
            var _type = this.L_IntegerLiteral;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:405:9: ( Digits )
            // xquery/XQueryLexer.g:405:13: Digits
            this.mDigits(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_IntegerLiteral",

    // $ANTLR start L_DecimalLiteral
    mL_DecimalLiteral: function()  {
        try {
            var _type = this.L_DecimalLiteral;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:410:9: ( ( '.' Digits ) | ( Digits '.' ( Digit )* ) )
            var alt13=2;
            var LA13_0 = this.input.LA(1);

            if ( (LA13_0=='.') ) {
                alt13=1;
            }
            else if ( ((LA13_0>='0' && LA13_0<='9')) ) {
                alt13=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 13, 0, this.input);

                throw nvae;
            }
            switch (alt13) {
                case 1 :
                    // xquery/XQueryLexer.g:410:11: ( '.' Digits )
                    // xquery/XQueryLexer.g:410:11: ( '.' Digits )
                    // xquery/XQueryLexer.g:410:12: '.' Digits
                    this.match('.'); 
                    this.mDigits(); 





                    break;
                case 2 :
                    // xquery/XQueryLexer.g:410:26: ( Digits '.' ( Digit )* )
                    // xquery/XQueryLexer.g:410:26: ( Digits '.' ( Digit )* )
                    // xquery/XQueryLexer.g:410:27: Digits '.' ( Digit )*
                    this.mDigits(); 
                    this.match('.'); 
                    // xquery/XQueryLexer.g:410:38: ( Digit )*
                    loop12:
                    do {
                        var alt12=2;
                        var LA12_0 = this.input.LA(1);

                        if ( ((LA12_0>='0' && LA12_0<='9')) ) {
                            alt12=1;
                        }


                        switch (alt12) {
                        case 1 :
                            // xquery/XQueryLexer.g:410:38: Digit
                            this.mDigit(); 


                            break;

                        default :
                            break loop12;
                        }
                    } while (true);






                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_DecimalLiteral",

    // $ANTLR start L_DoubleLiteral
    mL_DoubleLiteral: function()  {
        try {
            var _type = this.L_DoubleLiteral;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:415:9: ( ( ( '.' Digits ) | ( Digits ( '.' ( Digit )* )? ) ) ( 'e' | 'E' ) ( '+' | '-' )? Digits )
            // xquery/XQueryLexer.g:415:11: ( ( '.' Digits ) | ( Digits ( '.' ( Digit )* )? ) ) ( 'e' | 'E' ) ( '+' | '-' )? Digits
            // xquery/XQueryLexer.g:415:11: ( ( '.' Digits ) | ( Digits ( '.' ( Digit )* )? ) )
            var alt16=2;
            var LA16_0 = this.input.LA(1);

            if ( (LA16_0=='.') ) {
                alt16=1;
            }
            else if ( ((LA16_0>='0' && LA16_0<='9')) ) {
                alt16=2;
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 16, 0, this.input);

                throw nvae;
            }
            switch (alt16) {
                case 1 :
                    // xquery/XQueryLexer.g:415:12: ( '.' Digits )
                    // xquery/XQueryLexer.g:415:12: ( '.' Digits )
                    // xquery/XQueryLexer.g:415:13: '.' Digits
                    this.match('.'); 
                    this.mDigits(); 





                    break;
                case 2 :
                    // xquery/XQueryLexer.g:415:27: ( Digits ( '.' ( Digit )* )? )
                    // xquery/XQueryLexer.g:415:27: ( Digits ( '.' ( Digit )* )? )
                    // xquery/XQueryLexer.g:415:28: Digits ( '.' ( Digit )* )?
                    this.mDigits(); 
                    // xquery/XQueryLexer.g:415:35: ( '.' ( Digit )* )?
                    var alt15=2;
                    var LA15_0 = this.input.LA(1);

                    if ( (LA15_0=='.') ) {
                        alt15=1;
                    }
                    switch (alt15) {
                        case 1 :
                            // xquery/XQueryLexer.g:415:36: '.' ( Digit )*
                            this.match('.'); 
                            // xquery/XQueryLexer.g:415:40: ( Digit )*
                            loop14:
                            do {
                                var alt14=2;
                                var LA14_0 = this.input.LA(1);

                                if ( ((LA14_0>='0' && LA14_0<='9')) ) {
                                    alt14=1;
                                }


                                switch (alt14) {
                                case 1 :
                                    // xquery/XQueryLexer.g:415:40: Digit
                                    this.mDigit(); 


                                    break;

                                default :
                                    break loop14;
                                }
                            } while (true);



                            break;

                    }






                    break;

            }

            if ( this.input.LA(1)=='E'||this.input.LA(1)=='e' ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}

            // xquery/XQueryLexer.g:415:63: ( '+' | '-' )?
            var alt17=2;
            var LA17_0 = this.input.LA(1);

            if ( (LA17_0=='+'||LA17_0=='-') ) {
                alt17=1;
            }
            switch (alt17) {
                case 1 :
                    // xquery/XQueryLexer.g:
                    if ( this.input.LA(1)=='+'||this.input.LA(1)=='-' ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

            }

            this.mDigits(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_DoubleLiteral",

    // $ANTLR start L_Comment
    mL_Comment: function()  {
        try {
            var _type = this.L_Comment;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:420:9: ({...}? => '(:' ( options {greedy=false; } : L_Comment | . )* ':)' )
            // xquery/XQueryLexer.g:420:11: {...}? => '(:' ( options {greedy=false; } : L_Comment | . )* ':)'
            if ( !((!this.inStr)) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_Comment", "!this.inStr");
            }
            this.match("(:"); 

            // xquery/XQueryLexer.g:420:33: ( options {greedy=false; } : L_Comment | . )*
            loop18:
            do {
                var alt18=3;
                var LA18_0 = this.input.LA(1);

                if ( (LA18_0==':') ) {
                    var LA18_1 = this.input.LA(2);

                    if ( (LA18_1==')') ) {
                        alt18=3;
                    }
                    else if ( ((LA18_1>='\u0000' && LA18_1<='(')||(LA18_1>='*' && LA18_1<='\uFFFF')) ) {
                        alt18=2;
                    }


                }
                else if ( (LA18_0=='(') ) {
                    var LA18_2 = this.input.LA(2);

                    if ( (LA18_2==':') ) {
                        var LA18_5 = this.input.LA(3);

                        if ( ((!this.inStr)) ) {
                            alt18=1;
                        }
                        else if ( (true) ) {
                            alt18=2;
                        }


                    }
                    else if ( ((LA18_2>='\u0000' && LA18_2<='9')||(LA18_2>=';' && LA18_2<='\uFFFF')) ) {
                        alt18=2;
                    }


                }
                else if ( ((LA18_0>='\u0000' && LA18_0<='\'')||(LA18_0>=')' && LA18_0<='9')||(LA18_0>=';' && LA18_0<='\uFFFF')) ) {
                    alt18=2;
                }


                switch (alt18) {
                case 1 :
                    // xquery/XQueryLexer.g:420:59: L_Comment
                    this.mL_Comment(); 


                    break;
                case 2 :
                    // xquery/XQueryLexer.g:420:71: .
                    this.matchAny(); 


                    break;

                default :
                    break loop18;
                }
            } while (true);

            this.match(":)"); 

             _channel = HIDDEN; this.addComment(this.state.tokenStartCharIndex, (this.getCharIndex()-1)); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_Comment",

    // $ANTLR start L_AnyChar
    mL_AnyChar: function()  {
        try {
            var _type = this.L_AnyChar;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XQueryLexer.g:423:11: ( . )
            // xquery/XQueryLexer.g:423:13: .
            this.matchAny(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_AnyChar",

    mTokens: function() {
        // xquery/XQueryLexer.g:1:8: ( ANCESTOR | ANCESTOR_OR_SELF | AND | AS | ASCENDING | AT | ATTRIBUTE | BASE_URI | BOUNDARY_SPACE | BY | CASE | CAST | CASTABLE | CHILD | COLLATION | COMMENT | CONSTRUCTION | COPY_NAMESPACES | DECLARE | DEFAULT | DESCENDANT | DESCENDANT_OR_SELF | DESCENDING | DIV | DOCUMENT | DOCUMENT_NODE | ELEMENT | ELSE | EMPTY | EMPTY_SEQUENCE | ENCODING | EQ | EVERY | EXCEPT | EXTERNAL | FOLLOWING | FOLLOWING_SIBLING | FOR | FUNCTION | GE | GREATEST | GT | IDIV | IF | IMPORT | IN | INHERIT | INSTANCE | INTERSECT | IS | ITEM | LAX | LE | LEAST | LET | LT | MOD | MODULE | NAMESPACE | NE | NO_INHERIT | NO_PRESERVE | NODE | OF | OPTION | OR | ORDER | ORDERED | ORDERING | PARENT | PRECEDING | PRECEDING_SIBLING | PRESERVE | PROCESSING_INSTRUCTION | RETURN | SATISFIES | SCHEMA | SCHEMA_ATTRIBUTE | SCHEMA_ELEMENT | SELF | SOME | STABLE | STRICT | STRIP | TEXT | THEN | TO | TREAT | TYPESWITCH | UNION | UNORDERED | VALIDATE | VARIABLE | VERSION | WHERE | XQUERY | ALLOWING | CATCH | CONTEXT | COUNT | DECIMAL_FORMAT | DECIMAL_SEPARATOR | DIGIT | END | GROUP | GROUPING_SEPARATOR | INFINITY | MINUS_SIGN | NAMESPACE_NODE | NAN | NEXT | ONLY | PATTERN_SEPARATOR | PERCENT | PER_MILLE | PREVIOUS | SLIDING | START | SWITCH | TRY | TUMBLING | TYPE | WHEN | WINDOW | ZERO_DIGIT | AFTER | BEFORE | COPY | DELETE | FIRST | INSERT | INTO | LAST | MODIFY | NODES | RENAME | REPLACE | REVALIDATION | SKIP | UPDATING | VALUE | WITH | ALL | ANY | CONTAINS | CONTENT | DIACRITICS | DIFFERENT | DISTANCE | ENTIRE | EXACTLY | FROM | FT_OPTION | FTAND | FTNOT | FTOR | INSENSITIVE | LANGUAGE | LEVELS | LOWERCASE | MOST | NO | NOT | OCCURS | PARAGRAPH | PARAGRAPHS | PHRASE | RELATIONSHIP | SAME | SCORE | SENSITIVE | SENTENCE | SENTENCES | STEMMING | STOP | THESAURUS | TIMES | UPPERCASE | USING | WEIGHT | WILDCARDS | WITHOUT | WORD | WORDS | BREAK | CONTINUE | EXIT | LOOP | RETURNING | WHILE | CHECK | COLLECTION | CONSTRAINT | FOREACH | FOREIGN | INDEX | INTEGRITY | KEY | ON | UNIQUE | BINARY | AMP_ER | APOS_ER | QUOT_ER | CONCAT | LPAREN | RPAREN | DOLLAR | LBRACKET | RBRACKET | LSQUARE | RSQUARE | EQUAL | BIND | NOTEQUAL | ANN_PERCENT | HASH | AMP | COMMA | QUESTION | STAR | PLUS | MINUS | SMALLER | GREATER | SMALLEREQ | GREATEREQ | SMALLER_SMALLER | GREATER_GREATER | SLASH | SLASH_SLASH | DOT | DOT_DOT | COLON | COLON_COLON | EMPTY_CLOSE_TAG | CLOSE_TAG | SEMICOLON | VBAR | PRAGMA_START | PRAGMA_END | XML_COMMENT_START | XML_COMMENT_END | PI_START | PI_END | ATTR_SIGN | CHARREF_DEC | CHARREF_HEX | APOS | QUOT | L_NCName | S | L_Pragma | L_DirCommentConstructor | L_DirPIConstructor | L_IntegerLiteral | L_DecimalLiteral | L_DoubleLiteral | L_Comment | L_AnyChar )
        var alt19=260;
        alt19 = this.dfa19.predict(this.input);
        switch (alt19) {
            case 1 :
                // xquery/XQueryLexer.g:1:10: ANCESTOR
                this.mANCESTOR(); 


                break;
            case 2 :
                // xquery/XQueryLexer.g:1:19: ANCESTOR_OR_SELF
                this.mANCESTOR_OR_SELF(); 


                break;
            case 3 :
                // xquery/XQueryLexer.g:1:36: AND
                this.mAND(); 


                break;
            case 4 :
                // xquery/XQueryLexer.g:1:40: AS
                this.mAS(); 


                break;
            case 5 :
                // xquery/XQueryLexer.g:1:43: ASCENDING
                this.mASCENDING(); 


                break;
            case 6 :
                // xquery/XQueryLexer.g:1:53: AT
                this.mAT(); 


                break;
            case 7 :
                // xquery/XQueryLexer.g:1:56: ATTRIBUTE
                this.mATTRIBUTE(); 


                break;
            case 8 :
                // xquery/XQueryLexer.g:1:66: BASE_URI
                this.mBASE_URI(); 


                break;
            case 9 :
                // xquery/XQueryLexer.g:1:75: BOUNDARY_SPACE
                this.mBOUNDARY_SPACE(); 


                break;
            case 10 :
                // xquery/XQueryLexer.g:1:90: BY
                this.mBY(); 


                break;
            case 11 :
                // xquery/XQueryLexer.g:1:93: CASE
                this.mCASE(); 


                break;
            case 12 :
                // xquery/XQueryLexer.g:1:98: CAST
                this.mCAST(); 


                break;
            case 13 :
                // xquery/XQueryLexer.g:1:103: CASTABLE
                this.mCASTABLE(); 


                break;
            case 14 :
                // xquery/XQueryLexer.g:1:112: CHILD
                this.mCHILD(); 


                break;
            case 15 :
                // xquery/XQueryLexer.g:1:118: COLLATION
                this.mCOLLATION(); 


                break;
            case 16 :
                // xquery/XQueryLexer.g:1:128: COMMENT
                this.mCOMMENT(); 


                break;
            case 17 :
                // xquery/XQueryLexer.g:1:136: CONSTRUCTION
                this.mCONSTRUCTION(); 


                break;
            case 18 :
                // xquery/XQueryLexer.g:1:149: COPY_NAMESPACES
                this.mCOPY_NAMESPACES(); 


                break;
            case 19 :
                // xquery/XQueryLexer.g:1:165: DECLARE
                this.mDECLARE(); 


                break;
            case 20 :
                // xquery/XQueryLexer.g:1:173: DEFAULT
                this.mDEFAULT(); 


                break;
            case 21 :
                // xquery/XQueryLexer.g:1:181: DESCENDANT
                this.mDESCENDANT(); 


                break;
            case 22 :
                // xquery/XQueryLexer.g:1:192: DESCENDANT_OR_SELF
                this.mDESCENDANT_OR_SELF(); 


                break;
            case 23 :
                // xquery/XQueryLexer.g:1:211: DESCENDING
                this.mDESCENDING(); 


                break;
            case 24 :
                // xquery/XQueryLexer.g:1:222: DIV
                this.mDIV(); 


                break;
            case 25 :
                // xquery/XQueryLexer.g:1:226: DOCUMENT
                this.mDOCUMENT(); 


                break;
            case 26 :
                // xquery/XQueryLexer.g:1:235: DOCUMENT_NODE
                this.mDOCUMENT_NODE(); 


                break;
            case 27 :
                // xquery/XQueryLexer.g:1:249: ELEMENT
                this.mELEMENT(); 


                break;
            case 28 :
                // xquery/XQueryLexer.g:1:257: ELSE
                this.mELSE(); 


                break;
            case 29 :
                // xquery/XQueryLexer.g:1:262: EMPTY
                this.mEMPTY(); 


                break;
            case 30 :
                // xquery/XQueryLexer.g:1:268: EMPTY_SEQUENCE
                this.mEMPTY_SEQUENCE(); 


                break;
            case 31 :
                // xquery/XQueryLexer.g:1:283: ENCODING
                this.mENCODING(); 


                break;
            case 32 :
                // xquery/XQueryLexer.g:1:292: EQ
                this.mEQ(); 


                break;
            case 33 :
                // xquery/XQueryLexer.g:1:295: EVERY
                this.mEVERY(); 


                break;
            case 34 :
                // xquery/XQueryLexer.g:1:301: EXCEPT
                this.mEXCEPT(); 


                break;
            case 35 :
                // xquery/XQueryLexer.g:1:308: EXTERNAL
                this.mEXTERNAL(); 


                break;
            case 36 :
                // xquery/XQueryLexer.g:1:317: FOLLOWING
                this.mFOLLOWING(); 


                break;
            case 37 :
                // xquery/XQueryLexer.g:1:327: FOLLOWING_SIBLING
                this.mFOLLOWING_SIBLING(); 


                break;
            case 38 :
                // xquery/XQueryLexer.g:1:345: FOR
                this.mFOR(); 


                break;
            case 39 :
                // xquery/XQueryLexer.g:1:349: FUNCTION
                this.mFUNCTION(); 


                break;
            case 40 :
                // xquery/XQueryLexer.g:1:358: GE
                this.mGE(); 


                break;
            case 41 :
                // xquery/XQueryLexer.g:1:361: GREATEST
                this.mGREATEST(); 


                break;
            case 42 :
                // xquery/XQueryLexer.g:1:370: GT
                this.mGT(); 


                break;
            case 43 :
                // xquery/XQueryLexer.g:1:373: IDIV
                this.mIDIV(); 


                break;
            case 44 :
                // xquery/XQueryLexer.g:1:378: IF
                this.mIF(); 


                break;
            case 45 :
                // xquery/XQueryLexer.g:1:381: IMPORT
                this.mIMPORT(); 


                break;
            case 46 :
                // xquery/XQueryLexer.g:1:388: IN
                this.mIN(); 


                break;
            case 47 :
                // xquery/XQueryLexer.g:1:391: INHERIT
                this.mINHERIT(); 


                break;
            case 48 :
                // xquery/XQueryLexer.g:1:399: INSTANCE
                this.mINSTANCE(); 


                break;
            case 49 :
                // xquery/XQueryLexer.g:1:408: INTERSECT
                this.mINTERSECT(); 


                break;
            case 50 :
                // xquery/XQueryLexer.g:1:418: IS
                this.mIS(); 


                break;
            case 51 :
                // xquery/XQueryLexer.g:1:421: ITEM
                this.mITEM(); 


                break;
            case 52 :
                // xquery/XQueryLexer.g:1:426: LAX
                this.mLAX(); 


                break;
            case 53 :
                // xquery/XQueryLexer.g:1:430: LE
                this.mLE(); 


                break;
            case 54 :
                // xquery/XQueryLexer.g:1:433: LEAST
                this.mLEAST(); 


                break;
            case 55 :
                // xquery/XQueryLexer.g:1:439: LET
                this.mLET(); 


                break;
            case 56 :
                // xquery/XQueryLexer.g:1:443: LT
                this.mLT(); 


                break;
            case 57 :
                // xquery/XQueryLexer.g:1:446: MOD
                this.mMOD(); 


                break;
            case 58 :
                // xquery/XQueryLexer.g:1:450: MODULE
                this.mMODULE(); 


                break;
            case 59 :
                // xquery/XQueryLexer.g:1:457: NAMESPACE
                this.mNAMESPACE(); 


                break;
            case 60 :
                // xquery/XQueryLexer.g:1:467: NE
                this.mNE(); 


                break;
            case 61 :
                // xquery/XQueryLexer.g:1:470: NO_INHERIT
                this.mNO_INHERIT(); 


                break;
            case 62 :
                // xquery/XQueryLexer.g:1:481: NO_PRESERVE
                this.mNO_PRESERVE(); 


                break;
            case 63 :
                // xquery/XQueryLexer.g:1:493: NODE
                this.mNODE(); 


                break;
            case 64 :
                // xquery/XQueryLexer.g:1:498: OF
                this.mOF(); 


                break;
            case 65 :
                // xquery/XQueryLexer.g:1:501: OPTION
                this.mOPTION(); 


                break;
            case 66 :
                // xquery/XQueryLexer.g:1:508: OR
                this.mOR(); 


                break;
            case 67 :
                // xquery/XQueryLexer.g:1:511: ORDER
                this.mORDER(); 


                break;
            case 68 :
                // xquery/XQueryLexer.g:1:517: ORDERED
                this.mORDERED(); 


                break;
            case 69 :
                // xquery/XQueryLexer.g:1:525: ORDERING
                this.mORDERING(); 


                break;
            case 70 :
                // xquery/XQueryLexer.g:1:534: PARENT
                this.mPARENT(); 


                break;
            case 71 :
                // xquery/XQueryLexer.g:1:541: PRECEDING
                this.mPRECEDING(); 


                break;
            case 72 :
                // xquery/XQueryLexer.g:1:551: PRECEDING_SIBLING
                this.mPRECEDING_SIBLING(); 


                break;
            case 73 :
                // xquery/XQueryLexer.g:1:569: PRESERVE
                this.mPRESERVE(); 


                break;
            case 74 :
                // xquery/XQueryLexer.g:1:578: PROCESSING_INSTRUCTION
                this.mPROCESSING_INSTRUCTION(); 


                break;
            case 75 :
                // xquery/XQueryLexer.g:1:601: RETURN
                this.mRETURN(); 


                break;
            case 76 :
                // xquery/XQueryLexer.g:1:608: SATISFIES
                this.mSATISFIES(); 


                break;
            case 77 :
                // xquery/XQueryLexer.g:1:618: SCHEMA
                this.mSCHEMA(); 


                break;
            case 78 :
                // xquery/XQueryLexer.g:1:625: SCHEMA_ATTRIBUTE
                this.mSCHEMA_ATTRIBUTE(); 


                break;
            case 79 :
                // xquery/XQueryLexer.g:1:642: SCHEMA_ELEMENT
                this.mSCHEMA_ELEMENT(); 


                break;
            case 80 :
                // xquery/XQueryLexer.g:1:657: SELF
                this.mSELF(); 


                break;
            case 81 :
                // xquery/XQueryLexer.g:1:662: SOME
                this.mSOME(); 


                break;
            case 82 :
                // xquery/XQueryLexer.g:1:667: STABLE
                this.mSTABLE(); 


                break;
            case 83 :
                // xquery/XQueryLexer.g:1:674: STRICT
                this.mSTRICT(); 


                break;
            case 84 :
                // xquery/XQueryLexer.g:1:681: STRIP
                this.mSTRIP(); 


                break;
            case 85 :
                // xquery/XQueryLexer.g:1:687: TEXT
                this.mTEXT(); 


                break;
            case 86 :
                // xquery/XQueryLexer.g:1:692: THEN
                this.mTHEN(); 


                break;
            case 87 :
                // xquery/XQueryLexer.g:1:697: TO
                this.mTO(); 


                break;
            case 88 :
                // xquery/XQueryLexer.g:1:700: TREAT
                this.mTREAT(); 


                break;
            case 89 :
                // xquery/XQueryLexer.g:1:706: TYPESWITCH
                this.mTYPESWITCH(); 


                break;
            case 90 :
                // xquery/XQueryLexer.g:1:717: UNION
                this.mUNION(); 


                break;
            case 91 :
                // xquery/XQueryLexer.g:1:723: UNORDERED
                this.mUNORDERED(); 


                break;
            case 92 :
                // xquery/XQueryLexer.g:1:733: VALIDATE
                this.mVALIDATE(); 


                break;
            case 93 :
                // xquery/XQueryLexer.g:1:742: VARIABLE
                this.mVARIABLE(); 


                break;
            case 94 :
                // xquery/XQueryLexer.g:1:751: VERSION
                this.mVERSION(); 


                break;
            case 95 :
                // xquery/XQueryLexer.g:1:759: WHERE
                this.mWHERE(); 


                break;
            case 96 :
                // xquery/XQueryLexer.g:1:765: XQUERY
                this.mXQUERY(); 


                break;
            case 97 :
                // xquery/XQueryLexer.g:1:772: ALLOWING
                this.mALLOWING(); 


                break;
            case 98 :
                // xquery/XQueryLexer.g:1:781: CATCH
                this.mCATCH(); 


                break;
            case 99 :
                // xquery/XQueryLexer.g:1:787: CONTEXT
                this.mCONTEXT(); 


                break;
            case 100 :
                // xquery/XQueryLexer.g:1:795: COUNT
                this.mCOUNT(); 


                break;
            case 101 :
                // xquery/XQueryLexer.g:1:801: DECIMAL_FORMAT
                this.mDECIMAL_FORMAT(); 


                break;
            case 102 :
                // xquery/XQueryLexer.g:1:816: DECIMAL_SEPARATOR
                this.mDECIMAL_SEPARATOR(); 


                break;
            case 103 :
                // xquery/XQueryLexer.g:1:834: DIGIT
                this.mDIGIT(); 


                break;
            case 104 :
                // xquery/XQueryLexer.g:1:840: END
                this.mEND(); 


                break;
            case 105 :
                // xquery/XQueryLexer.g:1:844: GROUP
                this.mGROUP(); 


                break;
            case 106 :
                // xquery/XQueryLexer.g:1:850: GROUPING_SEPARATOR
                this.mGROUPING_SEPARATOR(); 


                break;
            case 107 :
                // xquery/XQueryLexer.g:1:869: INFINITY
                this.mINFINITY(); 


                break;
            case 108 :
                // xquery/XQueryLexer.g:1:878: MINUS_SIGN
                this.mMINUS_SIGN(); 


                break;
            case 109 :
                // xquery/XQueryLexer.g:1:889: NAMESPACE_NODE
                this.mNAMESPACE_NODE(); 


                break;
            case 110 :
                // xquery/XQueryLexer.g:1:904: NAN
                this.mNAN(); 


                break;
            case 111 :
                // xquery/XQueryLexer.g:1:908: NEXT
                this.mNEXT(); 


                break;
            case 112 :
                // xquery/XQueryLexer.g:1:913: ONLY
                this.mONLY(); 


                break;
            case 113 :
                // xquery/XQueryLexer.g:1:918: PATTERN_SEPARATOR
                this.mPATTERN_SEPARATOR(); 


                break;
            case 114 :
                // xquery/XQueryLexer.g:1:936: PERCENT
                this.mPERCENT(); 


                break;
            case 115 :
                // xquery/XQueryLexer.g:1:944: PER_MILLE
                this.mPER_MILLE(); 


                break;
            case 116 :
                // xquery/XQueryLexer.g:1:954: PREVIOUS
                this.mPREVIOUS(); 


                break;
            case 117 :
                // xquery/XQueryLexer.g:1:963: SLIDING
                this.mSLIDING(); 


                break;
            case 118 :
                // xquery/XQueryLexer.g:1:971: START
                this.mSTART(); 


                break;
            case 119 :
                // xquery/XQueryLexer.g:1:977: SWITCH
                this.mSWITCH(); 


                break;
            case 120 :
                // xquery/XQueryLexer.g:1:984: TRY
                this.mTRY(); 


                break;
            case 121 :
                // xquery/XQueryLexer.g:1:988: TUMBLING
                this.mTUMBLING(); 


                break;
            case 122 :
                // xquery/XQueryLexer.g:1:997: TYPE
                this.mTYPE(); 


                break;
            case 123 :
                // xquery/XQueryLexer.g:1:1002: WHEN
                this.mWHEN(); 


                break;
            case 124 :
                // xquery/XQueryLexer.g:1:1007: WINDOW
                this.mWINDOW(); 


                break;
            case 125 :
                // xquery/XQueryLexer.g:1:1014: ZERO_DIGIT
                this.mZERO_DIGIT(); 


                break;
            case 126 :
                // xquery/XQueryLexer.g:1:1025: AFTER
                this.mAFTER(); 


                break;
            case 127 :
                // xquery/XQueryLexer.g:1:1031: BEFORE
                this.mBEFORE(); 


                break;
            case 128 :
                // xquery/XQueryLexer.g:1:1038: COPY
                this.mCOPY(); 


                break;
            case 129 :
                // xquery/XQueryLexer.g:1:1043: DELETE
                this.mDELETE(); 


                break;
            case 130 :
                // xquery/XQueryLexer.g:1:1050: FIRST
                this.mFIRST(); 


                break;
            case 131 :
                // xquery/XQueryLexer.g:1:1056: INSERT
                this.mINSERT(); 


                break;
            case 132 :
                // xquery/XQueryLexer.g:1:1063: INTO
                this.mINTO(); 


                break;
            case 133 :
                // xquery/XQueryLexer.g:1:1068: LAST
                this.mLAST(); 


                break;
            case 134 :
                // xquery/XQueryLexer.g:1:1073: MODIFY
                this.mMODIFY(); 


                break;
            case 135 :
                // xquery/XQueryLexer.g:1:1080: NODES
                this.mNODES(); 


                break;
            case 136 :
                // xquery/XQueryLexer.g:1:1086: RENAME
                this.mRENAME(); 


                break;
            case 137 :
                // xquery/XQueryLexer.g:1:1093: REPLACE
                this.mREPLACE(); 


                break;
            case 138 :
                // xquery/XQueryLexer.g:1:1101: REVALIDATION
                this.mREVALIDATION(); 


                break;
            case 139 :
                // xquery/XQueryLexer.g:1:1114: SKIP
                this.mSKIP(); 


                break;
            case 140 :
                // xquery/XQueryLexer.g:1:1119: UPDATING
                this.mUPDATING(); 


                break;
            case 141 :
                // xquery/XQueryLexer.g:1:1128: VALUE
                this.mVALUE(); 


                break;
            case 142 :
                // xquery/XQueryLexer.g:1:1134: WITH
                this.mWITH(); 


                break;
            case 143 :
                // xquery/XQueryLexer.g:1:1139: ALL
                this.mALL(); 


                break;
            case 144 :
                // xquery/XQueryLexer.g:1:1143: ANY
                this.mANY(); 


                break;
            case 145 :
                // xquery/XQueryLexer.g:1:1147: CONTAINS
                this.mCONTAINS(); 


                break;
            case 146 :
                // xquery/XQueryLexer.g:1:1156: CONTENT
                this.mCONTENT(); 


                break;
            case 147 :
                // xquery/XQueryLexer.g:1:1164: DIACRITICS
                this.mDIACRITICS(); 


                break;
            case 148 :
                // xquery/XQueryLexer.g:1:1175: DIFFERENT
                this.mDIFFERENT(); 


                break;
            case 149 :
                // xquery/XQueryLexer.g:1:1185: DISTANCE
                this.mDISTANCE(); 


                break;
            case 150 :
                // xquery/XQueryLexer.g:1:1194: ENTIRE
                this.mENTIRE(); 


                break;
            case 151 :
                // xquery/XQueryLexer.g:1:1201: EXACTLY
                this.mEXACTLY(); 


                break;
            case 152 :
                // xquery/XQueryLexer.g:1:1209: FROM
                this.mFROM(); 


                break;
            case 153 :
                // xquery/XQueryLexer.g:1:1214: FT_OPTION
                this.mFT_OPTION(); 


                break;
            case 154 :
                // xquery/XQueryLexer.g:1:1224: FTAND
                this.mFTAND(); 


                break;
            case 155 :
                // xquery/XQueryLexer.g:1:1230: FTNOT
                this.mFTNOT(); 


                break;
            case 156 :
                // xquery/XQueryLexer.g:1:1236: FTOR
                this.mFTOR(); 


                break;
            case 157 :
                // xquery/XQueryLexer.g:1:1241: INSENSITIVE
                this.mINSENSITIVE(); 


                break;
            case 158 :
                // xquery/XQueryLexer.g:1:1253: LANGUAGE
                this.mLANGUAGE(); 


                break;
            case 159 :
                // xquery/XQueryLexer.g:1:1262: LEVELS
                this.mLEVELS(); 


                break;
            case 160 :
                // xquery/XQueryLexer.g:1:1269: LOWERCASE
                this.mLOWERCASE(); 


                break;
            case 161 :
                // xquery/XQueryLexer.g:1:1279: MOST
                this.mMOST(); 


                break;
            case 162 :
                // xquery/XQueryLexer.g:1:1284: NO
                this.mNO(); 


                break;
            case 163 :
                // xquery/XQueryLexer.g:1:1287: NOT
                this.mNOT(); 


                break;
            case 164 :
                // xquery/XQueryLexer.g:1:1291: OCCURS
                this.mOCCURS(); 


                break;
            case 165 :
                // xquery/XQueryLexer.g:1:1298: PARAGRAPH
                this.mPARAGRAPH(); 


                break;
            case 166 :
                // xquery/XQueryLexer.g:1:1308: PARAGRAPHS
                this.mPARAGRAPHS(); 


                break;
            case 167 :
                // xquery/XQueryLexer.g:1:1319: PHRASE
                this.mPHRASE(); 


                break;
            case 168 :
                // xquery/XQueryLexer.g:1:1326: RELATIONSHIP
                this.mRELATIONSHIP(); 


                break;
            case 169 :
                // xquery/XQueryLexer.g:1:1339: SAME
                this.mSAME(); 


                break;
            case 170 :
                // xquery/XQueryLexer.g:1:1344: SCORE
                this.mSCORE(); 


                break;
            case 171 :
                // xquery/XQueryLexer.g:1:1350: SENSITIVE
                this.mSENSITIVE(); 


                break;
            case 172 :
                // xquery/XQueryLexer.g:1:1360: SENTENCE
                this.mSENTENCE(); 


                break;
            case 173 :
                // xquery/XQueryLexer.g:1:1369: SENTENCES
                this.mSENTENCES(); 


                break;
            case 174 :
                // xquery/XQueryLexer.g:1:1379: STEMMING
                this.mSTEMMING(); 


                break;
            case 175 :
                // xquery/XQueryLexer.g:1:1388: STOP
                this.mSTOP(); 


                break;
            case 176 :
                // xquery/XQueryLexer.g:1:1393: THESAURUS
                this.mTHESAURUS(); 


                break;
            case 177 :
                // xquery/XQueryLexer.g:1:1403: TIMES
                this.mTIMES(); 


                break;
            case 178 :
                // xquery/XQueryLexer.g:1:1409: UPPERCASE
                this.mUPPERCASE(); 


                break;
            case 179 :
                // xquery/XQueryLexer.g:1:1419: USING
                this.mUSING(); 


                break;
            case 180 :
                // xquery/XQueryLexer.g:1:1425: WEIGHT
                this.mWEIGHT(); 


                break;
            case 181 :
                // xquery/XQueryLexer.g:1:1432: WILDCARDS
                this.mWILDCARDS(); 


                break;
            case 182 :
                // xquery/XQueryLexer.g:1:1442: WITHOUT
                this.mWITHOUT(); 


                break;
            case 183 :
                // xquery/XQueryLexer.g:1:1450: WORD
                this.mWORD(); 


                break;
            case 184 :
                // xquery/XQueryLexer.g:1:1455: WORDS
                this.mWORDS(); 


                break;
            case 185 :
                // xquery/XQueryLexer.g:1:1461: BREAK
                this.mBREAK(); 


                break;
            case 186 :
                // xquery/XQueryLexer.g:1:1467: CONTINUE
                this.mCONTINUE(); 


                break;
            case 187 :
                // xquery/XQueryLexer.g:1:1476: EXIT
                this.mEXIT(); 


                break;
            case 188 :
                // xquery/XQueryLexer.g:1:1481: LOOP
                this.mLOOP(); 


                break;
            case 189 :
                // xquery/XQueryLexer.g:1:1486: RETURNING
                this.mRETURNING(); 


                break;
            case 190 :
                // xquery/XQueryLexer.g:1:1496: WHILE
                this.mWHILE(); 


                break;
            case 191 :
                // xquery/XQueryLexer.g:1:1502: CHECK
                this.mCHECK(); 


                break;
            case 192 :
                // xquery/XQueryLexer.g:1:1508: COLLECTION
                this.mCOLLECTION(); 


                break;
            case 193 :
                // xquery/XQueryLexer.g:1:1519: CONSTRAINT
                this.mCONSTRAINT(); 


                break;
            case 194 :
                // xquery/XQueryLexer.g:1:1530: FOREACH
                this.mFOREACH(); 


                break;
            case 195 :
                // xquery/XQueryLexer.g:1:1538: FOREIGN
                this.mFOREIGN(); 


                break;
            case 196 :
                // xquery/XQueryLexer.g:1:1546: INDEX
                this.mINDEX(); 


                break;
            case 197 :
                // xquery/XQueryLexer.g:1:1552: INTEGRITY
                this.mINTEGRITY(); 


                break;
            case 198 :
                // xquery/XQueryLexer.g:1:1562: KEY
                this.mKEY(); 


                break;
            case 199 :
                // xquery/XQueryLexer.g:1:1566: ON
                this.mON(); 


                break;
            case 200 :
                // xquery/XQueryLexer.g:1:1569: UNIQUE
                this.mUNIQUE(); 


                break;
            case 201 :
                // xquery/XQueryLexer.g:1:1576: BINARY
                this.mBINARY(); 


                break;
            case 202 :
                // xquery/XQueryLexer.g:1:1583: AMP_ER
                this.mAMP_ER(); 


                break;
            case 203 :
                // xquery/XQueryLexer.g:1:1590: APOS_ER
                this.mAPOS_ER(); 


                break;
            case 204 :
                // xquery/XQueryLexer.g:1:1598: QUOT_ER
                this.mQUOT_ER(); 


                break;
            case 205 :
                // xquery/XQueryLexer.g:1:1606: CONCAT
                this.mCONCAT(); 


                break;
            case 206 :
                // xquery/XQueryLexer.g:1:1613: LPAREN
                this.mLPAREN(); 


                break;
            case 207 :
                // xquery/XQueryLexer.g:1:1620: RPAREN
                this.mRPAREN(); 


                break;
            case 208 :
                // xquery/XQueryLexer.g:1:1627: DOLLAR
                this.mDOLLAR(); 


                break;
            case 209 :
                // xquery/XQueryLexer.g:1:1634: LBRACKET
                this.mLBRACKET(); 


                break;
            case 210 :
                // xquery/XQueryLexer.g:1:1643: RBRACKET
                this.mRBRACKET(); 


                break;
            case 211 :
                // xquery/XQueryLexer.g:1:1652: LSQUARE
                this.mLSQUARE(); 


                break;
            case 212 :
                // xquery/XQueryLexer.g:1:1660: RSQUARE
                this.mRSQUARE(); 


                break;
            case 213 :
                // xquery/XQueryLexer.g:1:1668: EQUAL
                this.mEQUAL(); 


                break;
            case 214 :
                // xquery/XQueryLexer.g:1:1674: BIND
                this.mBIND(); 


                break;
            case 215 :
                // xquery/XQueryLexer.g:1:1679: NOTEQUAL
                this.mNOTEQUAL(); 


                break;
            case 216 :
                // xquery/XQueryLexer.g:1:1688: ANN_PERCENT
                this.mANN_PERCENT(); 


                break;
            case 217 :
                // xquery/XQueryLexer.g:1:1700: HASH
                this.mHASH(); 


                break;
            case 218 :
                // xquery/XQueryLexer.g:1:1705: AMP
                this.mAMP(); 


                break;
            case 219 :
                // xquery/XQueryLexer.g:1:1709: COMMA
                this.mCOMMA(); 


                break;
            case 220 :
                // xquery/XQueryLexer.g:1:1715: QUESTION
                this.mQUESTION(); 


                break;
            case 221 :
                // xquery/XQueryLexer.g:1:1724: STAR
                this.mSTAR(); 


                break;
            case 222 :
                // xquery/XQueryLexer.g:1:1729: PLUS
                this.mPLUS(); 


                break;
            case 223 :
                // xquery/XQueryLexer.g:1:1734: MINUS
                this.mMINUS(); 


                break;
            case 224 :
                // xquery/XQueryLexer.g:1:1740: SMALLER
                this.mSMALLER(); 


                break;
            case 225 :
                // xquery/XQueryLexer.g:1:1748: GREATER
                this.mGREATER(); 


                break;
            case 226 :
                // xquery/XQueryLexer.g:1:1756: SMALLEREQ
                this.mSMALLEREQ(); 


                break;
            case 227 :
                // xquery/XQueryLexer.g:1:1766: GREATEREQ
                this.mGREATEREQ(); 


                break;
            case 228 :
                // xquery/XQueryLexer.g:1:1776: SMALLER_SMALLER
                this.mSMALLER_SMALLER(); 


                break;
            case 229 :
                // xquery/XQueryLexer.g:1:1792: GREATER_GREATER
                this.mGREATER_GREATER(); 


                break;
            case 230 :
                // xquery/XQueryLexer.g:1:1808: SLASH
                this.mSLASH(); 


                break;
            case 231 :
                // xquery/XQueryLexer.g:1:1814: SLASH_SLASH
                this.mSLASH_SLASH(); 


                break;
            case 232 :
                // xquery/XQueryLexer.g:1:1826: DOT
                this.mDOT(); 


                break;
            case 233 :
                // xquery/XQueryLexer.g:1:1830: DOT_DOT
                this.mDOT_DOT(); 


                break;
            case 234 :
                // xquery/XQueryLexer.g:1:1838: COLON
                this.mCOLON(); 


                break;
            case 235 :
                // xquery/XQueryLexer.g:1:1844: COLON_COLON
                this.mCOLON_COLON(); 


                break;
            case 236 :
                // xquery/XQueryLexer.g:1:1856: EMPTY_CLOSE_TAG
                this.mEMPTY_CLOSE_TAG(); 


                break;
            case 237 :
                // xquery/XQueryLexer.g:1:1872: CLOSE_TAG
                this.mCLOSE_TAG(); 


                break;
            case 238 :
                // xquery/XQueryLexer.g:1:1882: SEMICOLON
                this.mSEMICOLON(); 


                break;
            case 239 :
                // xquery/XQueryLexer.g:1:1892: VBAR
                this.mVBAR(); 


                break;
            case 240 :
                // xquery/XQueryLexer.g:1:1897: PRAGMA_START
                this.mPRAGMA_START(); 


                break;
            case 241 :
                // xquery/XQueryLexer.g:1:1910: PRAGMA_END
                this.mPRAGMA_END(); 


                break;
            case 242 :
                // xquery/XQueryLexer.g:1:1921: XML_COMMENT_START
                this.mXML_COMMENT_START(); 


                break;
            case 243 :
                // xquery/XQueryLexer.g:1:1939: XML_COMMENT_END
                this.mXML_COMMENT_END(); 


                break;
            case 244 :
                // xquery/XQueryLexer.g:1:1955: PI_START
                this.mPI_START(); 


                break;
            case 245 :
                // xquery/XQueryLexer.g:1:1964: PI_END
                this.mPI_END(); 


                break;
            case 246 :
                // xquery/XQueryLexer.g:1:1971: ATTR_SIGN
                this.mATTR_SIGN(); 


                break;
            case 247 :
                // xquery/XQueryLexer.g:1:1981: CHARREF_DEC
                this.mCHARREF_DEC(); 


                break;
            case 248 :
                // xquery/XQueryLexer.g:1:1993: CHARREF_HEX
                this.mCHARREF_HEX(); 


                break;
            case 249 :
                // xquery/XQueryLexer.g:1:2005: APOS
                this.mAPOS(); 


                break;
            case 250 :
                // xquery/XQueryLexer.g:1:2010: QUOT
                this.mQUOT(); 


                break;
            case 251 :
                // xquery/XQueryLexer.g:1:2015: L_NCName
                this.mL_NCName(); 


                break;
            case 252 :
                // xquery/XQueryLexer.g:1:2024: S
                this.mS(); 


                break;
            case 253 :
                // xquery/XQueryLexer.g:1:2026: L_Pragma
                this.mL_Pragma(); 


                break;
            case 254 :
                // xquery/XQueryLexer.g:1:2035: L_DirCommentConstructor
                this.mL_DirCommentConstructor(); 


                break;
            case 255 :
                // xquery/XQueryLexer.g:1:2059: L_DirPIConstructor
                this.mL_DirPIConstructor(); 


                break;
            case 256 :
                // xquery/XQueryLexer.g:1:2078: L_IntegerLiteral
                this.mL_IntegerLiteral(); 


                break;
            case 257 :
                // xquery/XQueryLexer.g:1:2095: L_DecimalLiteral
                this.mL_DecimalLiteral(); 


                break;
            case 258 :
                // xquery/XQueryLexer.g:1:2112: L_DoubleLiteral
                this.mL_DoubleLiteral(); 


                break;
            case 259 :
                // xquery/XQueryLexer.g:1:2128: L_Comment
                this.mL_Comment(); 


                break;
            case 260 :
                // xquery/XQueryLexer.g:1:2138: L_AnyChar
                this.mL_AnyChar(); 


                break;

        }

    }

}, true); // important to pass true to overwrite default implementations

org.antlr.lang.augmentObject(XQueryLexer, {
    DFA19_eotS:
        "\u0001\uffff\u0018\u003f\u0001\u0091\u0001\u0094\u0007\uffff\u0001"+
    "\u009e\u0001\u0037\u0001\uffff\u0001\u00a2\u0001\u00a4\u0001\uffff\u0001"+
    "\u00a7\u0002\uffff\u0001\u00ab\u0001\u00b1\u0001\u00b4\u0001\u00b7\u0001"+
    "\u00b9\u0006\uffff\u0001\u00c0\u0001\uffff\u0001\u003f\u0001\u00c8\u0001"+
    "\u00ca\u0004\u003f\u0001\uffff\u0002\u003f\u0001\u00d1\u000c\u003f\u0001"+
    "\u00ee\u0007\u003f\u0001\u00fd\u0001\u003f\u0001\u0100\u0001\u003f\u0001"+
    "\u0102\u0001\u003f\u0001\u0109\u0001\u010a\u0002\u003f\u0001\u0112\u0001"+
    "\u0113\u0004\u003f\u0001\u011b\u0001\u011f\u0001\u0120\u0001\u003f\u0001"+
    "\u0123\u0001\u0125\u0010\u003f\u0001\u0142\u0012\u003f\u0002\uffff\u0001"+
    "\u015c\u0010\uffff\u0001\u015f\u000c\uffff\u0001\u0161\u0009\uffff\u0001"+
    "\u0163\u0006\uffff\u0001\u00c0\u0001\u0163\u0001\uffff\u0001\u003f\u0001"+
    "\u0166\u0001\u0167\u0001\u003f\u0001\uffff\u0001\u003f\u0001\uffff\u0001"+
    "\u016b\u0001\u003f\u0001\u016d\u0003\u003f\u0001\uffff\u0010\u003f\u0001"+
    "\u0184\u0009\u003f\u0001\u018e\u0001\u003f\u0001\uffff\u0006\u003f\u0001"+
    "\u0197\u0007\u003f\u0001\uffff\u0002\u003f\u0001\uffff\u0001\u003f\u0001"+
    "\uffff\u0006\u003f\u0002\uffff\u0001\u003f\u0001\u01ab\u0003\u003f\u0001"+
    "\u01af\u0001\u003f\u0002\uffff\u0002\u003f\u0001\u01b5\u0004\u003f\u0001"+
    "\uffff\u0002\u003f\u0001\u01bd\u0002\uffff\u0002\u003f\u0001\uffff\u0001"+
    "\u003f\u0001\uffff\u001c\u003f\u0001\uffff\u0001\u003f\u0001\u01e5\u0013"+
    "\u003f\u0001\u01fc\u0001\u003f\u0001\u01fe\u0001\u003f\u0008\uffff\u0001"+
    "\u0163\u0001\u003f\u0002\uffff\u0003\u003f\u0001\uffff\u0001\u003f\u0001"+
    "\uffff\u0001\u0206\u0005\u003f\u0001\u020c\u0001\u020e\u0007\u003f\u0001"+
    "\u021a\u0006\u003f\u0001\uffff\u0006\u003f\u0001\u0227\u0002\u003f\u0001"+
    "\uffff\u0005\u003f\u0001\u022f\u0002\u003f\u0001\uffff\u0002\u003f\u0001"+
    "\u0235\u0003\u003f\u0001\u0239\u0002\u003f\u0001\u023c\u0005\u003f\u0001"+
    "\u0244\u0002\u003f\u0001\u0247\u0001\uffff\u0001\u0248\u0002\u003f\u0001"+
    "\uffff\u0002\u003f\u0001\u024d\u0002\u003f\u0001\uffff\u0001\u0250\u0002"+
    "\u003f\u0001\u0253\u0002\u003f\u0001\u0257\u0001\uffff\u0002\u003f\u0001"+
    "\u025a\u0011\u003f\u0001\u026c\u0002\u003f\u0001\u026f\u0002\u003f\u0001"+
    "\u0272\u0004\u003f\u0001\u0278\u0002\u003f\u0001\u027b\u0001\u027c\u0001"+
    "\u027d\u0002\u003f\u0001\uffff\u0001\u0281\u000d\u003f\u0001\u028f\u0002"+
    "\u003f\u0001\u0293\u0002\u003f\u0001\u0297\u0001\u003f\u0001\uffff\u0001"+
    "\u003f\u0001\uffff\u0001\u029a\u0001\u029b\u0004\u003f\u0001\u02a1\u0001"+
    "\uffff\u0003\u003f\u0001\u02a5\u0001\u003f\u0001\uffff\u0001\u003f\u0001"+
    "\uffff\u0001\u02a8\u0001\u02a9\u0001\u02aa\u0008\u003f\u0001\uffff\u0001"+
    "\u02b4\u0005\u003f\u0001\u02ba\u0005\u003f\u0001\uffff\u0001\u02c1\u0002"+
    "\u003f\u0001\u02c4\u0003\u003f\u0001\uffff\u0004\u003f\u0001\u02cc\u0001"+
    "\uffff\u0001\u003f\u0001\u02ce\u0001\u02cf\u0001\uffff\u0001\u003f\u0001"+
    "\u02d2\u0001\uffff\u0007\u003f\u0001\uffff\u0001\u003f\u0001\u02db\u0002"+
    "\uffff\u0001\u003f\u0001\u02dd\u0002\u003f\u0001\uffff\u0002\u003f\u0001"+
    "\uffff\u0002\u003f\u0001\uffff\u0002\u003f\u0001\u02e6\u0001\uffff\u0001"+
    "\u003f\u0001\u02ea\u0001\uffff\u0011\u003f\u0001\uffff\u0001\u003f\u0001"+
    "\u02fd\u0001\uffff\u0002\u003f\u0001\uffff\u0001\u003f\u0001\u0301\u0001"+
    "\u003f\u0001\u0303\u0001\u003f\u0001\uffff\u0002\u003f\u0003\uffff\u0001"+
    "\u003f\u0001\u0308\u0001\u003f\u0001\uffff\u0001\u003f\u0001\u030b\u0001"+
    "\u030c\u0004\u003f\u0001\u0311\u0001\u003f\u0001\u0313\u0002\u003f\u0001"+
    "\u0316\u0001\uffff\u0001\u0317\u0002\u003f\u0001\uffff\u0002\u003f\u0001"+
    "\u031c\u0001\uffff\u0002\u003f\u0003\uffff\u0004\u003f\u0001\uffff\u0002"+
    "\u003f\u0001\u0325\u0001\uffff\u0001\u0326\u0001\u003f\u0003\uffff\u0009"+
    "\u003f\u0001\uffff\u0004\u003f\u0001\u0336\u0001\uffff\u0006\u003f\u0001"+
    "\uffff\u0001\u003f\u0001\u033e\u0001\uffff\u0001\u033f\u0006\u003f\u0001"+
    "\uffff\u0001\u003f\u0002\uffff\u0002\u003f\u0001\uffff\u0001\u0349\u0002"+
    "\u003f\u0001\u034c\u0004\u003f\u0001\uffff\u0001\u003f\u0001\uffff\u0001"+
    "\u0352\u0001\u003f\u0001\u0354\u0001\u0355\u0004\u003f\u0001\uffff\u0001"+
    "\u035a\u0002\u003f\u0001\uffff\u0001\u035d\u0001\u035e\u0008\u003f\u0001"+
    "\u0367\u0001\u0369\u0001\u036a\u0004\u003f\u0001\u0370\u0001\uffff\u0002"+
    "\u003f\u0001\u0373\u0001\uffff\u0001\u0374\u0001\uffff\u0002\u003f\u0001"+
    "\u0377\u0001\u003f\u0001\uffff\u0002\u003f\u0002\uffff\u0001\u037b\u0003"+
    "\u003f\u0001\uffff\u0001\u003f\u0001\uffff\u0002\u003f\u0002\uffff\u0001"+
    "\u0382\u0002\u003f\u0001\u0385\u0001\uffff\u0001\u0386\u0007\u003f\u0002"+
    "\uffff\u0003\u003f\u0001\u0391\u0002\u003f\u0001\u0394\u0001\u0395\u0003"+
    "\u003f\u0001\u0399\u0001\u003f\u0001\u039b\u0001\u003f\u0001\uffff\u0004"+
    "\u003f\u0001\u03a2\u0002\u003f\u0002\uffff\u0001\u003f\u0001\u03a6\u0001"+
    "\u003f\u0001\u03a8\u0001\u03a9\u0004\u003f\u0001\uffff\u0001\u03ae\u0001"+
    "\u003f\u0001\uffff\u0005\u003f\u0001\uffff\u0001\u003f\u0002\uffff\u0004"+
    "\u003f\u0001\uffff\u0001\u03ba\u0001\u003f\u0002\uffff\u0006\u003f\u0001"+
    "\u03c2\u0001\u003f\u0001\uffff\u0001\u003f\u0002\uffff\u0001\u03c5\u0004"+
    "\u003f\u0001\uffff\u0002\u003f\u0002\uffff\u0001\u003f\u0001\u03ce\u0001"+
    "\uffff\u0003\u003f\u0001\uffff\u0005\u003f\u0001\u03d7\u0001\uffff\u0001"+
    "\u03d8\u0001\u003f\u0002\uffff\u0001\u003f\u0001\u03dc\u0002\u003f\u0001"+
    "\u03df\u0001\u03e0\u0001\u003f\u0001\u03e2\u0002\u003f\u0001\uffff\u0002"+
    "\u003f\u0002\uffff\u0001\u03e7\u0001\u03e8\u0001\u003f\u0001\uffff\u0001"+
    "\u003f\u0001\uffff\u0004\u003f\u0001\u03f0\u0001\u03f2\u0001\uffff\u0001"+
    "\u003f\u0001\u03f4\u0001\u03f5\u0001\uffff\u0001\u003f\u0002\uffff\u0001"+
    "\u03f7\u0001\u003f\u0001\u03f9\u0001\u003f\u0001\uffff\u0001\u03fb\u0003"+
    "\u003f\u0001\u03ff\u0001\u0400\u0005\u003f\u0001\uffff\u0001\u0406\u0003"+
    "\u003f\u0001\u040a\u0001\u040b\u0001\u003f\u0001\uffff\u0002\u003f\u0001"+
    "\uffff\u0006\u003f\u0001\u0416\u0001\u0417\u0001\uffff\u0002\u003f\u0001"+
    "\u041a\u0001\u003f\u0001\u041c\u0001\u003f\u0001\u041e\u0001\u041f\u0002"+
    "\uffff\u0003\u003f\u0001\uffff\u0001\u0423\u0001\u0424\u0002\uffff\u0001"+
    "\u003f\u0001\uffff\u0001\u0426\u0003\u003f\u0002\uffff\u0006\u003f\u0001"+
    "\u0430\u0001\uffff\u0001\u003f\u0001\uffff\u0001\u003f\u0002\uffff\u0001"+
    "\u0434\u0001\uffff\u0001\u0435\u0001\uffff\u0001\u003f\u0001\uffff\u0001"+
    "\u003f\u0001\u0438\u0001\u0439\u0002\uffff\u0001\u043a\u0001\u003f\u0001"+
    "\u043d\u0002\u003f\u0001\uffff\u0001\u0441\u0001\u003f\u0001\u0444\u0002"+
    "\uffff\u0001\u003f\u0001\u0446\u0001\u0447\u0002\u003f\u0001\u044a\u0002"+
    "\u003f\u0001\u044d\u0001\u044e\u0002\uffff\u0001\u044f\u0001\u003f\u0001"+
    "\uffff\u0001\u0451\u0001\uffff\u0001\u0452\u0002\uffff\u0001\u0453\u0002"+
    "\u003f\u0002\uffff\u0001\u003f\u0001\uffff\u0001\u0457\u0001\u003f\u0001"+
    "\u0459\u0003\u003f\u0001\u045e\u0001\u045f\u0001\u0460\u0001\uffff\u0003"+
    "\u003f\u0002\uffff\u0002\u003f\u0003\uffff\u0001\u0466\u0001\u003f\u0001"+
    "\uffff\u0001\u0468\u0001\u003f\u0001\u046a\u0001\uffff\u0002\u003f\u0001"+
    "\uffff\u0001\u003f\u0002\uffff\u0002\u003f\u0001\uffff\u0002\u003f\u0003"+
    "\uffff\u0001\u0472\u0003\uffff\u0001\u0473\u0002\u003f\u0001\uffff\u0001"+
    "\u003f\u0001\uffff\u0004\u003f\u0003\uffff\u0004\u003f\u0001\u047f\u0001"+
    "\uffff\u0001\u003f\u0001\uffff\u0001\u0481\u0001\uffff\u0007\u003f\u0002"+
    "\uffff\u0002\u003f\u0001\u048b\u0008\u003f\u0001\uffff\u0001\u003f\u0001"+
    "\uffff\u0003\u003f\u0001\u0498\u0001\u0499\u0004\u003f\u0001\uffff\u0004"+
    "\u003f\u0001\u04a2\u0007\u003f\u0002\uffff\u0003\u003f\u0001\u04ad\u0001"+
    "\u003f\u0001\u04af\u0002\u003f\u0001\uffff\u0001\u04b2\u0002\u003f\u0001"+
    "\u04b5\u0004\u003f\u0001\u04ba\u0001\u003f\u0001\uffff\u0001\u04bc\u0001"+
    "\uffff\u0002\u003f\u0001\uffff\u0002\u003f\u0001\uffff\u0004\u003f\u0001"+
    "\uffff\u0001\u04c5\u0001\uffff\u0007\u003f\u0001\u04cd\u0001\uffff\u0001"+
    "\u04ce\u0001\u003f\u0001\u04d0\u0001\u003f\u0001\u04d2\u0001\u04d3\u0001"+
    "\u003f\u0002\uffff\u0001\u04d5\u0001\uffff\u0001\u04d6\u0002\uffff\u0001"+
    "\u003f\u0002\uffff\u0003\u003f\u0001\u04db\u0001\uffff",
    DFA19_eofS:
        "\u04dc\uffff",
    DFA19_minS:
        "\u0001\u0000\u0001\u0066\u0002\u0061\u0001\u0065\u0001\u006c\u0001"+
    "\u0069\u0001\u0065\u0001\u0064\u0001\u0061\u0001\u0069\u0001\u0061\u0001"+
    "\u0063\u0001\u0061\u0001\u0065\u0001\u0061\u0001\u0065\u0001\u006e\u0001"+
    "\u0061\u0001\u0065\u0001\u0071\u0001\u0061\u0002\u0065\u0001\u0075\u0001"+
    "\u007c\u0001\u0023\u0007\uffff\u0001\u003a\u0001\u003d\u0001\uffff\u0001"+
    "\u0029\u0001\u0023\u0001\uffff\u0001\u003e\u0002\uffff\u0001\u002d\u0001"+
    "\u0021\u0001\u003d\u0001\u002f\u0001\u002e\u0006\uffff\u0001\u002e\u0001"+
    "\uffff\u0001\u0063\u0002\u002d\u0001\u006c\u0001\u0074\u0001\u0070\u0001"+
    "\u006f\u0001\uffff\u0001\u0073\u0001\u0075\u0001\u002d\u0001\u0066\u0001"+
    "\u0065\u0001\u006e\u0001\u0073\u0001\u0065\u0001\u006c\u0001\u0063\u0001"+
    "\u0061\u0001\u0063\u0001\u0065\u0001\u0070\u0001\u0063\u0001\u002d\u0001"+
    "\u0065\u0001\u0061\u0001\u006c\u0001\u006e\u0001\u0072\u0001\u006f\u0002"+
    "\u002d\u0001\u0065\u0001\u002d\u0001\u0069\u0001\u002d\u0001\u0070\u0002"+
    "\u002d\u0001\u0065\u0001\u006e\u0002\u002d\u0001\u006f\u0001\u0064\u0001"+
    "\u006e\u0001\u006d\u0003\u002d\u0001\u0074\u0002\u002d\u0001\u0063\u0001"+
    "\u0072\u0001\u0065\u0002\u0072\u0001\u006c\u0001\u006d\u0001\u0068\u0001"+
    "\u006c\u0001\u006d\u0001\u0061\u0003\u0069\u0001\u0078\u0001\u0065\u0001"+
    "\u002d\u0001\u0065\u0001\u0070\u0002\u006d\u0001\u0069\u0001\u0064\u0001"+
    "\u0069\u0001\u006c\u0001\u0072\u0001\u0065\u0001\u006c\u0001\u0069\u0001"+
    "\u0072\u0001\u0075\u0001\u004e\u0001\u0072\u0001\u0079\u0001\u006f\u0002"+
    "\uffff\u0001\u0009\u0010\uffff\u0001\u0078\u000b\uffff\u0001\u002d\u0001"+
    "\u0009\u0009\uffff\u0001\u0030\u0006\uffff\u0001\u002e\u0001\u0030\u0001"+
    "\uffff\u0001\u0065\u0002\u002d\u0001\u0065\u0001\uffff\u0001\u0072\u0001"+
    "\uffff\u0001\u002d\u0001\u0065\u0001\u002d\u0001\u0073\u0001\u0065\u0001"+
    "\u006e\u0001\uffff\u0001\u006f\u0002\u0061\u0001\u0065\u0001\u0063\u0001"+
    "\u006c\u0001\u0063\u0001\u006c\u0001\u006d\u0001\u0073\u0001\u0079\u0001"+
    "\u006e\u0001\u0069\u0001\u0061\u0001\u0063\u0001\u0065\u0001\u002d\u0001"+
    "\u0069\u0001\u0063\u0001\u0066\u0001\u0074\u0001\u0075\u0001\u006d\u0001"+
    "\u0065\u0001\u0074\u0001\u006f\u0001\u002d\u0001\u0069\u0001\uffff\u0001"+
    "\u0072\u0002\u0065\u0001\u0063\u0001\u0074\u0001\u006c\u0001\u002d\u0001"+
    "\u0063\u0001\u0073\u0001\u006d\u0001\u006f\u0001\u006e\u0001\u006f\u0001"+
    "\u0072\u0001\uffff\u0001\u0061\u0001\u0075\u0001\uffff\u0001\u0076\u0001"+
    "\uffff\u0001\u006f\u0003\u0065\u0001\u0069\u0001\u0065\u0002\uffff\u0001"+
    "\u006d\u0001\u002d\u0001\u0074\u0001\u0067\u0001\u0073\u0001\u002d\u0001"+
    "\u0065\u0002\uffff\u0001\u0065\u0001\u0070\u0001\u002d\u0001\u0074\u0001"+
    "\u0075\u0001\u0065\u0001\u0074\u0001\uffff\u0001\u0069\u0001\u0065\u0001"+
    "\u002d\u0002\uffff\u0001\u0069\u0001\u0065\u0001\uffff\u0001\u0079\u0001"+
    "\uffff\u0001\u0075\u0001\u0061\u0001\u0074\u0002\u0063\u0001\u002d\u0001"+
    "\u0061\u0001\u0075\u0001\u0061\u0001\u006c\u0002\u0061\u0001\u0069\u0002"+
    "\u0065\u0001\u0072\u0001\u0066\u0001\u0073\u0001\u0065\u0001\u0062\u0001"+
    "\u0069\u0001\u006d\u0001\u0070\u0001\u0064\u0001\u0074\u0001\u0070\u0001"+
    "\u0074\u0001\u006e\u0001\uffff\u0001\u0061\u0001\u002d\u0001\u0065\u0001"+
    "\u0062\u0001\u0065\u0001\u006f\u0001\u0072\u0001\u0061\u0001\u0065\u0001"+
    "\u006e\u0002\u0069\u0001\u0073\u0001\u006e\u0001\u006c\u0001\u0064\u0001"+
    "\u0068\u0001\u0064\u0001\u0067\u0001\u0064\u0001\u0065\u0001\u002d\u0001"+
    "\u006f\u0001\u002d\u0001\u0074\u0004\uffff\u0001\u002d\u0003\uffff\u0001"+
    "\u0030\u0001\u0073\u0002\uffff\u0001\u006e\u0001\u0069\u0001\u0077\u0001"+
    "\uffff\u0001\u0072\u0001\uffff\u0002\u002d\u0001\u0064\u0001\u0072\u0001"+
    "\u006b\u0001\u0072\u0002\u002d\u0001\u0068\u0001\u0064\u0001\u006b\u0001"+
    "\u0061\u0001\u0065\u0001\u0074\u0001\u0061\u0001\u002d\u0001\u0074\u0001"+
    "\u0061\u0001\u006d\u0001\u0075\u0001\u0065\u0001\u0074\u0001\uffff\u0001"+
    "\u0074\u0001\u0072\u0001\u0065\u0001\u0061\u0001\u006d\u0001\u0065\u0001"+
    "\u002d\u0001\u0079\u0001\u0064\u0001\uffff\u0001\u0072\u0001\u0079\u0001"+
    "\u0070\u0001\u0072\u0001\u0074\u0001\u002d\u0001\u006f\u0001\u0061\u0001"+
    "\uffff\u0002\u0074\u0001\u002d\u0001\u0070\u0001\u0064\u0001\u0074\u0001"+
    "\u002d\u0001\u0074\u0001\u0070\u0001\u002d\u0002\u0072\u0001\u0061\u0001"+
    "\u006e\u0001\u0067\u0001\u002d\u0001\u006e\u0001\u0078\u0001\u002d\u0001"+
    "\uffff\u0001\u002d\u0001\u0075\u0001\u0074\u0001\uffff\u0001\u006c\u0001"+
    "\u0072\u0001\u002d\u0001\u006c\u0001\u0066\u0001\uffff\u0001\u002d\u0002"+
    "\u0073\u0001\u002d\u0001\u006e\u0001\u0072\u0001\u002d\u0001\uffff\u0001"+
    "\u006f\u0001\u0072\u0001\u002d\u0001\u0072\u0001\u006e\u0001\u0067\u0003"+
    "\u0065\u0001\u0069\u0002\u0065\u0001\u006d\u0001\u0073\u0001\u0072\u0001"+
    "\u006d\u0001\u0061\u0001\u006c\u0001\u0074\u0001\u0073\u0001\u002d\u0001"+
    "\u006d\u0001\u0065\u0001\u002d\u0001\u0069\u0001\u0065\u0001\u002d\u0001"+
    "\u006c\u0001\u0074\u0001\u0063\u0001\u006d\u0001\u002d\u0001\u0069\u0001"+
    "\u0063\u0003\u002d\u0001\u0061\u0001\u0074\u0001\uffff\u0001\u002d\u0001"+
    "\u006c\u0001\u0073\u0001\u006e\u0001\u0075\u0001\u0064\u0001\u0074\u0001"+
    "\u0072\u0001\u0067\u0001\u0064\u0001\u0065\u0001\u0061\u0001\u0069\u0001"+
    "\u0065\u0001\u002d\u0001\u0065\u0001\u006f\u0001\u002d\u0001\u0063\u0001"+
    "\u0068\u0001\u002d\u0001\u0072\u0001\uffff\u0001\u002d\u0001\uffff\u0001"+
    "\u002d\u0001\u0000\u0001\u0074\u0001\u0064\u0001\u0062\u0001\u0069\u0001"+
    "\u002d\u0001\uffff\u0001\u0075\u0001\u0061\u0001\u0065\u0001\u002d\u0001"+
    "\u0079\u0001\uffff\u0001\u0062\u0001\uffff\u0003\u002d\u0001\u0074\u0001"+
    "\u0063\u0001\u006e\u0001\u0072\u0001\u006e\u0001\u0069\u0002\u006e\u0001"+
    "\uffff\u0001\u002d\u0001\u0072\u0001\u0061\u0001\u006c\u0001\u006e\u0001"+
    "\u0065\u0001\u002d\u0001\u0069\u0001\u0072\u0001\u006e\u0001\u0065\u0001"+
    "\u006e\u0001\uffff\u0001\u002d\u0001\u0069\u0001\u0065\u0001\u002d\u0001"+
    "\u0074\u0001\u006e\u0001\u006c\u0001\uffff\u0001\u0077\u0001\u0063\u0001"+
    "\u0067\u0001\u0069\u0001\u002d\u0001\uffff\u0001\u0074\u0002\u002d\u0001"+
    "\uffff\u0001\u0065\u0001\u002d\u0001\uffff\u0001\u0074\u0001\u0069\u0001"+
    "\u006e\u0001\u0074\u0002\u0073\u0001\u0072\u0001\uffff\u0001\u0069\u0001"+
    "\u002d\u0002\uffff\u0001\u0061\u0001\u002d\u0001\u0073\u0001\u0063\u0001"+
    "\uffff\u0001\u0065\u0001\u0079\u0001\uffff\u0001\u002d\u0001\u0070\u0001"+
    "\uffff\u0001\u0068\u0001\u0065\u0001\u002d\u0001\uffff\u0001\u006e\u0001"+
    "\u002d\u0001\uffff\u0001\u0073\u0001\u0074\u0002\u0072\u0001\u0064\u0001"+
    "\u0072\u0001\u006f\u0001\u0073\u0001\u006e\u0001\u0069\u0001\u0065\u0001"+
    "\u006e\u0001\u0065\u0001\u0063\u0002\u0069\u0001\u0066\u0001\uffff\u0001"+
    "\u0061\u0001\u002d\u0001\uffff\u0001\u0074\u0001\u006e\u0001\uffff\u0001"+
    "\u0065\u0001\u002d\u0001\u0074\u0001\u002d\u0001\u0069\u0001\uffff\u0001"+
    "\u006e\u0001\u0068\u0003\uffff\u0001\u0075\u0001\u002d\u0001\u0077\u0001"+
    "\uffff\u0001\u0069\u0002\u002d\u0002\u0065\u0001\u0069\u0001\u0063\u0001"+
    "\u002d\u0001\u0061\u0001\u002d\u0001\u0062\u0001\u006f\u0001\u002d\u0001"+
    "\uffff\u0001\u002d\u0001\u0077\u0001\u0075\u0001\uffff\u0001\u0061\u0001"+
    "\u0074\u0001\u002d\u0001\uffff\u0001\u0079\u0001\u0064\u0003\uffff\u0001"+
    "\u006f\u0001\u0069\u0001\u0075\u0001\u006e\u0001\uffff\u0002\u0072\u0001"+
    "\u002d\u0001\uffff\u0001\u002d\u0001\u006c\u0003\uffff\u0001\u0069\u0002"+
    "\u0074\u0001\u0061\u0002\u0074\u0001\u006e\u0001\u0075\u0001\u0061\u0001"+
    "\uffff\u0001\u0065\u0001\u006c\u0001\u0074\u0001\u0064\u0001\u002d\u0001"+
    "\uffff\u0001\u0074\u0001\u0065\u0001\u0063\u0001\u006e\u0001\u0074\u0001"+
    "\u0073\u0001\uffff\u0001\u006e\u0001\u002d\u0001\uffff\u0001\u002d\u0001"+
    "\u0061\u0001\u0079\u0001\u0069\u0001\u0068\u0001\u006e\u0001\u006f\u0001"+
    "\uffff\u0001\u0069\u0002\uffff\u0001\u0073\u0001\u006e\u0001\uffff\u0001"+
    "\u002d\u0001\u0074\u0001\u0063\u0001\u002d\u0001\u0069\u0001\u0065\u0001"+
    "\u0069\u0001\u0074\u0001\uffff\u0001\u0067\u0001\uffff\u0001\u002d\u0001"+
    "\u0061\u0002\u002d\u0001\u0073\u0001\u0061\u0001\u0065\u0001\u0073\u0001"+
    "\uffff\u0001\u002d\u0001\u0064\u0001\u006e\u0001\uffff\u0002\u002d\u0001"+
    "\u0061\u0001\u006e\u0001\u0069\u0001\u0076\u0001\u0075\u0001\u0073\u0001"+
    "\u0074\u0001\u006c\u0003\u002d\u0001\u0065\u0001\u0064\u0001\u006f\u0001"+
    "\u0069\u0001\u002d\u0001\uffff\u0001\u0069\u0001\u0063\u0001\u002d\u0001"+
    "\uffff\u0001\u002d\u0001\uffff\u0001\u006e\u0001\u0067\u0001\u002d\u0001"+
    "\u0072\u0001\uffff\u0001\u0069\u0001\u006e\u0002\uffff\u0001\u002d\u0001"+
    "\u0072\u0001\u006e\u0001\u0061\u0001\uffff\u0001\u0074\u0001\uffff\u0001"+
    "\u006c\u0001\u006e\u0002\uffff\u0001\u002d\u0001\u0074\u0001\u0072\u0001"+
    "\u002d\u0001\uffff\u0001\u002d\u0001\u0069\u0001\u0072\u0001\u006e\u0001"+
    "\u0074\u0001\u0067\u0001\u0069\u0001\u0079\u0002\uffff\u0001\u0065\u0001"+
    "\u006f\u0001\u0069\u0001\u002d\u0001\u0063\u0001\u0069\u0002\u002d\u0001"+
    "\u0073\u0001\u0065\u0001\u006d\u0003\u002d\u0001\u0061\u0001\uffff\u0001"+
    "\u0069\u0001\u006e\u0001\u0065\u0001\u0074\u0001\u002d\u0001\u0065\u0001"+
    "\u0067\u0002\uffff\u0001\u006c\u0001\u002d\u0001\u006e\u0002\u002d\u0001"+
    "\u006e\u0001\u006f\u0001\u0074\u0001\u0067\u0001\uffff\u0001\u002d\u0001"+
    "\u0065\u0001\uffff\u0001\u0074\u0001\u0063\u0001\u0074\u0001\u0079\u0001"+
    "\u0065\u0001\uffff\u0001\u0073\u0002\uffff\u0001\u0069\u0001\u0063\u0001"+
    "\u0072\u0001\u0065\u0001\uffff\u0001\u002d\u0001\u0067\u0002\uffff\u0001"+
    "\u0070\u0001\u002d\u0001\u006e\u0001\u0065\u0001\u0073\u0001\u0069\u0001"+
    "\u002d\u0001\u006c\u0001\uffff\u0001\u006e\u0002\uffff\u0001\u002d\u0001"+
    "\u0061\u0001\u006e\u0001\u0065\u0001\u0061\u0001\uffff\u0001\u0076\u0001"+
    "\u0065\u0002\uffff\u0001\u0067\u0001\u002d\u0001\uffff\u0001\u0075\u0001"+
    "\u0074\u0001\u0067\u0001\uffff\u0001\u0065\u0001\u0067\u0001\u0073\u0002"+
    "\u0065\u0001\u002d\u0001\uffff\u0001\u002d\u0001\u0064\u0002\uffff\u0001"+
    "\u0067\u0001\u002d\u0001\u0067\u0001\u0065\u0004\u002d\u0001\u006e\u0001"+
    "\u006f\u0001\uffff\u0001\u0074\u0001\u006e\u0002\uffff\u0002\u002d\u0001"+
    "\u0065\u0001\uffff\u0001\u0066\u0001\uffff\u0002\u006e\u0001\u0063\u0001"+
    "\u0074\u0002\u002d\u0001\uffff\u0001\u0071\u0002\u002d\u0001\uffff\u0001"+
    "\u0067\u0002\uffff\u0001\u002d\u0001\u006e\u0002\u002d\u0001\uffff\u0001"+
    "\u002d\u0001\u0069\u0001\u0074\u0001\u0079\u0002\u002d\u0001\u0065\u0001"+
    "\u0067\u0001\u0065\u0001\u0069\u0001\u0072\u0001\uffff\u0001\u002d\u0001"+
    "\u0068\u0001\u0073\u0001\u0067\u0002\u002d\u0001\u006e\u0001\uffff\u0001"+
    "\u0065\u0001\u0067\u0001\uffff\u0001\u0074\u0002\u0073\u0001\u0074\u0001"+
    "\u006c\u0001\u0065\u0002\u002d\u0001\uffff\u0001\u0073\u0001\u0063\u0001"+
    "\u002d\u0001\u0064\u0001\u002d\u0001\u0065\u0002\u002d\u0002\uffff\u0001"+
    "\u0073\u0001\u0069\u0001\u006f\u0001\uffff\u0002\u002d\u0002\uffff\u0001"+
    "\u0073\u0001\uffff\u0001\u002d\u0001\u006e\u0001\u0069\u0001\u0074\u0002"+
    "\uffff\u0001\u0073\u0001\u006f\u0001\u0065\u0001\u0074\u0001\u0067\u0001"+
    "\u0073\u0001\u002d\u0001\uffff\u0001\u006e\u0001\uffff\u0001\u0075\u0002"+
    "\uffff\u0001\u002d\u0001\uffff\u0001\u002d\u0001\uffff\u0001\u0073\u0001"+
    "\uffff\u0001\u0076\u0002\u002d\u0002\uffff\u0001\u002d\u0001\u006e\u0001"+
    "\u002d\u0001\u0074\u0001\u0076\u0001\uffff\u0001\u002d\u0001\u0065\u0001"+
    "\u002d\u0002\uffff\u0001\u0067\u0002\u002d\u0001\u0069\u0001\u0068\u0001"+
    "\u002d\u0001\u0074\u0001\u0065\u0002\u002d\u0002\uffff\u0001\u002d\u0001"+
    "\u0068\u0001\uffff\u0001\u002d\u0001\uffff\u0001\u002d\u0002\uffff\u0001"+
    "\u002d\u0001\u0074\u0001\u0072\u0002\uffff\u0001\u0070\u0001\uffff\u0001"+
    "\u002d\u0001\u006f\u0001\u002d\u0001\u0070\u0001\u0072\u0001\u0070\u0003"+
    "\u002d\u0001\uffff\u0001\u006f\u0001\u0065\u0001\u0073\u0002\uffff\u0002"+
    "\u0065\u0003\uffff\u0001\u002d\u0001\u006e\u0001\uffff\u0001\u002d\u0001"+
    "\u0065\u0001\u002d\u0001\uffff\u0001\u0070\u0001\u0073\u0001\uffff\u0001"+
    "\u002d\u0002\uffff\u0001\u006f\u0001\u0069\u0001\uffff\u0001\u0072\u0001"+
    "\u006d\u0003\uffff\u0001\u002d\u0003\uffff\u0002\u002d\u0001\u0061\u0001"+
    "\uffff\u0001\u006e\u0001\uffff\u0001\u0061\u0001\u006d\u0001\u0061\u0001"+
    "\u006f\u0003\uffff\u0001\u0064\u0001\u006e\u0001\u0069\u0001\u0070\u0001"+
    "\u002d\u0001\uffff\u0001\u006f\u0001\uffff\u0001\u002d\u0001\uffff\u0001"+
    "\u0061\u0002\u0069\u0001\u006e\u0001\u0070\u0001\u0069\u0001\u0065\u0002"+
    "\uffff\u0001\u0073\u0001\u0063\u0001\u002d\u0001\u0063\u0001\u0061\u0002"+
    "\u0072\u0001\u0065\u0001\u0063\u0001\u0062\u0001\u0061\u0001\uffff\u0001"+
    "\u0064\u0001\uffff\u0001\u0072\u0001\u0062\u0001\u006e\u0002\u002d\u0001"+
    "\u0062\u0001\u006e\u0002\u0065\u0001\uffff\u0001\u0065\u0001\u0074\u0001"+
    "\u0061\u0002\u002d\u0001\u0065\u0001\u006c\u0001\u0072\u0001\u0065\u0001"+
    "\u0061\u0001\u006c\u0001\u0073\u0002\uffff\u0001\u0075\u0001\u0074\u0001"+
    "\u006c\u0001\u002d\u0001\u0073\u0001\u002d\u0001\u0074\u0001\u0073\u0001"+
    "\uffff\u0001\u002d\u0001\u0069\u0001\u0061\u0001\u002d\u0001\u0074\u0001"+
    "\u0069\u0002\u0074\u0001\u002d\u0001\u0066\u0001\uffff\u0001\u002d\u0001"+
    "\uffff\u0001\u006f\u0001\u0065\u0001\uffff\u0001\u006e\u0001\u0074\u0001"+
    "\uffff\u0001\u006f\u0001\u006e\u0001\u0072\u0001\u0065\u0001\uffff\u0001"+
    "\u002d\u0001\uffff\u0001\u0072\u0001\u006c\u0001\u0067\u0001\u006f\u0001"+
    "\u0072\u0001\u0067\u0001\u0075\u0001\u002d\u0001\uffff\u0001\u002d\u0001"+
    "\u0066\u0001\u002d\u0001\u0072\u0002\u002d\u0001\u0063\u0002\uffff\u0001"+
    "\u002d\u0001\uffff\u0001\u002d\u0002\uffff\u0001\u0074\u0002\uffff\u0001"+
    "\u0069\u0001\u006f\u0001\u006e\u0001\u002d\u0001\uffff",
    DFA19_maxS:
        "\u0001\uffff\u0001\u0074\u0001\u0079\u0002\u006f\u0001\u0078\u0001"+
    "\u0075\u0003\u0074\u0002\u006f\u0002\u0072\u0001\u0065\u0001\u0077\u0001"+
    "\u0079\u0001\u0073\u0001\u0065\u0001\u006f\u0001\u0071\u0001\u0061\u0002"+
    "\u0065\u0001\u0075\u0001\u007c\u0001\u003a\u0007\uffff\u0002\u003d\u0001"+
    "\uffff\u0001\u0029\u0001\u0023\u0001\uffff\u0001\u003e\u0002\uffff\u0001"+
    "\u002d\u0001\u003f\u0002\u003e\u0001\u0039\u0006\uffff\u0001\u0065\u0001"+
    "\uffff\u0001\u0079\u0002\u007a\u0001\u006c\u0001\u0074\u0001\u0070\u0001"+
    "\u006f\u0001\uffff\u0001\u0073\u0001\u0075\u0001\u007a\u0001\u0066\u0001"+
    "\u0065\u0001\u006e\u0001\u0074\u0001\u0069\u0001\u0075\u0001\u0073\u0001"+
    "\u0076\u0001\u0063\u0001\u0073\u0001\u0070\u0001\u0074\u0001\u007a\u0001"+
    "\u0065\u0001\u0074\u0001\u0072\u0001\u006e\u0001\u0072\u0002\u006f\u0001"+
    "\u007a\u0001\u006f\u0001\u007a\u0001\u0069\u0001\u007a\u0001\u0070\u0002"+
    "\u007a\u0001\u0065\u0001\u0078\u0002\u007a\u0001\u0077\u0001\u0073\u0001"+
    "\u006e\u0001\u006d\u0003\u007a\u0001\u0074\u0002\u007a\u0001\u0063\u0001"+
    "\u0074\u0001\u006f\u0002\u0072\u0001\u0076\u0001\u0074\u0001\u006f\u0001"+
    "\u006e\u0001\u006d\u0001\u0072\u0003\u0069\u0001\u0078\u0001\u0065\u0001"+
    "\u007a\u0001\u0079\u0001\u0070\u0002\u006d\u0001\u006f\u0001\u0070\u0001"+
    "\u0069\u0002\u0072\u0001\u0069\u0001\u0074\u0001\u0069\u0001\u0072\u0001"+
    "\u0075\u0001\u004e\u0001\u0072\u0001\u0079\u0001\u006f\u0002\uffff\u0001"+
    "\u007a\u0010\uffff\u0001\u0078\u000b\uffff\u0001\u002d\u0001\u007a\u0009"+
    "\uffff\u0001\u0065\u0006\uffff\u0002\u0065\u0001\uffff\u0001\u0065\u0002"+
    "\u007a\u0001\u0065\u0001\uffff\u0001\u0072\u0001\uffff\u0001\u007a\u0001"+
    "\u0065\u0001\u007a\u0001\u0073\u0001\u0065\u0001\u006e\u0001\uffff\u0001"+
    "\u006f\u0002\u0061\u0001\u0074\u0001\u0063\u0001\u006c\u0001\u0063\u0001"+
    "\u006c\u0001\u006d\u0001\u0074\u0001\u0079\u0001\u006e\u0001\u006c\u0001"+
    "\u0061\u0001\u0063\u0001\u0065\u0001\u007a\u0001\u0069\u0001\u0063\u0001"+
    "\u0066\u0001\u0074\u0001\u0075\u0001\u006d\u0001\u0065\u0001\u0074\u0001"+
    "\u006f\u0001\u007a\u0001\u0069\u0001\uffff\u0001\u0072\u0002\u0065\u0001"+
    "\u0063\u0001\u0074\u0001\u006c\u0001\u007a\u0001\u0063\u0001\u0073\u0001"+
    "\u006d\u0001\u006f\u0001\u006e\u0001\u006f\u0001\u0072\u0001\uffff\u0001"+
    "\u0061\u0001\u0075\u0001\uffff\u0001\u0076\u0001\uffff\u0001\u006f\u0001"+
    "\u0065\u0001\u0074\u0001\u006f\u0001\u0069\u0001\u0065\u0002\uffff\u0001"+
    "\u006d\u0001\u007a\u0001\u0074\u0001\u0067\u0001\u0073\u0001\u007a\u0001"+
    "\u0065\u0002\uffff\u0001\u0065\u0001\u0070\u0001\u007a\u0001\u0074\u0001"+
    "\u0075\u0001\u0065\u0001\u0074\u0001\uffff\u0001\u0070\u0001\u0065\u0001"+
    "\u007a\u0002\uffff\u0001\u0069\u0001\u0065\u0001\uffff\u0001\u0079\u0001"+
    "\uffff\u0001\u0075\u0001\u0065\u0001\u0074\u0001\u0076\u0002\u0063\u0001"+
    "\u0061\u0001\u0075\u0001\u0061\u0001\u006c\u0002\u0061\u0001\u0069\u0002"+
    "\u0065\u0001\u0072\u0001\u0066\u0001\u0074\u0001\u0065\u0001\u0072\u0001"+
    "\u0069\u0001\u006d\u0001\u0070\u0001\u0064\u0001\u0074\u0001\u0070\u0001"+
    "\u0074\u0001\u0073\u0001\uffff\u0001\u0061\u0001\u007a\u0001\u0065\u0001"+
    "\u0062\u0001\u0065\u0001\u0071\u0001\u0072\u0001\u0061\u0001\u0065\u0001"+
    "\u006e\u0001\u0075\u0001\u0069\u0001\u0073\u0001\u0072\u0001\u006c\u0001"+
    "\u0064\u0001\u0068\u0001\u0064\u0001\u0067\u0001\u0064\u0001\u0065\u0001"+
    "\u007a\u0001\u006f\u0001\u007a\u0001\u0074\u0004\uffff\u0001\u002d\u0003"+
    "\uffff\u0001\u0065\u0001\u0073\u0002\uffff\u0001\u006e\u0001\u0069\u0001"+
    "\u0077\u0001\uffff\u0001\u0072\u0001\uffff\u0001\u007a\u0001\u002d\u0001"+
    "\u0064\u0001\u0072\u0001\u006b\u0001\u0072\u0002\u007a\u0001\u0068\u0001"+
    "\u0064\u0001\u006b\u0002\u0065\u0001\u0074\u0001\u0069\u0001\u007a\u0001"+
    "\u0074\u0001\u0061\u0001\u006d\u0001\u0075\u0001\u0065\u0001\u0074\u0001"+
    "\uffff\u0001\u0074\u0001\u0072\u0001\u0065\u0001\u0061\u0001\u006d\u0001"+
    "\u0065\u0001\u007a\u0001\u0079\u0001\u0064\u0001\uffff\u0001\u0072\u0001"+
    "\u0079\u0001\u0070\u0001\u0072\u0001\u0074\u0001\u007a\u0001\u006f\u0001"+
    "\u0069\u0001\uffff\u0002\u0074\u0001\u007a\u0001\u0070\u0001\u0064\u0001"+
    "\u0074\u0001\u007a\u0001\u0074\u0001\u0070\u0001\u007a\u0002\u0072\u0001"+
    "\u0061\u0002\u0072\u0001\u007a\u0001\u006e\u0001\u0078\u0001\u007a\u0001"+
    "\uffff\u0001\u007a\u0001\u0075\u0001\u0074\u0001\uffff\u0001\u006c\u0001"+
    "\u0072\u0001\u007a\u0001\u006c\u0001\u0066\u0001\uffff\u0001\u007a\u0002"+
    "\u0073\u0001\u007a\u0001\u006e\u0001\u0072\u0001\u007a\u0001\uffff\u0001"+
    "\u006f\u0001\u0072\u0001\u007a\u0001\u0072\u0001\u006e\u0001\u0067\u0003"+
    "\u0065\u0001\u0069\u0002\u0065\u0001\u006d\u0001\u0073\u0001\u0072\u0001"+
    "\u006d\u0001\u0061\u0001\u006c\u0001\u0074\u0001\u0073\u0001\u007a\u0001"+
    "\u006d\u0001\u0065\u0001\u007a\u0001\u0069\u0001\u0065\u0001\u007a\u0001"+
    "\u006c\u0001\u0074\u0001\u0070\u0001\u006d\u0001\u007a\u0001\u0069\u0001"+
    "\u0063\u0003\u007a\u0001\u0061\u0001\u0074\u0001\uffff\u0001\u007a\u0001"+
    "\u006c\u0001\u0073\u0001\u006e\u0001\u0075\u0001\u0064\u0001\u0074\u0001"+
    "\u0072\u0001\u0067\u0001\u0064\u0001\u0065\u0001\u0061\u0001\u0069\u0001"+
    "\u0065\u0001\u007a\u0001\u0065\u0001\u006f\u0001\u007a\u0001\u0063\u0001"+
    "\u0068\u0001\u007a\u0001\u0072\u0001\uffff\u0001\u002d\u0001\uffff\u0001"+
    "\u007a\u0001\uffff\u0001\u0074\u0001\u0064\u0001\u0062\u0001\u0069\u0001"+
    "\u007a\u0001\uffff\u0001\u0075\u0001\u0061\u0001\u0065\u0001\u007a\u0001"+
    "\u0079\u0001\uffff\u0001\u0062\u0001\uffff\u0003\u007a\u0001\u0074\u0001"+
    "\u0063\u0001\u006e\u0001\u0072\u0001\u0078\u0001\u0069\u0002\u006e\u0001"+
    "\uffff\u0001\u007a\u0001\u0072\u0001\u0061\u0001\u006c\u0001\u006e\u0001"+
    "\u0065\u0001\u007a\u0001\u0069\u0001\u0072\u0001\u006e\u0001\u0065\u0001"+
    "\u006e\u0001\uffff\u0001\u007a\u0001\u0069\u0001\u0065\u0001\u007a\u0001"+
    "\u0074\u0001\u006e\u0001\u006c\u0001\uffff\u0001\u0077\u0001\u0063\u0001"+
    "\u0067\u0001\u0069\u0001\u007a\u0001\uffff\u0001\u0074\u0002\u007a\u0001"+
    "\uffff\u0001\u0065\u0001\u007a\u0001\uffff\u0001\u0074\u0001\u0069\u0001"+
    "\u006e\u0001\u0074\u0002\u0073\u0001\u0072\u0001\uffff\u0001\u0069\u0001"+
    "\u007a\u0002\uffff\u0001\u0061\u0001\u007a\u0001\u0073\u0001\u0063\u0001"+
    "\uffff\u0001\u0065\u0001\u0079\u0001\uffff\u0001\u002d\u0001\u0070\u0001"+
    "\uffff\u0001\u0068\u0001\u0065\u0001\u007a\u0001\uffff\u0001\u006e\u0001"+
    "\u007a\u0001\uffff\u0001\u0073\u0001\u0074\u0002\u0072\u0001\u0064\u0001"+
    "\u0072\u0001\u006f\u0001\u0073\u0001\u006e\u0001\u0069\u0001\u0065\u0001"+
    "\u006e\u0001\u0065\u0001\u0063\u0002\u0069\u0001\u0066\u0001\uffff\u0001"+
    "\u0061\u0001\u007a\u0001\uffff\u0001\u0074\u0001\u006e\u0001\uffff\u0001"+
    "\u0065\u0001\u007a\u0001\u0074\u0001\u007a\u0001\u0069\u0001\uffff\u0001"+
    "\u006e\u0001\u0068\u0003\uffff\u0001\u0075\u0001\u007a\u0001\u0077\u0001"+
    "\uffff\u0001\u0069\u0002\u007a\u0002\u0065\u0001\u0069\u0001\u0063\u0001"+
    "\u007a\u0001\u0061\u0001\u007a\u0001\u0062\u0001\u006f\u0001\u007a\u0001"+
    "\uffff\u0001\u007a\u0001\u0077\u0001\u0075\u0001\uffff\u0001\u0061\u0001"+
    "\u0074\u0001\u007a\u0001\uffff\u0001\u0079\u0001\u0064\u0003\uffff\u0001"+
    "\u006f\u0001\u0069\u0001\u0075\u0001\u006e\u0001\uffff\u0002\u0072\u0001"+
    "\u007a\u0001\uffff\u0001\u007a\u0001\u006c\u0003\uffff\u0001\u0069\u0002"+
    "\u0074\u0001\u0075\u0002\u0074\u0001\u006e\u0001\u0075\u0001\u0061\u0001"+
    "\uffff\u0001\u0065\u0001\u006c\u0001\u0074\u0001\u0064\u0001\u007a\u0001"+
    "\uffff\u0001\u0074\u0001\u0065\u0001\u0063\u0001\u006e\u0001\u0074\u0001"+
    "\u0073\u0001\uffff\u0001\u006e\u0001\u007a\u0001\uffff\u0001\u007a\u0001"+
    "\u0061\u0001\u0079\u0001\u0069\u0001\u0068\u0001\u006e\u0001\u006f\u0001"+
    "\uffff\u0001\u0069\u0002\uffff\u0001\u0073\u0001\u006e\u0001\uffff\u0001"+
    "\u007a\u0001\u0074\u0001\u0063\u0001\u007a\u0001\u0069\u0001\u0065\u0001"+
    "\u0069\u0001\u0074\u0001\uffff\u0001\u0067\u0001\uffff\u0001\u007a\u0001"+
    "\u0061\u0002\u007a\u0001\u0073\u0001\u0061\u0001\u0065\u0001\u0073\u0001"+
    "\uffff\u0001\u007a\u0001\u0064\u0001\u006e\u0001\uffff\u0002\u007a\u0001"+
    "\u0061\u0001\u006e\u0001\u0069\u0001\u0076\u0001\u0075\u0001\u0073\u0001"+
    "\u0074\u0001\u006c\u0003\u007a\u0001\u0065\u0001\u0064\u0001\u006f\u0001"+
    "\u0069\u0001\u007a\u0001\uffff\u0001\u0069\u0001\u0063\u0001\u007a\u0001"+
    "\uffff\u0001\u007a\u0001\uffff\u0001\u006e\u0001\u0067\u0001\u007a\u0001"+
    "\u0072\u0001\uffff\u0001\u0069\u0001\u006e\u0002\uffff\u0001\u007a\u0001"+
    "\u0072\u0001\u006e\u0001\u0061\u0001\uffff\u0001\u0074\u0001\uffff\u0001"+
    "\u006c\u0001\u006e\u0002\uffff\u0001\u007a\u0001\u0074\u0001\u0072\u0001"+
    "\u007a\u0001\uffff\u0001\u007a\u0001\u0069\u0001\u0072\u0001\u006e\u0001"+
    "\u0074\u0001\u0067\u0001\u0069\u0001\u0079\u0002\uffff\u0001\u0065\u0001"+
    "\u006f\u0001\u0069\u0001\u007a\u0001\u0063\u0001\u0069\u0002\u007a\u0001"+
    "\u0073\u0001\u0065\u0001\u006d\u0001\u007a\u0001\u002d\u0001\u007a\u0001"+
    "\u0069\u0001\uffff\u0001\u0069\u0001\u006e\u0001\u0065\u0001\u0074\u0001"+
    "\u007a\u0001\u0065\u0001\u0067\u0002\uffff\u0001\u006c\u0001\u007a\u0001"+
    "\u006e\u0002\u007a\u0001\u006e\u0001\u006f\u0001\u0074\u0001\u0067\u0001"+
    "\uffff\u0001\u007a\u0001\u0065\u0001\uffff\u0001\u0074\u0001\u0063\u0001"+
    "\u0074\u0001\u0079\u0001\u0065\u0001\uffff\u0001\u0073\u0002\uffff\u0001"+
    "\u0069\u0001\u0063\u0001\u0072\u0001\u0065\u0001\uffff\u0001\u007a\u0001"+
    "\u0067\u0002\uffff\u0001\u0070\u0001\u002d\u0001\u006e\u0001\u0065\u0001"+
    "\u0073\u0001\u0069\u0001\u007a\u0001\u006c\u0001\uffff\u0001\u006e\u0002"+
    "\uffff\u0001\u007a\u0001\u0061\u0001\u006e\u0002\u0065\u0001\uffff\u0001"+
    "\u0076\u0001\u0065\u0002\uffff\u0001\u0067\u0001\u007a\u0001\uffff\u0001"+
    "\u0075\u0001\u0074\u0001\u0067\u0001\uffff\u0001\u0065\u0001\u0067\u0001"+
    "\u0073\u0002\u0065\u0001\u007a\u0001\uffff\u0001\u007a\u0001\u0064\u0002"+
    "\uffff\u0001\u0067\u0001\u007a\u0001\u0067\u0001\u0065\u0002\u007a\u0001"+
    "\u002d\u0001\u007a\u0001\u006e\u0001\u006f\u0001\uffff\u0001\u0074\u0001"+
    "\u006e\u0002\uffff\u0002\u007a\u0001\u0065\u0001\uffff\u0001\u0073\u0001"+
    "\uffff\u0002\u006e\u0001\u0063\u0001\u0074\u0002\u007a\u0001\uffff\u0001"+
    "\u0071\u0002\u007a\u0001\uffff\u0001\u0067\u0002\uffff\u0001\u007a\u0001"+
    "\u006e\u0001\u007a\u0001\u002d\u0001\uffff\u0001\u007a\u0001\u0069\u0001"+
    "\u0074\u0001\u0079\u0002\u007a\u0001\u0065\u0001\u0067\u0001\u0065\u0001"+
    "\u0069\u0001\u0072\u0001\uffff\u0001\u007a\u0001\u0068\u0001\u0073\u0001"+
    "\u0067\u0002\u007a\u0001\u006e\u0001\uffff\u0001\u0065\u0001\u0067\u0001"+
    "\uffff\u0001\u0074\u0002\u0073\u0001\u0074\u0001\u006c\u0001\u0065\u0002"+
    "\u007a\u0001\uffff\u0001\u0073\u0001\u0063\u0001\u007a\u0001\u0064\u0001"+
    "\u007a\u0001\u0065\u0002\u007a\u0002\uffff\u0001\u0073\u0001\u0069\u0001"+
    "\u006f\u0001\uffff\u0002\u007a\u0002\uffff\u0001\u0073\u0001\uffff\u0001"+
    "\u007a\u0001\u006e\u0001\u0069\u0001\u0074\u0002\uffff\u0001\u0073\u0001"+
    "\u006f\u0001\u0065\u0001\u0074\u0001\u0067\u0001\u0073\u0001\u007a\u0001"+
    "\uffff\u0001\u006e\u0001\uffff\u0001\u0075\u0002\uffff\u0001\u007a\u0001"+
    "\uffff\u0001\u007a\u0001\uffff\u0001\u0073\u0001\uffff\u0001\u0076\u0002"+
    "\u007a\u0002\uffff\u0001\u007a\u0001\u006e\u0001\u007a\u0001\u0074\u0001"+
    "\u0076\u0001\uffff\u0001\u007a\u0001\u0065\u0001\u007a\u0002\uffff\u0001"+
    "\u0067\u0002\u007a\u0001\u0069\u0001\u0068\u0001\u007a\u0001\u0074\u0001"+
    "\u0065\u0002\u007a\u0002\uffff\u0001\u007a\u0001\u0068\u0001\uffff\u0001"+
    "\u007a\u0001\uffff\u0001\u007a\u0002\uffff\u0001\u007a\u0001\u0074\u0001"+
    "\u0072\u0002\uffff\u0001\u0070\u0001\uffff\u0001\u007a\u0001\u006f\u0001"+
    "\u007a\u0001\u0070\u0001\u0072\u0001\u0070\u0003\u007a\u0001\uffff\u0001"+
    "\u006f\u0001\u0065\u0001\u0073\u0002\uffff\u0002\u0065\u0003\uffff\u0001"+
    "\u007a\u0001\u006e\u0001\uffff\u0001\u007a\u0001\u0065\u0001\u007a\u0001"+
    "\uffff\u0001\u0070\u0001\u0073\u0001\uffff\u0001\u002d\u0002\uffff\u0001"+
    "\u006f\u0001\u0069\u0001\uffff\u0001\u0072\u0001\u006d\u0003\uffff\u0001"+
    "\u007a\u0003\uffff\u0001\u007a\u0001\u002d\u0001\u0061\u0001\uffff\u0001"+
    "\u006e\u0001\uffff\u0001\u0061\u0001\u006d\u0001\u0061\u0001\u006f\u0003"+
    "\uffff\u0001\u0064\u0001\u006e\u0001\u0069\u0001\u0070\u0001\u007a\u0001"+
    "\uffff\u0001\u006f\u0001\uffff\u0001\u007a\u0001\uffff\u0001\u0061\u0002"+
    "\u0069\u0001\u006e\u0001\u0070\u0001\u0069\u0001\u0065\u0002\uffff\u0001"+
    "\u0073\u0001\u0063\u0001\u007a\u0001\u0063\u0001\u0061\u0002\u0072\u0001"+
    "\u0065\u0001\u0063\u0001\u0062\u0001\u0061\u0001\uffff\u0001\u0064\u0001"+
    "\uffff\u0001\u0072\u0001\u0062\u0001\u006e\u0002\u007a\u0001\u0062\u0001"+
    "\u006e\u0002\u0065\u0001\uffff\u0001\u0065\u0001\u0074\u0001\u0061\u0001"+
    "\u002d\u0001\u007a\u0001\u0065\u0001\u006c\u0001\u0072\u0001\u0065\u0001"+
    "\u0061\u0001\u006c\u0001\u0073\u0002\uffff\u0001\u0075\u0001\u0074\u0001"+
    "\u006c\u0001\u007a\u0001\u0073\u0001\u007a\u0001\u0074\u0001\u0073\u0001"+
    "\uffff\u0001\u007a\u0001\u0069\u0001\u0061\u0001\u007a\u0001\u0074\u0001"+
    "\u0069\u0002\u0074\u0001\u007a\u0001\u0066\u0001\uffff\u0001\u007a\u0001"+
    "\uffff\u0001\u006f\u0001\u0065\u0001\uffff\u0001\u006e\u0001\u0074\u0001"+
    "\uffff\u0001\u006f\u0001\u006e\u0001\u0072\u0001\u0065\u0001\uffff\u0001"+
    "\u007a\u0001\uffff\u0001\u0072\u0001\u006c\u0001\u0067\u0001\u006f\u0001"+
    "\u0072\u0001\u0067\u0001\u0075\u0001\u007a\u0001\uffff\u0001\u007a\u0001"+
    "\u0066\u0001\u007a\u0001\u0072\u0002\u007a\u0001\u0063\u0002\uffff\u0001"+
    "\u007a\u0001\uffff\u0001\u007a\u0002\uffff\u0001\u0074\u0002\uffff\u0001"+
    "\u0069\u0001\u006f\u0001\u006e\u0001\u007a\u0001\uffff",
    DFA19_acceptS:
        "\u001b\uffff\u0001\u00cf\u0001\u00d0\u0001\u00d1\u0001\u00d2\u0001"+
    "\u00d3\u0001\u00d4\u0001\u00d5\u0002\uffff\u0001\u00d8\u0002\uffff\u0001"+
    "\u00db\u0001\uffff\u0001\u00dd\u0001\u00de\u0005\uffff\u0001\u00ee\u0001"+
    "\u00f6\u0001\u00f9\u0001\u00fa\u0001\u00fb\u0001\u00fc\u0001\uffff\u0001"+
    "\u0104\u0007\uffff\u0001\u00fb\u0050\uffff\u0001\u00cd\u0001\u00ef\u0001"+
    "\uffff\u0001\u0103\u0001\u00ce\u0001\u00cf\u0001\u00d0\u0001\u00d1\u0001"+
    "\u00d2\u0001\u00d3\u0001\u00d4\u0001\u00d5\u0001\u00d6\u0001\u00eb\u0001"+
    "\u00ea\u0001\u00d7\u0001\u00d8\u0001\u00f1\u0001\u00d9\u0001\uffff\u0001"+
    "\u00da\u0001\u00db\u0001\u00f5\u0001\u00dc\u0001\u00dd\u0001\u00de\u0001"+
    "\u00f3\u0001\u00df\u0001\u00e2\u0001\u00e4\u0001\u00ed\u0002\uffff\u0001"+
    "\u00e0\u0001\u00e3\u0001\u00e5\u0001\u00e1\u0001\u00e7\u0001\u00ec\u0001"+
    "\u00e6\u0001\u00e9\u0001\u00e8\u0001\uffff\u0001\u00ee\u0001\u00f6\u0001"+
    "\u00f9\u0001\u00fa\u0001\u00fc\u0001\u0100\u0002\uffff\u0001\u0102\u0004"+
    "\uffff\u0001\u0004\u0001\uffff\u0001\u0006\u0006\uffff\u0001\u000a\u001c"+
    "\uffff\u0001\u0020\u000e\uffff\u0001\u0028\u0002\uffff\u0001\u002a\u0001"+
    "\uffff\u0001\u002c\u0006\uffff\u0001\u002e\u0001\u0032\u0007\uffff\u0001"+
    "\u0035\u0001\u0038\u0007\uffff\u0001\u003c\u0003\uffff\u0001\u00a2\u0001"+
    "\u0040\u0002\uffff\u0001\u0042\u0001\uffff\u0001\u00c7\u001c\uffff\u0001"+
    "\u0057\u0019\uffff\u0001\u00f0\u0001\u00fd\u0001\u00f8\u0001\u00f7\u0001"+
    "\uffff\u0001\u00f4\u0001\u00ff\u0001\u0101\u0002\uffff\u0001\u0003\u0001"+
    "\u0090\u0003\uffff\u0001\u008f\u0001\uffff\u0001\u00ca\u0016\uffff\u0001"+
    "\u0018\u0009\uffff\u0001\u0068\u0008\uffff\u0001\u0026\u0013\uffff\u0001"+
    "\u0034\u0003\uffff\u0001\u0037\u0005\uffff\u0001\u0039\u0007\uffff\u0001"+
    "\u00a3\u0027\uffff\u0001\u0078\u0016\uffff\u0001\u006e\u0001\uffff\u0001"+
    "\u00c6\u0007\uffff\u0001\u00cb\u0005\uffff\u0001\u000b\u0001\uffff\u0001"+
    "\u000c\u000b\uffff\u0001\u0080\u000c\uffff\u0001\u001c\u0007\uffff\u0001"+
    "\u00bb\u0005\uffff\u0001\u0098\u0003\uffff\u0001\u009c\u0002\uffff\u0001"+
    "\u002b\u0007\uffff\u0001\u0084\u0002\uffff\u0001\u0033\u0001\u0085\u0004"+
    "\uffff\u0001\u00bc\u0002\uffff\u0001\u00a1\u0002\uffff\u0001\u006f\u0003"+
    "\uffff\u0001\u003f\u0002\uffff\u0001\u0070\u0011\uffff\u0001\u00a9\u0002"+
    "\uffff\u0001\u0050\u0002\uffff\u0001\u0051\u0005\uffff\u0001\u00af\u0002"+
    "\uffff\u0001\u008b\u0001\u0055\u0001\u0056\u0003\uffff\u0001\u007a\u000d"+
    "\uffff\u0001\u007b\u0003\uffff\u0001\u008e\u0003\uffff\u0001\u00b7\u0002"+
    "\uffff\u0001\u00cc\u0001\u00f2\u0001\u00fe\u0004\uffff\u0001\u007e\u0003"+
    "\uffff\u0001\u00b9\u0002\uffff\u0001\u0062\u0001\u000e\u0001\u00bf\u0009"+
    "\uffff\u0001\u0064\u0005\uffff\u0001\u0067\u0006\uffff\u0001\u001d\u0002"+
    "\uffff\u0001\u0021\u0007\uffff\u0001\u0082\u0001\uffff\u0001\u009a\u0001"+
    "\u009b\u0002\uffff\u0001\u0069\u0008\uffff\u0001\u00c4\u0001\uffff\u0001"+
    "\u0036\u0008\uffff\u0001\u0087\u0003\uffff\u0001\u0043\u0012\uffff\u0001"+
    "\u00aa\u0003\uffff\u0001\u0076\u0001\uffff\u0001\u0054\u0004\uffff\u0001"+
    "\u0058\u0002\uffff\u0001\u00b1\u0001\u005a\u0004\uffff\u0001\u00b3\u0001"+
    "\uffff\u0001\u008d\u0002\uffff\u0001\u005f\u0001\u00be\u0004\uffff\u0001"+
    "\u00b8\u0008\uffff\u0001\u007f\u0001\u00c9\u000f\uffff\u0001\u0081\u0007"+
    "\uffff\u0001\u0096\u0001\u0022\u0009\uffff\u0001\u002d\u0002\uffff\u0001"+
    "\u0083\u0005\uffff\u0001\u009f\u0001\uffff\u0001\u003a\u0001\u0086\u0004"+
    "\uffff\u0001\u0041\u0002\uffff\u0001\u00a4\u0001\u0046\u0008\uffff\u0001"+
    "\u00a7\u0001\uffff\u0001\u004b\u0001\u0088\u0005\uffff\u0001\u004d\u0002"+
    "\uffff\u0001\u0052\u0001\u0053\u0002\uffff\u0001\u0077\u0003\uffff\u0001"+
    "\u00c8\u0006\uffff\u0001\u007c\u0002\uffff\u0001\u00b4\u0001\u0060\u000a"+
    "\uffff\u0001\u0010\u0002\uffff\u0001\u0063\u0001\u0092\u0003\uffff\u0001"+
    "\u0013\u0001\uffff\u0001\u0014\u0006\uffff\u0001\u001b\u0003\uffff\u0001"+
    "\u0097\u0001\uffff\u0001\u00c2\u0001\u00c3\u0004\uffff\u0001\u002f\u000b"+
    "\uffff\u0001\u0044\u0007\uffff\u0001\u0072\u0002\uffff\u0001\u0089\u0008"+
    "\uffff\u0001\u0075\u0008\uffff\u0001\u005e\u0001\u00b6\u0003\uffff\u0001"+
    "\u0001\u0002\uffff\u0001\u0061\u0001\u0008\u0001\uffff\u0001\u000d\u0004"+
    "\uffff\u0001\u0091\u0001\u00ba\u0007\uffff\u0001\u0095\u0001\uffff\u0001"+
    "\u0019\u0001\uffff\u0001\u001f\u0001\u0023\u0001\uffff\u0001\u0027\u0001"+
    "\uffff\u0001\u0029\u0001\uffff\u0001\u0030\u0003\uffff\u0001\u006b\u0001"+
    "\u009e\u0005\uffff\u0001\u0045\u0003\uffff\u0001\u0049\u0001\u0074\u000a"+
    "\uffff\u0001\u00ac\u0001\u00ae\u0002\uffff\u0001\u0079\u0001\uffff\u0001"+
    "\u008c\u0001\uffff\u0001\u005c\u0001\u005d\u0003\uffff\u0001\u0005\u0001"+
    "\u0007\u0001\uffff\u0001\u000f\u0009\uffff\u0001\u0094\u0003\uffff\u0001"+
    "\u0024\u0001\u0099\u0002\uffff\u0001\u0031\u0001\u00c5\u0001\u00a0\u0002"+
    "\uffff\u0001\u003b\u0003\uffff\u0001\u00a5\u0002\uffff\u0001\u0047\u0001"+
    "\uffff\u0001\u0073\u0001\u00bd\u0002\uffff\u0001\u004c\u0002\uffff\u0001"+
    "\u00ab\u0001\u00ad\u0001\u00b0\u0001\uffff\u0001\u005b\u0001\u00b2\u0001"+
    "\u00b5\u0003\uffff\u0001\u00c0\u0001\uffff\u0001\u00c1\u0004\uffff\u0001"+
    "\u0015\u0001\u0017\u0001\u0093\u0005\uffff\u0001\u006c\u0001\uffff\u0001"+
    "\u003d\u0001\uffff\u0001\u00a6\u0007\uffff\u0001\u0059\u0001\u007d\u000b"+
    "\uffff\u0001\u009d\u0001\uffff\u0001\u003e\u0009\uffff\u0001\u0011\u000c"+
    "\uffff\u0001\u008a\u0001\u00a8\u0008\uffff\u0001\u001a\u000a\uffff\u0001"+
    "\u0009\u0001\uffff\u0001\u0065\u0002\uffff\u0001\u001e\u0002\uffff\u0001"+
    "\u006d\u0004\uffff\u0001\u004f\u0001\uffff\u0001\u0012\u0008\uffff\u0001"+
    "\u0002\u0007\uffff\u0001\u004e\u0001\u0066\u0001\uffff\u0001\u0025\u0001"+
    "\uffff\u0001\u0071\u0001\u0048\u0001\uffff\u0001\u0016\u0001\u006a\u0004"+
    "\uffff\u0001\u004a",
    DFA19_specialS:
        "\u0001\u0000\u0019\uffff\u0001\u0001\u01e5\uffff\u0001\u0002\u02db"+
    "\uffff}>",
    DFA19_transitionS: [
            "\u0009\u0037\u0002\u0035\u0002\u0037\u0001\u0035\u0012\u0037"+
            "\u0001\u0035\u0001\u0023\u0001\u0033\u0001\u0025\u0001\u001c"+
            "\u0001\u0024\u0001\u0026\u0001\u0032\u0001\u001a\u0001\u001b"+
            "\u0001\u0029\u0001\u002a\u0001\u0027\u0001\u002b\u0001\u002f"+
            "\u0001\u002e\u000a\u0036\u0001\u0022\u0001\u0030\u0001\u002c"+
            "\u0001\u0021\u0001\u002d\u0001\u0028\u0001\u0031\u000d\u0034"+
            "\u0001\u0015\u000c\u0034\u0001\u001f\u0001\u0037\u0001\u0020"+
            "\u0001\u0037\u0001\u0034\u0001\u0037\u0001\u0001\u0001\u0002"+
            "\u0001\u0003\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007"+
            "\u0001\u0034\u0001\u0008\u0001\u0034\u0001\u0017\u0001\u0009"+
            "\u0001\u000a\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u0018"+
            "\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0012"+
            "\u0001\u0013\u0001\u0014\u0001\u0034\u0001\u0016\u0001\u001d"+
            "\u0001\u0019\u0001\u001e\uff82\u0037",
            "\u0001\u003c\u0005\uffff\u0001\u003b\u0001\u003d\u0001\u0038"+
            "\u0001\uffff\u0001\u003e\u0002\uffff\u0001\u0039\u0001\u003a",
            "\u0001\u0040\u0003\uffff\u0001\u0043\u0003\uffff\u0001\u0045"+
            "\u0005\uffff\u0001\u0041\u0002\uffff\u0001\u0044\u0006\uffff"+
            "\u0001\u0042",
            "\u0001\u0046\u0006\uffff\u0001\u0047\u0006\uffff\u0001\u0048",
            "\u0001\u0049\u0003\uffff\u0001\u004a\u0005\uffff\u0001\u004b",
            "\u0001\u004c\u0001\u004d\u0001\u004e\u0002\uffff\u0001\u004f"+
            "\u0004\uffff\u0001\u0050\u0001\uffff\u0001\u0051",
            "\u0001\u0054\u0005\uffff\u0001\u0052\u0002\uffff\u0001\u0055"+
            "\u0001\uffff\u0001\u0056\u0001\u0053",
            "\u0001\u0057\u000c\uffff\u0001\u0058\u0001\uffff\u0001\u0059",
            "\u0001\u005a\u0001\uffff\u0001\u005b\u0006\uffff\u0001\u005c"+
            "\u0001\u005d\u0004\uffff\u0001\u005e\u0001\u005f",
            "\u0001\u0060\u0003\uffff\u0001\u0061\u0009\uffff\u0001\u0063"+
            "\u0004\uffff\u0001\u0062",
            "\u0001\u0065\u0005\uffff\u0001\u0064",
            "\u0001\u0066\u0003\uffff\u0001\u0067\u0009\uffff\u0001\u0068",
            "\u0001\u006d\u0002\uffff\u0001\u0069\u0007\uffff\u0001\u006c"+
            "\u0001\uffff\u0001\u006a\u0001\uffff\u0001\u006b",
            "\u0001\u006e\u0003\uffff\u0001\u0070\u0002\uffff\u0001\u0071"+
            "\u0009\uffff\u0001\u006f",
            "\u0001\u0072",
            "\u0001\u0073\u0001\uffff\u0001\u0074\u0001\uffff\u0001\u0075"+
            "\u0005\uffff\u0001\u007a\u0001\u0078\u0002\uffff\u0001\u0076"+
            "\u0004\uffff\u0001\u0077\u0002\uffff\u0001\u0079",
            "\u0001\u007b\u0002\uffff\u0001\u007c\u0001\u0081\u0005\uffff"+
            "\u0001\u007d\u0002\uffff\u0001\u007e\u0002\uffff\u0001\u0080"+
            "\u0003\uffff\u0001\u007f",
            "\u0001\u0082\u0001\uffff\u0001\u0083\u0002\uffff\u0001\u0084",
            "\u0001\u0085\u0003\uffff\u0001\u0086",
            "\u0001\u0089\u0002\uffff\u0001\u0087\u0001\u0088\u0005\uffff"+
            "\u0001\u008a",
            "\u0001\u008b",
            "\u0001\u008c",
            "\u0001\u008d",
            "\u0001\u008e",
            "\u0001\u008f",
            "\u0001\u0090",
            "\u0001\u0092\u0016\uffff\u0001\u0093",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u009d\u0002\uffff\u0001\u009c",
            "\u0001\u009f",
            "",
            "\u0001\u00a1",
            "\u0001\u00a3",
            "",
            "\u0001\u00a6",
            "",
            "",
            "\u0001\u00aa",
            "\u0001\u00af\u000d\uffff\u0001\u00ae\u000c\uffff\u0001\u00ad"+
            "\u0001\u00ac\u0001\uffff\u0001\u00b0",
            "\u0001\u00b2\u0001\u00b3",
            "\u0001\u00b5\u000e\uffff\u0001\u00b6",
            "\u0001\u00b8\u0001\uffff\u000a\u00ba",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u00c2\u0001\uffff\u000a\u00c1\u000b\uffff\u0001\u00c3"+
            "\u001f\uffff\u0001\u00c3",
            "",
            "\u0001\u00c4\u0001\u00c5\u0014\uffff\u0001\u00c6",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0002\u003f\u0001\u00c7"+
            "\u0017\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0013\u003f\u0001\u00c9"+
            "\u0006\u003f",
            "\u0001\u00cb",
            "\u0001\u00cc",
            "\u0001\u00cd",
            "\u0001\u00ce",
            "",
            "\u0001\u00cf",
            "\u0001\u00d0",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u00d2",
            "\u0001\u00d3",
            "\u0001\u00d4",
            "\u0001\u00d5\u0001\u00d6",
            "\u0001\u00d8\u0003\uffff\u0001\u00d7",
            "\u0001\u00d9\u0001\u00da\u0001\u00db\u0001\uffff\u0001\u00dc"+
            "\u0004\uffff\u0001\u00dd",
            "\u0001\u00de\u0002\uffff\u0001\u00df\u0005\uffff\u0001\u00e1"+
            "\u0006\uffff\u0001\u00e0",
            "\u0001\u00e4\u0004\uffff\u0001\u00e5\u0001\u00e3\u000b\uffff"+
            "\u0001\u00e6\u0002\uffff\u0001\u00e2",
            "\u0001\u00e7",
            "\u0001\u00e8\u000d\uffff\u0001\u00e9",
            "\u0001\u00ea",
            "\u0001\u00eb\u0001\u00ec\u000f\uffff\u0001\u00ed",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u00ef",
            "\u0001\u00f2\u0001\uffff\u0001\u00f0\u0005\uffff\u0001\u00f3"+
            "\u000a\uffff\u0001\u00f1",
            "\u0001\u00f4\u0005\uffff\u0001\u00f5",
            "\u0001\u00f6",
            "\u0001\u00f7",
            "\u0001\u00f8",
            "\u0001\u00f9\u0033\uffff\u0001\u00fa\u000c\uffff\u0001\u00fb"+
            "\u0001\u00fc",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u00fe\u0009\uffff\u0001\u00ff",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0101",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0103",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0003\u003f\u0001\u0108"+
            "\u0001\u003f\u0001\u0107\u0001\u003f\u0001\u0104\u000a\u003f"+
            "\u0001\u0105\u0001\u0106\u0006\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u010b",
            "\u0001\u010e\u0004\uffff\u0001\u010d\u0004\uffff\u0001\u010c",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0001\u010f\u0012\u003f"+
            "\u0001\u0110\u0001\u003f\u0001\u0111\u0004\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0115\u0007\uffff\u0001\u0114",
            "\u0001\u0116\u000e\uffff\u0001\u0117",
            "\u0001\u0118",
            "\u0001\u0119",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0017\u003f\u0001\u011a"+
            "\u0002\u003f",
            "\u0001\u011c\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u0003\u003f"+
            "\u0001\u011d\u000f\u003f\u0001\u011e\u0006\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0121",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0003\u003f\u0001\u0122"+
            "\u0016\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u000b\u003f\u0001\u0124"+
            "\u000e\u003f",
            "\u0001\u0126",
            "\u0001\u0127\u0001\uffff\u0001\u0128",
            "\u0001\u0129\u0009\uffff\u0001\u012a",
            "\u0001\u012b",
            "\u0001\u012c",
            "\u0001\u0131\u0001\uffff\u0001\u012e\u0001\uffff\u0001\u012f"+
            "\u0003\uffff\u0001\u012d\u0001\uffff\u0001\u0130",
            "\u0001\u0133\u0006\uffff\u0001\u0132",
            "\u0001\u0134\u0006\uffff\u0001\u0135",
            "\u0001\u0136\u0001\uffff\u0001\u0137",
            "\u0001\u0138",
            "\u0001\u0139\u0003\uffff\u0001\u013b\u0009\uffff\u0001\u013c"+
            "\u0002\uffff\u0001\u013a",
            "\u0001\u013d",
            "\u0001\u013e",
            "\u0001\u013f",
            "\u0001\u0140",
            "\u0001\u0141",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0143\u0013\uffff\u0001\u0144",
            "\u0001\u0145",
            "\u0001\u0146",
            "\u0001\u0147",
            "\u0001\u0148\u0005\uffff\u0001\u0149",
            "\u0001\u014a\u000b\uffff\u0001\u014b",
            "\u0001\u014c",
            "\u0001\u014d\u0005\uffff\u0001\u014e",
            "\u0001\u014f",
            "\u0001\u0150\u0003\uffff\u0001\u0151",
            "\u0001\u0154\u0001\uffff\u0001\u0152\u0005\uffff\u0001\u0153",
            "\u0001\u0155",
            "\u0001\u0156",
            "\u0001\u0157",
            "\u0001\u0158",
            "\u0001\u0159",
            "\u0001\u015a",
            "\u0001\u015b",
            "",
            "",
            "\u0002\u015d\u0002\uffff\u0001\u015d\u0012\uffff\u0001\u015d"+
            "\u0020\uffff\u001a\u015d\u0004\uffff\u0001\u015d\u0001\uffff"+
            "\u001a\u015d",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u015e",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u0160",
            "\u0002\u0162\u0002\uffff\u0001\u0162\u0012\uffff\u0001\u0162"+
            "\u0020\uffff\u001a\u0162\u0004\uffff\u0001\u0162\u0001\uffff"+
            "\u001a\u0162",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u000a\u00ba\u000b\uffff\u0001\u00c3\u001f\uffff\u0001\u00c3",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u00c2\u0001\uffff\u000a\u00c1\u000b\uffff\u0001\u00c3"+
            "\u001f\uffff\u0001\u00c3",
            "\u000a\u0164\u000b\uffff\u0001\u00c3\u001f\uffff\u0001\u00c3",
            "",
            "\u0001\u0165",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0168",
            "",
            "\u0001\u0169",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u000e\u003f\u0001\u016a"+
            "\u000b\u003f",
            "\u0001\u016c",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u016e",
            "\u0001\u016f",
            "\u0001\u0170",
            "",
            "\u0001\u0171",
            "\u0001\u0172",
            "\u0001\u0173",
            "\u0001\u0174\u000e\uffff\u0001\u0175",
            "\u0001\u0176",
            "\u0001\u0177",
            "\u0001\u0178",
            "\u0001\u0179",
            "\u0001\u017a",
            "\u0001\u017b\u0001\u017c",
            "\u0001\u017d",
            "\u0001\u017e",
            "\u0001\u0180\u0002\uffff\u0001\u017f",
            "\u0001\u0181",
            "\u0001\u0182",
            "\u0001\u0183",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0185",
            "\u0001\u0186",
            "\u0001\u0187",
            "\u0001\u0188",
            "\u0001\u0189",
            "\u0001\u018a",
            "\u0001\u018b",
            "\u0001\u018c",
            "\u0001\u018d",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u018f",
            "",
            "\u0001\u0190",
            "\u0001\u0191",
            "\u0001\u0192",
            "\u0001\u0193",
            "\u0001\u0194",
            "\u0001\u0195",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0004\u003f\u0001\u0196"+
            "\u0015\u003f",
            "\u0001\u0198",
            "\u0001\u0199",
            "\u0001\u019a",
            "\u0001\u019b",
            "\u0001\u019c",
            "\u0001\u019d",
            "\u0001\u019e",
            "",
            "\u0001\u019f",
            "\u0001\u01a0",
            "",
            "\u0001\u01a1",
            "",
            "\u0001\u01a2",
            "\u0001\u01a3",
            "\u0001\u01a5\u000e\uffff\u0001\u01a4",
            "\u0001\u01a6\u0009\uffff\u0001\u01a7",
            "\u0001\u01a8",
            "\u0001\u01a9",
            "",
            "",
            "\u0001\u01aa",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u01ac",
            "\u0001\u01ad",
            "\u0001\u01ae",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u01b0",
            "",
            "",
            "\u0001\u01b1",
            "\u0001\u01b2",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0008\u003f\u0001\u01b4"+
            "\u000b\u003f\u0001\u01b3\u0005\u003f",
            "\u0001\u01b6",
            "\u0001\u01b7",
            "\u0001\u01b8",
            "\u0001\u01b9",
            "",
            "\u0001\u01ba\u0006\uffff\u0001\u01bb",
            "\u0001\u01bc",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0001\u01be",
            "\u0001\u01bf",
            "",
            "\u0001\u01c0",
            "",
            "\u0001\u01c1",
            "\u0001\u01c3\u0003\uffff\u0001\u01c2",
            "\u0001\u01c4",
            "\u0001\u01c5\u000f\uffff\u0001\u01c6\u0002\uffff\u0001\u01c7",
            "\u0001\u01c8",
            "\u0001\u01ca\u0035\uffff\u0001\u01c9",
            "\u0001\u01cb",
            "\u0001\u01cc",
            "\u0001\u01cd",
            "\u0001\u01ce",
            "\u0001\u01cf",
            "\u0001\u01d0",
            "\u0001\u01d1",
            "\u0001\u01d2",
            "\u0001\u01d3",
            "\u0001\u01d4",
            "\u0001\u01d5",
            "\u0001\u01d6\u0001\u01d7",
            "\u0001\u01d8",
            "\u0001\u01d9\u000f\uffff\u0001\u01da",
            "\u0001\u01db",
            "\u0001\u01dc",
            "\u0001\u01dd",
            "\u0001\u01de",
            "\u0001\u01df",
            "\u0001\u01e0",
            "\u0001\u01e1",
            "\u0001\u01e2\u0004\uffff\u0001\u01e3",
            "",
            "\u0001\u01e4",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u01e6",
            "\u0001\u01e7",
            "\u0001\u01e8",
            "\u0001\u01e9\u0001\uffff\u0001\u01ea",
            "\u0001\u01eb",
            "\u0001\u01ec",
            "\u0001\u01ed",
            "\u0001\u01ee",
            "\u0001\u01ef\u000b\uffff\u0001\u01f0",
            "\u0001\u01f1",
            "\u0001\u01f2",
            "\u0001\u01f4\u0003\uffff\u0001\u01f3",
            "\u0001\u01f5",
            "\u0001\u01f6",
            "\u0001\u01f7",
            "\u0001\u01f8",
            "\u0001\u01f9",
            "\u0001\u01fa",
            "\u0001\u01fb",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u01fd",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u01ff",
            "",
            "",
            "",
            "",
            "\u0001\u0200",
            "",
            "",
            "",
            "\u000a\u0164\u000b\uffff\u0001\u00c3\u001f\uffff\u0001\u00c3",
            "\u0001\u0201",
            "",
            "",
            "\u0001\u0202",
            "\u0001\u0203",
            "\u0001\u0204",
            "",
            "\u0001\u0205",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0207",
            "\u0001\u0208",
            "\u0001\u0209",
            "\u0001\u020a",
            "\u0001\u020b",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0001\u020d\u0019\u003f",
            "\u0001\u020f",
            "\u0001\u0210",
            "\u0001\u0211",
            "\u0001\u0212\u0003\uffff\u0001\u0213",
            "\u0001\u0214",
            "\u0001\u0215",
            "\u0001\u0217\u0003\uffff\u0001\u0216\u0003\uffff\u0001\u0218",
            "\u0001\u0219\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u021b",
            "\u0001\u021c",
            "\u0001\u021d",
            "\u0001\u021e",
            "\u0001\u021f",
            "\u0001\u0220",
            "",
            "\u0001\u0221",
            "\u0001\u0222",
            "\u0001\u0223",
            "\u0001\u0224",
            "\u0001\u0225",
            "\u0001\u0226",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0228",
            "\u0001\u0229",
            "",
            "\u0001\u022a",
            "\u0001\u022b",
            "\u0001\u022c",
            "\u0001\u022d",
            "\u0001\u022e",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0230",
            "\u0001\u0231\u0007\uffff\u0001\u0232",
            "",
            "\u0001\u0233",
            "\u0001\u0234",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0236",
            "\u0001\u0237",
            "\u0001\u0238",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u023a",
            "\u0001\u023b",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u023d",
            "\u0001\u023e",
            "\u0001\u023f",
            "\u0001\u0241\u0003\uffff\u0001\u0240",
            "\u0001\u0243\u000a\uffff\u0001\u0242",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0245",
            "\u0001\u0246",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0249",
            "\u0001\u024a",
            "",
            "\u0001\u024b",
            "\u0001\u024c",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u024e",
            "\u0001\u024f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0251",
            "\u0001\u0252",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0254",
            "\u0001\u0255",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0012\u003f\u0001\u0256"+
            "\u0007\u003f",
            "",
            "\u0001\u0258",
            "\u0001\u0259",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u025b",
            "\u0001\u025c",
            "\u0001\u025d",
            "\u0001\u025e",
            "\u0001\u025f",
            "\u0001\u0260",
            "\u0001\u0261",
            "\u0001\u0262",
            "\u0001\u0263",
            "\u0001\u0264",
            "\u0001\u0265",
            "\u0001\u0266",
            "\u0001\u0267",
            "\u0001\u0268",
            "\u0001\u0269",
            "\u0001\u026a",
            "\u0001\u026b",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u026d",
            "\u0001\u026e",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0270",
            "\u0001\u0271",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0273",
            "\u0001\u0274",
            "\u0001\u0275\u000c\uffff\u0001\u0276",
            "\u0001\u0277",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0279",
            "\u0001\u027a",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u027e",
            "\u0001\u027f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0012\u003f\u0001\u0280"+
            "\u0007\u003f",
            "\u0001\u0282",
            "\u0001\u0283",
            "\u0001\u0284",
            "\u0001\u0285",
            "\u0001\u0286",
            "\u0001\u0287",
            "\u0001\u0288",
            "\u0001\u0289",
            "\u0001\u028a",
            "\u0001\u028b",
            "\u0001\u028c",
            "\u0001\u028d",
            "\u0001\u028e",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0290",
            "\u0001\u0291",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u000e\u003f\u0001\u0292"+
            "\u000b\u003f",
            "\u0001\u0294",
            "\u0001\u0295",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0012\u003f\u0001\u0296"+
            "\u0007\u003f",
            "\u0001\u0298",
            "",
            "\u0001\u0299",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0000\u029c",
            "\u0001\u029d",
            "\u0001\u029e",
            "\u0001\u029f",
            "\u0001\u02a0",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u02a2",
            "\u0001\u02a3",
            "\u0001\u02a4",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u02a6",
            "",
            "\u0001\u02a7",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u02ab",
            "\u0001\u02ac",
            "\u0001\u02ad",
            "\u0001\u02ae",
            "\u0001\u02b0\u0009\uffff\u0001\u02af",
            "\u0001\u02b1",
            "\u0001\u02b2",
            "\u0001\u02b3",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u02b5",
            "\u0001\u02b6",
            "\u0001\u02b7",
            "\u0001\u02b8",
            "\u0001\u02b9",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u02bb",
            "\u0001\u02bc",
            "\u0001\u02bd",
            "\u0001\u02be",
            "\u0001\u02bf",
            "",
            "\u0001\u02c0\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u02c2",
            "\u0001\u02c3",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u02c5",
            "\u0001\u02c6",
            "\u0001\u02c7",
            "",
            "\u0001\u02c8",
            "\u0001\u02c9",
            "\u0001\u02ca",
            "\u0001\u02cb",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u02cd",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u02d0",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0008\u003f\u0001\u02d1"+
            "\u0011\u003f",
            "",
            "\u0001\u02d3",
            "\u0001\u02d4",
            "\u0001\u02d5",
            "\u0001\u02d6",
            "\u0001\u02d7",
            "\u0001\u02d8",
            "\u0001\u02d9",
            "",
            "\u0001\u02da",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0001\u02dc",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u02de",
            "\u0001\u02df",
            "",
            "\u0001\u02e0",
            "\u0001\u02e1",
            "",
            "\u0001\u02e2",
            "\u0001\u02e3",
            "",
            "\u0001\u02e4",
            "\u0001\u02e5",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u02e7",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0004\u003f\u0001\u02e8"+
            "\u0003\u003f\u0001\u02e9\u0011\u003f",
            "",
            "\u0001\u02eb",
            "\u0001\u02ec",
            "\u0001\u02ed",
            "\u0001\u02ee",
            "\u0001\u02ef",
            "\u0001\u02f0",
            "\u0001\u02f1",
            "\u0001\u02f2",
            "\u0001\u02f3",
            "\u0001\u02f4",
            "\u0001\u02f5",
            "\u0001\u02f6",
            "\u0001\u02f7",
            "\u0001\u02f8",
            "\u0001\u02f9",
            "\u0001\u02fa",
            "\u0001\u02fb",
            "",
            "\u0001\u02fc",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u02fe",
            "\u0001\u02ff",
            "",
            "\u0001\u0300",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0302",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0304",
            "",
            "\u0001\u0305",
            "\u0001\u0306",
            "",
            "",
            "",
            "\u0001\u0307",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0309",
            "",
            "\u0001\u030a",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u030d",
            "\u0001\u030e",
            "\u0001\u030f",
            "\u0001\u0310",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0312",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0314",
            "\u0001\u0315",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0318",
            "\u0001\u0319",
            "",
            "\u0001\u031a",
            "\u0001\u031b",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u031d",
            "\u0001\u031e",
            "",
            "",
            "",
            "\u0001\u031f",
            "\u0001\u0320",
            "\u0001\u0321",
            "\u0001\u0322",
            "",
            "\u0001\u0323",
            "\u0001\u0324",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0327",
            "",
            "",
            "",
            "\u0001\u0328",
            "\u0001\u0329",
            "\u0001\u032a",
            "\u0001\u032c\u0013\uffff\u0001\u032b",
            "\u0001\u032d",
            "\u0001\u032e",
            "\u0001\u032f",
            "\u0001\u0330",
            "\u0001\u0331",
            "",
            "\u0001\u0332",
            "\u0001\u0333",
            "\u0001\u0334",
            "\u0001\u0335",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0337",
            "\u0001\u0338",
            "\u0001\u0339",
            "\u0001\u033a",
            "\u0001\u033b",
            "\u0001\u033c",
            "",
            "\u0001\u033d",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0340",
            "\u0001\u0341",
            "\u0001\u0342",
            "\u0001\u0343",
            "\u0001\u0344",
            "\u0001\u0345",
            "",
            "\u0001\u0346",
            "",
            "",
            "\u0001\u0347",
            "\u0001\u0348",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u034a",
            "\u0001\u034b",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u034d",
            "\u0001\u034e",
            "\u0001\u034f",
            "\u0001\u0350",
            "",
            "\u0001\u0351",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0353",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0356",
            "\u0001\u0357",
            "\u0001\u0358",
            "\u0001\u0359",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u035b",
            "\u0001\u035c",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u035f",
            "\u0001\u0360",
            "\u0001\u0361",
            "\u0001\u0362",
            "\u0001\u0363",
            "\u0001\u0364",
            "\u0001\u0365",
            "\u0001\u0366",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0008\u003f\u0001\u0368"+
            "\u0011\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u036b",
            "\u0001\u036c",
            "\u0001\u036d",
            "\u0001\u036e",
            "\u0001\u036f\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0371",
            "\u0001\u0372",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0375",
            "\u0001\u0376",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0378",
            "",
            "\u0001\u0379",
            "\u0001\u037a",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u037c",
            "\u0001\u037d",
            "\u0001\u037e",
            "",
            "\u0001\u037f",
            "",
            "\u0001\u0380",
            "\u0001\u0381",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0383",
            "\u0001\u0384",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0387",
            "\u0001\u0388",
            "\u0001\u0389",
            "\u0001\u038a",
            "\u0001\u038b",
            "\u0001\u038c",
            "\u0001\u038d",
            "",
            "",
            "\u0001\u038e",
            "\u0001\u038f",
            "\u0001\u0390",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0392",
            "\u0001\u0393",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0396",
            "\u0001\u0397",
            "\u0001\u0398",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u039a",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u039c\u0007\uffff\u0001\u039d",
            "",
            "\u0001\u039e",
            "\u0001\u039f",
            "\u0001\u03a0",
            "\u0001\u03a1",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03a3",
            "\u0001\u03a4",
            "",
            "",
            "\u0001\u03a5",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03a7",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03aa",
            "\u0001\u03ab",
            "\u0001\u03ac",
            "\u0001\u03ad",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03af",
            "",
            "\u0001\u03b0",
            "\u0001\u03b1",
            "\u0001\u03b2",
            "\u0001\u03b3",
            "\u0001\u03b4",
            "",
            "\u0001\u03b5",
            "",
            "",
            "\u0001\u03b6",
            "\u0001\u03b7",
            "\u0001\u03b8",
            "\u0001\u03b9",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03bb",
            "",
            "",
            "\u0001\u03bc",
            "\u0001\u03bd",
            "\u0001\u03be",
            "\u0001\u03bf",
            "\u0001\u03c0",
            "\u0001\u03c1",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03c3",
            "",
            "\u0001\u03c4",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03c6",
            "\u0001\u03c7",
            "\u0001\u03c8",
            "\u0001\u03c9\u0003\uffff\u0001\u03ca",
            "",
            "\u0001\u03cb",
            "\u0001\u03cc",
            "",
            "",
            "\u0001\u03cd",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u03cf",
            "\u0001\u03d0",
            "\u0001\u03d1",
            "",
            "\u0001\u03d2",
            "\u0001\u03d3",
            "\u0001\u03d4",
            "\u0001\u03d5",
            "\u0001\u03d6",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03d9",
            "",
            "",
            "\u0001\u03da",
            "\u0001\u03db\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03dd",
            "\u0001\u03de",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03e1",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03e3",
            "\u0001\u03e4",
            "",
            "\u0001\u03e5",
            "\u0001\u03e6",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03e9",
            "",
            "\u0001\u03ea\u000c\uffff\u0001\u03eb",
            "",
            "\u0001\u03ec",
            "\u0001\u03ed",
            "\u0001\u03ee",
            "\u0001\u03ef",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03f1\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u03f3",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u03f6",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03f8",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03fa",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u03fc",
            "\u0001\u03fd",
            "\u0001\u03fe",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0401",
            "\u0001\u0402",
            "\u0001\u0403",
            "\u0001\u0404",
            "\u0001\u0405",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0407",
            "\u0001\u0408",
            "\u0001\u0409",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u040c",
            "",
            "\u0001\u040d",
            "\u0001\u040e",
            "",
            "\u0001\u040f",
            "\u0001\u0410",
            "\u0001\u0411",
            "\u0001\u0412",
            "\u0001\u0413",
            "\u0001\u0414",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0012\u003f\u0001\u0415"+
            "\u0007\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0418",
            "\u0001\u0419",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u041b",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u041d",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0001\u0420",
            "\u0001\u0421",
            "\u0001\u0422",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0001\u0425",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0427",
            "\u0001\u0428",
            "\u0001\u0429",
            "",
            "",
            "\u0001\u042a",
            "\u0001\u042b",
            "\u0001\u042c",
            "\u0001\u042d",
            "\u0001\u042e",
            "\u0001\u042f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0431",
            "",
            "\u0001\u0432",
            "",
            "",
            "\u0001\u0433\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0436",
            "",
            "\u0001\u0437",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u043b",
            "\u0001\u043c\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u043e",
            "\u0001\u043f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u0012\u003f\u0001\u0440"+
            "\u0007\u003f",
            "\u0001\u0442",
            "\u0001\u0443\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0001\u0445",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0448",
            "\u0001\u0449",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u044b",
            "\u0001\u044c",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0450",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0454",
            "\u0001\u0455",
            "",
            "",
            "\u0001\u0456",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0458",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u045a",
            "\u0001\u045b",
            "\u0001\u045c",
            "\u0001\u045d\u0001\u003f\u0001\uffff\u000a\u003f\u0007\uffff"+
            "\u001a\u003f\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0461",
            "\u0001\u0462",
            "\u0001\u0463",
            "",
            "",
            "\u0001\u0464",
            "\u0001\u0465",
            "",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0467",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0469",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u046b",
            "\u0001\u046c",
            "",
            "\u0001\u046d",
            "",
            "",
            "\u0001\u046e",
            "\u0001\u046f",
            "",
            "\u0001\u0470",
            "\u0001\u0471",
            "",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u0474",
            "\u0001\u0475",
            "",
            "\u0001\u0476",
            "",
            "\u0001\u0477",
            "\u0001\u0478",
            "\u0001\u0479",
            "\u0001\u047a",
            "",
            "",
            "",
            "\u0001\u047b",
            "\u0001\u047c",
            "\u0001\u047d",
            "\u0001\u047e",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0480",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u0482",
            "\u0001\u0483",
            "\u0001\u0484",
            "\u0001\u0485",
            "\u0001\u0486",
            "\u0001\u0487",
            "\u0001\u0488",
            "",
            "",
            "\u0001\u0489",
            "\u0001\u048a",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u048c",
            "\u0001\u048d",
            "\u0001\u048e",
            "\u0001\u048f",
            "\u0001\u0490",
            "\u0001\u0491",
            "\u0001\u0492",
            "\u0001\u0493",
            "",
            "\u0001\u0494",
            "",
            "\u0001\u0495",
            "\u0001\u0496",
            "\u0001\u0497",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u049a",
            "\u0001\u049b",
            "\u0001\u049c",
            "\u0001\u049d",
            "",
            "\u0001\u049e",
            "\u0001\u049f",
            "\u0001\u04a0",
            "\u0001\u04a1",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04a3",
            "\u0001\u04a4",
            "\u0001\u04a5",
            "\u0001\u04a6",
            "\u0001\u04a7",
            "\u0001\u04a8",
            "\u0001\u04a9",
            "",
            "",
            "\u0001\u04aa",
            "\u0001\u04ab",
            "\u0001\u04ac",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04ae",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04b0",
            "\u0001\u04b1",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04b3",
            "\u0001\u04b4",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04b6",
            "\u0001\u04b7",
            "\u0001\u04b8",
            "\u0001\u04b9",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04bb",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u04bd",
            "\u0001\u04be",
            "",
            "\u0001\u04bf",
            "\u0001\u04c0",
            "",
            "\u0001\u04c1",
            "\u0001\u04c2",
            "\u0001\u04c3",
            "\u0001\u04c4",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0001\u04c6",
            "\u0001\u04c7",
            "\u0001\u04c8",
            "\u0001\u04c9",
            "\u0001\u04ca",
            "\u0001\u04cb",
            "\u0001\u04cc",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04cf",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04d1",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "\u0001\u04d4",
            "",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            "",
            "",
            "\u0001\u04d7",
            "",
            "",
            "\u0001\u04d8",
            "\u0001\u04d9",
            "\u0001\u04da",
            "\u0002\u003f\u0001\uffff\u000a\u003f\u0007\uffff\u001a\u003f"+
            "\u0004\uffff\u0001\u003f\u0001\uffff\u001a\u003f",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryLexer, {
    DFA19_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryLexer.DFA19_eotS),
    DFA19_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryLexer.DFA19_eofS),
    DFA19_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryLexer.DFA19_minS),
    DFA19_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryLexer.DFA19_maxS),
    DFA19_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryLexer.DFA19_acceptS),
    DFA19_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryLexer.DFA19_specialS),
    DFA19_transition: (function() {
        var a = [],
            i,
            numStates = XQueryLexer.DFA19_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryLexer.DFA19_transitionS[i]));
        }
        return a;
    })()
});

XQueryLexer.DFA19 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 19;
    this.eot = XQueryLexer.DFA19_eot;
    this.eof = XQueryLexer.DFA19_eof;
    this.min = XQueryLexer.DFA19_min;
    this.max = XQueryLexer.DFA19_max;
    this.accept = XQueryLexer.DFA19_accept;
    this.special = XQueryLexer.DFA19_special;
    this.transition = XQueryLexer.DFA19_transition;
};

org.antlr.lang.extend(XQueryLexer.DFA19, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1:1: Tokens : ( ANCESTOR | ANCESTOR_OR_SELF | AND | AS | ASCENDING | AT | ATTRIBUTE | BASE_URI | BOUNDARY_SPACE | BY | CASE | CAST | CASTABLE | CHILD | COLLATION | COMMENT | CONSTRUCTION | COPY_NAMESPACES | DECLARE | DEFAULT | DESCENDANT | DESCENDANT_OR_SELF | DESCENDING | DIV | DOCUMENT | DOCUMENT_NODE | ELEMENT | ELSE | EMPTY | EMPTY_SEQUENCE | ENCODING | EQ | EVERY | EXCEPT | EXTERNAL | FOLLOWING | FOLLOWING_SIBLING | FOR | FUNCTION | GE | GREATEST | GT | IDIV | IF | IMPORT | IN | INHERIT | INSTANCE | INTERSECT | IS | ITEM | LAX | LE | LEAST | LET | LT | MOD | MODULE | NAMESPACE | NE | NO_INHERIT | NO_PRESERVE | NODE | OF | OPTION | OR | ORDER | ORDERED | ORDERING | PARENT | PRECEDING | PRECEDING_SIBLING | PRESERVE | PROCESSING_INSTRUCTION | RETURN | SATISFIES | SCHEMA | SCHEMA_ATTRIBUTE | SCHEMA_ELEMENT | SELF | SOME | STABLE | STRICT | STRIP | TEXT | THEN | TO | TREAT | TYPESWITCH | UNION | UNORDERED | VALIDATE | VARIABLE | VERSION | WHERE | XQUERY | ALLOWING | CATCH | CONTEXT | COUNT | DECIMAL_FORMAT | DECIMAL_SEPARATOR | DIGIT | END | GROUP | GROUPING_SEPARATOR | INFINITY | MINUS_SIGN | NAMESPACE_NODE | NAN | NEXT | ONLY | PATTERN_SEPARATOR | PERCENT | PER_MILLE | PREVIOUS | SLIDING | START | SWITCH | TRY | TUMBLING | TYPE | WHEN | WINDOW | ZERO_DIGIT | AFTER | BEFORE | COPY | DELETE | FIRST | INSERT | INTO | LAST | MODIFY | NODES | RENAME | REPLACE | REVALIDATION | SKIP | UPDATING | VALUE | WITH | ALL | ANY | CONTAINS | CONTENT | DIACRITICS | DIFFERENT | DISTANCE | ENTIRE | EXACTLY | FROM | FT_OPTION | FTAND | FTNOT | FTOR | INSENSITIVE | LANGUAGE | LEVELS | LOWERCASE | MOST | NO | NOT | OCCURS | PARAGRAPH | PARAGRAPHS | PHRASE | RELATIONSHIP | SAME | SCORE | SENSITIVE | SENTENCE | SENTENCES | STEMMING | STOP | THESAURUS | TIMES | UPPERCASE | USING | WEIGHT | WILDCARDS | WITHOUT | WORD | WORDS | BREAK | CONTINUE | EXIT | LOOP | RETURNING | WHILE | CHECK | COLLECTION | CONSTRAINT | FOREACH | FOREIGN | INDEX | INTEGRITY | KEY | ON | UNIQUE | BINARY | AMP_ER | APOS_ER | QUOT_ER | CONCAT | LPAREN | RPAREN | DOLLAR | LBRACKET | RBRACKET | LSQUARE | RSQUARE | EQUAL | BIND | NOTEQUAL | ANN_PERCENT | HASH | AMP | COMMA | QUESTION | STAR | PLUS | MINUS | SMALLER | GREATER | SMALLEREQ | GREATEREQ | SMALLER_SMALLER | GREATER_GREATER | SLASH | SLASH_SLASH | DOT | DOT_DOT | COLON | COLON_COLON | EMPTY_CLOSE_TAG | CLOSE_TAG | SEMICOLON | VBAR | PRAGMA_START | PRAGMA_END | XML_COMMENT_START | XML_COMMENT_END | PI_START | PI_END | ATTR_SIGN | CHARREF_DEC | CHARREF_HEX | APOS | QUOT | L_NCName | S | L_Pragma | L_DirCommentConstructor | L_DirPIConstructor | L_IntegerLiteral | L_DecimalLiteral | L_DoubleLiteral | L_Comment | L_AnyChar );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA19_0 = input.LA(1);

                            s = -1;
                            if ( (LA19_0=='a') ) {s = 1;}

                            else if ( (LA19_0=='b') ) {s = 2;}

                            else if ( (LA19_0=='c') ) {s = 3;}

                            else if ( (LA19_0=='d') ) {s = 4;}

                            else if ( (LA19_0=='e') ) {s = 5;}

                            else if ( (LA19_0=='f') ) {s = 6;}

                            else if ( (LA19_0=='g') ) {s = 7;}

                            else if ( (LA19_0=='i') ) {s = 8;}

                            else if ( (LA19_0=='l') ) {s = 9;}

                            else if ( (LA19_0=='m') ) {s = 10;}

                            else if ( (LA19_0=='n') ) {s = 11;}

                            else if ( (LA19_0=='o') ) {s = 12;}

                            else if ( (LA19_0=='p') ) {s = 13;}

                            else if ( (LA19_0=='r') ) {s = 14;}

                            else if ( (LA19_0=='s') ) {s = 15;}

                            else if ( (LA19_0=='t') ) {s = 16;}

                            else if ( (LA19_0=='u') ) {s = 17;}

                            else if ( (LA19_0=='v') ) {s = 18;}

                            else if ( (LA19_0=='w') ) {s = 19;}

                            else if ( (LA19_0=='x') ) {s = 20;}

                            else if ( (LA19_0=='N') ) {s = 21;}

                            else if ( (LA19_0=='z') ) {s = 22;}

                            else if ( (LA19_0=='k') ) {s = 23;}

                            else if ( (LA19_0=='q') ) {s = 24;}

                            else if ( (LA19_0=='|') ) {s = 25;}

                            else if ( (LA19_0=='(') ) {s = 26;}

                            else if ( (LA19_0==')') ) {s = 27;}

                            else if ( (LA19_0=='$') ) {s = 28;}

                            else if ( (LA19_0=='{') ) {s = 29;}

                            else if ( (LA19_0=='}') ) {s = 30;}

                            else if ( (LA19_0=='[') ) {s = 31;}

                            else if ( (LA19_0==']') ) {s = 32;}

                            else if ( (LA19_0=='=') ) {s = 33;}

                            else if ( (LA19_0==':') ) {s = 34;}

                            else if ( (LA19_0=='!') ) {s = 35;}

                            else if ( (LA19_0=='%') ) {s = 36;}

                            else if ( (LA19_0=='#') ) {s = 37;}

                            else if ( (LA19_0=='&') ) {s = 38;}

                            else if ( (LA19_0==',') ) {s = 39;}

                            else if ( (LA19_0=='?') ) {s = 40;}

                            else if ( (LA19_0=='*') ) {s = 41;}

                            else if ( (LA19_0=='+') ) {s = 42;}

                            else if ( (LA19_0=='-') ) {s = 43;}

                            else if ( (LA19_0=='<') ) {s = 44;}

                            else if ( (LA19_0=='>') ) {s = 45;}

                            else if ( (LA19_0=='/') ) {s = 46;}

                            else if ( (LA19_0=='.') ) {s = 47;}

                            else if ( (LA19_0==';') ) {s = 48;}

                            else if ( (LA19_0=='@') ) {s = 49;}

                            else if ( (LA19_0=='\'') ) {s = 50;}

                            else if ( (LA19_0=='\"') ) {s = 51;}

                            else if ( ((LA19_0>='A' && LA19_0<='M')||(LA19_0>='O' && LA19_0<='Z')||LA19_0=='_'||LA19_0=='h'||LA19_0=='j'||LA19_0=='y') ) {s = 52;}

                            else if ( ((LA19_0>='\t' && LA19_0<='\n')||LA19_0=='\r'||LA19_0==' ') ) {s = 53;}

                            else if ( ((LA19_0>='0' && LA19_0<='9')) ) {s = 54;}

                            else if ( ((LA19_0>='\u0000' && LA19_0<='\b')||(LA19_0>='\u000B' && LA19_0<='\f')||(LA19_0>='\u000E' && LA19_0<='\u001F')||LA19_0=='\\'||LA19_0=='^'||LA19_0=='`'||(LA19_0>='~' && LA19_0<='\uFFFF')) ) {s = 55;}

                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA19_26 = input.LA(1);

                             
                            var index19_26 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA19_26=='#') ) {s = 146;}

                            else if ( (LA19_26==':') && ((!this.inStr))) {s = 147;}

                            else s = 148;

                             
                            input.seek(index19_26);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA19_512 = input.LA(1);

                            s = -1;
                            if ( ((LA19_512>='\u0000' && LA19_512<='\uFFFF')) ) {s = 668;}

                            else s = 667;

                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 19, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
 
})();
exports.XQueryLexer = XQueryLexer;
});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
define('ace/mode/xquery/XQDTLexer', ['require', 'exports', 'module' , 'ace/mode/xquery/antlr3-all'], function(require, exports, module) {

var org =  require("./antlr3-all").org;

var XQDTLexer = exports.XQDTLexer = function(input, state)
{
  XQDTLexer.superclass.constructor.call(this, input, state);
};

org.antlr.lang.extend(XQDTLexer, org.antlr.runtime.Lexer, {

  comments: [],

  addComment: function(start, stop){ console.log("BOUH!"); },

  isWsExplicit: false,

  setIsWsExplicit: function (wsExplicit) {
    //console.log("A WS: " + wsExplicit);
    this.isWsExplicit = wsExplicit;
    //console.log("B WS: " + wsExplicit);
  },

  addToStack: function (stack) {
    stack.push(this);
  },

  rewindToIndex: function(index) {
    var stream = this.input;
    stream.seek(index);
  }
});

});
define('ace/mode/xquery/XQueryParser', ['require', 'exports', 'module' , 'ace/mode/xquery/antlr3-all', 'ace/mode/xquery/StringLexer', 'ace/mode/xquery/XMLLexer', 'ace/mode/xquery/XQueryLexer', 'ace/mode/xquery/XQDTParser', 'ace/mode/xquery/Position'], function(require, exports, module) {
// $ANTLR 3.3 Nov 30, 2010 12:50:56 xquery/XQueryParser.g 2012-04-18 21:05:15

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
var org =  require("./antlr3-all").org;
var StringLexer   = require("./StringLexer").StringLexer;
var XMLLexer   = require("./XMLLexer").XMLLexer;
var XQueryLexer   = require("./XQueryLexer").XQueryLexer;
var XQDTParser = require("./XQDTParser").XQDTParser;
var Position = require("./Position").Position;
var Exception = function(){};

var XQS = true;
var XQU = true;
var ZORBA = true;
var MLS = false;



var XQueryParser = function(input, state) {
    if (!state) {
        state = new org.antlr.runtime.RecognizerSharedState();
    }

    (function(){


        this.errors = [];

        this.hasErrors = function(){
          return this.errors.length > 0;
        };

        this.addError = function(error){
          this.errors.push(error);
        };

        this.getErrors = function(){
          return this.errors;
        };

        this.source = null;
        this.setSource = function(s){
          this.source = s;
          this.highlighter.setSource(s);
        };

        this.lexerStack = new Array();

        this.lc = function(b){ return b; };
        this.popLexer = function (){
          //console.log("popLexer");
          if(this.lexerStack.length == 0) return;
          this.getTokenStream().mark();
          var oldLexer = this.getTokenStream().getTokenSource();
          var newLexer = this.lexerStack.pop();
          if(oldLexer instanceof StringLexer && newLexer instanceof XQueryLexer) {
            newLexer.inStr = false;
          }
          this.getTokenStream().setTokenSource(newLexer);
        };

        this.pushXQueryLexer = function() {
          xqueryLexer = new XQueryLexer(this.source);
          this.pushLexer(xqueryLexer);
        };

        this.pushStringLexer = function(isAposStr){
          //console.log("pushStringLexer");
          var stringLexer = new StringLexer(this.source);
          stringLexer.inAposStr = isAposStr;
          stringLexer.inQuotStr = !isAposStr;
          stringLexer.setIsWsExplicit(true);
          this.pushLexer(stringLexer);
        };

        this.pushXMLLexer = function(){
          //console.log("pushXMLLexer");
          var xmlLexer = new XMLLexer(this.source);
          xmlLexer.setIsWsExplicit(true);
          this.pushLexer(xmlLexer);
        };

        this.pushLexer = function(lexer){
          var oldLexer = this.getTokenStream().getTokenSource();
          oldLexer.addToStack(this.lexerStack);
          this.getTokenStream().setTokenSource(lexer);
        };

        this.setWsExplicit = function(isExplicit){
          this.getTokenStream().setWsExplicit(isExplicit);
        };

        this.ax = function(start, stop)
        {
          this.highlighter.addToken(start.getStartIndex(), stop.getStopIndex(), "xml_pe");
        };

        this.at = function(start, stop)
        {
          this.highlighter.addToken(start.getStartIndex(), stop.getStopIndex(), "tag");
        };

        this.av = function(start, stop)
        {
          this.highlighter.addToken(start.getStartIndex(), stop.getStopIndex(), "variable");
        };

        this.af = function(start, stop)
        {
          this.highlighter.addToken(start.getStartIndex(), stop.getStopIndex(), "function");
        };

        this.ao = function(t)
        {
          this.addToken(t, "operator");
        };

        this.ak = function(t)
        {
          this.addToken(t, "keyword");
        };

        this.ad = function(t)
        {
          this.addToken(t, "constant");
        };

        this.addString = function(start, stop)
        {
         if(stop == undefined) {
           this.addToken(start, "string");
         } else {
           this.highlighter.addToken(start.getStartIndex(), stop.getStopIndex(), "string");
         }
        };

        this.ac = function(t)
        {
          this.addToken(t, "comment");
        };

        this.addToken = function(k, type){
          if(org.antlr.lang.isArray(k)){
            for(i in k)
            {
              this.highlighter.addToken(k[i].getStartIndex(), k[i].getStopIndex(), type);
            }
          } else if(k != null ) {
            this.highlighter.addToken(k.getStartIndex(), k.getStopIndex(), type); 
          }
        };


    }).call(this);

    XQueryParser.superclass.constructor.call(this, input, state);

    this.dfa1 = new XQueryParser.DFA1(this);
    this.dfa2 = new XQueryParser.DFA2(this);
    this.dfa6 = new XQueryParser.DFA6(this);
    this.dfa9 = new XQueryParser.DFA9(this);
    this.dfa44 = new XQueryParser.DFA44(this);
    this.dfa46 = new XQueryParser.DFA46(this);
    this.dfa116 = new XQueryParser.DFA116(this);
    this.dfa118 = new XQueryParser.DFA118(this);
    this.dfa120 = new XQueryParser.DFA120(this);
    this.dfa125 = new XQueryParser.DFA125(this);
    this.dfa133 = new XQueryParser.DFA133(this);
    this.dfa161 = new XQueryParser.DFA161(this);
    this.dfa163 = new XQueryParser.DFA163(this);
    this.dfa217 = new XQueryParser.DFA217(this);
    this.dfa236 = new XQueryParser.DFA236(this);
    this.dfa252 = new XQueryParser.DFA252(this);

         

    /* @todo only create adaptor if output=AST */
    this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();

};

org.antlr.lang.augmentObject(XQueryParser, {
    EOF: -1,
    L_QuotAttrContentChar: 4,
    L_AposAttrContentChar: 5,
    L_ElementContentChar: 6,
    L_CDataSection: 7,
    L_PredefinedEntityRef: 8,
    L_CharRef: 9,
    ESCAPE_LBRACKET: 10,
    ESCAPE_RBRACKET: 11,
    ESCAPE_APOS: 12,
    ESCAPE_QUOT: 13,
    CDATA_START: 14,
    CDATA_END: 15,
    ANCESTOR: 16,
    ANCESTOR_OR_SELF: 17,
    AND: 18,
    AS: 19,
    ASCENDING: 20,
    AT: 21,
    ATTRIBUTE: 22,
    BASE_URI: 23,
    BOUNDARY_SPACE: 24,
    BY: 25,
    CASE: 26,
    CAST: 27,
    CASTABLE: 28,
    CHILD: 29,
    COLLATION: 30,
    COMMENT: 31,
    CONSTRUCTION: 32,
    COPY_NAMESPACES: 33,
    DECLARE: 34,
    DEFAULT: 35,
    DESCENDANT: 36,
    DESCENDANT_OR_SELF: 37,
    DESCENDING: 38,
    DIV: 39,
    DOCUMENT: 40,
    DOCUMENT_NODE: 41,
    ELEMENT: 42,
    ELSE: 43,
    EMPTY: 44,
    EMPTY_SEQUENCE: 45,
    ENCODING: 46,
    EQ: 47,
    EVERY: 48,
    EXCEPT: 49,
    EXTERNAL: 50,
    FOLLOWING: 51,
    FOLLOWING_SIBLING: 52,
    FOR: 53,
    FUNCTION: 54,
    GE: 55,
    GREATEST: 56,
    GT: 57,
    IDIV: 58,
    IF: 59,
    IMPORT: 60,
    IN: 61,
    INHERIT: 62,
    INSTANCE: 63,
    INTERSECT: 64,
    IS: 65,
    ITEM: 66,
    LAX: 67,
    LE: 68,
    LEAST: 69,
    LET: 70,
    LT: 71,
    MOD: 72,
    MODULE: 73,
    NAMESPACE: 74,
    NE: 75,
    NO_INHERIT: 76,
    NO_PRESERVE: 77,
    NODE: 78,
    OF: 79,
    OPTION: 80,
    OR: 81,
    ORDER: 82,
    ORDERED: 83,
    ORDERING: 84,
    PARENT: 85,
    PRECEDING: 86,
    PRECEDING_SIBLING: 87,
    PRESERVE: 88,
    PROCESSING_INSTRUCTION: 89,
    RETURN: 90,
    SATISFIES: 91,
    SCHEMA: 92,
    SCHEMA_ATTRIBUTE: 93,
    SCHEMA_ELEMENT: 94,
    SELF: 95,
    SOME: 96,
    STABLE: 97,
    STRICT: 98,
    STRIP: 99,
    TEXT: 100,
    THEN: 101,
    TO: 102,
    TREAT: 103,
    TYPESWITCH: 104,
    UNION: 105,
    UNORDERED: 106,
    VALIDATE: 107,
    VARIABLE: 108,
    VERSION: 109,
    WHERE: 110,
    XQUERY: 111,
    ALLOWING: 112,
    CATCH: 113,
    CONTEXT: 114,
    COUNT: 115,
    DECIMAL_FORMAT: 116,
    DECIMAL_SEPARATOR: 117,
    DIGIT: 118,
    END: 119,
    GROUP: 120,
    GROUPING_SEPARATOR: 121,
    INFINITY: 122,
    MINUS_SIGN: 123,
    NAMESPACE_NODE: 124,
    NAN: 125,
    NEXT: 126,
    ONLY: 127,
    PATTERN_SEPARATOR: 128,
    PERCENT: 129,
    PER_MILLE: 130,
    PREVIOUS: 131,
    SLIDING: 132,
    START: 133,
    SWITCH: 134,
    TRY: 135,
    TUMBLING: 136,
    TYPE: 137,
    WHEN: 138,
    WINDOW: 139,
    ZERO_DIGIT: 140,
    AFTER: 141,
    BEFORE: 142,
    COPY: 143,
    DELETE: 144,
    FIRST: 145,
    INSERT: 146,
    INTO: 147,
    LAST: 148,
    MODIFY: 149,
    NODES: 150,
    RENAME: 151,
    REPLACE: 152,
    REVALIDATION: 153,
    SKIP: 154,
    UPDATING: 155,
    VALUE: 156,
    WITH: 157,
    ALL: 158,
    ANY: 159,
    CONTAINS: 160,
    CONTENT: 161,
    DIACRITICS: 162,
    DIFFERENT: 163,
    DISTANCE: 164,
    ENTIRE: 165,
    EXACTLY: 166,
    FROM: 167,
    FT_OPTION: 168,
    FTAND: 169,
    FTNOT: 170,
    FTOR: 171,
    INSENSITIVE: 172,
    LANGUAGE: 173,
    LEVELS: 174,
    LOWERCASE: 175,
    MOST: 176,
    NO: 177,
    NOT: 178,
    OCCURS: 179,
    PARAGRAPH: 180,
    PARAGRAPHS: 181,
    PHRASE: 182,
    RELATIONSHIP: 183,
    SAME: 184,
    SCORE: 185,
    SENSITIVE: 186,
    SENTENCE: 187,
    SENTENCES: 188,
    STEMMING: 189,
    STOP: 190,
    THESAURUS: 191,
    TIMES: 192,
    UPPERCASE: 193,
    USING: 194,
    WEIGHT: 195,
    WILDCARDS: 196,
    WITHOUT: 197,
    WORD: 198,
    WORDS: 199,
    BREAK: 200,
    CONTINUE: 201,
    EXIT: 202,
    LOOP: 203,
    RETURNING: 204,
    WHILE: 205,
    CHECK: 206,
    COLLECTION: 207,
    CONSTRAINT: 208,
    FOREACH: 209,
    FOREIGN: 210,
    INDEX: 211,
    INTEGRITY: 212,
    KEY: 213,
    ON: 214,
    UNIQUE: 215,
    BINARY: 216,
    AMP_ER: 217,
    APOS_ER: 218,
    QUOT_ER: 219,
    CONCAT: 220,
    LPAREN: 221,
    RPAREN: 222,
    DOLLAR: 223,
    LBRACKET: 224,
    RBRACKET: 225,
    LSQUARE: 226,
    RSQUARE: 227,
    EQUAL: 228,
    BIND: 229,
    NOTEQUAL: 230,
    ANN_PERCENT: 231,
    HASH: 232,
    AMP: 233,
    COMMA: 234,
    QUESTION: 235,
    STAR: 236,
    PLUS: 237,
    MINUS: 238,
    SMALLER: 239,
    GREATER: 240,
    SMALLEREQ: 241,
    GREATEREQ: 242,
    SMALLER_SMALLER: 243,
    GREATER_GREATER: 244,
    SLASH: 245,
    SLASH_SLASH: 246,
    DOT: 247,
    DOT_DOT: 248,
    COLON: 249,
    COLON_COLON: 250,
    EMPTY_CLOSE_TAG: 251,
    CLOSE_TAG: 252,
    SEMICOLON: 253,
    VBAR: 254,
    PRAGMA_START: 255,
    PRAGMA_END: 256,
    XML_COMMENT_START: 257,
    XML_COMMENT_END: 258,
    PI_START: 259,
    PI_END: 260,
    ATTR_SIGN: 261,
    CHARREF_DEC: 262,
    CHARREF_HEX: 263,
    APOS: 264,
    QUOT: 265,
    NCNameStartChar: 266,
    NCNameChar: 267,
    L_NCName: 268,
    Letter: 269,
    HexLetter: 270,
    Digit: 271,
    Digits: 272,
    S: 273,
    SU: 274,
    L_Pragma: 275,
    L_DirCommentConstructor: 276,
    L_DirPIConstructor: 277,
    L_IntegerLiteral: 278,
    L_DecimalLiteral: 279,
    L_DoubleLiteral: 280,
    L_Comment: 281,
    L_AnyChar: 282,
    L_QuotStringLiteralChar: 283,
    L_AposStringLiteralChar: 284,
    LibraryModule: 285,
    MainModule: 286,
    VersionDecl: 287,
    VersionDeclEncoding: 288,
    VersionDeclVersion: 289,
    ModuleDecl: 290,
    Prolog: 291,
    DefaultNamespaceDecls: 292,
    DefaultNamespaceDecl: 293,
    Setters: 294,
    Setter: 295,
    NamespaceDecls: 296,
    NamespaceDecl: 297,
    Imports: 298,
    FTOptionDecls: 299,
    SchemaImport: 300,
    SchemaPrefix: 301,
    NamespaceName: 302,
    DefaultElementNamespace: 303,
    AtHints: 304,
    ModuleImport: 305,
    BaseURIDecl: 306,
    OrderedDecls: 307,
    VarDecl: 308,
    VarType: 309,
    VarValue: 310,
    VarDefaultValue: 311,
    VarVariableDecl: 312,
    FunctionDecl: 313,
    ParamList: 314,
    ReturnType: 315,
    OptionDecl: 316,
    TypeDeclaration: 317,
    Param: 318,
    EnclosedExpr: 319,
    QueryBody: 320,
    UnaryExpr: 321,
    DirElemConstructor: 322,
    DirAttributeList: 323,
    DirAttributeValue: 324,
    DirElemContent: 325,
    CommonContent: 326,
    SequenceType: 327,
    EmptySequenceTest: 328,
    KindTest: 329,
    ItemTest: 330,
    FunctionTest: 331,
    AtomicType: 332,
    AtomicOrUnionType: 333,
    StringLiteral: 334,
    ElementContentChar: 335,
    AttributeValueChar: 336,
    QName: 337,
    BlockExpr: 338,
    BinaryTest: 339,
    EXPLICITLY: 340
});

(function(){
// public class variables
var EOF= -1,
    L_QuotAttrContentChar= 4,
    L_AposAttrContentChar= 5,
    L_ElementContentChar= 6,
    L_CDataSection= 7,
    L_PredefinedEntityRef= 8,
    L_CharRef= 9,
    ESCAPE_LBRACKET= 10,
    ESCAPE_RBRACKET= 11,
    ESCAPE_APOS= 12,
    ESCAPE_QUOT= 13,
    CDATA_START= 14,
    CDATA_END= 15,
    ANCESTOR= 16,
    ANCESTOR_OR_SELF= 17,
    AND= 18,
    AS= 19,
    ASCENDING= 20,
    AT= 21,
    ATTRIBUTE= 22,
    BASE_URI= 23,
    BOUNDARY_SPACE= 24,
    BY= 25,
    CASE= 26,
    CAST= 27,
    CASTABLE= 28,
    CHILD= 29,
    COLLATION= 30,
    COMMENT= 31,
    CONSTRUCTION= 32,
    COPY_NAMESPACES= 33,
    DECLARE= 34,
    DEFAULT= 35,
    DESCENDANT= 36,
    DESCENDANT_OR_SELF= 37,
    DESCENDING= 38,
    DIV= 39,
    DOCUMENT= 40,
    DOCUMENT_NODE= 41,
    ELEMENT= 42,
    ELSE= 43,
    EMPTY= 44,
    EMPTY_SEQUENCE= 45,
    ENCODING= 46,
    EQ= 47,
    EVERY= 48,
    EXCEPT= 49,
    EXTERNAL= 50,
    FOLLOWING= 51,
    FOLLOWING_SIBLING= 52,
    FOR= 53,
    FUNCTION= 54,
    GE= 55,
    GREATEST= 56,
    GT= 57,
    IDIV= 58,
    IF= 59,
    IMPORT= 60,
    IN= 61,
    INHERIT= 62,
    INSTANCE= 63,
    INTERSECT= 64,
    IS= 65,
    ITEM= 66,
    LAX= 67,
    LE= 68,
    LEAST= 69,
    LET= 70,
    LT= 71,
    MOD= 72,
    MODULE= 73,
    NAMESPACE= 74,
    NE= 75,
    NO_INHERIT= 76,
    NO_PRESERVE= 77,
    NODE= 78,
    OF= 79,
    OPTION= 80,
    OR= 81,
    ORDER= 82,
    ORDERED= 83,
    ORDERING= 84,
    PARENT= 85,
    PRECEDING= 86,
    PRECEDING_SIBLING= 87,
    PRESERVE= 88,
    PROCESSING_INSTRUCTION= 89,
    RETURN= 90,
    SATISFIES= 91,
    SCHEMA= 92,
    SCHEMA_ATTRIBUTE= 93,
    SCHEMA_ELEMENT= 94,
    SELF= 95,
    SOME= 96,
    STABLE= 97,
    STRICT= 98,
    STRIP= 99,
    TEXT= 100,
    THEN= 101,
    TO= 102,
    TREAT= 103,
    TYPESWITCH= 104,
    UNION= 105,
    UNORDERED= 106,
    VALIDATE= 107,
    VARIABLE= 108,
    VERSION= 109,
    WHERE= 110,
    XQUERY= 111,
    ALLOWING= 112,
    CATCH= 113,
    CONTEXT= 114,
    COUNT= 115,
    DECIMAL_FORMAT= 116,
    DECIMAL_SEPARATOR= 117,
    DIGIT= 118,
    END= 119,
    GROUP= 120,
    GROUPING_SEPARATOR= 121,
    INFINITY= 122,
    MINUS_SIGN= 123,
    NAMESPACE_NODE= 124,
    NAN= 125,
    NEXT= 126,
    ONLY= 127,
    PATTERN_SEPARATOR= 128,
    PERCENT= 129,
    PER_MILLE= 130,
    PREVIOUS= 131,
    SLIDING= 132,
    START= 133,
    SWITCH= 134,
    TRY= 135,
    TUMBLING= 136,
    TYPE= 137,
    WHEN= 138,
    WINDOW= 139,
    ZERO_DIGIT= 140,
    AFTER= 141,
    BEFORE= 142,
    COPY= 143,
    DELETE= 144,
    FIRST= 145,
    INSERT= 146,
    INTO= 147,
    LAST= 148,
    MODIFY= 149,
    NODES= 150,
    RENAME= 151,
    REPLACE= 152,
    REVALIDATION= 153,
    SKIP= 154,
    UPDATING= 155,
    VALUE= 156,
    WITH= 157,
    ALL= 158,
    ANY= 159,
    CONTAINS= 160,
    CONTENT= 161,
    DIACRITICS= 162,
    DIFFERENT= 163,
    DISTANCE= 164,
    ENTIRE= 165,
    EXACTLY= 166,
    FROM= 167,
    FT_OPTION= 168,
    FTAND= 169,
    FTNOT= 170,
    FTOR= 171,
    INSENSITIVE= 172,
    LANGUAGE= 173,
    LEVELS= 174,
    LOWERCASE= 175,
    MOST= 176,
    NO= 177,
    NOT= 178,
    OCCURS= 179,
    PARAGRAPH= 180,
    PARAGRAPHS= 181,
    PHRASE= 182,
    RELATIONSHIP= 183,
    SAME= 184,
    SCORE= 185,
    SENSITIVE= 186,
    SENTENCE= 187,
    SENTENCES= 188,
    STEMMING= 189,
    STOP= 190,
    THESAURUS= 191,
    TIMES= 192,
    UPPERCASE= 193,
    USING= 194,
    WEIGHT= 195,
    WILDCARDS= 196,
    WITHOUT= 197,
    WORD= 198,
    WORDS= 199,
    BREAK= 200,
    CONTINUE= 201,
    EXIT= 202,
    LOOP= 203,
    RETURNING= 204,
    WHILE= 205,
    CHECK= 206,
    COLLECTION= 207,
    CONSTRAINT= 208,
    FOREACH= 209,
    FOREIGN= 210,
    INDEX= 211,
    INTEGRITY= 212,
    KEY= 213,
    ON= 214,
    UNIQUE= 215,
    BINARY= 216,
    AMP_ER= 217,
    APOS_ER= 218,
    QUOT_ER= 219,
    CONCAT= 220,
    LPAREN= 221,
    RPAREN= 222,
    DOLLAR= 223,
    LBRACKET= 224,
    RBRACKET= 225,
    LSQUARE= 226,
    RSQUARE= 227,
    EQUAL= 228,
    BIND= 229,
    NOTEQUAL= 230,
    ANN_PERCENT= 231,
    HASH= 232,
    AMP= 233,
    COMMA= 234,
    QUESTION= 235,
    STAR= 236,
    PLUS= 237,
    MINUS= 238,
    SMALLER= 239,
    GREATER= 240,
    SMALLEREQ= 241,
    GREATEREQ= 242,
    SMALLER_SMALLER= 243,
    GREATER_GREATER= 244,
    SLASH= 245,
    SLASH_SLASH= 246,
    DOT= 247,
    DOT_DOT= 248,
    COLON= 249,
    COLON_COLON= 250,
    EMPTY_CLOSE_TAG= 251,
    CLOSE_TAG= 252,
    SEMICOLON= 253,
    VBAR= 254,
    PRAGMA_START= 255,
    PRAGMA_END= 256,
    XML_COMMENT_START= 257,
    XML_COMMENT_END= 258,
    PI_START= 259,
    PI_END= 260,
    ATTR_SIGN= 261,
    CHARREF_DEC= 262,
    CHARREF_HEX= 263,
    APOS= 264,
    QUOT= 265,
    NCNameStartChar= 266,
    NCNameChar= 267,
    L_NCName= 268,
    Letter= 269,
    HexLetter= 270,
    Digit= 271,
    Digits= 272,
    S= 273,
    SU= 274,
    L_Pragma= 275,
    L_DirCommentConstructor= 276,
    L_DirPIConstructor= 277,
    L_IntegerLiteral= 278,
    L_DecimalLiteral= 279,
    L_DoubleLiteral= 280,
    L_Comment= 281,
    L_AnyChar= 282,
    L_QuotStringLiteralChar= 283,
    L_AposStringLiteralChar= 284,
    LibraryModule= 285,
    MainModule= 286,
    VersionDecl= 287,
    VersionDeclEncoding= 288,
    VersionDeclVersion= 289,
    ModuleDecl= 290,
    Prolog= 291,
    DefaultNamespaceDecls= 292,
    DefaultNamespaceDecl= 293,
    Setters= 294,
    Setter= 295,
    NamespaceDecls= 296,
    NamespaceDecl= 297,
    Imports= 298,
    FTOptionDecls= 299,
    SchemaImport= 300,
    SchemaPrefix= 301,
    NamespaceName= 302,
    DefaultElementNamespace= 303,
    AtHints= 304,
    ModuleImport= 305,
    BaseURIDecl= 306,
    OrderedDecls= 307,
    VarDecl= 308,
    VarType= 309,
    VarValue= 310,
    VarDefaultValue= 311,
    VarVariableDecl= 312,
    FunctionDecl= 313,
    ParamList= 314,
    ReturnType= 315,
    OptionDecl= 316,
    TypeDeclaration= 317,
    Param= 318,
    EnclosedExpr= 319,
    QueryBody= 320,
    UnaryExpr= 321,
    DirElemConstructor= 322,
    DirAttributeList= 323,
    DirAttributeValue= 324,
    DirElemContent= 325,
    CommonContent= 326,
    SequenceType= 327,
    EmptySequenceTest= 328,
    KindTest= 329,
    ItemTest= 330,
    FunctionTest= 331,
    AtomicType= 332,
    AtomicOrUnionType= 333,
    StringLiteral= 334,
    ElementContentChar= 335,
    AttributeValueChar= 336,
    QName= 337,
    BlockExpr= 338,
    BinaryTest= 339,
    EXPLICITLY= 340;

// public instance methods/vars
org.antlr.lang.extend(XQueryParser, XQDTParser, {
        
    setTreeAdaptor: function(adaptor) {
        this.adaptor = adaptor;
    },
    getTreeAdaptor: function() {
        return this.adaptor;
    },

    getTokenNames: function() { return XQueryParser.tokenNames; },
    getGrammarFileName: function() { return "xquery/XQueryParser.g"; }
});
org.antlr.lang.augmentObject(XQueryParser.prototype, {

    // inline static return class
    p_Module_return: (function() {
        XQueryParser.p_Module_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Module_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:288:1: p_Module : (vd= p_VersionDecl )? (lm= p_LibraryModule[$vd.tree] -> | mm= p_MainModule[$vd.tree] ->) EOF ;
    // $ANTLR start "p_Module"
    p_Module: function() {
        var retval = new XQueryParser.p_Module_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var EOF1 = null;
         var vd = null;
         var lm = null;
         var mm = null;

        var EOF1_tree=null;
        var stream_EOF=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EOF");
        var stream_p_VersionDecl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_VersionDecl");
        var stream_p_LibraryModule=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_LibraryModule");
        var stream_p_MainModule=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_MainModule");
        try {
            // xquery/XQueryParser.g:289:9: ( (vd= p_VersionDecl )? (lm= p_LibraryModule[$vd.tree] -> | mm= p_MainModule[$vd.tree] ->) EOF )
            // xquery/XQueryParser.g:289:11: (vd= p_VersionDecl )? (lm= p_LibraryModule[$vd.tree] -> | mm= p_MainModule[$vd.tree] ->) EOF
            // xquery/XQueryParser.g:289:13: (vd= p_VersionDecl )?
            var alt1=2;
            alt1 = this.dfa1.predict(this.input);
            switch (alt1) {
                case 1 :
                    // xquery/XQueryParser.g:289:13: vd= p_VersionDecl
                    this.pushFollow(XQueryParser.FOLLOW_p_VersionDecl_in_p_Module507);
                    vd=this.p_VersionDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_VersionDecl.add(vd.getTree());


                    break;

            }

            // xquery/XQueryParser.g:290:13: (lm= p_LibraryModule[$vd.tree] -> | mm= p_MainModule[$vd.tree] ->)
            var alt2=2;
            alt2 = this.dfa2.predict(this.input);
            switch (alt2) {
                case 1 :
                    // xquery/XQueryParser.g:291:15: lm= p_LibraryModule[$vd.tree]
                    this.pushFollow(XQueryParser.FOLLOW_p_LibraryModule_in_p_Module540);
                    lm=this.p_LibraryModule((vd?vd.tree:null));

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_LibraryModule.add(lm.getTree());


                    // AST REWRITE
                    // elements: 
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 291:44: ->
                    {
                        this.adaptor.addChild(root_0, (lm?lm.tree:null));

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // xquery/XQueryParser.g:292:15: mm= p_MainModule[$vd.tree]
                    this.pushFollow(XQueryParser.FOLLOW_p_MainModule_in_p_Module563);
                    mm=this.p_MainModule((vd?vd.tree:null));

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_MainModule.add(mm.getTree());


                    // AST REWRITE
                    // elements: 
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 292:44: ->
                    {
                        this.adaptor.addChild(root_0, (mm?mm.tree:null));

                    }

                    retval.tree = root_0;}

                    break;

            }

            EOF1=this.match(this.input,EOF,XQueryParser.FOLLOW_EOF_in_p_Module587); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_EOF.add(EOF1);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_VersionDecl_return: (function() {
        XQueryParser.p_VersionDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_VersionDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:297:1: p_VersionDecl : k= XQUERY ( (k= ENCODING enc= p_StringLiteral ) | (k= VERSION ver= p_StringLiteral (k= ENCODING enc= p_StringLiteral )? ) ) SEMICOLON -> ^( VersionDecl ^( VersionDeclVersion ( $ver)? ) ^( VersionDeclEncoding ( $enc)? ) ) ;
    // $ANTLR start "p_VersionDecl"
    p_VersionDecl: function() {
        var retval = new XQueryParser.p_VersionDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON2 = null;
         var enc = null;
         var ver = null;

        var k_tree=null;
        var SEMICOLON2_tree=null;
        var stream_ENCODING=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ENCODING");
        var stream_VERSION=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token VERSION");
        var stream_SEMICOLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SEMICOLON");
        var stream_XQUERY=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token XQUERY");
        var stream_p_StringLiteral=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_StringLiteral");
        try {
            // xquery/XQueryParser.g:298:9: (k= XQUERY ( (k= ENCODING enc= p_StringLiteral ) | (k= VERSION ver= p_StringLiteral (k= ENCODING enc= p_StringLiteral )? ) ) SEMICOLON -> ^( VersionDecl ^( VersionDeclVersion ( $ver)? ) ^( VersionDeclEncoding ( $enc)? ) ) )
            // xquery/XQueryParser.g:298:11: k= XQUERY ( (k= ENCODING enc= p_StringLiteral ) | (k= VERSION ver= p_StringLiteral (k= ENCODING enc= p_StringLiteral )? ) ) SEMICOLON
            k=this.match(this.input,XQUERY,XQueryParser.FOLLOW_XQUERY_in_p_VersionDecl615); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_XQUERY.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:298:35: ( (k= ENCODING enc= p_StringLiteral ) | (k= VERSION ver= p_StringLiteral (k= ENCODING enc= p_StringLiteral )? ) )
            var alt4=2;
            var LA4_0 = this.input.LA(1);

            if ( (LA4_0==ENCODING) ) {
                alt4=1;
            }
            else if ( (LA4_0==VERSION) ) {
                alt4=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);

                throw nvae;
            }
            switch (alt4) {
                case 1 :
                    // xquery/XQueryParser.g:298:36: (k= ENCODING enc= p_StringLiteral )
                    // xquery/XQueryParser.g:298:36: (k= ENCODING enc= p_StringLiteral )
                    // xquery/XQueryParser.g:298:37: k= ENCODING enc= p_StringLiteral
                    k=this.match(this.input,ENCODING,XQueryParser.FOLLOW_ENCODING_in_p_VersionDecl623); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_ENCODING.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_VersionDecl629);
                    enc=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(enc.getTree());





                    break;
                case 2 :
                    // xquery/XQueryParser.g:299:13: (k= VERSION ver= p_StringLiteral (k= ENCODING enc= p_StringLiteral )? )
                    // xquery/XQueryParser.g:299:13: (k= VERSION ver= p_StringLiteral (k= ENCODING enc= p_StringLiteral )? )
                    // xquery/XQueryParser.g:299:14: k= VERSION ver= p_StringLiteral (k= ENCODING enc= p_StringLiteral )?
                    k=this.match(this.input,VERSION,XQueryParser.FOLLOW_VERSION_in_p_VersionDecl650); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_VERSION.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_VersionDecl656);
                    ver=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(ver.getTree());
                    // xquery/XQueryParser.g:299:59: (k= ENCODING enc= p_StringLiteral )?
                    var alt3=2;
                    var LA3_0 = this.input.LA(1);

                    if ( (LA3_0==ENCODING) ) {
                        alt3=1;
                    }
                    switch (alt3) {
                        case 1 :
                            // xquery/XQueryParser.g:299:60: k= ENCODING enc= p_StringLiteral
                            k=this.match(this.input,ENCODING,XQueryParser.FOLLOW_ENCODING_in_p_VersionDecl661); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_ENCODING.add(k);

                            if ( this.state.backtracking===0 ) {
                              this.ak(k);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_VersionDecl667);
                            enc=this.p_StringLiteral();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(enc.getTree());


                            break;

                    }






                    break;

            }

            SEMICOLON2=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_VersionDecl673); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SEMICOLON.add(SEMICOLON2);



            // AST REWRITE
            // elements: enc, ver
            // token labels: 
            // rule labels: retval, ver, enc
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_ver=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token ver",ver!=null?ver.tree:null);
            var stream_enc=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token enc",enc!=null?enc.tree:null);

            root_0 = this.adaptor.nil();
            // 300:17: -> ^( VersionDecl ^( VersionDeclVersion ( $ver)? ) ^( VersionDeclEncoding ( $enc)? ) )
            {
                // xquery/XQueryParser.g:300:20: ^( VersionDecl ^( VersionDeclVersion ( $ver)? ) ^( VersionDeclEncoding ( $enc)? ) )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(VersionDecl, "VersionDecl"), root_1);

                // xquery/XQueryParser.g:300:34: ^( VersionDeclVersion ( $ver)? )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(VersionDeclVersion, "VersionDeclVersion"), root_2);

                // xquery/XQueryParser.g:300:55: ( $ver)?
                if ( stream_ver.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_ver.nextTree());

                }
                stream_ver.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:300:62: ^( VersionDeclEncoding ( $enc)? )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(VersionDeclEncoding, "VersionDeclEncoding"), root_2);

                // xquery/XQueryParser.g:300:84: ( $enc)?
                if ( stream_enc.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_enc.nextTree());

                }
                stream_enc.reset();

                this.adaptor.addChild(root_1, root_2);
                }

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_MainModule_return: (function() {
        XQueryParser.p_MainModule_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_MainModule_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:304:1: p_MainModule[vd] : pm_Prolog pm_QueryBody -> ^( MainModule pm_Prolog ) ;
    // $ANTLR start "p_MainModule"
    p_MainModule: function(vd) {
        var retval = new XQueryParser.p_MainModule_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var pm_Prolog3 = null;
         var pm_QueryBody4 = null;

        var stream_pm_QueryBody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pm_QueryBody");
        var stream_pm_Prolog=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pm_Prolog");
        try {
            // xquery/XQueryParser.g:305:9: ( pm_Prolog pm_QueryBody -> ^( MainModule pm_Prolog ) )
            // xquery/XQueryParser.g:305:11: pm_Prolog pm_QueryBody
            this.pushFollow(XQueryParser.FOLLOW_pm_Prolog_in_p_MainModule739);
            pm_Prolog3=this.pm_Prolog();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_pm_Prolog.add(pm_Prolog3.getTree());
            this.pushFollow(XQueryParser.FOLLOW_pm_QueryBody_in_p_MainModule741);
            pm_QueryBody4=this.pm_QueryBody();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_pm_QueryBody.add(pm_QueryBody4.getTree());


            // AST REWRITE
            // elements: pm_Prolog
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 306:17: -> ^( MainModule pm_Prolog )
            {
                // xquery/XQueryParser.g:306:20: ^( MainModule pm_Prolog )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(MainModule, "MainModule"), root_1);

                this.adaptor.addChild(root_1, vd);
                this.adaptor.addChild(root_1, stream_pm_Prolog.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_LibraryModule_return: (function() {
        XQueryParser.p_LibraryModule_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_LibraryModule_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:310:1: p_LibraryModule[vd] : p_ModuleDecl pm_Prolog -> ^( LibraryModule p_ModuleDecl pm_Prolog ) ;
    // $ANTLR start "p_LibraryModule"
    p_LibraryModule: function(vd) {
        var retval = new XQueryParser.p_LibraryModule_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ModuleDecl5 = null;
         var pm_Prolog6 = null;

        var stream_pm_Prolog=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pm_Prolog");
        var stream_p_ModuleDecl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_ModuleDecl");
        try {
            // xquery/XQueryParser.g:311:9: ( p_ModuleDecl pm_Prolog -> ^( LibraryModule p_ModuleDecl pm_Prolog ) )
            // xquery/XQueryParser.g:311:11: p_ModuleDecl pm_Prolog
            this.pushFollow(XQueryParser.FOLLOW_p_ModuleDecl_in_p_LibraryModule797);
            p_ModuleDecl5=this.p_ModuleDecl();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_ModuleDecl.add(p_ModuleDecl5.getTree());
            this.pushFollow(XQueryParser.FOLLOW_pm_Prolog_in_p_LibraryModule799);
            pm_Prolog6=this.pm_Prolog();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_pm_Prolog.add(pm_Prolog6.getTree());


            // AST REWRITE
            // elements: p_ModuleDecl, pm_Prolog
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 312:17: -> ^( LibraryModule p_ModuleDecl pm_Prolog )
            {
                // xquery/XQueryParser.g:312:20: ^( LibraryModule p_ModuleDecl pm_Prolog )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(LibraryModule, "LibraryModule"), root_1);

                this.adaptor.addChild(root_1, vd);
                this.adaptor.addChild(root_1, stream_p_ModuleDecl.nextTree());
                this.adaptor.addChild(root_1, stream_pm_Prolog.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ModuleDecl_return: (function() {
        XQueryParser.p_ModuleDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ModuleDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:316:1: p_ModuleDecl : k+= MODULE k+= NAMESPACE p_NCName EQUAL p_StringLiteral SEMICOLON -> ^( ModuleDecl p_NCName p_StringLiteral ) ;
    // $ANTLR start "p_ModuleDecl"
    p_ModuleDecl: function() {
        var retval = new XQueryParser.p_ModuleDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var EQUAL8 = null;
        var SEMICOLON10 = null;
        var k = null;
        var list_k=null;
         var p_NCName7 = null;
         var p_StringLiteral9 = null;

        var EQUAL8_tree=null;
        var SEMICOLON10_tree=null;
        var k_tree=null;
        var stream_SEMICOLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SEMICOLON");
        var stream_MODULE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token MODULE");
        var stream_NAMESPACE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NAMESPACE");
        var stream_EQUAL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EQUAL");
        var stream_p_NCName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_NCName");
        var stream_p_StringLiteral=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_StringLiteral");
        try {
            // xquery/XQueryParser.g:317:9: (k+= MODULE k+= NAMESPACE p_NCName EQUAL p_StringLiteral SEMICOLON -> ^( ModuleDecl p_NCName p_StringLiteral ) )
            // xquery/XQueryParser.g:317:11: k+= MODULE k+= NAMESPACE p_NCName EQUAL p_StringLiteral SEMICOLON
            k=this.match(this.input,MODULE,XQueryParser.FOLLOW_MODULE_in_p_ModuleDecl855); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_MODULE.add(k);

            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            k=this.match(this.input,NAMESPACE,XQueryParser.FOLLOW_NAMESPACE_in_p_ModuleDecl859); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_NAMESPACE.add(k);

            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_p_ModuleDecl863);
            p_NCName7=this.p_NCName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_NCName.add(p_NCName7.getTree());
            EQUAL8=this.match(this.input,EQUAL,XQueryParser.FOLLOW_EQUAL_in_p_ModuleDecl865); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_EQUAL.add(EQUAL8);

            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_ModuleDecl867);
            p_StringLiteral9=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(p_StringLiteral9.getTree());
            SEMICOLON10=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_ModuleDecl869); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SEMICOLON.add(SEMICOLON10);



            // AST REWRITE
            // elements: p_StringLiteral, p_NCName
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 318:17: -> ^( ModuleDecl p_NCName p_StringLiteral )
            {
                // xquery/XQueryParser.g:318:21: ^( ModuleDecl p_NCName p_StringLiteral )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(ModuleDecl, "ModuleDecl"), root_1);

                this.adaptor.addChild(root_1, stream_p_NCName.nextTree());
                this.adaptor.addChild(root_1, stream_p_StringLiteral.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_Prolog_return: (function() {
        XQueryParser.pm_Prolog_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_Prolog_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:324:1: pm_Prolog : ( (dnd+= pm_DefaultNamespaceDecl | s+= p_Setter | nd+= pm_NamespaceDecl | i+= p_Import | fto+= pm_FTOptionDecl ) )* (od+= pg_OrderedDecl )* -> ^( Prolog ^( DefaultNamespaceDecls ( $dnd)* ) ^( Setters ( $s)* ) ^( NamespaceDecls ( $nd)* ) ^( Imports ( $i)* ) ^( FTOptionDecls ( $fto)* ) ^( OrderedDecls ( $od)* ) ) ;
    // $ANTLR start "pm_Prolog"
    pm_Prolog: function() {
        var retval = new XQueryParser.pm_Prolog_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var list_dnd=null;
        var list_s=null;
        var list_nd=null;
        var list_i=null;
        var list_fto=null;
        var list_od=null;
        var dnd = null;
        var s = null;
        var nd = null;
        var i = null;
        var fto = null;
        var od = null;
        var stream_pm_NamespaceDecl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pm_NamespaceDecl");
        var stream_p_Import=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_Import");
        var stream_p_Setter=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_Setter");
        var stream_pm_DefaultNamespaceDecl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pm_DefaultNamespaceDecl");
        var stream_pg_OrderedDecl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pg_OrderedDecl");
        var stream_pm_FTOptionDecl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pm_FTOptionDecl");
        try {
            // xquery/XQueryParser.g:325:9: ( ( (dnd+= pm_DefaultNamespaceDecl | s+= p_Setter | nd+= pm_NamespaceDecl | i+= p_Import | fto+= pm_FTOptionDecl ) )* (od+= pg_OrderedDecl )* -> ^( Prolog ^( DefaultNamespaceDecls ( $dnd)* ) ^( Setters ( $s)* ) ^( NamespaceDecls ( $nd)* ) ^( Imports ( $i)* ) ^( FTOptionDecls ( $fto)* ) ^( OrderedDecls ( $od)* ) ) )
            // xquery/XQueryParser.g:325:11: ( (dnd+= pm_DefaultNamespaceDecl | s+= p_Setter | nd+= pm_NamespaceDecl | i+= p_Import | fto+= pm_FTOptionDecl ) )* (od+= pg_OrderedDecl )*
            // xquery/XQueryParser.g:325:11: ( (dnd+= pm_DefaultNamespaceDecl | s+= p_Setter | nd+= pm_NamespaceDecl | i+= p_Import | fto+= pm_FTOptionDecl ) )*
            loop6:
            do {
                var alt6=2;
                alt6 = this.dfa6.predict(this.input);
                switch (alt6) {
                case 1 :
                    // xquery/XQueryParser.g:325:12: (dnd+= pm_DefaultNamespaceDecl | s+= p_Setter | nd+= pm_NamespaceDecl | i+= p_Import | fto+= pm_FTOptionDecl )
                    // xquery/XQueryParser.g:325:12: (dnd+= pm_DefaultNamespaceDecl | s+= p_Setter | nd+= pm_NamespaceDecl | i+= p_Import | fto+= pm_FTOptionDecl )
                    var alt5=5;
                    var LA5_0 = this.input.LA(1);

                    if ( (LA5_0==DECLARE) ) {
                        var LA5_1 = this.input.LA(2);

                        if ( (LA5_1==REVALIDATION) && ((this.lc(XQU)))) {
                            alt5=2;
                        }
                        else if ( (LA5_1==FT_OPTION) ) {
                            alt5=5;
                        }
                        else if ( (LA5_1==DEFAULT) ) {
                            var LA5_5 = this.input.LA(3);

                            if ( (LA5_5==ELEMENT||LA5_5==FUNCTION) ) {
                                alt5=1;
                            }
                            else if ( (LA5_5==COLLATION||LA5_5==ORDER||LA5_5==DECIMAL_FORMAT) ) {
                                alt5=2;
                            }
                            else {
                                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var nvae =
                                    new org.antlr.runtime.NoViableAltException("", 5, 5, this.input);

                                throw nvae;
                            }
                        }
                        else if ( ((LA5_1>=BASE_URI && LA5_1<=BOUNDARY_SPACE)||(LA5_1>=CONSTRUCTION && LA5_1<=COPY_NAMESPACES)||LA5_1==ORDERING||LA5_1==DECIMAL_FORMAT) ) {
                            alt5=2;
                        }
                        else if ( (LA5_1==NAMESPACE) ) {
                            alt5=3;
                        }
                        else {
                            if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                            var nvae =
                                new org.antlr.runtime.NoViableAltException("", 5, 1, this.input);

                            throw nvae;
                        }
                    }
                    else if ( (LA5_0==IMPORT) ) {
                        alt5=4;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 5, 0, this.input);

                        throw nvae;
                    }
                    switch (alt5) {
                        case 1 :
                            // xquery/XQueryParser.g:325:13: dnd+= pm_DefaultNamespaceDecl
                            this.pushFollow(XQueryParser.FOLLOW_pm_DefaultNamespaceDecl_in_pm_Prolog928);
                            dnd=this.pm_DefaultNamespaceDecl();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_pm_DefaultNamespaceDecl.add(dnd.getTree());
                            if (org.antlr.lang.isNull(list_dnd)) list_dnd = [];
                            list_dnd.push(dnd.getTree());



                            break;
                        case 2 :
                            // xquery/XQueryParser.g:325:44: s+= p_Setter
                            this.pushFollow(XQueryParser.FOLLOW_p_Setter_in_pm_Prolog934);
                            s=this.p_Setter();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_Setter.add(s.getTree());
                            if (org.antlr.lang.isNull(list_s)) list_s = [];
                            list_s.push(s.getTree());



                            break;
                        case 3 :
                            // xquery/XQueryParser.g:325:58: nd+= pm_NamespaceDecl
                            this.pushFollow(XQueryParser.FOLLOW_pm_NamespaceDecl_in_pm_Prolog940);
                            nd=this.pm_NamespaceDecl();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_pm_NamespaceDecl.add(nd.getTree());
                            if (org.antlr.lang.isNull(list_nd)) list_nd = [];
                            list_nd.push(nd.getTree());



                            break;
                        case 4 :
                            // xquery/XQueryParser.g:325:81: i+= p_Import
                            this.pushFollow(XQueryParser.FOLLOW_p_Import_in_pm_Prolog946);
                            i=this.p_Import();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_Import.add(i.getTree());
                            if (org.antlr.lang.isNull(list_i)) list_i = [];
                            list_i.push(i.getTree());



                            break;
                        case 5 :
                            // xquery/XQueryParser.g:325:95: fto+= pm_FTOptionDecl
                            this.pushFollow(XQueryParser.FOLLOW_pm_FTOptionDecl_in_pm_Prolog952);
                            fto=this.pm_FTOptionDecl();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_pm_FTOptionDecl.add(fto.getTree());
                            if (org.antlr.lang.isNull(list_fto)) list_fto = [];
                            list_fto.push(fto.getTree());



                            break;

                    }



                    break;

                default :
                    break loop6;
                }
            } while (true);

            // xquery/XQueryParser.g:325:121: (od+= pg_OrderedDecl )*
            loop7:
            do {
                var alt7=2;
                var LA7_0 = this.input.LA(1);

                if ( (LA7_0==DECLARE) ) {
                    var LA7_3 = this.input.LA(2);

                    if ( (LA7_3==FUNCTION||LA7_3==OPTION||LA7_3==VARIABLE||LA7_3==CONTEXT||LA7_3==UPDATING||LA7_3==COLLECTION||(LA7_3>=INDEX && LA7_3<=INTEGRITY)||LA7_3==ANN_PERCENT) ) {
                        alt7=1;
                    }


                }


                switch (alt7) {
                case 1 :
                    // xquery/XQueryParser.g:325:121: od+= pg_OrderedDecl
                    this.pushFollow(XQueryParser.FOLLOW_pg_OrderedDecl_in_pm_Prolog959);
                    od=this.pg_OrderedDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_pg_OrderedDecl.add(od.getTree());
                    if (org.antlr.lang.isNull(list_od)) list_od = [];
                    list_od.push(od.getTree());



                    break;

                default :
                    break loop7;
                }
            } while (true);



            // AST REWRITE
            // elements: nd, i, s, od, fto, dnd
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: od, fto, s, nd, dnd, i
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_od=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token od",list_od);
            var stream_fto=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token fto",list_fto);
            var stream_s=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token s",list_s);
            var stream_nd=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token nd",list_nd);
            var stream_dnd=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token dnd",list_dnd);
            var stream_i=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token i",list_i);
            root_0 = this.adaptor.nil();
            // 326:17: -> ^( Prolog ^( DefaultNamespaceDecls ( $dnd)* ) ^( Setters ( $s)* ) ^( NamespaceDecls ( $nd)* ) ^( Imports ( $i)* ) ^( FTOptionDecls ( $fto)* ) ^( OrderedDecls ( $od)* ) )
            {
                // xquery/XQueryParser.g:326:21: ^( Prolog ^( DefaultNamespaceDecls ( $dnd)* ) ^( Setters ( $s)* ) ^( NamespaceDecls ( $nd)* ) ^( Imports ( $i)* ) ^( FTOptionDecls ( $fto)* ) ^( OrderedDecls ( $od)* ) )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(Prolog, "Prolog"), root_1);

                // xquery/XQueryParser.g:327:33: ^( DefaultNamespaceDecls ( $dnd)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(DefaultNamespaceDecls, "DefaultNamespaceDecls"), root_2);

                // xquery/XQueryParser.g:327:57: ( $dnd)*
                while ( stream_dnd.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_dnd.nextTree());

                }
                stream_dnd.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:328:33: ^( Setters ( $s)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(Setters, "Setters"), root_2);

                // xquery/XQueryParser.g:328:43: ( $s)*
                while ( stream_s.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_s.nextTree());

                }
                stream_s.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:329:33: ^( NamespaceDecls ( $nd)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(NamespaceDecls, "NamespaceDecls"), root_2);

                // xquery/XQueryParser.g:329:50: ( $nd)*
                while ( stream_nd.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_nd.nextTree());

                }
                stream_nd.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:330:33: ^( Imports ( $i)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(Imports, "Imports"), root_2);

                // xquery/XQueryParser.g:330:43: ( $i)*
                while ( stream_i.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_i.nextTree());

                }
                stream_i.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:331:33: ^( FTOptionDecls ( $fto)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(FTOptionDecls, "FTOptionDecls"), root_2);

                // xquery/XQueryParser.g:331:49: ( $fto)*
                while ( stream_fto.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_fto.nextTree());

                }
                stream_fto.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:332:33: ^( OrderedDecls ( $od)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(OrderedDecls, "OrderedDecls"), root_2);

                // xquery/XQueryParser.g:332:48: ( $od)*
                while ( stream_od.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_od.nextTree());

                }
                stream_od.reset();

                this.adaptor.addChild(root_1, root_2);
                }

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pg_OrderedDecl_return: (function() {
        XQueryParser.pg_OrderedDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_OrderedDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:340:1: pg_OrderedDecl : ( pm_ContextItemDecl | pm_AnnotatedDecl | pm_OptionDecl );
    // $ANTLR start "pg_OrderedDecl"
    pg_OrderedDecl: function() {
        var retval = new XQueryParser.pg_OrderedDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var pm_ContextItemDecl11 = null;
         var pm_AnnotatedDecl12 = null;
         var pm_OptionDecl13 = null;


        try {
            // xquery/XQueryParser.g:341:9: ( pm_ContextItemDecl | pm_AnnotatedDecl | pm_OptionDecl )
            var alt8=3;
            var LA8_0 = this.input.LA(1);

            if ( (LA8_0==DECLARE) ) {
                switch ( this.input.LA(2) ) {
                case CONTEXT:
                    alt8=1;
                    break;
                case FUNCTION:
                case VARIABLE:
                case UPDATING:
                case COLLECTION:
                case INDEX:
                case INTEGRITY:
                case ANN_PERCENT:
                    alt8=2;
                    break;
                case OPTION:
                    alt8=3;
                    break;
                default:
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 8, 1, this.input);

                    throw nvae;
                }

            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 8, 0, this.input);

                throw nvae;
            }
            switch (alt8) {
                case 1 :
                    // xquery/XQueryParser.g:341:11: pm_ContextItemDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_ContextItemDecl_in_pg_OrderedDecl1274);
                    pm_ContextItemDecl11=this.pm_ContextItemDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_ContextItemDecl11.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:342:11: pm_AnnotatedDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_AnnotatedDecl_in_pg_OrderedDecl1286);
                    pm_AnnotatedDecl12=this.pm_AnnotatedDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_AnnotatedDecl12.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:343:11: pm_OptionDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_OptionDecl_in_pg_OrderedDecl1298);
                    pm_OptionDecl13=this.pm_OptionDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_OptionDecl13.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Setter_return: (function() {
        XQueryParser.p_Setter_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Setter_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:351:1: p_Setter : ( pm_BoundarySpaceDecl | pm_DefaultCollationDecl | pm_BaseURIDecl | pm_ConstructionDecl | pm_OrderingModeDecl | pm_EmptyOrderDecl | {...}? => pm_RevalidationDecl | pm_CopyNamespacesDecl | pm_DecimalFormatDecl );
    // $ANTLR start "p_Setter"
    p_Setter: function() {
        var retval = new XQueryParser.p_Setter_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var pm_BoundarySpaceDecl14 = null;
         var pm_DefaultCollationDecl15 = null;
         var pm_BaseURIDecl16 = null;
         var pm_ConstructionDecl17 = null;
         var pm_OrderingModeDecl18 = null;
         var pm_EmptyOrderDecl19 = null;
         var pm_RevalidationDecl20 = null;
         var pm_CopyNamespacesDecl21 = null;
         var pm_DecimalFormatDecl22 = null;


        try {
            // xquery/XQueryParser.g:352:9: ( pm_BoundarySpaceDecl | pm_DefaultCollationDecl | pm_BaseURIDecl | pm_ConstructionDecl | pm_OrderingModeDecl | pm_EmptyOrderDecl | {...}? => pm_RevalidationDecl | pm_CopyNamespacesDecl | pm_DecimalFormatDecl )
            var alt9=9;
            alt9 = this.dfa9.predict(this.input);
            switch (alt9) {
                case 1 :
                    // xquery/XQueryParser.g:352:11: pm_BoundarySpaceDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_BoundarySpaceDecl_in_p_Setter1328);
                    pm_BoundarySpaceDecl14=this.pm_BoundarySpaceDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_BoundarySpaceDecl14.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:353:11: pm_DefaultCollationDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_DefaultCollationDecl_in_p_Setter1340);
                    pm_DefaultCollationDecl15=this.pm_DefaultCollationDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_DefaultCollationDecl15.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:354:11: pm_BaseURIDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_BaseURIDecl_in_p_Setter1352);
                    pm_BaseURIDecl16=this.pm_BaseURIDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_BaseURIDecl16.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:355:11: pm_ConstructionDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_ConstructionDecl_in_p_Setter1364);
                    pm_ConstructionDecl17=this.pm_ConstructionDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_ConstructionDecl17.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:356:11: pm_OrderingModeDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_OrderingModeDecl_in_p_Setter1376);
                    pm_OrderingModeDecl18=this.pm_OrderingModeDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_OrderingModeDecl18.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:357:11: pm_EmptyOrderDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_EmptyOrderDecl_in_p_Setter1388);
                    pm_EmptyOrderDecl19=this.pm_EmptyOrderDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_EmptyOrderDecl19.getTree());


                    break;
                case 7 :
                    // xquery/XQueryParser.g:358:11: {...}? => pm_RevalidationDecl
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(XQU))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "p_Setter", "this.lc(XQU)");
                    }
                    this.pushFollow(XQueryParser.FOLLOW_pm_RevalidationDecl_in_p_Setter1403);
                    pm_RevalidationDecl20=this.pm_RevalidationDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_RevalidationDecl20.getTree());


                    break;
                case 8 :
                    // xquery/XQueryParser.g:359:11: pm_CopyNamespacesDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CopyNamespacesDecl_in_p_Setter1415);
                    pm_CopyNamespacesDecl21=this.pm_CopyNamespacesDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CopyNamespacesDecl21.getTree());


                    break;
                case 9 :
                    // xquery/XQueryParser.g:360:11: pm_DecimalFormatDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_DecimalFormatDecl_in_p_Setter1427);
                    pm_DecimalFormatDecl22=this.pm_DecimalFormatDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_DecimalFormatDecl22.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_BoundarySpaceDecl_return: (function() {
        XQueryParser.pm_BoundarySpaceDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_BoundarySpaceDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:364:1: pm_BoundarySpaceDecl : k= DECLARE k= BOUNDARY_SPACE ( (k= PRESERVE ) | (k= STRIP ) ) SEMICOLON ;
    // $ANTLR start "pm_BoundarySpaceDecl"
    pm_BoundarySpaceDecl: function() {
        var retval = new XQueryParser.pm_BoundarySpaceDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON23 = null;

        var k_tree=null;
        var SEMICOLON23_tree=null;

        try {
            // xquery/XQueryParser.g:365:9: (k= DECLARE k= BOUNDARY_SPACE ( (k= PRESERVE ) | (k= STRIP ) ) SEMICOLON )
            // xquery/XQueryParser.g:365:11: k= DECLARE k= BOUNDARY_SPACE ( (k= PRESERVE ) | (k= STRIP ) ) SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_BoundarySpaceDecl1459); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,BOUNDARY_SPACE,XQueryParser.FOLLOW_BOUNDARY_SPACE_in_pm_BoundarySpaceDecl1465); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:365:68: ( (k= PRESERVE ) | (k= STRIP ) )
            var alt10=2;
            var LA10_0 = this.input.LA(1);

            if ( (LA10_0==PRESERVE) ) {
                alt10=1;
            }
            else if ( (LA10_0==STRIP) ) {
                alt10=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 10, 0, this.input);

                throw nvae;
            }
            switch (alt10) {
                case 1 :
                    // xquery/XQueryParser.g:365:70: (k= PRESERVE )
                    // xquery/XQueryParser.g:365:70: (k= PRESERVE )
                    // xquery/XQueryParser.g:365:71: k= PRESERVE
                    k=this.match(this.input,PRESERVE,XQueryParser.FOLLOW_PRESERVE_in_pm_BoundarySpaceDecl1474); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }





                    break;
                case 2 :
                    // xquery/XQueryParser.g:365:100: (k= STRIP )
                    // xquery/XQueryParser.g:365:100: (k= STRIP )
                    // xquery/XQueryParser.g:365:101: k= STRIP
                    k=this.match(this.input,STRIP,XQueryParser.FOLLOW_STRIP_in_pm_BoundarySpaceDecl1484); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }





                    break;

            }

            SEMICOLON23=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_BoundarySpaceDecl1491); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON23_tree = this.adaptor.create(SEMICOLON23);
            this.adaptor.addChild(root_0, SEMICOLON23_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_DefaultCollationDecl_return: (function() {
        XQueryParser.pm_DefaultCollationDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_DefaultCollationDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:369:1: pm_DefaultCollationDecl : k= DECLARE k= DEFAULT k= COLLATION p_StringLiteral SEMICOLON ;
    // $ANTLR start "pm_DefaultCollationDecl"
    pm_DefaultCollationDecl: function() {
        var retval = new XQueryParser.pm_DefaultCollationDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON25 = null;
         var p_StringLiteral24 = null;

        var k_tree=null;
        var SEMICOLON25_tree=null;

        try {
            // xquery/XQueryParser.g:370:9: (k= DECLARE k= DEFAULT k= COLLATION p_StringLiteral SEMICOLON )
            // xquery/XQueryParser.g:370:11: k= DECLARE k= DEFAULT k= COLLATION p_StringLiteral SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_DefaultCollationDecl1519); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_pm_DefaultCollationDecl1525); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,COLLATION,XQueryParser.FOLLOW_COLLATION_in_pm_DefaultCollationDecl1531); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_DefaultCollationDecl1535);
            p_StringLiteral24=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral24.getTree());
            SEMICOLON25=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_DefaultCollationDecl1537); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON25_tree = this.adaptor.create(SEMICOLON25);
            this.adaptor.addChild(root_0, SEMICOLON25_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_BaseURIDecl_return: (function() {
        XQueryParser.pm_BaseURIDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_BaseURIDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:374:1: pm_BaseURIDecl : k= DECLARE k= BASE_URI sl= p_StringLiteral SEMICOLON -> ^( BaseURIDecl $sl) ;
    // $ANTLR start "pm_BaseURIDecl"
    pm_BaseURIDecl: function() {
        var retval = new XQueryParser.pm_BaseURIDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON26 = null;
         var sl = null;

        var k_tree=null;
        var SEMICOLON26_tree=null;
        var stream_DECLARE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token DECLARE");
        var stream_SEMICOLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SEMICOLON");
        var stream_BASE_URI=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token BASE_URI");
        var stream_p_StringLiteral=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_StringLiteral");
        try {
            // xquery/XQueryParser.g:375:9: (k= DECLARE k= BASE_URI sl= p_StringLiteral SEMICOLON -> ^( BaseURIDecl $sl) )
            // xquery/XQueryParser.g:375:11: k= DECLARE k= BASE_URI sl= p_StringLiteral SEMICOLON
            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_BaseURIDecl1573); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_DECLARE.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,BASE_URI,XQueryParser.FOLLOW_BASE_URI_in_pm_BaseURIDecl1579); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_BASE_URI.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_BaseURIDecl1585);
            sl=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(sl.getTree());
            SEMICOLON26=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_BaseURIDecl1587); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SEMICOLON.add(SEMICOLON26);



            // AST REWRITE
            // elements: sl
            // token labels: 
            // rule labels: sl, retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_sl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token sl",sl!=null?sl.tree:null);
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 376:17: -> ^( BaseURIDecl $sl)
            {
                // xquery/XQueryParser.g:376:20: ^( BaseURIDecl $sl)
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(BaseURIDecl, "BaseURIDecl"), root_1);

                this.adaptor.addChild(root_1, stream_sl.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_ConstructionDecl_return: (function() {
        XQueryParser.pm_ConstructionDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_ConstructionDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:380:1: pm_ConstructionDecl : k= DECLARE k= CONSTRUCTION ( (k= STRIP | k= PRESERVE ) ) SEMICOLON ;
    // $ANTLR start "pm_ConstructionDecl"
    pm_ConstructionDecl: function() {
        var retval = new XQueryParser.pm_ConstructionDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON27 = null;

        var k_tree=null;
        var SEMICOLON27_tree=null;

        try {
            // xquery/XQueryParser.g:381:9: (k= DECLARE k= CONSTRUCTION ( (k= STRIP | k= PRESERVE ) ) SEMICOLON )
            // xquery/XQueryParser.g:381:11: k= DECLARE k= CONSTRUCTION ( (k= STRIP | k= PRESERVE ) ) SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_ConstructionDecl1640); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,CONSTRUCTION,XQueryParser.FOLLOW_CONSTRUCTION_in_pm_ConstructionDecl1646); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:381:66: ( (k= STRIP | k= PRESERVE ) )
            // xquery/XQueryParser.g:381:68: (k= STRIP | k= PRESERVE )
            // xquery/XQueryParser.g:381:68: (k= STRIP | k= PRESERVE )
            var alt11=2;
            var LA11_0 = this.input.LA(1);

            if ( (LA11_0==STRIP) ) {
                alt11=1;
            }
            else if ( (LA11_0==PRESERVE) ) {
                alt11=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 11, 0, this.input);

                throw nvae;
            }
            switch (alt11) {
                case 1 :
                    // xquery/XQueryParser.g:381:69: k= STRIP
                    k=this.match(this.input,STRIP,XQueryParser.FOLLOW_STRIP_in_pm_ConstructionDecl1655); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:381:79: k= PRESERVE
                    k=this.match(this.input,PRESERVE,XQueryParser.FOLLOW_PRESERVE_in_pm_ConstructionDecl1661); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            SEMICOLON27=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_ConstructionDecl1668); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON27_tree = this.adaptor.create(SEMICOLON27);
            this.adaptor.addChild(root_0, SEMICOLON27_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_OrderingModeDecl_return: (function() {
        XQueryParser.pm_OrderingModeDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_OrderingModeDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:385:1: pm_OrderingModeDecl : k= DECLARE k= ORDERING ( (k= ORDERED | k= UNORDERED ) ) SEMICOLON ;
    // $ANTLR start "pm_OrderingModeDecl"
    pm_OrderingModeDecl: function() {
        var retval = new XQueryParser.pm_OrderingModeDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON28 = null;

        var k_tree=null;
        var SEMICOLON28_tree=null;

        try {
            // xquery/XQueryParser.g:386:9: (k= DECLARE k= ORDERING ( (k= ORDERED | k= UNORDERED ) ) SEMICOLON )
            // xquery/XQueryParser.g:386:11: k= DECLARE k= ORDERING ( (k= ORDERED | k= UNORDERED ) ) SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_OrderingModeDecl1696); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,ORDERING,XQueryParser.FOLLOW_ORDERING_in_pm_OrderingModeDecl1702); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:386:62: ( (k= ORDERED | k= UNORDERED ) )
            // xquery/XQueryParser.g:386:64: (k= ORDERED | k= UNORDERED )
            // xquery/XQueryParser.g:386:64: (k= ORDERED | k= UNORDERED )
            var alt12=2;
            var LA12_0 = this.input.LA(1);

            if ( (LA12_0==ORDERED) ) {
                alt12=1;
            }
            else if ( (LA12_0==UNORDERED) ) {
                alt12=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 12, 0, this.input);

                throw nvae;
            }
            switch (alt12) {
                case 1 :
                    // xquery/XQueryParser.g:386:65: k= ORDERED
                    k=this.match(this.input,ORDERED,XQueryParser.FOLLOW_ORDERED_in_pm_OrderingModeDecl1711); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:386:77: k= UNORDERED
                    k=this.match(this.input,UNORDERED,XQueryParser.FOLLOW_UNORDERED_in_pm_OrderingModeDecl1717); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            SEMICOLON28=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_OrderingModeDecl1724); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON28_tree = this.adaptor.create(SEMICOLON28);
            this.adaptor.addChild(root_0, SEMICOLON28_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_EmptyOrderDecl_return: (function() {
        XQueryParser.pm_EmptyOrderDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_EmptyOrderDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:390:1: pm_EmptyOrderDecl : k= DECLARE k= DEFAULT k= ORDER k= EMPTY ( (k= GREATEST | k= LEAST ) ) SEMICOLON ;
    // $ANTLR start "pm_EmptyOrderDecl"
    pm_EmptyOrderDecl: function() {
        var retval = new XQueryParser.pm_EmptyOrderDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON29 = null;

        var k_tree=null;
        var SEMICOLON29_tree=null;

        try {
            // xquery/XQueryParser.g:391:9: (k= DECLARE k= DEFAULT k= ORDER k= EMPTY ( (k= GREATEST | k= LEAST ) ) SEMICOLON )
            // xquery/XQueryParser.g:391:11: k= DECLARE k= DEFAULT k= ORDER k= EMPTY ( (k= GREATEST | k= LEAST ) ) SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_EmptyOrderDecl1752); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_pm_EmptyOrderDecl1758); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,ORDER,XQueryParser.FOLLOW_ORDER_in_pm_EmptyOrderDecl1764); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,EMPTY,XQueryParser.FOLLOW_EMPTY_in_pm_EmptyOrderDecl1770); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:391:107: ( (k= GREATEST | k= LEAST ) )
            // xquery/XQueryParser.g:391:109: (k= GREATEST | k= LEAST )
            // xquery/XQueryParser.g:391:109: (k= GREATEST | k= LEAST )
            var alt13=2;
            var LA13_0 = this.input.LA(1);

            if ( (LA13_0==GREATEST) ) {
                alt13=1;
            }
            else if ( (LA13_0==LEAST) ) {
                alt13=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 13, 0, this.input);

                throw nvae;
            }
            switch (alt13) {
                case 1 :
                    // xquery/XQueryParser.g:391:110: k= GREATEST
                    k=this.match(this.input,GREATEST,XQueryParser.FOLLOW_GREATEST_in_pm_EmptyOrderDecl1779); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:391:123: k= LEAST
                    k=this.match(this.input,LEAST,XQueryParser.FOLLOW_LEAST_in_pm_EmptyOrderDecl1785); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            SEMICOLON29=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_EmptyOrderDecl1792); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON29_tree = this.adaptor.create(SEMICOLON29);
            this.adaptor.addChild(root_0, SEMICOLON29_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_CopyNamespacesDecl_return: (function() {
        XQueryParser.pm_CopyNamespacesDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_CopyNamespacesDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:395:1: pm_CopyNamespacesDecl : k= DECLARE k= COPY_NAMESPACES p_PreserveMode COMMA p_InheritMode SEMICOLON ;
    // $ANTLR start "pm_CopyNamespacesDecl"
    pm_CopyNamespacesDecl: function() {
        var retval = new XQueryParser.pm_CopyNamespacesDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var COMMA31 = null;
        var SEMICOLON33 = null;
         var p_PreserveMode30 = null;
         var p_InheritMode32 = null;

        var k_tree=null;
        var COMMA31_tree=null;
        var SEMICOLON33_tree=null;

        try {
            // xquery/XQueryParser.g:396:9: (k= DECLARE k= COPY_NAMESPACES p_PreserveMode COMMA p_InheritMode SEMICOLON )
            // xquery/XQueryParser.g:396:11: k= DECLARE k= COPY_NAMESPACES p_PreserveMode COMMA p_InheritMode SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_CopyNamespacesDecl1820); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,COPY_NAMESPACES,XQueryParser.FOLLOW_COPY_NAMESPACES_in_pm_CopyNamespacesDecl1826); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_PreserveMode_in_pm_CopyNamespacesDecl1830);
            p_PreserveMode30=this.p_PreserveMode();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PreserveMode30.getTree());
            COMMA31=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_pm_CopyNamespacesDecl1832); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            COMMA31_tree = this.adaptor.create(COMMA31);
            this.adaptor.addChild(root_0, COMMA31_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_InheritMode_in_pm_CopyNamespacesDecl1834);
            p_InheritMode32=this.p_InheritMode();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InheritMode32.getTree());
            SEMICOLON33=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_CopyNamespacesDecl1836); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON33_tree = this.adaptor.create(SEMICOLON33);
            this.adaptor.addChild(root_0, SEMICOLON33_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PreserveMode_return: (function() {
        XQueryParser.p_PreserveMode_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PreserveMode_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:400:1: p_PreserveMode : (k+= PRESERVE | k+= NO_PRESERVE ) ;
    // $ANTLR start "p_PreserveMode"
    p_PreserveMode: function() {
        var retval = new XQueryParser.p_PreserveMode_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:401:9: ( (k+= PRESERVE | k+= NO_PRESERVE ) )
            // xquery/XQueryParser.g:401:11: (k+= PRESERVE | k+= NO_PRESERVE )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:401:11: (k+= PRESERVE | k+= NO_PRESERVE )
            var alt14=2;
            var LA14_0 = this.input.LA(1);

            if ( (LA14_0==PRESERVE) ) {
                alt14=1;
            }
            else if ( (LA14_0==NO_PRESERVE) ) {
                alt14=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 14, 0, this.input);

                throw nvae;
            }
            switch (alt14) {
                case 1 :
                    // xquery/XQueryParser.g:401:12: k+= PRESERVE
                    k=this.match(this.input,PRESERVE,XQueryParser.FOLLOW_PRESERVE_in_p_PreserveMode1865); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:401:26: k+= NO_PRESERVE
                    k=this.match(this.input,NO_PRESERVE,XQueryParser.FOLLOW_NO_PRESERVE_in_p_PreserveMode1871); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_InheritMode_return: (function() {
        XQueryParser.p_InheritMode_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_InheritMode_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:405:1: p_InheritMode : (k+= INHERIT | k+= NO_INHERIT ) ;
    // $ANTLR start "p_InheritMode"
    p_InheritMode: function() {
        var retval = new XQueryParser.p_InheritMode_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:406:9: ( (k+= INHERIT | k+= NO_INHERIT ) )
            // xquery/XQueryParser.g:406:11: (k+= INHERIT | k+= NO_INHERIT )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:406:11: (k+= INHERIT | k+= NO_INHERIT )
            var alt15=2;
            var LA15_0 = this.input.LA(1);

            if ( (LA15_0==INHERIT) ) {
                alt15=1;
            }
            else if ( (LA15_0==NO_INHERIT) ) {
                alt15=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 15, 0, this.input);

                throw nvae;
            }
            switch (alt15) {
                case 1 :
                    // xquery/XQueryParser.g:406:12: k+= INHERIT
                    k=this.match(this.input,INHERIT,XQueryParser.FOLLOW_INHERIT_in_p_InheritMode1903); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:406:25: k+= NO_INHERIT
                    k=this.match(this.input,NO_INHERIT,XQueryParser.FOLLOW_NO_INHERIT_in_p_InheritMode1909); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_DecimalFormatDecl_return: (function() {
        XQueryParser.pm_DecimalFormatDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_DecimalFormatDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:410:1: pm_DecimalFormatDecl : k= DECLARE ( (k= DECIMAL_FORMAT p_QName ) | (k= DEFAULT k= DECIMAL_FORMAT ) ) ( p_DFPropertyName EQUAL p_StringLiteral )* SEMICOLON ;
    // $ANTLR start "pm_DecimalFormatDecl"
    pm_DecimalFormatDecl: function() {
        var retval = new XQueryParser.pm_DecimalFormatDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var EQUAL36 = null;
        var SEMICOLON38 = null;
         var p_QName34 = null;
         var p_DFPropertyName35 = null;
         var p_StringLiteral37 = null;

        var k_tree=null;
        var EQUAL36_tree=null;
        var SEMICOLON38_tree=null;

        try {
            // xquery/XQueryParser.g:411:9: (k= DECLARE ( (k= DECIMAL_FORMAT p_QName ) | (k= DEFAULT k= DECIMAL_FORMAT ) ) ( p_DFPropertyName EQUAL p_StringLiteral )* SEMICOLON )
            // xquery/XQueryParser.g:411:11: k= DECLARE ( (k= DECIMAL_FORMAT p_QName ) | (k= DEFAULT k= DECIMAL_FORMAT ) ) ( p_DFPropertyName EQUAL p_StringLiteral )* SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_DecimalFormatDecl1948); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:411:36: ( (k= DECIMAL_FORMAT p_QName ) | (k= DEFAULT k= DECIMAL_FORMAT ) )
            var alt16=2;
            var LA16_0 = this.input.LA(1);

            if ( (LA16_0==DECIMAL_FORMAT) ) {
                alt16=1;
            }
            else if ( (LA16_0==DEFAULT) ) {
                alt16=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 16, 0, this.input);

                throw nvae;
            }
            switch (alt16) {
                case 1 :
                    // xquery/XQueryParser.g:411:37: (k= DECIMAL_FORMAT p_QName )
                    // xquery/XQueryParser.g:411:37: (k= DECIMAL_FORMAT p_QName )
                    // xquery/XQueryParser.g:411:38: k= DECIMAL_FORMAT p_QName
                    k=this.match(this.input,DECIMAL_FORMAT,XQueryParser.FOLLOW_DECIMAL_FORMAT_in_pm_DecimalFormatDecl1956); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_pm_DecimalFormatDecl1960);
                    p_QName34=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName34.getTree());





                    break;
                case 2 :
                    // xquery/XQueryParser.g:411:81: (k= DEFAULT k= DECIMAL_FORMAT )
                    // xquery/XQueryParser.g:411:81: (k= DEFAULT k= DECIMAL_FORMAT )
                    // xquery/XQueryParser.g:411:82: k= DEFAULT k= DECIMAL_FORMAT
                    k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_pm_DecimalFormatDecl1968); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    k=this.match(this.input,DECIMAL_FORMAT,XQueryParser.FOLLOW_DECIMAL_FORMAT_in_pm_DecimalFormatDecl1974); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }





                    break;

            }

            // xquery/XQueryParser.g:411:141: ( p_DFPropertyName EQUAL p_StringLiteral )*
            loop17:
            do {
                var alt17=2;
                var LA17_0 = this.input.LA(1);

                if ( ((LA17_0>=DECIMAL_SEPARATOR && LA17_0<=DIGIT)||(LA17_0>=GROUPING_SEPARATOR && LA17_0<=MINUS_SIGN)||LA17_0==NAN||(LA17_0>=PATTERN_SEPARATOR && LA17_0<=PER_MILLE)||LA17_0==ZERO_DIGIT) ) {
                    alt17=1;
                }


                switch (alt17) {
                case 1 :
                    // xquery/XQueryParser.g:411:142: p_DFPropertyName EQUAL p_StringLiteral
                    this.pushFollow(XQueryParser.FOLLOW_p_DFPropertyName_in_pm_DecimalFormatDecl1981);
                    p_DFPropertyName35=this.p_DFPropertyName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DFPropertyName35.getTree());
                    EQUAL36=this.match(this.input,EQUAL,XQueryParser.FOLLOW_EQUAL_in_pm_DecimalFormatDecl1983); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    EQUAL36_tree = this.adaptor.create(EQUAL36);
                    this.adaptor.addChild(root_0, EQUAL36_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_DecimalFormatDecl1985);
                    p_StringLiteral37=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral37.getTree());


                    break;

                default :
                    break loop17;
                }
            } while (true);

            SEMICOLON38=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_DecimalFormatDecl1989); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON38_tree = this.adaptor.create(SEMICOLON38);
            this.adaptor.addChild(root_0, SEMICOLON38_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DFPropertyName_return: (function() {
        XQueryParser.p_DFPropertyName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DFPropertyName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:415:1: p_DFPropertyName : (k= DECIMAL_SEPARATOR | k= GROUPING_SEPARATOR | k= INFINITY | k= MINUS_SIGN | k= NAN | k= PERCENT | k= PER_MILLE | k= ZERO_DIGIT | k= DIGIT | k= PATTERN_SEPARATOR ) ;
    // $ANTLR start "p_DFPropertyName"
    p_DFPropertyName: function() {
        var retval = new XQueryParser.p_DFPropertyName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:416:9: ( (k= DECIMAL_SEPARATOR | k= GROUPING_SEPARATOR | k= INFINITY | k= MINUS_SIGN | k= NAN | k= PERCENT | k= PER_MILLE | k= ZERO_DIGIT | k= DIGIT | k= PATTERN_SEPARATOR ) )
            // xquery/XQueryParser.g:416:11: (k= DECIMAL_SEPARATOR | k= GROUPING_SEPARATOR | k= INFINITY | k= MINUS_SIGN | k= NAN | k= PERCENT | k= PER_MILLE | k= ZERO_DIGIT | k= DIGIT | k= PATTERN_SEPARATOR )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:416:11: (k= DECIMAL_SEPARATOR | k= GROUPING_SEPARATOR | k= INFINITY | k= MINUS_SIGN | k= NAN | k= PERCENT | k= PER_MILLE | k= ZERO_DIGIT | k= DIGIT | k= PATTERN_SEPARATOR )
            var alt18=10;
            switch ( this.input.LA(1) ) {
            case DECIMAL_SEPARATOR:
                alt18=1;
                break;
            case GROUPING_SEPARATOR:
                alt18=2;
                break;
            case INFINITY:
                alt18=3;
                break;
            case MINUS_SIGN:
                alt18=4;
                break;
            case NAN:
                alt18=5;
                break;
            case PERCENT:
                alt18=6;
                break;
            case PER_MILLE:
                alt18=7;
                break;
            case ZERO_DIGIT:
                alt18=8;
                break;
            case DIGIT:
                alt18=9;
                break;
            case PATTERN_SEPARATOR:
                alt18=10;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 18, 0, this.input);

                throw nvae;
            }

            switch (alt18) {
                case 1 :
                    // xquery/XQueryParser.g:416:12: k= DECIMAL_SEPARATOR
                    k=this.match(this.input,DECIMAL_SEPARATOR,XQueryParser.FOLLOW_DECIMAL_SEPARATOR_in_p_DFPropertyName2018); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:416:34: k= GROUPING_SEPARATOR
                    k=this.match(this.input,GROUPING_SEPARATOR,XQueryParser.FOLLOW_GROUPING_SEPARATOR_in_p_DFPropertyName2024); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:416:57: k= INFINITY
                    k=this.match(this.input,INFINITY,XQueryParser.FOLLOW_INFINITY_in_p_DFPropertyName2030); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 4 :
                    // xquery/XQueryParser.g:416:70: k= MINUS_SIGN
                    k=this.match(this.input,MINUS_SIGN,XQueryParser.FOLLOW_MINUS_SIGN_in_p_DFPropertyName2036); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 5 :
                    // xquery/XQueryParser.g:416:85: k= NAN
                    k=this.match(this.input,NAN,XQueryParser.FOLLOW_NAN_in_p_DFPropertyName2042); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 6 :
                    // xquery/XQueryParser.g:416:93: k= PERCENT
                    k=this.match(this.input,PERCENT,XQueryParser.FOLLOW_PERCENT_in_p_DFPropertyName2048); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 7 :
                    // xquery/XQueryParser.g:416:105: k= PER_MILLE
                    k=this.match(this.input,PER_MILLE,XQueryParser.FOLLOW_PER_MILLE_in_p_DFPropertyName2054); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 8 :
                    // xquery/XQueryParser.g:416:119: k= ZERO_DIGIT
                    k=this.match(this.input,ZERO_DIGIT,XQueryParser.FOLLOW_ZERO_DIGIT_in_p_DFPropertyName2060); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 9 :
                    // xquery/XQueryParser.g:416:134: k= DIGIT
                    k=this.match(this.input,DIGIT,XQueryParser.FOLLOW_DIGIT_in_p_DFPropertyName2066); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 10 :
                    // xquery/XQueryParser.g:416:144: k= PATTERN_SEPARATOR
                    k=this.match(this.input,PATTERN_SEPARATOR,XQueryParser.FOLLOW_PATTERN_SEPARATOR_in_p_DFPropertyName2072); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Import_return: (function() {
        XQueryParser.p_Import_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Import_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:420:1: p_Import : ( pm_SchemaImport | pm_ModuleImport );
    // $ANTLR start "p_Import"
    p_Import: function() {
        var retval = new XQueryParser.p_Import_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var pm_SchemaImport39 = null;
         var pm_ModuleImport40 = null;


        try {
            // xquery/XQueryParser.g:421:9: ( pm_SchemaImport | pm_ModuleImport )
            var alt19=2;
            var LA19_0 = this.input.LA(1);

            if ( (LA19_0==IMPORT) ) {
                var LA19_1 = this.input.LA(2);

                if ( (LA19_1==SCHEMA) ) {
                    alt19=1;
                }
                else if ( (LA19_1==MODULE) ) {
                    alt19=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 19, 1, this.input);

                    throw nvae;
                }
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 19, 0, this.input);

                throw nvae;
            }
            switch (alt19) {
                case 1 :
                    // xquery/XQueryParser.g:421:11: pm_SchemaImport
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_SchemaImport_in_p_Import2101);
                    pm_SchemaImport39=this.pm_SchemaImport();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_SchemaImport39.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:421:29: pm_ModuleImport
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_ModuleImport_in_p_Import2105);
                    pm_ModuleImport40=this.pm_ModuleImport();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_ModuleImport40.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_SchemaImport_return: (function() {
        XQueryParser.pm_SchemaImport_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_SchemaImport_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:425:1: pm_SchemaImport : k= IMPORT k= SCHEMA (sp= p_SchemaPrefix )? us= p_StringLiteral (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )? SEMICOLON -> ^( SchemaImport ^( SchemaPrefix ( $sp)? ) $us ^( AtHints ( $ah)* ) ) ;
    // $ANTLR start "pm_SchemaImport"
    pm_SchemaImport: function() {
        var retval = new XQueryParser.pm_SchemaImport_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var COMMA41 = null;
        var SEMICOLON42 = null;
        var list_ah=null;
         var sp = null;
         var us = null;
        var ah = null;
        var k_tree=null;
        var COMMA41_tree=null;
        var SEMICOLON42_tree=null;
        var stream_AT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token AT");
        var stream_IMPORT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IMPORT");
        var stream_SCHEMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SCHEMA");
        var stream_SEMICOLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SEMICOLON");
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_p_SchemaPrefix=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_SchemaPrefix");
        var stream_p_StringLiteral=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_StringLiteral");
        try {
            // xquery/XQueryParser.g:426:9: (k= IMPORT k= SCHEMA (sp= p_SchemaPrefix )? us= p_StringLiteral (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )? SEMICOLON -> ^( SchemaImport ^( SchemaPrefix ( $sp)? ) $us ^( AtHints ( $ah)* ) ) )
            // xquery/XQueryParser.g:426:11: k= IMPORT k= SCHEMA (sp= p_SchemaPrefix )? us= p_StringLiteral (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )? SEMICOLON
            k=this.match(this.input,IMPORT,XQueryParser.FOLLOW_IMPORT_in_pm_SchemaImport2141); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IMPORT.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,SCHEMA,XQueryParser.FOLLOW_SCHEMA_in_pm_SchemaImport2147); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SCHEMA.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:426:61: (sp= p_SchemaPrefix )?
            var alt20=2;
            var LA20_0 = this.input.LA(1);

            if ( (LA20_0==DEFAULT||LA20_0==NAMESPACE) ) {
                alt20=1;
            }
            switch (alt20) {
                case 1 :
                    // xquery/XQueryParser.g:426:61: sp= p_SchemaPrefix
                    this.pushFollow(XQueryParser.FOLLOW_p_SchemaPrefix_in_pm_SchemaImport2153);
                    sp=this.p_SchemaPrefix();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_SchemaPrefix.add(sp.getTree());


                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_SchemaImport2158);
            us=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(us.getTree());
            // xquery/XQueryParser.g:426:97: (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )?
            var alt22=2;
            var LA22_0 = this.input.LA(1);

            if ( (LA22_0==AT) ) {
                alt22=1;
            }
            switch (alt22) {
                case 1 :
                    // xquery/XQueryParser.g:426:98: k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )*
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_pm_SchemaImport2163); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_AT.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_SchemaImport2169);
                    ah=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(ah.getTree());
                    if (org.antlr.lang.isNull(list_ah)) list_ah = [];
                    list_ah.push(ah.getTree());

                    // xquery/XQueryParser.g:426:138: ( COMMA ah+= p_StringLiteral )*
                    loop21:
                    do {
                        var alt21=2;
                        var LA21_0 = this.input.LA(1);

                        if ( (LA21_0==COMMA) ) {
                            alt21=1;
                        }


                        switch (alt21) {
                        case 1 :
                            // xquery/XQueryParser.g:426:139: COMMA ah+= p_StringLiteral
                            COMMA41=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_pm_SchemaImport2172); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_COMMA.add(COMMA41);

                            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_SchemaImport2176);
                            ah=this.p_StringLiteral();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(ah.getTree());
                            if (org.antlr.lang.isNull(list_ah)) list_ah = [];
                            list_ah.push(ah.getTree());



                            break;

                        default :
                            break loop21;
                        }
                    } while (true);



                    break;

            }

            SEMICOLON42=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_SchemaImport2182); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SEMICOLON.add(SEMICOLON42);



            // AST REWRITE
            // elements: ah, us, sp
            // token labels: 
            // rule labels: retval, sp, us
            // token list labels: 
            // rule list labels: ah
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_sp=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token sp",sp!=null?sp.tree:null);
            var stream_us=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token us",us!=null?us.tree:null);
            var stream_ah=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token ah",list_ah);
            root_0 = this.adaptor.nil();
            // 427:17: -> ^( SchemaImport ^( SchemaPrefix ( $sp)? ) $us ^( AtHints ( $ah)* ) )
            {
                // xquery/XQueryParser.g:427:20: ^( SchemaImport ^( SchemaPrefix ( $sp)? ) $us ^( AtHints ( $ah)* ) )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(SchemaImport, "SchemaImport"), root_1);

                // xquery/XQueryParser.g:427:35: ^( SchemaPrefix ( $sp)? )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(SchemaPrefix, "SchemaPrefix"), root_2);

                // xquery/XQueryParser.g:427:50: ( $sp)?
                if ( stream_sp.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_sp.nextTree());

                }
                stream_sp.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                this.adaptor.addChild(root_1, stream_us.nextTree());
                // xquery/XQueryParser.g:427:60: ^( AtHints ( $ah)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(AtHints, "AtHints"), root_2);

                // xquery/XQueryParser.g:427:70: ( $ah)*
                while ( stream_ah.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_ah.nextTree());

                }
                stream_ah.reset();

                this.adaptor.addChild(root_1, root_2);
                }

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SchemaPrefix_return: (function() {
        XQueryParser.p_SchemaPrefix_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SchemaPrefix_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:431:1: p_SchemaPrefix : (k= NAMESPACE nn= p_NCName EQUAL -> ^( NamespaceName $nn) | k= DEFAULT k= ELEMENT k= NAMESPACE -> DefaultElementNamespace );
    // $ANTLR start "p_SchemaPrefix"
    p_SchemaPrefix: function() {
        var retval = new XQueryParser.p_SchemaPrefix_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var EQUAL43 = null;
         var nn = null;

        var k_tree=null;
        var EQUAL43_tree=null;
        var stream_ELEMENT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ELEMENT");
        var stream_NAMESPACE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NAMESPACE");
        var stream_EQUAL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EQUAL");
        var stream_DEFAULT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token DEFAULT");
        var stream_p_NCName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_NCName");
        try {
            // xquery/XQueryParser.g:432:9: (k= NAMESPACE nn= p_NCName EQUAL -> ^( NamespaceName $nn) | k= DEFAULT k= ELEMENT k= NAMESPACE -> DefaultElementNamespace )
            var alt23=2;
            var LA23_0 = this.input.LA(1);

            if ( (LA23_0==NAMESPACE) ) {
                alt23=1;
            }
            else if ( (LA23_0==DEFAULT) ) {
                alt23=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 23, 0, this.input);

                throw nvae;
            }
            switch (alt23) {
                case 1 :
                    // xquery/XQueryParser.g:432:11: k= NAMESPACE nn= p_NCName EQUAL
                    k=this.match(this.input,NAMESPACE,XQueryParser.FOLLOW_NAMESPACE_in_p_SchemaPrefix2252); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NAMESPACE.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_p_SchemaPrefix2258);
                    nn=this.p_NCName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_NCName.add(nn.getTree());
                    EQUAL43=this.match(this.input,EQUAL,XQueryParser.FOLLOW_EQUAL_in_p_SchemaPrefix2260); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_EQUAL.add(EQUAL43);



                    // AST REWRITE
                    // elements: nn
                    // token labels: 
                    // rule labels: retval, nn
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
                    var stream_nn=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token nn",nn!=null?nn.tree:null);

                    root_0 = this.adaptor.nil();
                    // 433:17: -> ^( NamespaceName $nn)
                    {
                        // xquery/XQueryParser.g:433:20: ^( NamespaceName $nn)
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(NamespaceName, "NamespaceName"), root_1);

                        this.adaptor.addChild(root_1, stream_nn.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // xquery/XQueryParser.g:434:11: k= DEFAULT k= ELEMENT k= NAMESPACE
                    k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_SchemaPrefix2299); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_DEFAULT.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    k=this.match(this.input,ELEMENT,XQueryParser.FOLLOW_ELEMENT_in_p_SchemaPrefix2305); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_ELEMENT.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    k=this.match(this.input,NAMESPACE,XQueryParser.FOLLOW_NAMESPACE_in_p_SchemaPrefix2311); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NAMESPACE.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }


                    // AST REWRITE
                    // elements: 
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 435:17: -> DefaultElementNamespace
                    {
                        this.adaptor.addChild(root_0, this.adaptor.create(DefaultElementNamespace, "DefaultElementNamespace"));

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_ModuleImport_return: (function() {
        XQueryParser.pm_ModuleImport_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_ModuleImport_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:439:1: pm_ModuleImport : k= IMPORT k= MODULE (k= NAMESPACE nn= p_NCName EQUAL )? us= p_StringLiteral (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )? SEMICOLON -> ^( ModuleImport ^( NamespaceName ( $nn)? ) $us ^( AtHints ( $ah)* ) ) ;
    // $ANTLR start "pm_ModuleImport"
    pm_ModuleImport: function() {
        var retval = new XQueryParser.pm_ModuleImport_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var EQUAL44 = null;
        var COMMA45 = null;
        var SEMICOLON46 = null;
        var list_ah=null;
         var nn = null;
         var us = null;
        var ah = null;
        var k_tree=null;
        var EQUAL44_tree=null;
        var COMMA45_tree=null;
        var SEMICOLON46_tree=null;
        var stream_AT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token AT");
        var stream_IMPORT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token IMPORT");
        var stream_SEMICOLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SEMICOLON");
        var stream_MODULE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token MODULE");
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_NAMESPACE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NAMESPACE");
        var stream_EQUAL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EQUAL");
        var stream_p_NCName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_NCName");
        var stream_p_StringLiteral=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_StringLiteral");
        try {
            // xquery/XQueryParser.g:440:9: (k= IMPORT k= MODULE (k= NAMESPACE nn= p_NCName EQUAL )? us= p_StringLiteral (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )? SEMICOLON -> ^( ModuleImport ^( NamespaceName ( $nn)? ) $us ^( AtHints ( $ah)* ) ) )
            // xquery/XQueryParser.g:440:11: k= IMPORT k= MODULE (k= NAMESPACE nn= p_NCName EQUAL )? us= p_StringLiteral (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )? SEMICOLON
            k=this.match(this.input,IMPORT,XQueryParser.FOLLOW_IMPORT_in_pm_ModuleImport2361); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_IMPORT.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,MODULE,XQueryParser.FOLLOW_MODULE_in_pm_ModuleImport2367); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_MODULE.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:440:59: (k= NAMESPACE nn= p_NCName EQUAL )?
            var alt24=2;
            var LA24_0 = this.input.LA(1);

            if ( (LA24_0==NAMESPACE) ) {
                alt24=1;
            }
            switch (alt24) {
                case 1 :
                    // xquery/XQueryParser.g:440:60: k= NAMESPACE nn= p_NCName EQUAL
                    k=this.match(this.input,NAMESPACE,XQueryParser.FOLLOW_NAMESPACE_in_pm_ModuleImport2374); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_NAMESPACE.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_pm_ModuleImport2380);
                    nn=this.p_NCName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_NCName.add(nn.getTree());
                    EQUAL44=this.match(this.input,EQUAL,XQueryParser.FOLLOW_EQUAL_in_pm_ModuleImport2382); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_EQUAL.add(EQUAL44);



                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_ModuleImport2388);
            us=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(us.getTree());
            // xquery/XQueryParser.g:440:126: (k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )* )?
            var alt26=2;
            var LA26_0 = this.input.LA(1);

            if ( (LA26_0==AT) ) {
                alt26=1;
            }
            switch (alt26) {
                case 1 :
                    // xquery/XQueryParser.g:440:127: k= AT ah+= p_StringLiteral ( COMMA ah+= p_StringLiteral )*
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_pm_ModuleImport2393); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_AT.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_ModuleImport2399);
                    ah=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(ah.getTree());
                    if (org.antlr.lang.isNull(list_ah)) list_ah = [];
                    list_ah.push(ah.getTree());

                    // xquery/XQueryParser.g:440:167: ( COMMA ah+= p_StringLiteral )*
                    loop25:
                    do {
                        var alt25=2;
                        var LA25_0 = this.input.LA(1);

                        if ( (LA25_0==COMMA) ) {
                            alt25=1;
                        }


                        switch (alt25) {
                        case 1 :
                            // xquery/XQueryParser.g:440:168: COMMA ah+= p_StringLiteral
                            COMMA45=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_pm_ModuleImport2402); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_COMMA.add(COMMA45);

                            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_ModuleImport2406);
                            ah=this.p_StringLiteral();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(ah.getTree());
                            if (org.antlr.lang.isNull(list_ah)) list_ah = [];
                            list_ah.push(ah.getTree());



                            break;

                        default :
                            break loop25;
                        }
                    } while (true);



                    break;

            }

            SEMICOLON46=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_ModuleImport2412); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SEMICOLON.add(SEMICOLON46);



            // AST REWRITE
            // elements: us, nn, ah
            // token labels: 
            // rule labels: retval, nn, us
            // token list labels: 
            // rule list labels: ah
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_nn=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token nn",nn!=null?nn.tree:null);
            var stream_us=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token us",us!=null?us.tree:null);
            var stream_ah=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token ah",list_ah);
            root_0 = this.adaptor.nil();
            // 441:17: -> ^( ModuleImport ^( NamespaceName ( $nn)? ) $us ^( AtHints ( $ah)* ) )
            {
                // xquery/XQueryParser.g:441:20: ^( ModuleImport ^( NamespaceName ( $nn)? ) $us ^( AtHints ( $ah)* ) )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(ModuleImport, "ModuleImport"), root_1);

                // xquery/XQueryParser.g:441:35: ^( NamespaceName ( $nn)? )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(NamespaceName, "NamespaceName"), root_2);

                // xquery/XQueryParser.g:441:51: ( $nn)?
                if ( stream_nn.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_nn.nextTree());

                }
                stream_nn.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                this.adaptor.addChild(root_1, stream_us.nextTree());
                // xquery/XQueryParser.g:441:61: ^( AtHints ( $ah)* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(AtHints, "AtHints"), root_2);

                // xquery/XQueryParser.g:441:71: ( $ah)*
                while ( stream_ah.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_ah.nextTree());

                }
                stream_ah.reset();

                this.adaptor.addChild(root_1, root_2);
                }

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_NamespaceDecl_return: (function() {
        XQueryParser.pm_NamespaceDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_NamespaceDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:445:1: pm_NamespaceDecl : k= DECLARE k= NAMESPACE nn= p_NCName EQUAL us= p_StringLiteral SEMICOLON -> ^( NamespaceDecl $nn $us) ;
    // $ANTLR start "pm_NamespaceDecl"
    pm_NamespaceDecl: function() {
        var retval = new XQueryParser.pm_NamespaceDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var EQUAL47 = null;
        var SEMICOLON48 = null;
         var nn = null;
         var us = null;

        var k_tree=null;
        var EQUAL47_tree=null;
        var SEMICOLON48_tree=null;
        var stream_DECLARE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token DECLARE");
        var stream_SEMICOLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SEMICOLON");
        var stream_NAMESPACE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token NAMESPACE");
        var stream_EQUAL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EQUAL");
        var stream_p_NCName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_NCName");
        var stream_p_StringLiteral=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_StringLiteral");
        try {
            // xquery/XQueryParser.g:446:9: (k= DECLARE k= NAMESPACE nn= p_NCName EQUAL us= p_StringLiteral SEMICOLON -> ^( NamespaceDecl $nn $us) )
            // xquery/XQueryParser.g:446:11: k= DECLARE k= NAMESPACE nn= p_NCName EQUAL us= p_StringLiteral SEMICOLON
            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_NamespaceDecl2481); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_DECLARE.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,NAMESPACE,XQueryParser.FOLLOW_NAMESPACE_in_pm_NamespaceDecl2487); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_NAMESPACE.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_pm_NamespaceDecl2493);
            nn=this.p_NCName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_NCName.add(nn.getTree());
            EQUAL47=this.match(this.input,EQUAL,XQueryParser.FOLLOW_EQUAL_in_pm_NamespaceDecl2495); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_EQUAL.add(EQUAL47);

            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_NamespaceDecl2499);
            us=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_StringLiteral.add(us.getTree());
            SEMICOLON48=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_NamespaceDecl2501); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SEMICOLON.add(SEMICOLON48);



            // AST REWRITE
            // elements: us, nn
            // token labels: 
            // rule labels: retval, nn, us
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_nn=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token nn",nn!=null?nn.tree:null);
            var stream_us=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token us",us!=null?us.tree:null);

            root_0 = this.adaptor.nil();
            // 447:17: -> ^( NamespaceDecl $nn $us)
            {
                // xquery/XQueryParser.g:447:20: ^( NamespaceDecl $nn $us)
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(NamespaceDecl, "NamespaceDecl"), root_1);

                this.adaptor.addChild(root_1, stream_nn.nextTree());
                this.adaptor.addChild(root_1, stream_us.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_DefaultNamespaceDecl_return: (function() {
        XQueryParser.pm_DefaultNamespaceDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_DefaultNamespaceDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:451:1: pm_DefaultNamespaceDecl : k= DECLARE k= DEFAULT (k= ELEMENT | k= FUNCTION ) k= NAMESPACE p_StringLiteral SEMICOLON ;
    // $ANTLR start "pm_DefaultNamespaceDecl"
    pm_DefaultNamespaceDecl: function() {
        var retval = new XQueryParser.pm_DefaultNamespaceDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON50 = null;
         var p_StringLiteral49 = null;

        var k_tree=null;
        var SEMICOLON50_tree=null;

        try {
            // xquery/XQueryParser.g:452:9: (k= DECLARE k= DEFAULT (k= ELEMENT | k= FUNCTION ) k= NAMESPACE p_StringLiteral SEMICOLON )
            // xquery/XQueryParser.g:452:11: k= DECLARE k= DEFAULT (k= ELEMENT | k= FUNCTION ) k= NAMESPACE p_StringLiteral SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_DefaultNamespaceDecl2558); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_pm_DefaultNamespaceDecl2564); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:452:61: (k= ELEMENT | k= FUNCTION )
            var alt27=2;
            var LA27_0 = this.input.LA(1);

            if ( (LA27_0==ELEMENT) ) {
                alt27=1;
            }
            else if ( (LA27_0==FUNCTION) ) {
                alt27=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 27, 0, this.input);

                throw nvae;
            }
            switch (alt27) {
                case 1 :
                    // xquery/XQueryParser.g:452:62: k= ELEMENT
                    k=this.match(this.input,ELEMENT,XQueryParser.FOLLOW_ELEMENT_in_pm_DefaultNamespaceDecl2571); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:452:74: k= FUNCTION
                    k=this.match(this.input,FUNCTION,XQueryParser.FOLLOW_FUNCTION_in_pm_DefaultNamespaceDecl2577); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,NAMESPACE,XQueryParser.FOLLOW_NAMESPACE_in_pm_DefaultNamespaceDecl2584); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_DefaultNamespaceDecl2588);
            p_StringLiteral49=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral49.getTree());
            SEMICOLON50=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_DefaultNamespaceDecl2590); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON50_tree = this.adaptor.create(SEMICOLON50);
            this.adaptor.addChild(root_0, SEMICOLON50_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_AnnotatedDecl_return: (function() {
        XQueryParser.pm_AnnotatedDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_AnnotatedDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:456:1: pm_AnnotatedDecl : k= DECLARE ( p_Annotation )* pg_AnnotatedDecl SEMICOLON ;
    // $ANTLR start "pm_AnnotatedDecl"
    pm_AnnotatedDecl: function() {
        var retval = new XQueryParser.pm_AnnotatedDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON53 = null;
         var p_Annotation51 = null;
         var pg_AnnotatedDecl52 = null;

        var k_tree=null;
        var SEMICOLON53_tree=null;

        try {
            // xquery/XQueryParser.g:457:9: (k= DECLARE ( p_Annotation )* pg_AnnotatedDecl SEMICOLON )
            // xquery/XQueryParser.g:457:11: k= DECLARE ( p_Annotation )* pg_AnnotatedDecl SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_AnnotatedDecl2618); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:457:36: ( p_Annotation )*
            loop28:
            do {
                var alt28=2;
                var LA28_0 = this.input.LA(1);

                if ( (LA28_0==ANN_PERCENT) ) {
                    alt28=1;
                }


                switch (alt28) {
                case 1 :
                    // xquery/XQueryParser.g:457:36: p_Annotation
                    this.pushFollow(XQueryParser.FOLLOW_p_Annotation_in_pm_AnnotatedDecl2622);
                    p_Annotation51=this.p_Annotation();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Annotation51.getTree());


                    break;

                default :
                    break loop28;
                }
            } while (true);

            this.pushFollow(XQueryParser.FOLLOW_pg_AnnotatedDecl_in_pm_AnnotatedDecl2625);
            pg_AnnotatedDecl52=this.pg_AnnotatedDecl();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pg_AnnotatedDecl52.getTree());
            SEMICOLON53=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_AnnotatedDecl2627); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON53_tree = this.adaptor.create(SEMICOLON53);
            this.adaptor.addChild(root_0, SEMICOLON53_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pg_AnnotatedDecl_return: (function() {
        XQueryParser.pg_AnnotatedDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_AnnotatedDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:459:1: pg_AnnotatedDecl : ( p_VarDecl | pm_FunctionDecl | {...}? => p_CollectionDecl | {...}? => p_IndexDecl | {...}? => p_ICDecl );
    // $ANTLR start "pg_AnnotatedDecl"
    pg_AnnotatedDecl: function() {
        var retval = new XQueryParser.pg_AnnotatedDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_VarDecl54 = null;
         var pm_FunctionDecl55 = null;
         var p_CollectionDecl56 = null;
         var p_IndexDecl57 = null;
         var p_ICDecl58 = null;


        try {
            // xquery/XQueryParser.g:460:9: ( p_VarDecl | pm_FunctionDecl | {...}? => p_CollectionDecl | {...}? => p_IndexDecl | {...}? => p_ICDecl )
            var alt29=5;
            var LA29_0 = this.input.LA(1);

            if ( (LA29_0==VARIABLE) ) {
                alt29=1;
            }
            else if ( (LA29_0==UPDATING) && ((this.lc(XQU)))) {
                alt29=2;
            }
            else if ( (LA29_0==FUNCTION) ) {
                alt29=2;
            }
            else if ( (LA29_0==COLLECTION) && ((this.lc(ZORBA)))) {
                alt29=3;
            }
            else if ( (LA29_0==INDEX) && ((this.lc(ZORBA)))) {
                alt29=4;
            }
            else if ( (LA29_0==INTEGRITY) && ((this.lc(ZORBA)))) {
                alt29=5;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 29, 0, this.input);

                throw nvae;
            }
            switch (alt29) {
                case 1 :
                    // xquery/XQueryParser.g:460:11: p_VarDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_VarDecl_in_pg_AnnotatedDecl2651);
                    p_VarDecl54=this.p_VarDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_VarDecl54.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:461:11: pm_FunctionDecl
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_FunctionDecl_in_pg_AnnotatedDecl2663);
                    pm_FunctionDecl55=this.pm_FunctionDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_FunctionDecl55.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:462:11: {...}? => p_CollectionDecl
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(ZORBA))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "pg_AnnotatedDecl", "this.lc(ZORBA)");
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_CollectionDecl_in_pg_AnnotatedDecl2678);
                    p_CollectionDecl56=this.p_CollectionDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CollectionDecl56.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:463:11: {...}? => p_IndexDecl
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(ZORBA))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "pg_AnnotatedDecl", "this.lc(ZORBA)");
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_IndexDecl_in_pg_AnnotatedDecl2693);
                    p_IndexDecl57=this.p_IndexDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexDecl57.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:464:11: {...}? => p_ICDecl
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(ZORBA))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "pg_AnnotatedDecl", "this.lc(ZORBA)");
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ICDecl_in_pg_AnnotatedDecl2708);
                    p_ICDecl58=this.p_ICDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICDecl58.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Annotation_return: (function() {
        XQueryParser.p_Annotation_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Annotation_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:468:1: p_Annotation : ANN_PERCENT p_QName ( LPAREN p_Literal ( COMMA p_Literal )* RPAREN )? ;
    // $ANTLR start "p_Annotation"
    p_Annotation: function() {
        var retval = new XQueryParser.p_Annotation_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ANN_PERCENT59 = null;
        var LPAREN61 = null;
        var COMMA63 = null;
        var RPAREN65 = null;
         var p_QName60 = null;
         var p_Literal62 = null;
         var p_Literal64 = null;

        var ANN_PERCENT59_tree=null;
        var LPAREN61_tree=null;
        var COMMA63_tree=null;
        var RPAREN65_tree=null;

        try {
            // xquery/XQueryParser.g:469:9: ( ANN_PERCENT p_QName ( LPAREN p_Literal ( COMMA p_Literal )* RPAREN )? )
            // xquery/XQueryParser.g:469:11: ANN_PERCENT p_QName ( LPAREN p_Literal ( COMMA p_Literal )* RPAREN )?
            root_0 = this.adaptor.nil();

            ANN_PERCENT59=this.match(this.input,ANN_PERCENT,XQueryParser.FOLLOW_ANN_PERCENT_in_p_Annotation2734); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            ANN_PERCENT59_tree = this.adaptor.create(ANN_PERCENT59);
            this.adaptor.addChild(root_0, ANN_PERCENT59_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_Annotation2736);
            p_QName60=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName60.getTree());
            // xquery/XQueryParser.g:469:31: ( LPAREN p_Literal ( COMMA p_Literal )* RPAREN )?
            var alt31=2;
            var LA31_0 = this.input.LA(1);

            if ( (LA31_0==LPAREN) ) {
                alt31=1;
            }
            switch (alt31) {
                case 1 :
                    // xquery/XQueryParser.g:469:32: LPAREN p_Literal ( COMMA p_Literal )* RPAREN
                    LPAREN61=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_Annotation2739); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LPAREN61_tree = this.adaptor.create(LPAREN61);
                    this.adaptor.addChild(root_0, LPAREN61_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_Literal_in_p_Annotation2741);
                    p_Literal62=this.p_Literal();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Literal62.getTree());
                    // xquery/XQueryParser.g:469:49: ( COMMA p_Literal )*
                    loop30:
                    do {
                        var alt30=2;
                        var LA30_0 = this.input.LA(1);

                        if ( (LA30_0==COMMA) ) {
                            alt30=1;
                        }


                        switch (alt30) {
                        case 1 :
                            // xquery/XQueryParser.g:469:50: COMMA p_Literal
                            COMMA63=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_Annotation2744); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COMMA63_tree = this.adaptor.create(COMMA63);
                            this.adaptor.addChild(root_0, COMMA63_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_Literal_in_p_Annotation2746);
                            p_Literal64=this.p_Literal();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Literal64.getTree());


                            break;

                        default :
                            break loop30;
                        }
                    } while (true);

                    RPAREN65=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_Annotation2750); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RPAREN65_tree = this.adaptor.create(RPAREN65);
                    this.adaptor.addChild(root_0, RPAREN65_tree);
                    }


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_VarDecl_return: (function() {
        XQueryParser.p_VarDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_VarDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:473:1: p_VarDecl : k= VARIABLE d= DOLLAR qn= p_QName (td= p_TypeDeclaration )? ( ( BIND vv= p_VarValue ) | (k= EXTERNAL ( BIND vdv= p_VarDefaultValue )? ) ) -> ^( VarDecl $qn ^( VarType ( $td)? ) ^( VarValue ( $vv)? ^( VarDefaultValue ( $vdv)? ) ) ) ;
    // $ANTLR start "p_VarDecl"
    p_VarDecl: function() {
        var retval = new XQueryParser.p_VarDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
        var BIND66 = null;
        var BIND67 = null;
         var qn = null;
         var td = null;
         var vv = null;
         var vdv = null;

        var k_tree=null;
        var d_tree=null;
        var BIND66_tree=null;
        var BIND67_tree=null;
        var stream_DOLLAR=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token DOLLAR");
        var stream_EXTERNAL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EXTERNAL");
        var stream_VARIABLE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token VARIABLE");
        var stream_BIND=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token BIND");
        var stream_p_TypeDeclaration=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_TypeDeclaration");
        var stream_p_QName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_QName");
        var stream_p_VarDefaultValue=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_VarDefaultValue");
        var stream_p_VarValue=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_VarValue");
        try {
            // xquery/XQueryParser.g:474:9: (k= VARIABLE d= DOLLAR qn= p_QName (td= p_TypeDeclaration )? ( ( BIND vv= p_VarValue ) | (k= EXTERNAL ( BIND vdv= p_VarDefaultValue )? ) ) -> ^( VarDecl $qn ^( VarType ( $td)? ) ^( VarValue ( $vv)? ^( VarDefaultValue ( $vdv)? ) ) ) )
            // xquery/XQueryParser.g:474:11: k= VARIABLE d= DOLLAR qn= p_QName (td= p_TypeDeclaration )? ( ( BIND vv= p_VarValue ) | (k= EXTERNAL ( BIND vdv= p_VarDefaultValue )? ) )
            k=this.match(this.input,VARIABLE,XQueryParser.FOLLOW_VARIABLE_in_p_VarDecl2780); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_VARIABLE.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_VarDecl2786); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_DOLLAR.add(d);

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_VarDecl2790);
            qn=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_QName.add(qn.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (qn?qn.stop:null)); 
            }
            // xquery/XQueryParser.g:474:86: (td= p_TypeDeclaration )?
            var alt32=2;
            var LA32_0 = this.input.LA(1);

            if ( (LA32_0==AS) ) {
                alt32=1;
            }
            switch (alt32) {
                case 1 :
                    // xquery/XQueryParser.g:474:86: td= p_TypeDeclaration
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_VarDecl2796);
                    td=this.p_TypeDeclaration();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_TypeDeclaration.add(td.getTree());


                    break;

            }

            // xquery/XQueryParser.g:474:106: ( ( BIND vv= p_VarValue ) | (k= EXTERNAL ( BIND vdv= p_VarDefaultValue )? ) )
            var alt34=2;
            var LA34_0 = this.input.LA(1);

            if ( (LA34_0==BIND) ) {
                alt34=1;
            }
            else if ( (LA34_0==EXTERNAL) ) {
                alt34=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 34, 0, this.input);

                throw nvae;
            }
            switch (alt34) {
                case 1 :
                    // xquery/XQueryParser.g:474:107: ( BIND vv= p_VarValue )
                    // xquery/XQueryParser.g:474:107: ( BIND vv= p_VarValue )
                    // xquery/XQueryParser.g:474:108: BIND vv= p_VarValue
                    BIND66=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_VarDecl2801); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_BIND.add(BIND66);

                    this.pushFollow(XQueryParser.FOLLOW_p_VarValue_in_p_VarDecl2805);
                    vv=this.p_VarValue();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_VarValue.add(vv.getTree());





                    break;
                case 2 :
                    // xquery/XQueryParser.g:474:130: (k= EXTERNAL ( BIND vdv= p_VarDefaultValue )? )
                    // xquery/XQueryParser.g:474:130: (k= EXTERNAL ( BIND vdv= p_VarDefaultValue )? )
                    // xquery/XQueryParser.g:474:131: k= EXTERNAL ( BIND vdv= p_VarDefaultValue )?
                    k=this.match(this.input,EXTERNAL,XQueryParser.FOLLOW_EXTERNAL_in_p_VarDecl2813); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_EXTERNAL.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    // xquery/XQueryParser.g:474:157: ( BIND vdv= p_VarDefaultValue )?
                    var alt33=2;
                    var LA33_0 = this.input.LA(1);

                    if ( (LA33_0==BIND) ) {
                        alt33=1;
                    }
                    switch (alt33) {
                        case 1 :
                            // xquery/XQueryParser.g:474:158: BIND vdv= p_VarDefaultValue
                            BIND67=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_VarDecl2818); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_BIND.add(BIND67);

                            this.pushFollow(XQueryParser.FOLLOW_p_VarDefaultValue_in_p_VarDecl2822);
                            vdv=this.p_VarDefaultValue();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_VarDefaultValue.add(vdv.getTree());


                            break;

                    }






                    break;

            }



            // AST REWRITE
            // elements: vv, vdv, qn, td
            // token labels: 
            // rule labels: qn, vv, retval, vdv, td
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_qn=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token qn",qn!=null?qn.tree:null);
            var stream_vv=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token vv",vv!=null?vv.tree:null);
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_vdv=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token vdv",vdv!=null?vdv.tree:null);
            var stream_td=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token td",td!=null?td.tree:null);

            root_0 = this.adaptor.nil();
            // 475:17: -> ^( VarDecl $qn ^( VarType ( $td)? ) ^( VarValue ( $vv)? ^( VarDefaultValue ( $vdv)? ) ) )
            {
                // xquery/XQueryParser.g:475:20: ^( VarDecl $qn ^( VarType ( $td)? ) ^( VarValue ( $vv)? ^( VarDefaultValue ( $vdv)? ) ) )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(VarDecl, "VarDecl"), root_1);

                this.adaptor.addChild(root_1, stream_qn.nextTree());
                // xquery/XQueryParser.g:475:34: ^( VarType ( $td)? )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(VarType, "VarType"), root_2);

                // xquery/XQueryParser.g:475:44: ( $td)?
                if ( stream_td.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_td.nextTree());

                }
                stream_td.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:475:50: ^( VarValue ( $vv)? ^( VarDefaultValue ( $vdv)? ) )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(VarValue, "VarValue"), root_2);

                // xquery/XQueryParser.g:475:61: ( $vv)?
                if ( stream_vv.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_vv.nextTree());

                }
                stream_vv.reset();
                // xquery/XQueryParser.g:475:66: ^( VarDefaultValue ( $vdv)? )
                {
                var root_3 = this.adaptor.nil();
                root_3 = this.adaptor.becomeRoot(this.adaptor.create(VarDefaultValue, "VarDefaultValue"), root_3);

                // xquery/XQueryParser.g:475:84: ( $vdv)?
                if ( stream_vdv.hasNext() ) {
                    this.adaptor.addChild(root_3, stream_vdv.nextTree());

                }
                stream_vdv.reset();

                this.adaptor.addChild(root_2, root_3);
                }

                this.adaptor.addChild(root_1, root_2);
                }

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_VarValue_return: (function() {
        XQueryParser.p_VarValue_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_VarValue_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:479:1: p_VarValue : p_ExprSingle[true] ;
    // $ANTLR start "p_VarValue"
    p_VarValue: function() {
        var retval = new XQueryParser.p_VarValue_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle68 = null;


        try {
            // xquery/XQueryParser.g:480:9: ( p_ExprSingle[true] )
            // xquery/XQueryParser.g:480:11: p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_VarValue2901);
            p_ExprSingle68=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle68.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_VarDefaultValue_return: (function() {
        XQueryParser.p_VarDefaultValue_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_VarDefaultValue_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:484:1: p_VarDefaultValue : p_ExprSingle[true] ;
    // $ANTLR start "p_VarDefaultValue"
    p_VarDefaultValue: function() {
        var retval = new XQueryParser.p_VarDefaultValue_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle69 = null;


        try {
            // xquery/XQueryParser.g:485:9: ( p_ExprSingle[true] )
            // xquery/XQueryParser.g:485:11: p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_VarDefaultValue2928);
            p_ExprSingle69=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle69.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_ContextItemDecl_return: (function() {
        XQueryParser.pm_ContextItemDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_ContextItemDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:489:1: pm_ContextItemDecl : k= DECLARE k= CONTEXT k= ITEM (k= AS p_ItemType )? ( ( BIND p_VarValue ) | (k= EXTERNAL ( BIND p_VarDefaultValue )? ) ) SEMICOLON ;
    // $ANTLR start "pm_ContextItemDecl"
    pm_ContextItemDecl: function() {
        var retval = new XQueryParser.pm_ContextItemDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var BIND71 = null;
        var BIND73 = null;
        var SEMICOLON75 = null;
         var p_ItemType70 = null;
         var p_VarValue72 = null;
         var p_VarDefaultValue74 = null;

        var k_tree=null;
        var BIND71_tree=null;
        var BIND73_tree=null;
        var SEMICOLON75_tree=null;

        try {
            // xquery/XQueryParser.g:490:9: (k= DECLARE k= CONTEXT k= ITEM (k= AS p_ItemType )? ( ( BIND p_VarValue ) | (k= EXTERNAL ( BIND p_VarDefaultValue )? ) ) SEMICOLON )
            // xquery/XQueryParser.g:490:11: k= DECLARE k= CONTEXT k= ITEM (k= AS p_ItemType )? ( ( BIND p_VarValue ) | (k= EXTERNAL ( BIND p_VarDefaultValue )? ) ) SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_ContextItemDecl2957); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,CONTEXT,XQueryParser.FOLLOW_CONTEXT_in_pm_ContextItemDecl2963); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,ITEM,XQueryParser.FOLLOW_ITEM_in_pm_ContextItemDecl2969); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:490:83: (k= AS p_ItemType )?
            var alt35=2;
            var LA35_0 = this.input.LA(1);

            if ( (LA35_0==AS) ) {
                alt35=1;
            }
            switch (alt35) {
                case 1 :
                    // xquery/XQueryParser.g:490:84: k= AS p_ItemType
                    k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_pm_ContextItemDecl2976); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ItemType_in_pm_ContextItemDecl2980);
                    p_ItemType70=this.p_ItemType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ItemType70.getTree());


                    break;

            }

            // xquery/XQueryParser.g:490:117: ( ( BIND p_VarValue ) | (k= EXTERNAL ( BIND p_VarDefaultValue )? ) )
            var alt37=2;
            var LA37_0 = this.input.LA(1);

            if ( (LA37_0==BIND) ) {
                alt37=1;
            }
            else if ( (LA37_0==EXTERNAL) ) {
                alt37=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 37, 0, this.input);

                throw nvae;
            }
            switch (alt37) {
                case 1 :
                    // xquery/XQueryParser.g:490:118: ( BIND p_VarValue )
                    // xquery/XQueryParser.g:490:118: ( BIND p_VarValue )
                    // xquery/XQueryParser.g:490:119: BIND p_VarValue
                    BIND71=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_pm_ContextItemDecl2986); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    BIND71_tree = this.adaptor.create(BIND71);
                    this.adaptor.addChild(root_0, BIND71_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarValue_in_pm_ContextItemDecl2988);
                    p_VarValue72=this.p_VarValue();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_VarValue72.getTree());





                    break;
                case 2 :
                    // xquery/XQueryParser.g:490:138: (k= EXTERNAL ( BIND p_VarDefaultValue )? )
                    // xquery/XQueryParser.g:490:138: (k= EXTERNAL ( BIND p_VarDefaultValue )? )
                    // xquery/XQueryParser.g:490:139: k= EXTERNAL ( BIND p_VarDefaultValue )?
                    k=this.match(this.input,EXTERNAL,XQueryParser.FOLLOW_EXTERNAL_in_pm_ContextItemDecl2996); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    // xquery/XQueryParser.g:490:165: ( BIND p_VarDefaultValue )?
                    var alt36=2;
                    var LA36_0 = this.input.LA(1);

                    if ( (LA36_0==BIND) ) {
                        alt36=1;
                    }
                    switch (alt36) {
                        case 1 :
                            // xquery/XQueryParser.g:490:166: BIND p_VarDefaultValue
                            BIND73=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_pm_ContextItemDecl3001); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            BIND73_tree = this.adaptor.create(BIND73);
                            this.adaptor.addChild(root_0, BIND73_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_VarDefaultValue_in_pm_ContextItemDecl3003);
                            p_VarDefaultValue74=this.p_VarDefaultValue();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_VarDefaultValue74.getTree());


                            break;

                    }






                    break;

            }

            SEMICOLON75=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_ContextItemDecl3009); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON75_tree = this.adaptor.create(SEMICOLON75);
            this.adaptor.addChild(root_0, SEMICOLON75_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_FunctionDecl_return: (function() {
        XQueryParser.pm_FunctionDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_FunctionDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:495:1: pm_FunctionDecl : ({...}? =>k= UPDATING )? k= FUNCTION qn= pg_FQName LPAREN (pl= p_ParamList )? RPAREN (k= AS st= p_SequenceType )? ( LBRACKET soe= p_StatementsAndOptionalExpr RBRACKET | k= EXTERNAL ) -> ^( FunctionDecl $qn ^( ParamList ( $pl)? ) ^( ReturnType ( $st)? ) ( $soe)? ) ;
    // $ANTLR start "pm_FunctionDecl"
    pm_FunctionDecl: function() {
        var retval = new XQueryParser.pm_FunctionDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LPAREN76 = null;
        var RPAREN77 = null;
        var LBRACKET78 = null;
        var RBRACKET79 = null;
         var qn = null;
         var pl = null;
         var st = null;
         var soe = null;

        var k_tree=null;
        var LPAREN76_tree=null;
        var RPAREN77_tree=null;
        var LBRACKET78_tree=null;
        var RBRACKET79_tree=null;
        var stream_FUNCTION=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token FUNCTION");
        var stream_LBRACKET=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LBRACKET");
        var stream_AS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token AS");
        var stream_RPAREN=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RPAREN");
        var stream_EXTERNAL=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EXTERNAL");
        var stream_RBRACKET=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RBRACKET");
        var stream_LPAREN=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LPAREN");
        var stream_UPDATING=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token UPDATING");
        var stream_p_StatementsAndOptionalExpr=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_StatementsAndOptionalExpr");
        var stream_p_ParamList=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_ParamList");
        var stream_pg_FQName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pg_FQName");
        var stream_p_SequenceType=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_SequenceType");
        try {
            // xquery/XQueryParser.g:496:9: ( ({...}? =>k= UPDATING )? k= FUNCTION qn= pg_FQName LPAREN (pl= p_ParamList )? RPAREN (k= AS st= p_SequenceType )? ( LBRACKET soe= p_StatementsAndOptionalExpr RBRACKET | k= EXTERNAL ) -> ^( FunctionDecl $qn ^( ParamList ( $pl)? ) ^( ReturnType ( $st)? ) ( $soe)? ) )
            // xquery/XQueryParser.g:496:11: ({...}? =>k= UPDATING )? k= FUNCTION qn= pg_FQName LPAREN (pl= p_ParamList )? RPAREN (k= AS st= p_SequenceType )? ( LBRACKET soe= p_StatementsAndOptionalExpr RBRACKET | k= EXTERNAL )
            // xquery/XQueryParser.g:496:11: ({...}? =>k= UPDATING )?
            var alt38=2;
            var LA38_0 = this.input.LA(1);

            if ( (LA38_0==UPDATING) && ((this.lc(XQU)))) {
                alt38=1;
            }
            switch (alt38) {
                case 1 :
                    // xquery/XQueryParser.g:496:12: {...}? =>k= UPDATING
                    if ( !((this.lc(XQU))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "pm_FunctionDecl", "this.lc(XQU)");
                    }
                    k=this.match(this.input,UPDATING,XQueryParser.FOLLOW_UPDATING_in_pm_FunctionDecl3042); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_UPDATING.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }


                    break;

            }

            k=this.match(this.input,FUNCTION,XQueryParser.FOLLOW_FUNCTION_in_pm_FunctionDecl3050); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_FUNCTION.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_pg_FQName_in_pm_FunctionDecl3056);
            qn=this.pg_FQName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_pg_FQName.add(qn.getTree());
            LPAREN76=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_pm_FunctionDecl3058); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_LPAREN.add(LPAREN76);

            // xquery/XQueryParser.g:496:106: (pl= p_ParamList )?
            var alt39=2;
            var LA39_0 = this.input.LA(1);

            if ( (LA39_0==DOLLAR) ) {
                alt39=1;
            }
            switch (alt39) {
                case 1 :
                    // xquery/XQueryParser.g:496:106: pl= p_ParamList
                    this.pushFollow(XQueryParser.FOLLOW_p_ParamList_in_pm_FunctionDecl3062);
                    pl=this.p_ParamList();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_ParamList.add(pl.getTree());


                    break;

            }

            RPAREN77=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_pm_FunctionDecl3065); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_RPAREN.add(RPAREN77);

            // xquery/XQueryParser.g:496:127: (k= AS st= p_SequenceType )?
            var alt40=2;
            var LA40_0 = this.input.LA(1);

            if ( (LA40_0==AS) ) {
                alt40=1;
            }
            switch (alt40) {
                case 1 :
                    // xquery/XQueryParser.g:496:128: k= AS st= p_SequenceType
                    k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_pm_FunctionDecl3070); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_AS.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_pm_FunctionDecl3076);
                    st=this.p_SequenceType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_SequenceType.add(st.getTree());


                    break;

            }

            // xquery/XQueryParser.g:496:168: ( LBRACKET soe= p_StatementsAndOptionalExpr RBRACKET | k= EXTERNAL )
            var alt41=2;
            var LA41_0 = this.input.LA(1);

            if ( (LA41_0==LBRACKET) ) {
                alt41=1;
            }
            else if ( (LA41_0==EXTERNAL) ) {
                alt41=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 41, 0, this.input);

                throw nvae;
            }
            switch (alt41) {
                case 1 :
                    // xquery/XQueryParser.g:496:169: LBRACKET soe= p_StatementsAndOptionalExpr RBRACKET
                    LBRACKET78=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_FunctionDecl3081); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_LBRACKET.add(LBRACKET78);

                    this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_pm_FunctionDecl3085);
                    soe=this.p_StatementsAndOptionalExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_StatementsAndOptionalExpr.add(soe.getTree());
                    RBRACKET79=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_FunctionDecl3087); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_RBRACKET.add(RBRACKET79);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:496:221: k= EXTERNAL
                    k=this.match(this.input,EXTERNAL,XQueryParser.FOLLOW_EXTERNAL_in_pm_FunctionDecl3093); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_EXTERNAL.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }


                    break;

            }



            // AST REWRITE
            // elements: st, pl, qn, soe
            // token labels: 
            // rule labels: soe, qn, retval, pl, st
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_soe=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token soe",soe!=null?soe.tree:null);
            var stream_qn=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token qn",qn!=null?qn.tree:null);
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_pl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token pl",pl!=null?pl.tree:null);
            var stream_st=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token st",st!=null?st.tree:null);

            root_0 = this.adaptor.nil();
            // 497:17: -> ^( FunctionDecl $qn ^( ParamList ( $pl)? ) ^( ReturnType ( $st)? ) ( $soe)? )
            {
                // xquery/XQueryParser.g:497:20: ^( FunctionDecl $qn ^( ParamList ( $pl)? ) ^( ReturnType ( $st)? ) ( $soe)? )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(FunctionDecl, "FunctionDecl"), root_1);

                this.adaptor.addChild(root_1, stream_qn.nextTree());
                // xquery/XQueryParser.g:497:39: ^( ParamList ( $pl)? )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(ParamList, "ParamList"), root_2);

                // xquery/XQueryParser.g:497:51: ( $pl)?
                if ( stream_pl.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_pl.nextTree());

                }
                stream_pl.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:497:57: ^( ReturnType ( $st)? )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(ReturnType, "ReturnType"), root_2);

                // xquery/XQueryParser.g:497:70: ( $st)?
                if ( stream_st.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_st.nextTree());

                }
                stream_st.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:497:76: ( $soe)?
                if ( stream_soe.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_soe.nextTree());

                }
                stream_soe.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ParamList_return: (function() {
        XQueryParser.p_ParamList_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ParamList_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:501:1: p_ParamList : p+= p_Param ( COMMA p+= p_Param )* -> ( $p)+ ;
    // $ANTLR start "p_ParamList"
    p_ParamList: function() {
        var retval = new XQueryParser.p_ParamList_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var COMMA80 = null;
        var list_p=null;
        var p = null;
        var COMMA80_tree=null;
        var stream_COMMA=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COMMA");
        var stream_p_Param=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_Param");
        try {
            // xquery/XQueryParser.g:502:9: (p+= p_Param ( COMMA p+= p_Param )* -> ( $p)+ )
            // xquery/XQueryParser.g:502:11: p+= p_Param ( COMMA p+= p_Param )*
            this.pushFollow(XQueryParser.FOLLOW_p_Param_in_p_ParamList3170);
            p=this.p_Param();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_Param.add(p.getTree());
            if (org.antlr.lang.isNull(list_p)) list_p = [];
            list_p.push(p.getTree());

            // xquery/XQueryParser.g:502:22: ( COMMA p+= p_Param )*
            loop42:
            do {
                var alt42=2;
                var LA42_0 = this.input.LA(1);

                if ( (LA42_0==COMMA) ) {
                    alt42=1;
                }


                switch (alt42) {
                case 1 :
                    // xquery/XQueryParser.g:502:23: COMMA p+= p_Param
                    COMMA80=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_ParamList3173); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_COMMA.add(COMMA80);

                    this.pushFollow(XQueryParser.FOLLOW_p_Param_in_p_ParamList3177);
                    p=this.p_Param();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_Param.add(p.getTree());
                    if (org.antlr.lang.isNull(list_p)) list_p = [];
                    list_p.push(p.getTree());



                    break;

                default :
                    break loop42;
                }
            } while (true);



            // AST REWRITE
            // elements: p
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: p
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_p=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token p",list_p);
            root_0 = this.adaptor.nil();
            // 503:17: -> ( $p)+
            {
                if ( !(stream_p.hasNext()) ) {
                    throw new org.antlr.runtime.tree.RewriteEarlyExitException();
                }
                while ( stream_p.hasNext() ) {
                    this.adaptor.addChild(root_0, stream_p.nextTree());

                }
                stream_p.reset();

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Param_return: (function() {
        XQueryParser.p_Param_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Param_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:507:1: p_Param : d= DOLLAR qn= p_QName (td= p_TypeDeclaration )? -> ^( Param $qn ( $td)? ) ;
    // $ANTLR start "p_Param"
    p_Param: function() {
        var retval = new XQueryParser.p_Param_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
         var qn = null;
         var td = null;

        var d_tree=null;
        var stream_DOLLAR=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token DOLLAR");
        var stream_p_TypeDeclaration=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_TypeDeclaration");
        var stream_p_QName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_QName");
        try {
            // xquery/XQueryParser.g:508:9: (d= DOLLAR qn= p_QName (td= p_TypeDeclaration )? -> ^( Param $qn ( $td)? ) )
            // xquery/XQueryParser.g:508:11: d= DOLLAR qn= p_QName (td= p_TypeDeclaration )?
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_Param3237); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_DOLLAR.add(d);

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_Param3241);
            qn=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_QName.add(qn.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (qn?qn.stop:null)); 
            }
            // xquery/XQueryParser.g:508:60: (td= p_TypeDeclaration )?
            var alt43=2;
            var LA43_0 = this.input.LA(1);

            if ( (LA43_0==AS) ) {
                alt43=1;
            }
            switch (alt43) {
                case 1 :
                    // xquery/XQueryParser.g:508:60: td= p_TypeDeclaration
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_Param3247);
                    td=this.p_TypeDeclaration();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_TypeDeclaration.add(td.getTree());


                    break;

            }



            // AST REWRITE
            // elements: qn, td
            // token labels: 
            // rule labels: qn, retval, td
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_qn=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token qn",qn!=null?qn.tree:null);
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_td=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token td",td!=null?td.tree:null);

            root_0 = this.adaptor.nil();
            // 509:17: -> ^( Param $qn ( $td)? )
            {
                // xquery/XQueryParser.g:509:20: ^( Param $qn ( $td)? )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(Param, "Param"), root_1);

                this.adaptor.addChild(root_1, stream_qn.nextTree());
                // xquery/XQueryParser.g:509:32: ( $td)?
                if ( stream_td.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_td.nextTree());

                }
                stream_td.reset();

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_FunctionBody_return: (function() {
        XQueryParser.pm_FunctionBody_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_FunctionBody_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:513:1: pm_FunctionBody : p_EnclosedExpr ;
    // $ANTLR start "pm_FunctionBody"
    pm_FunctionBody: function() {
        var retval = new XQueryParser.pm_FunctionBody_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_EnclosedExpr81 = null;


        try {
            // xquery/XQueryParser.g:514:9: ( p_EnclosedExpr )
            // xquery/XQueryParser.g:514:11: p_EnclosedExpr
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_EnclosedExpr_in_pm_FunctionBody3303);
            p_EnclosedExpr81=this.p_EnclosedExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_EnclosedExpr81.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_EnclosedExpr_return: (function() {
        XQueryParser.p_EnclosedExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_EnclosedExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:519:1: p_EnclosedExpr : LBRACKET p_Expr[true,true] RBRACKET -> ^( EnclosedExpr p_Expr ) ;
    // $ANTLR start "p_EnclosedExpr"
    p_EnclosedExpr: function() {
        var retval = new XQueryParser.p_EnclosedExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LBRACKET82 = null;
        var RBRACKET84 = null;
         var p_Expr83 = null;

        var LBRACKET82_tree=null;
        var RBRACKET84_tree=null;
        var stream_LBRACKET=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LBRACKET");
        var stream_RBRACKET=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RBRACKET");
        var stream_p_Expr=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_Expr");
        try {
            // xquery/XQueryParser.g:520:9: ( LBRACKET p_Expr[true,true] RBRACKET -> ^( EnclosedExpr p_Expr ) )
            // xquery/XQueryParser.g:520:11: LBRACKET p_Expr[true,true] RBRACKET
            LBRACKET82=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_EnclosedExpr3330); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_LBRACKET.add(LBRACKET82);

            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_EnclosedExpr3332);
            p_Expr83=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_Expr.add(p_Expr83.getTree());
            RBRACKET84=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_EnclosedExpr3335); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_RBRACKET.add(RBRACKET84);



            // AST REWRITE
            // elements: p_Expr
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 521:17: -> ^( EnclosedExpr p_Expr )
            {
                // xquery/XQueryParser.g:521:20: ^( EnclosedExpr p_Expr )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(EnclosedExpr, "EnclosedExpr"), root_1);

                this.adaptor.addChild(root_1, stream_p_Expr.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_OptionDecl_return: (function() {
        XQueryParser.pm_OptionDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_OptionDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:525:1: pm_OptionDecl : k= DECLARE k= OPTION p_QName p_StringLiteral SEMICOLON ;
    // $ANTLR start "pm_OptionDecl"
    pm_OptionDecl: function() {
        var retval = new XQueryParser.pm_OptionDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON87 = null;
         var p_QName85 = null;
         var p_StringLiteral86 = null;

        var k_tree=null;
        var SEMICOLON87_tree=null;

        try {
            // xquery/XQueryParser.g:526:9: (k= DECLARE k= OPTION p_QName p_StringLiteral SEMICOLON )
            // xquery/XQueryParser.g:526:11: k= DECLARE k= OPTION p_QName p_StringLiteral SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_OptionDecl3387); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,OPTION,XQueryParser.FOLLOW_OPTION_in_pm_OptionDecl3393); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_pm_OptionDecl3397);
            p_QName85=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName85.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_pm_OptionDecl3399);
            p_StringLiteral86=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral86.getTree());
            SEMICOLON87=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_OptionDecl3401); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON87_tree = this.adaptor.create(SEMICOLON87);
            this.adaptor.addChild(root_0, SEMICOLON87_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_QueryBody_return: (function() {
        XQueryParser.pm_QueryBody_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_QueryBody_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:530:1: pm_QueryBody : ({...}? => p_Program | p_Expr[true,true] );
    // $ANTLR start "pm_QueryBody"
    pm_QueryBody: function() {
        var retval = new XQueryParser.pm_QueryBody_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Program88 = null;
         var p_Expr89 = null;


        try {
            // xquery/XQueryParser.g:531:9: ({...}? => p_Program | p_Expr[true,true] )
            var alt44=2;
            alt44 = this.dfa44.predict(this.input);
            switch (alt44) {
                case 1 :
                    // xquery/XQueryParser.g:531:11: {...}? => p_Program
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(XQS))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "pm_QueryBody", "this.lc(XQS)");
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_Program_in_pm_QueryBody3430);
                    p_Program88=this.p_Program();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Program88.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:532:11: p_Expr[true,true]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_pm_QueryBody3442);
                    p_Expr89=this.p_Expr(true, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr89.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Expr_return: (function() {
        XQueryParser.p_Expr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Expr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:542:1: p_Expr[strict, allowConcat] : es= p_ExprSingle[$strict] ( COMMA p_ExprSingle[$strict] )* ;
    // $ANTLR start "p_Expr"
    p_Expr: function(strict, allowConcat) {
        var retval = new XQueryParser.p_Expr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var COMMA90 = null;
         var es = null;
         var p_ExprSingle91 = null;

        var COMMA90_tree=null;

        try {
            // xquery/XQueryParser.g:543:9: (es= p_ExprSingle[$strict] ( COMMA p_ExprSingle[$strict] )* )
            // xquery/XQueryParser.g:543:11: es= p_ExprSingle[$strict] ( COMMA p_ExprSingle[$strict] )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_Expr3478);
            es=this.p_ExprSingle(strict);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, es.getTree());
            if ( this.state.backtracking===0 ) {
               if (!allowConcat) throw new Exception(); 
            }
            // xquery/XQueryParser.g:544:11: ( COMMA p_ExprSingle[$strict] )*
            loop45:
            do {
                var alt45=2;
                var LA45_0 = this.input.LA(1);

                if ( (LA45_0==COMMA) ) {
                    alt45=1;
                }


                switch (alt45) {
                case 1 :
                    // xquery/XQueryParser.g:544:12: COMMA p_ExprSingle[$strict]
                    COMMA90=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_Expr3494); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA90_tree = this.adaptor.create(COMMA90);
                    this.adaptor.addChild(root_0, COMMA90_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_Expr3496);
                    p_ExprSingle91=this.p_ExprSingle(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle91.getTree());


                    break;

                default :
                    break loop45;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (e) {

              if(e instanceof org.antlr.runtime.RecognitionException) {
                //console.log("catch1");
                reportError(e);
                recover(this.input, e);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), e);
              } else if(e instanceof Exception) {
                //console.log("catch2");
                root_0 = this.adaptor.nil();
                this.adaptor.addChild(root_0, es.getTree());
                retval.stop = this.input.LT(-1);
                retval.tree = this.adaptor.rulePostProcessing(root_0);
                this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
              } else {
                throw e;
              }

        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ExprSingle_return: (function() {
        XQueryParser.p_ExprSingle_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ExprSingle_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:566:1: p_ExprSingle[strict] : ( ( ( ( FOR | LET ) DOLLAR ) | ( FOR ( TUMBLING | SLIDING ) ) )=> p_FLWORHybrid[$strict] | ( IF LPAREN )=> p_IfHybrid[$strict] | ( SWITCH LPAREN )=> p_SwitchHybrid[$strict] | ( TYPESWITCH LPAREN )=> p_TypeswitchHybrid[$strict] | ( TRY LBRACKET )=> p_TryCatchHybrid[$strict] | p_ExprSimple );
    // $ANTLR start "p_ExprSingle"
    p_ExprSingle: function(strict) {
        var retval = new XQueryParser.p_ExprSingle_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_FLWORHybrid92 = null;
         var p_IfHybrid93 = null;
         var p_SwitchHybrid94 = null;
         var p_TypeswitchHybrid95 = null;
         var p_TryCatchHybrid96 = null;
         var p_ExprSimple97 = null;


        try {
            // xquery/XQueryParser.g:567:9: ( ( ( ( FOR | LET ) DOLLAR ) | ( FOR ( TUMBLING | SLIDING ) ) )=> p_FLWORHybrid[$strict] | ( IF LPAREN )=> p_IfHybrid[$strict] | ( SWITCH LPAREN )=> p_SwitchHybrid[$strict] | ( TYPESWITCH LPAREN )=> p_TypeswitchHybrid[$strict] | ( TRY LBRACKET )=> p_TryCatchHybrid[$strict] | p_ExprSimple )
            var alt46=6;
            alt46 = this.dfa46.predict(this.input);
            switch (alt46) {
                case 1 :
                    // xquery/XQueryParser.g:567:11: ( ( ( FOR | LET ) DOLLAR ) | ( FOR ( TUMBLING | SLIDING ) ) )=> p_FLWORHybrid[$strict]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FLWORHybrid_in_p_ExprSingle3563);
                    p_FLWORHybrid92=this.p_FLWORHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FLWORHybrid92.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:568:11: ( IF LPAREN )=> p_IfHybrid[$strict]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_IfHybrid_in_p_ExprSingle3593);
                    p_IfHybrid93=this.p_IfHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IfHybrid93.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:569:11: ( SWITCH LPAREN )=> p_SwitchHybrid[$strict]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_SwitchHybrid_in_p_ExprSingle3619);
                    p_SwitchHybrid94=this.p_SwitchHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SwitchHybrid94.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:570:11: ( TYPESWITCH LPAREN )=> p_TypeswitchHybrid[$strict]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_TypeswitchHybrid_in_p_ExprSingle3641);
                    p_TypeswitchHybrid95=this.p_TypeswitchHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeswitchHybrid95.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:571:11: ( TRY LBRACKET )=> p_TryCatchHybrid[$strict]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_TryCatchHybrid_in_p_ExprSingle3668);
                    p_TryCatchHybrid96=this.p_TryCatchHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TryCatchHybrid96.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:572:11: p_ExprSimple
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ExprSimple_in_p_ExprSingle3681);
                    p_ExprSimple97=this.p_ExprSimple();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSimple97.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FLWORHybrid_return: (function() {
        XQueryParser.p_FLWORHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FLWORHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:576:1: p_FLWORHybrid[strict] : p_InitialClause ( p_IntermediateClause )* p_ReturnHybrid[$strict] ;
    // $ANTLR start "p_FLWORHybrid"
    p_FLWORHybrid: function(strict) {
        var retval = new XQueryParser.p_FLWORHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_InitialClause98 = null;
         var p_IntermediateClause99 = null;
         var p_ReturnHybrid100 = null;


        try {
            // xquery/XQueryParser.g:577:9: ( p_InitialClause ( p_IntermediateClause )* p_ReturnHybrid[$strict] )
            // xquery/XQueryParser.g:577:11: p_InitialClause ( p_IntermediateClause )* p_ReturnHybrid[$strict]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_InitialClause_in_p_FLWORHybrid3708);
            p_InitialClause98=this.p_InitialClause();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InitialClause98.getTree());
            // xquery/XQueryParser.g:577:27: ( p_IntermediateClause )*
            loop47:
            do {
                var alt47=2;
                var LA47_0 = this.input.LA(1);

                if ( (LA47_0==FOR||LA47_0==LET||LA47_0==ORDER||LA47_0==STABLE||LA47_0==WHERE||LA47_0==COUNT||LA47_0==GROUP) ) {
                    alt47=1;
                }


                switch (alt47) {
                case 1 :
                    // xquery/XQueryParser.g:577:27: p_IntermediateClause
                    this.pushFollow(XQueryParser.FOLLOW_p_IntermediateClause_in_p_FLWORHybrid3710);
                    p_IntermediateClause99=this.p_IntermediateClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IntermediateClause99.getTree());


                    break;

                default :
                    break loop47;
                }
            } while (true);

            this.pushFollow(XQueryParser.FOLLOW_p_ReturnHybrid_in_p_FLWORHybrid3713);
            p_ReturnHybrid100=this.p_ReturnHybrid(strict);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ReturnHybrid100.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_InitialClause_return: (function() {
        XQueryParser.p_InitialClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_InitialClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:581:1: p_InitialClause : ( p_ForClause | p_LetClause | p_WindowClause );
    // $ANTLR start "p_InitialClause"
    p_InitialClause: function() {
        var retval = new XQueryParser.p_InitialClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ForClause101 = null;
         var p_LetClause102 = null;
         var p_WindowClause103 = null;


        try {
            // xquery/XQueryParser.g:582:9: ( p_ForClause | p_LetClause | p_WindowClause )
            var alt48=3;
            var LA48_0 = this.input.LA(1);

            if ( (LA48_0==FOR) ) {
                var LA48_1 = this.input.LA(2);

                if ( (LA48_1==DOLLAR) ) {
                    alt48=1;
                }
                else if ( (LA48_1==SLIDING||LA48_1==TUMBLING) ) {
                    alt48=3;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 48, 1, this.input);

                    throw nvae;
                }
            }
            else if ( (LA48_0==LET) ) {
                alt48=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 48, 0, this.input);

                throw nvae;
            }
            switch (alt48) {
                case 1 :
                    // xquery/XQueryParser.g:582:11: p_ForClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ForClause_in_p_InitialClause3740);
                    p_ForClause101=this.p_ForClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ForClause101.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:582:25: p_LetClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_LetClause_in_p_InitialClause3744);
                    p_LetClause102=this.p_LetClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_LetClause102.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:582:39: p_WindowClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_WindowClause_in_p_InitialClause3748);
                    p_WindowClause103=this.p_WindowClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WindowClause103.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IntermediateClause_return: (function() {
        XQueryParser.p_IntermediateClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IntermediateClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:586:1: p_IntermediateClause : ( p_InitialClause | p_WhereClause | p_GroupByClause | p_OrderByClause | p_CountClause );
    // $ANTLR start "p_IntermediateClause"
    p_IntermediateClause: function() {
        var retval = new XQueryParser.p_IntermediateClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_InitialClause104 = null;
         var p_WhereClause105 = null;
         var p_GroupByClause106 = null;
         var p_OrderByClause107 = null;
         var p_CountClause108 = null;


        try {
            // xquery/XQueryParser.g:587:9: ( p_InitialClause | p_WhereClause | p_GroupByClause | p_OrderByClause | p_CountClause )
            var alt49=5;
            switch ( this.input.LA(1) ) {
            case FOR:
            case LET:
                alt49=1;
                break;
            case WHERE:
                alt49=2;
                break;
            case GROUP:
                alt49=3;
                break;
            case ORDER:
            case STABLE:
                alt49=4;
                break;
            case COUNT:
                alt49=5;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 49, 0, this.input);

                throw nvae;
            }

            switch (alt49) {
                case 1 :
                    // xquery/XQueryParser.g:587:11: p_InitialClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_InitialClause_in_p_IntermediateClause3774);
                    p_InitialClause104=this.p_InitialClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InitialClause104.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:587:29: p_WhereClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_WhereClause_in_p_IntermediateClause3778);
                    p_WhereClause105=this.p_WhereClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WhereClause105.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:587:45: p_GroupByClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_GroupByClause_in_p_IntermediateClause3782);
                    p_GroupByClause106=this.p_GroupByClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_GroupByClause106.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:587:63: p_OrderByClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_OrderByClause_in_p_IntermediateClause3786);
                    p_OrderByClause107=this.p_OrderByClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OrderByClause107.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:587:81: p_CountClause
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_CountClause_in_p_IntermediateClause3790);
                    p_CountClause108=this.p_CountClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CountClause108.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_StringConcatExpr_return: (function() {
        XQueryParser.p_StringConcatExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_StringConcatExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:591:1: p_StringConcatExpr : p_RangeExpr ( CONCAT p_RangeExpr )* ;
    // $ANTLR start "p_StringConcatExpr"
    p_StringConcatExpr: function() {
        var retval = new XQueryParser.p_StringConcatExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var CONCAT110 = null;
         var p_RangeExpr109 = null;
         var p_RangeExpr111 = null;

        var CONCAT110_tree=null;

        try {
            // xquery/XQueryParser.g:592:4: ( p_RangeExpr ( CONCAT p_RangeExpr )* )
            // xquery/XQueryParser.g:592:6: p_RangeExpr ( CONCAT p_RangeExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_RangeExpr_in_p_StringConcatExpr3811);
            p_RangeExpr109=this.p_RangeExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_RangeExpr109.getTree());
            // xquery/XQueryParser.g:592:18: ( CONCAT p_RangeExpr )*
            loop50:
            do {
                var alt50=2;
                var LA50_0 = this.input.LA(1);

                if ( (LA50_0==CONCAT) ) {
                    alt50=1;
                }


                switch (alt50) {
                case 1 :
                    // xquery/XQueryParser.g:592:20: CONCAT p_RangeExpr
                    CONCAT110=this.match(this.input,CONCAT,XQueryParser.FOLLOW_CONCAT_in_p_StringConcatExpr3815); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    CONCAT110_tree = this.adaptor.create(CONCAT110);
                    this.adaptor.addChild(root_0, CONCAT110_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_RangeExpr_in_p_StringConcatExpr3817);
                    p_RangeExpr111=this.p_RangeExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_RangeExpr111.getTree());


                    break;

                default :
                    break loop50;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ForClause_return: (function() {
        XQueryParser.p_ForClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ForClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:597:1: p_ForClause : k= FOR p_ForBinding ( COMMA p_ForBinding )* ;
    // $ANTLR start "p_ForClause"
    p_ForClause: function() {
        var retval = new XQueryParser.p_ForClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var COMMA113 = null;
         var p_ForBinding112 = null;
         var p_ForBinding114 = null;

        var k_tree=null;
        var COMMA113_tree=null;

        try {
            // xquery/XQueryParser.g:598:9: (k= FOR p_ForBinding ( COMMA p_ForBinding )* )
            // xquery/XQueryParser.g:598:11: k= FOR p_ForBinding ( COMMA p_ForBinding )*
            root_0 = this.adaptor.nil();

            k=this.match(this.input,FOR,XQueryParser.FOLLOW_FOR_in_p_ForClause3844); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ForBinding_in_p_ForClause3848);
            p_ForBinding112=this.p_ForBinding();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ForBinding112.getTree());
            // xquery/XQueryParser.g:598:45: ( COMMA p_ForBinding )*
            loop51:
            do {
                var alt51=2;
                var LA51_0 = this.input.LA(1);

                if ( (LA51_0==COMMA) ) {
                    alt51=1;
                }


                switch (alt51) {
                case 1 :
                    // xquery/XQueryParser.g:598:46: COMMA p_ForBinding
                    COMMA113=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_ForClause3851); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA113_tree = this.adaptor.create(COMMA113);
                    this.adaptor.addChild(root_0, COMMA113_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ForBinding_in_p_ForClause3853);
                    p_ForBinding114=this.p_ForBinding();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ForBinding114.getTree());


                    break;

                default :
                    break loop51;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ForBinding_return: (function() {
        XQueryParser.p_ForBinding_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ForBinding_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:602:1: p_ForBinding : s= DOLLAR v= p_VarName ( p_TypeDeclaration )? ( p_AllowingEmpty )? ( p_PositionalVar )? ( p_FTScoreVar )? k= IN p_ExprSingle[true] ;
    // $ANTLR start "p_ForBinding"
    p_ForBinding: function() {
        var retval = new XQueryParser.p_ForBinding_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var s = null;
        var k = null;
         var v = null;
         var p_TypeDeclaration115 = null;
         var p_AllowingEmpty116 = null;
         var p_PositionalVar117 = null;
         var p_FTScoreVar118 = null;
         var p_ExprSingle119 = null;

        var s_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:603:9: (s= DOLLAR v= p_VarName ( p_TypeDeclaration )? ( p_AllowingEmpty )? ( p_PositionalVar )? ( p_FTScoreVar )? k= IN p_ExprSingle[true] )
            // xquery/XQueryParser.g:603:11: s= DOLLAR v= p_VarName ( p_TypeDeclaration )? ( p_AllowingEmpty )? ( p_PositionalVar )? ( p_FTScoreVar )? k= IN p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            s=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_ForBinding3883); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            s_tree = this.adaptor.create(s);
            this.adaptor.addChild(root_0, s_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_ForBinding3887);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(s, (v?v.stop:null)); 
            }
            // xquery/XQueryParser.g:603:58: ( p_TypeDeclaration )?
            var alt52=2;
            var LA52_0 = this.input.LA(1);

            if ( (LA52_0==AS) ) {
                alt52=1;
            }
            switch (alt52) {
                case 1 :
                    // xquery/XQueryParser.g:603:58: p_TypeDeclaration
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_ForBinding3891);
                    p_TypeDeclaration115=this.p_TypeDeclaration();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration115.getTree());


                    break;

            }

            // xquery/XQueryParser.g:603:77: ( p_AllowingEmpty )?
            var alt53=2;
            var LA53_0 = this.input.LA(1);

            if ( (LA53_0==ALLOWING) ) {
                alt53=1;
            }
            switch (alt53) {
                case 1 :
                    // xquery/XQueryParser.g:603:77: p_AllowingEmpty
                    this.pushFollow(XQueryParser.FOLLOW_p_AllowingEmpty_in_p_ForBinding3894);
                    p_AllowingEmpty116=this.p_AllowingEmpty();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AllowingEmpty116.getTree());


                    break;

            }

            // xquery/XQueryParser.g:603:94: ( p_PositionalVar )?
            var alt54=2;
            var LA54_0 = this.input.LA(1);

            if ( (LA54_0==AT) ) {
                alt54=1;
            }
            switch (alt54) {
                case 1 :
                    // xquery/XQueryParser.g:603:94: p_PositionalVar
                    this.pushFollow(XQueryParser.FOLLOW_p_PositionalVar_in_p_ForBinding3897);
                    p_PositionalVar117=this.p_PositionalVar();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PositionalVar117.getTree());


                    break;

            }

            // xquery/XQueryParser.g:603:111: ( p_FTScoreVar )?
            var alt55=2;
            var LA55_0 = this.input.LA(1);

            if ( (LA55_0==SCORE) ) {
                alt55=1;
            }
            switch (alt55) {
                case 1 :
                    // xquery/XQueryParser.g:603:111: p_FTScoreVar
                    this.pushFollow(XQueryParser.FOLLOW_p_FTScoreVar_in_p_ForBinding3900);
                    p_FTScoreVar118=this.p_FTScoreVar();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTScoreVar118.getTree());


                    break;

            }

            k=this.match(this.input,IN,XQueryParser.FOLLOW_IN_in_p_ForBinding3905); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_ForBinding3909);
            p_ExprSingle119=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle119.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AllowingEmpty_return: (function() {
        XQueryParser.p_AllowingEmpty_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AllowingEmpty_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:607:1: p_AllowingEmpty : k= ALLOWING k= EMPTY ;
    // $ANTLR start "p_AllowingEmpty"
    p_AllowingEmpty: function() {
        var retval = new XQueryParser.p_AllowingEmpty_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:608:9: (k= ALLOWING k= EMPTY )
            // xquery/XQueryParser.g:608:11: k= ALLOWING k= EMPTY
            root_0 = this.adaptor.nil();

            k=this.match(this.input,ALLOWING,XQueryParser.FOLLOW_ALLOWING_in_p_AllowingEmpty3938); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,EMPTY,XQueryParser.FOLLOW_EMPTY_in_p_AllowingEmpty3944); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PositionalVar_return: (function() {
        XQueryParser.p_PositionalVar_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PositionalVar_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:612:1: p_PositionalVar : k= AT d= DOLLAR v= p_VarName ;
    // $ANTLR start "p_PositionalVar"
    p_PositionalVar: function() {
        var retval = new XQueryParser.p_PositionalVar_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:613:9: (k= AT d= DOLLAR v= p_VarName )
            // xquery/XQueryParser.g:613:11: k= AT d= DOLLAR v= p_VarName
            root_0 = this.adaptor.nil();

            k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_PositionalVar3974); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_PositionalVar3980); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_PositionalVar3984);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_LetClause_return: (function() {
        XQueryParser.p_LetClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_LetClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:617:1: p_LetClause : k= LET p_LetBinding ( COMMA p_LetBinding )* ;
    // $ANTLR start "p_LetClause"
    p_LetClause: function() {
        var retval = new XQueryParser.p_LetClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var COMMA121 = null;
         var p_LetBinding120 = null;
         var p_LetBinding122 = null;

        var k_tree=null;
        var COMMA121_tree=null;

        try {
            // xquery/XQueryParser.g:618:9: (k= LET p_LetBinding ( COMMA p_LetBinding )* )
            // xquery/XQueryParser.g:618:11: k= LET p_LetBinding ( COMMA p_LetBinding )*
            root_0 = this.adaptor.nil();

            k=this.match(this.input,LET,XQueryParser.FOLLOW_LET_in_p_LetClause4014); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_LetBinding_in_p_LetClause4018);
            p_LetBinding120=this.p_LetBinding();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_LetBinding120.getTree());
            // xquery/XQueryParser.g:618:45: ( COMMA p_LetBinding )*
            loop56:
            do {
                var alt56=2;
                var LA56_0 = this.input.LA(1);

                if ( (LA56_0==COMMA) ) {
                    alt56=1;
                }


                switch (alt56) {
                case 1 :
                    // xquery/XQueryParser.g:618:46: COMMA p_LetBinding
                    COMMA121=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_LetClause4021); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA121_tree = this.adaptor.create(COMMA121);
                    this.adaptor.addChild(root_0, COMMA121_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_LetBinding_in_p_LetClause4023);
                    p_LetBinding122=this.p_LetBinding();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_LetBinding122.getTree());


                    break;

                default :
                    break loop56;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_LetBinding_return: (function() {
        XQueryParser.p_LetBinding_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_LetBinding_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:623:1: p_LetBinding : ( (d= DOLLAR v= p_VarName ( p_TypeDeclaration )? ) | p_FTScoreVar ) BIND p_ExprSingle[true] ;
    // $ANTLR start "p_LetBinding"
    p_LetBinding: function() {
        var retval = new XQueryParser.p_LetBinding_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
        var BIND125 = null;
         var v = null;
         var p_TypeDeclaration123 = null;
         var p_FTScoreVar124 = null;
         var p_ExprSingle126 = null;

        var d_tree=null;
        var BIND125_tree=null;

        try {
            // xquery/XQueryParser.g:624:9: ( ( (d= DOLLAR v= p_VarName ( p_TypeDeclaration )? ) | p_FTScoreVar ) BIND p_ExprSingle[true] )
            // xquery/XQueryParser.g:624:11: ( (d= DOLLAR v= p_VarName ( p_TypeDeclaration )? ) | p_FTScoreVar ) BIND p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:624:11: ( (d= DOLLAR v= p_VarName ( p_TypeDeclaration )? ) | p_FTScoreVar )
            var alt58=2;
            var LA58_0 = this.input.LA(1);

            if ( (LA58_0==DOLLAR) ) {
                alt58=1;
            }
            else if ( (LA58_0==SCORE) ) {
                alt58=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 58, 0, this.input);

                throw nvae;
            }
            switch (alt58) {
                case 1 :
                    // xquery/XQueryParser.g:624:13: (d= DOLLAR v= p_VarName ( p_TypeDeclaration )? )
                    // xquery/XQueryParser.g:624:13: (d= DOLLAR v= p_VarName ( p_TypeDeclaration )? )
                    // xquery/XQueryParser.g:624:14: d= DOLLAR v= p_VarName ( p_TypeDeclaration )?
                    d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_LetBinding4057); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_LetBinding4061);
                    v=this.p_VarName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
                    if ( this.state.backtracking===0 ) {
                      this.av(d, (v?v.stop:null));
                    }
                    // xquery/XQueryParser.g:624:59: ( p_TypeDeclaration )?
                    var alt57=2;
                    var LA57_0 = this.input.LA(1);

                    if ( (LA57_0==AS) ) {
                        alt57=1;
                    }
                    switch (alt57) {
                        case 1 :
                            // xquery/XQueryParser.g:624:59: p_TypeDeclaration
                            this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_LetBinding4065);
                            p_TypeDeclaration123=this.p_TypeDeclaration();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration123.getTree());


                            break;

                    }






                    break;
                case 2 :
                    // xquery/XQueryParser.g:624:81: p_FTScoreVar
                    this.pushFollow(XQueryParser.FOLLOW_p_FTScoreVar_in_p_LetBinding4071);
                    p_FTScoreVar124=this.p_FTScoreVar();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTScoreVar124.getTree());


                    break;

            }

            BIND125=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_LetBinding4075); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            BIND125_tree = this.adaptor.create(BIND125);
            this.adaptor.addChild(root_0, BIND125_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_LetBinding4077);
            p_ExprSingle126=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle126.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_WindowClause_return: (function() {
        XQueryParser.p_WindowClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_WindowClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:628:1: p_WindowClause : k= FOR ( p_TumblingWindowClause | p_SlidingWindowClause ) ;
    // $ANTLR start "p_WindowClause"
    p_WindowClause: function() {
        var retval = new XQueryParser.p_WindowClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_TumblingWindowClause127 = null;
         var p_SlidingWindowClause128 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:629:9: (k= FOR ( p_TumblingWindowClause | p_SlidingWindowClause ) )
            // xquery/XQueryParser.g:629:11: k= FOR ( p_TumblingWindowClause | p_SlidingWindowClause )
            root_0 = this.adaptor.nil();

            k=this.match(this.input,FOR,XQueryParser.FOLLOW_FOR_in_p_WindowClause4106); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:629:32: ( p_TumblingWindowClause | p_SlidingWindowClause )
            var alt59=2;
            var LA59_0 = this.input.LA(1);

            if ( (LA59_0==TUMBLING) ) {
                alt59=1;
            }
            else if ( (LA59_0==SLIDING) ) {
                alt59=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 59, 0, this.input);

                throw nvae;
            }
            switch (alt59) {
                case 1 :
                    // xquery/XQueryParser.g:629:33: p_TumblingWindowClause
                    this.pushFollow(XQueryParser.FOLLOW_p_TumblingWindowClause_in_p_WindowClause4111);
                    p_TumblingWindowClause127=this.p_TumblingWindowClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TumblingWindowClause127.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:629:58: p_SlidingWindowClause
                    this.pushFollow(XQueryParser.FOLLOW_p_SlidingWindowClause_in_p_WindowClause4115);
                    p_SlidingWindowClause128=this.p_SlidingWindowClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SlidingWindowClause128.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TumblingWindowClause_return: (function() {
        XQueryParser.p_TumblingWindowClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TumblingWindowClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:633:1: p_TumblingWindowClause : k= TUMBLING k= WINDOW d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] p_WindowStartCondition ( p_WindowEndCondition )? ;
    // $ANTLR start "p_TumblingWindowClause"
    p_TumblingWindowClause: function() {
        var retval = new XQueryParser.p_TumblingWindowClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;
         var p_TypeDeclaration129 = null;
         var p_ExprSingle130 = null;
         var p_WindowStartCondition131 = null;
         var p_WindowEndCondition132 = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:634:9: (k= TUMBLING k= WINDOW d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] p_WindowStartCondition ( p_WindowEndCondition )? )
            // xquery/XQueryParser.g:634:11: k= TUMBLING k= WINDOW d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] p_WindowStartCondition ( p_WindowEndCondition )?
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TUMBLING,XQueryParser.FOLLOW_TUMBLING_in_p_TumblingWindowClause4152); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,WINDOW,XQueryParser.FOLLOW_WINDOW_in_p_TumblingWindowClause4158); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_TumblingWindowClause4164); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_TumblingWindowClause4168);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
              this.av(d, (v?v.stop:null));
            }
            // xquery/XQueryParser.g:634:106: ( p_TypeDeclaration )?
            var alt60=2;
            var LA60_0 = this.input.LA(1);

            if ( (LA60_0==AS) ) {
                alt60=1;
            }
            switch (alt60) {
                case 1 :
                    // xquery/XQueryParser.g:634:106: p_TypeDeclaration
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_TumblingWindowClause4172);
                    p_TypeDeclaration129=this.p_TypeDeclaration();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration129.getTree());


                    break;

            }

            k=this.match(this.input,IN,XQueryParser.FOLLOW_IN_in_p_TumblingWindowClause4177); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_TumblingWindowClause4181);
            p_ExprSingle130=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle130.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_WindowStartCondition_in_p_TumblingWindowClause4184);
            p_WindowStartCondition131=this.p_WindowStartCondition();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WindowStartCondition131.getTree());
            // xquery/XQueryParser.g:634:187: ( p_WindowEndCondition )?
            var alt61=2;
            var LA61_0 = this.input.LA(1);

            if ( (LA61_0==END||LA61_0==ONLY) ) {
                alt61=1;
            }
            switch (alt61) {
                case 1 :
                    // xquery/XQueryParser.g:634:187: p_WindowEndCondition
                    this.pushFollow(XQueryParser.FOLLOW_p_WindowEndCondition_in_p_TumblingWindowClause4186);
                    p_WindowEndCondition132=this.p_WindowEndCondition();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WindowEndCondition132.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SlidingWindowClause_return: (function() {
        XQueryParser.p_SlidingWindowClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SlidingWindowClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:638:1: p_SlidingWindowClause : k= SLIDING k= WINDOW d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] p_WindowStartCondition ( p_WindowEndCondition )? ;
    // $ANTLR start "p_SlidingWindowClause"
    p_SlidingWindowClause: function() {
        var retval = new XQueryParser.p_SlidingWindowClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;
         var p_TypeDeclaration133 = null;
         var p_ExprSingle134 = null;
         var p_WindowStartCondition135 = null;
         var p_WindowEndCondition136 = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:639:9: (k= SLIDING k= WINDOW d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] p_WindowStartCondition ( p_WindowEndCondition )? )
            // xquery/XQueryParser.g:639:11: k= SLIDING k= WINDOW d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] p_WindowStartCondition ( p_WindowEndCondition )?
            root_0 = this.adaptor.nil();

            k=this.match(this.input,SLIDING,XQueryParser.FOLLOW_SLIDING_in_p_SlidingWindowClause4215); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,WINDOW,XQueryParser.FOLLOW_WINDOW_in_p_SlidingWindowClause4221); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_SlidingWindowClause4227); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_SlidingWindowClause4231);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            // xquery/XQueryParser.g:639:107: ( p_TypeDeclaration )?
            var alt62=2;
            var LA62_0 = this.input.LA(1);

            if ( (LA62_0==AS) ) {
                alt62=1;
            }
            switch (alt62) {
                case 1 :
                    // xquery/XQueryParser.g:639:107: p_TypeDeclaration
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_SlidingWindowClause4235);
                    p_TypeDeclaration133=this.p_TypeDeclaration();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration133.getTree());


                    break;

            }

            k=this.match(this.input,IN,XQueryParser.FOLLOW_IN_in_p_SlidingWindowClause4240); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_SlidingWindowClause4244);
            p_ExprSingle134=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle134.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_WindowStartCondition_in_p_SlidingWindowClause4247);
            p_WindowStartCondition135=this.p_WindowStartCondition();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WindowStartCondition135.getTree());
            // xquery/XQueryParser.g:639:188: ( p_WindowEndCondition )?
            var alt63=2;
            var LA63_0 = this.input.LA(1);

            if ( (LA63_0==END||LA63_0==ONLY) ) {
                alt63=1;
            }
            switch (alt63) {
                case 1 :
                    // xquery/XQueryParser.g:639:188: p_WindowEndCondition
                    this.pushFollow(XQueryParser.FOLLOW_p_WindowEndCondition_in_p_SlidingWindowClause4249);
                    p_WindowEndCondition136=this.p_WindowEndCondition();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WindowEndCondition136.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_WindowStartCondition_return: (function() {
        XQueryParser.p_WindowStartCondition_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_WindowStartCondition_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:643:1: p_WindowStartCondition : k= START p_WindowVars k= WHEN p_ExprSingle[true] ;
    // $ANTLR start "p_WindowStartCondition"
    p_WindowStartCondition: function() {
        var retval = new XQueryParser.p_WindowStartCondition_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_WindowVars137 = null;
         var p_ExprSingle138 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:644:9: (k= START p_WindowVars k= WHEN p_ExprSingle[true] )
            // xquery/XQueryParser.g:644:11: k= START p_WindowVars k= WHEN p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,START,XQueryParser.FOLLOW_START_in_p_WindowStartCondition4278); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_WindowVars_in_p_WindowStartCondition4282);
            p_WindowVars137=this.p_WindowVars();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WindowVars137.getTree());
            k=this.match(this.input,WHEN,XQueryParser.FOLLOW_WHEN_in_p_WindowStartCondition4286); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_WindowStartCondition4290);
            p_ExprSingle138=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle138.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_WindowEndCondition_return: (function() {
        XQueryParser.p_WindowEndCondition_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_WindowEndCondition_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:648:1: p_WindowEndCondition : (k= ONLY )? k= END p_WindowVars k= WHEN p_ExprSingle[true] ;
    // $ANTLR start "p_WindowEndCondition"
    p_WindowEndCondition: function() {
        var retval = new XQueryParser.p_WindowEndCondition_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_WindowVars139 = null;
         var p_ExprSingle140 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:649:9: ( (k= ONLY )? k= END p_WindowVars k= WHEN p_ExprSingle[true] )
            // xquery/XQueryParser.g:649:11: (k= ONLY )? k= END p_WindowVars k= WHEN p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:649:11: (k= ONLY )?
            var alt64=2;
            var LA64_0 = this.input.LA(1);

            if ( (LA64_0==ONLY) ) {
                alt64=1;
            }
            switch (alt64) {
                case 1 :
                    // xquery/XQueryParser.g:649:12: k= ONLY
                    k=this.match(this.input,ONLY,XQueryParser.FOLLOW_ONLY_in_p_WindowEndCondition4320); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }


                    break;

            }

            k=this.match(this.input,END,XQueryParser.FOLLOW_END_in_p_WindowEndCondition4328); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_WindowVars_in_p_WindowEndCondition4332);
            p_WindowVars139=this.p_WindowVars();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WindowVars139.getTree());
            k=this.match(this.input,WHEN,XQueryParser.FOLLOW_WHEN_in_p_WindowEndCondition4336); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_WindowEndCondition4340);
            p_ExprSingle140=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle140.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_WindowVars_return: (function() {
        XQueryParser.p_WindowVars_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_WindowVars_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:653:1: p_WindowVars : (d= DOLLAR v= p_CurrentItem )? ( p_PositionalVar )? (k= PREVIOUS DOLLAR p_PreviousItem )? (k= NEXT DOLLAR p_NextItem )? ;
    // $ANTLR start "p_WindowVars"
    p_WindowVars: function() {
        var retval = new XQueryParser.p_WindowVars_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
        var k = null;
        var DOLLAR142 = null;
        var DOLLAR144 = null;
         var v = null;
         var p_PositionalVar141 = null;
         var p_PreviousItem143 = null;
         var p_NextItem145 = null;

        var d_tree=null;
        var k_tree=null;
        var DOLLAR142_tree=null;
        var DOLLAR144_tree=null;

        try {
            // xquery/XQueryParser.g:654:9: ( (d= DOLLAR v= p_CurrentItem )? ( p_PositionalVar )? (k= PREVIOUS DOLLAR p_PreviousItem )? (k= NEXT DOLLAR p_NextItem )? )
            // xquery/XQueryParser.g:654:11: (d= DOLLAR v= p_CurrentItem )? ( p_PositionalVar )? (k= PREVIOUS DOLLAR p_PreviousItem )? (k= NEXT DOLLAR p_NextItem )?
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:654:11: (d= DOLLAR v= p_CurrentItem )?
            var alt65=2;
            var LA65_0 = this.input.LA(1);

            if ( (LA65_0==DOLLAR) ) {
                alt65=1;
            }
            switch (alt65) {
                case 1 :
                    // xquery/XQueryParser.g:654:12: d= DOLLAR v= p_CurrentItem
                    d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_WindowVars4370); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_CurrentItem_in_p_WindowVars4374);
                    v=this.p_CurrentItem();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
                    if ( this.state.backtracking===0 ) {
                       this.av(d, (v?v.stop:null)); 
                    }


                    break;

            }

            // xquery/XQueryParser.g:654:65: ( p_PositionalVar )?
            var alt66=2;
            var LA66_0 = this.input.LA(1);

            if ( (LA66_0==AT) ) {
                alt66=1;
            }
            switch (alt66) {
                case 1 :
                    // xquery/XQueryParser.g:654:65: p_PositionalVar
                    this.pushFollow(XQueryParser.FOLLOW_p_PositionalVar_in_p_WindowVars4380);
                    p_PositionalVar141=this.p_PositionalVar();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PositionalVar141.getTree());


                    break;

            }

            // xquery/XQueryParser.g:654:82: (k= PREVIOUS DOLLAR p_PreviousItem )?
            var alt67=2;
            var LA67_0 = this.input.LA(1);

            if ( (LA67_0==PREVIOUS) ) {
                alt67=1;
            }
            switch (alt67) {
                case 1 :
                    // xquery/XQueryParser.g:654:83: k= PREVIOUS DOLLAR p_PreviousItem
                    k=this.match(this.input,PREVIOUS,XQueryParser.FOLLOW_PREVIOUS_in_p_WindowVars4386); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    DOLLAR142=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_WindowVars4390); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    DOLLAR142_tree = this.adaptor.create(DOLLAR142);
                    this.adaptor.addChild(root_0, DOLLAR142_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_PreviousItem_in_p_WindowVars4392);
                    p_PreviousItem143=this.p_PreviousItem();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PreviousItem143.getTree());


                    break;

            }

            // xquery/XQueryParser.g:654:133: (k= NEXT DOLLAR p_NextItem )?
            var alt68=2;
            var LA68_0 = this.input.LA(1);

            if ( (LA68_0==NEXT) ) {
                alt68=1;
            }
            switch (alt68) {
                case 1 :
                    // xquery/XQueryParser.g:654:134: k= NEXT DOLLAR p_NextItem
                    k=this.match(this.input,NEXT,XQueryParser.FOLLOW_NEXT_in_p_WindowVars4399); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    DOLLAR144=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_WindowVars4403); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    DOLLAR144_tree = this.adaptor.create(DOLLAR144);
                    this.adaptor.addChild(root_0, DOLLAR144_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_NextItem_in_p_WindowVars4405);
                    p_NextItem145=this.p_NextItem();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NextItem145.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CurrentItem_return: (function() {
        XQueryParser.p_CurrentItem_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CurrentItem_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:658:1: p_CurrentItem : p_QName ;
    // $ANTLR start "p_CurrentItem"
    p_CurrentItem: function() {
        var retval = new XQueryParser.p_CurrentItem_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName146 = null;


        try {
            // xquery/XQueryParser.g:659:9: ( p_QName )
            // xquery/XQueryParser.g:659:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_CurrentItem4433);
            p_QName146=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName146.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PreviousItem_return: (function() {
        XQueryParser.p_PreviousItem_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PreviousItem_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:663:1: p_PreviousItem : p_QName ;
    // $ANTLR start "p_PreviousItem"
    p_PreviousItem: function() {
        var retval = new XQueryParser.p_PreviousItem_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName147 = null;


        try {
            // xquery/XQueryParser.g:664:9: ( p_QName )
            // xquery/XQueryParser.g:664:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_PreviousItem4459);
            p_QName147=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName147.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NextItem_return: (function() {
        XQueryParser.p_NextItem_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NextItem_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:668:1: p_NextItem : p_QName ;
    // $ANTLR start "p_NextItem"
    p_NextItem: function() {
        var retval = new XQueryParser.p_NextItem_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName148 = null;


        try {
            // xquery/XQueryParser.g:669:9: ( p_QName )
            // xquery/XQueryParser.g:669:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_NextItem4485);
            p_QName148=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName148.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CountClause_return: (function() {
        XQueryParser.p_CountClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CountClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:673:1: p_CountClause : k= COUNT d= DOLLAR v= p_VarName ;
    // $ANTLR start "p_CountClause"
    p_CountClause: function() {
        var retval = new XQueryParser.p_CountClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:674:9: (k= COUNT d= DOLLAR v= p_VarName )
            // xquery/XQueryParser.g:674:11: k= COUNT d= DOLLAR v= p_VarName
            root_0 = this.adaptor.nil();

            k=this.match(this.input,COUNT,XQueryParser.FOLLOW_COUNT_in_p_CountClause4513); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_CountClause4519); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_CountClause4523);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_WhereClause_return: (function() {
        XQueryParser.p_WhereClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_WhereClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:678:1: p_WhereClause : k= WHERE p_ExprSingle[true] ;
    // $ANTLR start "p_WhereClause"
    p_WhereClause: function() {
        var retval = new XQueryParser.p_WhereClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_ExprSingle149 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:679:9: (k= WHERE p_ExprSingle[true] )
            // xquery/XQueryParser.g:679:11: k= WHERE p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,WHERE,XQueryParser.FOLLOW_WHERE_in_p_WhereClause4561); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_WhereClause4565);
            p_ExprSingle149=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle149.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_GroupByClause_return: (function() {
        XQueryParser.p_GroupByClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_GroupByClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:683:1: p_GroupByClause : k= GROUP k= BY p_GroupingSpecList ;
    // $ANTLR start "p_GroupByClause"
    p_GroupByClause: function() {
        var retval = new XQueryParser.p_GroupByClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_GroupingSpecList150 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:684:9: (k= GROUP k= BY p_GroupingSpecList )
            // xquery/XQueryParser.g:684:11: k= GROUP k= BY p_GroupingSpecList
            root_0 = this.adaptor.nil();

            k=this.match(this.input,GROUP,XQueryParser.FOLLOW_GROUP_in_p_GroupByClause4594); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,BY,XQueryParser.FOLLOW_BY_in_p_GroupByClause4600); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_GroupingSpecList_in_p_GroupByClause4604);
            p_GroupingSpecList150=this.p_GroupingSpecList();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_GroupingSpecList150.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_GroupingSpecList_return: (function() {
        XQueryParser.p_GroupingSpecList_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_GroupingSpecList_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:688:1: p_GroupingSpecList : p_GroupingSpec ( COMMA p_GroupingSpec )* ;
    // $ANTLR start "p_GroupingSpecList"
    p_GroupingSpecList: function() {
        var retval = new XQueryParser.p_GroupingSpecList_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var COMMA152 = null;
         var p_GroupingSpec151 = null;
         var p_GroupingSpec153 = null;

        var COMMA152_tree=null;

        try {
            // xquery/XQueryParser.g:689:9: ( p_GroupingSpec ( COMMA p_GroupingSpec )* )
            // xquery/XQueryParser.g:689:11: p_GroupingSpec ( COMMA p_GroupingSpec )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_GroupingSpec_in_p_GroupingSpecList4630);
            p_GroupingSpec151=this.p_GroupingSpec();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_GroupingSpec151.getTree());
            // xquery/XQueryParser.g:689:26: ( COMMA p_GroupingSpec )*
            loop69:
            do {
                var alt69=2;
                var LA69_0 = this.input.LA(1);

                if ( (LA69_0==COMMA) ) {
                    alt69=1;
                }


                switch (alt69) {
                case 1 :
                    // xquery/XQueryParser.g:689:27: COMMA p_GroupingSpec
                    COMMA152=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_GroupingSpecList4633); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA152_tree = this.adaptor.create(COMMA152);
                    this.adaptor.addChild(root_0, COMMA152_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_GroupingSpec_in_p_GroupingSpecList4635);
                    p_GroupingSpec153=this.p_GroupingSpec();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_GroupingSpec153.getTree());


                    break;

                default :
                    break loop69;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_GroupingSpec_return: (function() {
        XQueryParser.p_GroupingSpec_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_GroupingSpec_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:693:1: p_GroupingSpec : d= DOLLAR v= p_VarName (k= COLLATION p_StringLiteral )? ;
    // $ANTLR start "p_GroupingSpec"
    p_GroupingSpec: function() {
        var retval = new XQueryParser.p_GroupingSpec_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
        var k = null;
         var v = null;
         var p_StringLiteral154 = null;

        var d_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:694:9: (d= DOLLAR v= p_VarName (k= COLLATION p_StringLiteral )? )
            // xquery/XQueryParser.g:694:11: d= DOLLAR v= p_VarName (k= COLLATION p_StringLiteral )?
            root_0 = this.adaptor.nil();

            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_GroupingSpec4665); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_GroupingSpec4669);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            // xquery/XQueryParser.g:694:58: (k= COLLATION p_StringLiteral )?
            var alt70=2;
            var LA70_0 = this.input.LA(1);

            if ( (LA70_0==COLLATION) ) {
                alt70=1;
            }
            switch (alt70) {
                case 1 :
                    // xquery/XQueryParser.g:694:59: k= COLLATION p_StringLiteral
                    k=this.match(this.input,COLLATION,XQueryParser.FOLLOW_COLLATION_in_p_GroupingSpec4676); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_GroupingSpec4680);
                    p_StringLiteral154=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral154.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_OrderByClause_return: (function() {
        XQueryParser.p_OrderByClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_OrderByClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:698:1: p_OrderByClause : ( (k+= ORDER k+= BY ) | (k+= STABLE k+= ORDER k+= BY ) ) p_OrderSpecList ;
    // $ANTLR start "p_OrderByClause"
    p_OrderByClause: function() {
        var retval = new XQueryParser.p_OrderByClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_OrderSpecList155 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:699:9: ( ( (k+= ORDER k+= BY ) | (k+= STABLE k+= ORDER k+= BY ) ) p_OrderSpecList )
            // xquery/XQueryParser.g:699:11: ( (k+= ORDER k+= BY ) | (k+= STABLE k+= ORDER k+= BY ) ) p_OrderSpecList
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:699:11: ( (k+= ORDER k+= BY ) | (k+= STABLE k+= ORDER k+= BY ) )
            var alt71=2;
            var LA71_0 = this.input.LA(1);

            if ( (LA71_0==ORDER) ) {
                alt71=1;
            }
            else if ( (LA71_0==STABLE) ) {
                alt71=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 71, 0, this.input);

                throw nvae;
            }
            switch (alt71) {
                case 1 :
                    // xquery/XQueryParser.g:699:12: (k+= ORDER k+= BY )
                    // xquery/XQueryParser.g:699:12: (k+= ORDER k+= BY )
                    // xquery/XQueryParser.g:699:13: k+= ORDER k+= BY
                    k=this.match(this.input,ORDER,XQueryParser.FOLLOW_ORDER_in_p_OrderByClause4712); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,BY,XQueryParser.FOLLOW_BY_in_p_OrderByClause4716); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;
                case 2 :
                    // xquery/XQueryParser.g:699:31: (k+= STABLE k+= ORDER k+= BY )
                    // xquery/XQueryParser.g:699:31: (k+= STABLE k+= ORDER k+= BY )
                    // xquery/XQueryParser.g:699:32: k+= STABLE k+= ORDER k+= BY
                    k=this.match(this.input,STABLE,XQueryParser.FOLLOW_STABLE_in_p_OrderByClause4724); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,ORDER,XQueryParser.FOLLOW_ORDER_in_p_OrderByClause4728); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,BY,XQueryParser.FOLLOW_BY_in_p_OrderByClause4732); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_OrderSpecList_in_p_OrderByClause4738);
            p_OrderSpecList155=this.p_OrderSpecList();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OrderSpecList155.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_OrderSpecList_return: (function() {
        XQueryParser.p_OrderSpecList_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_OrderSpecList_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:703:1: p_OrderSpecList : p_OrderSpec ( COMMA p_OrderSpec )* ;
    // $ANTLR start "p_OrderSpecList"
    p_OrderSpecList: function() {
        var retval = new XQueryParser.p_OrderSpecList_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var COMMA157 = null;
         var p_OrderSpec156 = null;
         var p_OrderSpec158 = null;

        var COMMA157_tree=null;

        try {
            // xquery/XQueryParser.g:704:9: ( p_OrderSpec ( COMMA p_OrderSpec )* )
            // xquery/XQueryParser.g:704:11: p_OrderSpec ( COMMA p_OrderSpec )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_OrderSpec_in_p_OrderSpecList4764);
            p_OrderSpec156=this.p_OrderSpec();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OrderSpec156.getTree());
            // xquery/XQueryParser.g:704:23: ( COMMA p_OrderSpec )*
            loop72:
            do {
                var alt72=2;
                var LA72_0 = this.input.LA(1);

                if ( (LA72_0==COMMA) ) {
                    alt72=1;
                }


                switch (alt72) {
                case 1 :
                    // xquery/XQueryParser.g:704:24: COMMA p_OrderSpec
                    COMMA157=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_OrderSpecList4767); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA157_tree = this.adaptor.create(COMMA157);
                    this.adaptor.addChild(root_0, COMMA157_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_OrderSpec_in_p_OrderSpecList4769);
                    p_OrderSpec158=this.p_OrderSpec();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OrderSpec158.getTree());


                    break;

                default :
                    break loop72;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_OrderSpec_return: (function() {
        XQueryParser.p_OrderSpec_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_OrderSpec_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:708:1: p_OrderSpec : p_ExprSingle[true] p_OrderModifier ;
    // $ANTLR start "p_OrderSpec"
    p_OrderSpec: function() {
        var retval = new XQueryParser.p_OrderSpec_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle159 = null;
         var p_OrderModifier160 = null;


        try {
            // xquery/XQueryParser.g:709:9: ( p_ExprSingle[true] p_OrderModifier )
            // xquery/XQueryParser.g:709:11: p_ExprSingle[true] p_OrderModifier
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_OrderSpec4797);
            p_ExprSingle159=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle159.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_OrderModifier_in_p_OrderSpec4800);
            p_OrderModifier160=this.p_OrderModifier();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OrderModifier160.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_OrderModifier_return: (function() {
        XQueryParser.p_OrderModifier_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_OrderModifier_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:713:1: p_OrderModifier : (k+= ASCENDING | k+= DESCENDING )? (k+= EMPTY (k+= GREATEST | k+= LEAST ) )? (k+= COLLATION p_StringLiteral )? ;
    // $ANTLR start "p_OrderModifier"
    p_OrderModifier: function() {
        var retval = new XQueryParser.p_OrderModifier_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_StringLiteral161 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:714:9: ( (k+= ASCENDING | k+= DESCENDING )? (k+= EMPTY (k+= GREATEST | k+= LEAST ) )? (k+= COLLATION p_StringLiteral )? )
            // xquery/XQueryParser.g:714:11: (k+= ASCENDING | k+= DESCENDING )? (k+= EMPTY (k+= GREATEST | k+= LEAST ) )? (k+= COLLATION p_StringLiteral )?
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:714:11: (k+= ASCENDING | k+= DESCENDING )?
            var alt73=3;
            var LA73_0 = this.input.LA(1);

            if ( (LA73_0==ASCENDING) ) {
                alt73=1;
            }
            else if ( (LA73_0==DESCENDING) ) {
                alt73=2;
            }
            switch (alt73) {
                case 1 :
                    // xquery/XQueryParser.g:714:12: k+= ASCENDING
                    k=this.match(this.input,ASCENDING,XQueryParser.FOLLOW_ASCENDING_in_p_OrderModifier4829); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:714:27: k+= DESCENDING
                    k=this.match(this.input,DESCENDING,XQueryParser.FOLLOW_DESCENDING_in_p_OrderModifier4835); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            // xquery/XQueryParser.g:714:43: (k+= EMPTY (k+= GREATEST | k+= LEAST ) )?
            var alt75=2;
            var LA75_0 = this.input.LA(1);

            if ( (LA75_0==EMPTY) ) {
                alt75=1;
            }
            switch (alt75) {
                case 1 :
                    // xquery/XQueryParser.g:714:44: k+= EMPTY (k+= GREATEST | k+= LEAST )
                    k=this.match(this.input,EMPTY,XQueryParser.FOLLOW_EMPTY_in_p_OrderModifier4842); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    // xquery/XQueryParser.g:714:53: (k+= GREATEST | k+= LEAST )
                    var alt74=2;
                    var LA74_0 = this.input.LA(1);

                    if ( (LA74_0==GREATEST) ) {
                        alt74=1;
                    }
                    else if ( (LA74_0==LEAST) ) {
                        alt74=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 74, 0, this.input);

                        throw nvae;
                    }
                    switch (alt74) {
                        case 1 :
                            // xquery/XQueryParser.g:714:54: k+= GREATEST
                            k=this.match(this.input,GREATEST,XQueryParser.FOLLOW_GREATEST_in_p_OrderModifier4847); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }
                            if (org.antlr.lang.isNull(list_k)) list_k = [];
                            list_k.push(k);



                            break;
                        case 2 :
                            // xquery/XQueryParser.g:714:68: k+= LEAST
                            k=this.match(this.input,LEAST,XQueryParser.FOLLOW_LEAST_in_p_OrderModifier4853); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }
                            if (org.antlr.lang.isNull(list_k)) list_k = [];
                            list_k.push(k);



                            break;

                    }



                    break;

            }

            // xquery/XQueryParser.g:714:80: (k+= COLLATION p_StringLiteral )?
            var alt76=2;
            var LA76_0 = this.input.LA(1);

            if ( (LA76_0==COLLATION) ) {
                alt76=1;
            }
            switch (alt76) {
                case 1 :
                    // xquery/XQueryParser.g:714:81: k+= COLLATION p_StringLiteral
                    k=this.match(this.input,COLLATION,XQueryParser.FOLLOW_COLLATION_in_p_OrderModifier4861); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_OrderModifier4863);
                    p_StringLiteral161=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral161.getTree());


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ReturnHybrid_return: (function() {
        XQueryParser.p_ReturnHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ReturnHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:718:1: p_ReturnHybrid[strict] : k= RETURN p_Hybrid[$strict,false] ;
    // $ANTLR start "p_ReturnHybrid"
    p_ReturnHybrid: function(strict) {
        var retval = new XQueryParser.p_ReturnHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_Hybrid162 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:719:9: (k= RETURN p_Hybrid[$strict,false] )
            // xquery/XQueryParser.g:719:11: k= RETURN p_Hybrid[$strict,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_ReturnHybrid4896); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_ReturnHybrid4900);
            p_Hybrid162=this.p_Hybrid(strict, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid162.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_QuantifiedExpr_return: (function() {
        XQueryParser.p_QuantifiedExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_QuantifiedExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:723:1: p_QuantifiedExpr : (k= SOME | k= EVERY ) d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] ( COMMA e= DOLLAR w= p_QName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] )* k= SATISFIES p_ExprSingle[true] ;
    // $ANTLR start "p_QuantifiedExpr"
    p_QuantifiedExpr: function() {
        var retval = new XQueryParser.p_QuantifiedExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
        var e = null;
        var COMMA165 = null;
         var v = null;
         var w = null;
         var p_TypeDeclaration163 = null;
         var p_ExprSingle164 = null;
         var p_TypeDeclaration166 = null;
         var p_ExprSingle167 = null;
         var p_ExprSingle168 = null;

        var k_tree=null;
        var d_tree=null;
        var e_tree=null;
        var COMMA165_tree=null;

        try {
            // xquery/XQueryParser.g:724:9: ( (k= SOME | k= EVERY ) d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] ( COMMA e= DOLLAR w= p_QName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] )* k= SATISFIES p_ExprSingle[true] )
            // xquery/XQueryParser.g:724:11: (k= SOME | k= EVERY ) d= DOLLAR v= p_VarName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] ( COMMA e= DOLLAR w= p_QName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] )* k= SATISFIES p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:724:11: (k= SOME | k= EVERY )
            var alt77=2;
            var LA77_0 = this.input.LA(1);

            if ( (LA77_0==SOME) ) {
                alt77=1;
            }
            else if ( (LA77_0==EVERY) ) {
                alt77=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 77, 0, this.input);

                throw nvae;
            }
            switch (alt77) {
                case 1 :
                    // xquery/XQueryParser.g:724:12: k= SOME
                    k=this.match(this.input,SOME,XQueryParser.FOLLOW_SOME_in_p_QuantifiedExpr4930); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:724:21: k= EVERY
                    k=this.match(this.input,EVERY,XQueryParser.FOLLOW_EVERY_in_p_QuantifiedExpr4936); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_QuantifiedExpr4943); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_QuantifiedExpr4947);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            // xquery/XQueryParser.g:724:92: ( p_TypeDeclaration )?
            var alt78=2;
            var LA78_0 = this.input.LA(1);

            if ( (LA78_0==AS) ) {
                alt78=1;
            }
            switch (alt78) {
                case 1 :
                    // xquery/XQueryParser.g:724:92: p_TypeDeclaration
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_QuantifiedExpr4951);
                    p_TypeDeclaration163=this.p_TypeDeclaration();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration163.getTree());


                    break;

            }

            k=this.match(this.input,IN,XQueryParser.FOLLOW_IN_in_p_QuantifiedExpr4956); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_QuantifiedExpr4960);
            p_ExprSingle164=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle164.getTree());
            // xquery/XQueryParser.g:724:150: ( COMMA e= DOLLAR w= p_QName ( p_TypeDeclaration )? k= IN p_ExprSingle[true] )*
            loop80:
            do {
                var alt80=2;
                var LA80_0 = this.input.LA(1);

                if ( (LA80_0==COMMA) ) {
                    alt80=1;
                }


                switch (alt80) {
                case 1 :
                    // xquery/XQueryParser.g:724:151: COMMA e= DOLLAR w= p_QName ( p_TypeDeclaration )? k= IN p_ExprSingle[true]
                    COMMA165=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_QuantifiedExpr4964); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA165_tree = this.adaptor.create(COMMA165);
                    this.adaptor.addChild(root_0, COMMA165_tree);
                    }
                    e=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_QuantifiedExpr4968); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    e_tree = this.adaptor.create(e);
                    this.adaptor.addChild(root_0, e_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_QuantifiedExpr4972);
                    w=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, w.getTree());
                    if ( this.state.backtracking===0 ) {
                      this.av(e, (w?w.stop:null));
                    }
                    // xquery/XQueryParser.g:724:200: ( p_TypeDeclaration )?
                    var alt79=2;
                    var LA79_0 = this.input.LA(1);

                    if ( (LA79_0==AS) ) {
                        alt79=1;
                    }
                    switch (alt79) {
                        case 1 :
                            // xquery/XQueryParser.g:724:200: p_TypeDeclaration
                            this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_QuantifiedExpr4976);
                            p_TypeDeclaration166=this.p_TypeDeclaration();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration166.getTree());


                            break;

                    }

                    k=this.match(this.input,IN,XQueryParser.FOLLOW_IN_in_p_QuantifiedExpr4981); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_QuantifiedExpr4985);
                    p_ExprSingle167=this.p_ExprSingle(true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle167.getTree());


                    break;

                default :
                    break loop80;
                }
            } while (true);

            k=this.match(this.input,SATISFIES,XQueryParser.FOLLOW_SATISFIES_in_p_QuantifiedExpr4992); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_QuantifiedExpr4996);
            p_ExprSingle168=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle168.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SwitchHybrid_return: (function() {
        XQueryParser.p_SwitchHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SwitchHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:728:1: p_SwitchHybrid[strict] : k= SWITCH LPAREN p_Expr[true,true] RPAREN ( p_SwitchCaseHybrid[$strict] )+ k= DEFAULT k= RETURN p_Hybrid[$strict,false] ;
    // $ANTLR start "p_SwitchHybrid"
    p_SwitchHybrid: function(strict) {
        var retval = new XQueryParser.p_SwitchHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LPAREN169 = null;
        var RPAREN171 = null;
         var p_Expr170 = null;
         var p_SwitchCaseHybrid172 = null;
         var p_Hybrid173 = null;

        var k_tree=null;
        var LPAREN169_tree=null;
        var RPAREN171_tree=null;

        try {
            // xquery/XQueryParser.g:729:9: (k= SWITCH LPAREN p_Expr[true,true] RPAREN ( p_SwitchCaseHybrid[$strict] )+ k= DEFAULT k= RETURN p_Hybrid[$strict,false] )
            // xquery/XQueryParser.g:729:11: k= SWITCH LPAREN p_Expr[true,true] RPAREN ( p_SwitchCaseHybrid[$strict] )+ k= DEFAULT k= RETURN p_Hybrid[$strict,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,SWITCH,XQueryParser.FOLLOW_SWITCH_in_p_SwitchHybrid5026); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LPAREN169=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_SwitchHybrid5030); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN169_tree = this.adaptor.create(LPAREN169);
            this.adaptor.addChild(root_0, LPAREN169_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_SwitchHybrid5032);
            p_Expr170=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr170.getTree());
            RPAREN171=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_SwitchHybrid5035); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN171_tree = this.adaptor.create(RPAREN171);
            this.adaptor.addChild(root_0, RPAREN171_tree);
            }
            // xquery/XQueryParser.g:729:67: ( p_SwitchCaseHybrid[$strict] )+
            var cnt81=0;
            loop81:
            do {
                var alt81=2;
                var LA81_0 = this.input.LA(1);

                if ( (LA81_0==CASE) ) {
                    alt81=1;
                }


                switch (alt81) {
                case 1 :
                    // xquery/XQueryParser.g:729:67: p_SwitchCaseHybrid[$strict]
                    this.pushFollow(XQueryParser.FOLLOW_p_SwitchCaseHybrid_in_p_SwitchHybrid5037);
                    p_SwitchCaseHybrid172=this.p_SwitchCaseHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SwitchCaseHybrid172.getTree());


                    break;

                default :
                    if ( cnt81 >= 1 ) {
                        break loop81;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(81, this.input);
                        throw eee;
                }
                cnt81++;
            } while (true);

            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_SwitchHybrid5043); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_SwitchHybrid5049); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_SwitchHybrid5053);
            p_Hybrid173=this.p_Hybrid(strict, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid173.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SwitchCaseHybrid_return: (function() {
        XQueryParser.p_SwitchCaseHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SwitchCaseHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:733:1: p_SwitchCaseHybrid[strict] : (k= CASE p_SwitchCaseOperand )+ k= RETURN p_Hybrid[$strict,false] ;
    // $ANTLR start "p_SwitchCaseHybrid"
    p_SwitchCaseHybrid: function(strict) {
        var retval = new XQueryParser.p_SwitchCaseHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_SwitchCaseOperand174 = null;
         var p_Hybrid175 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:734:9: ( (k= CASE p_SwitchCaseOperand )+ k= RETURN p_Hybrid[$strict,false] )
            // xquery/XQueryParser.g:734:11: (k= CASE p_SwitchCaseOperand )+ k= RETURN p_Hybrid[$strict,false]
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:734:11: (k= CASE p_SwitchCaseOperand )+
            var cnt82=0;
            loop82:
            do {
                var alt82=2;
                var LA82_0 = this.input.LA(1);

                if ( (LA82_0==CASE) ) {
                    alt82=1;
                }


                switch (alt82) {
                case 1 :
                    // xquery/XQueryParser.g:734:12: k= CASE p_SwitchCaseOperand
                    k=this.match(this.input,CASE,XQueryParser.FOLLOW_CASE_in_p_SwitchCaseHybrid5084); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SwitchCaseOperand_in_p_SwitchCaseHybrid5088);
                    p_SwitchCaseOperand174=this.p_SwitchCaseOperand();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SwitchCaseOperand174.getTree());


                    break;

                default :
                    if ( cnt82 >= 1 ) {
                        break loop82;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(82, this.input);
                        throw eee;
                }
                cnt82++;
            } while (true);

            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_SwitchCaseHybrid5094); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_SwitchCaseHybrid5098);
            p_Hybrid175=this.p_Hybrid(strict, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid175.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SwitchCaseOperand_return: (function() {
        XQueryParser.p_SwitchCaseOperand_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SwitchCaseOperand_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:738:1: p_SwitchCaseOperand : p_ExprSingle[true] ;
    // $ANTLR start "p_SwitchCaseOperand"
    p_SwitchCaseOperand: function() {
        var retval = new XQueryParser.p_SwitchCaseOperand_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle176 = null;


        try {
            // xquery/XQueryParser.g:739:9: ( p_ExprSingle[true] )
            // xquery/XQueryParser.g:739:11: p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_SwitchCaseOperand5125);
            p_ExprSingle176=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle176.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TypeswitchHybrid_return: (function() {
        XQueryParser.p_TypeswitchHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TypeswitchHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:743:1: p_TypeswitchHybrid[strict] : k= TYPESWITCH LPAREN p_Expr[true,true] RPAREN ( p_CaseHybrid[$strict] )+ k= DEFAULT (d= DOLLAR v= p_VarName )? k= RETURN p_Hybrid[$strict,false] ;
    // $ANTLR start "p_TypeswitchHybrid"
    p_TypeswitchHybrid: function(strict) {
        var retval = new XQueryParser.p_TypeswitchHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
        var LPAREN177 = null;
        var RPAREN179 = null;
         var v = null;
         var p_Expr178 = null;
         var p_CaseHybrid180 = null;
         var p_Hybrid181 = null;

        var k_tree=null;
        var d_tree=null;
        var LPAREN177_tree=null;
        var RPAREN179_tree=null;

        try {
            // xquery/XQueryParser.g:744:9: (k= TYPESWITCH LPAREN p_Expr[true,true] RPAREN ( p_CaseHybrid[$strict] )+ k= DEFAULT (d= DOLLAR v= p_VarName )? k= RETURN p_Hybrid[$strict,false] )
            // xquery/XQueryParser.g:744:11: k= TYPESWITCH LPAREN p_Expr[true,true] RPAREN ( p_CaseHybrid[$strict] )+ k= DEFAULT (d= DOLLAR v= p_VarName )? k= RETURN p_Hybrid[$strict,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TYPESWITCH,XQueryParser.FOLLOW_TYPESWITCH_in_p_TypeswitchHybrid5155); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LPAREN177=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_TypeswitchHybrid5159); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN177_tree = this.adaptor.create(LPAREN177);
            this.adaptor.addChild(root_0, LPAREN177_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_TypeswitchHybrid5161);
            p_Expr178=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr178.getTree());
            RPAREN179=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_TypeswitchHybrid5164); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN179_tree = this.adaptor.create(RPAREN179);
            this.adaptor.addChild(root_0, RPAREN179_tree);
            }
            // xquery/XQueryParser.g:744:71: ( p_CaseHybrid[$strict] )+
            var cnt83=0;
            loop83:
            do {
                var alt83=2;
                var LA83_0 = this.input.LA(1);

                if ( (LA83_0==CASE) ) {
                    alt83=1;
                }


                switch (alt83) {
                case 1 :
                    // xquery/XQueryParser.g:744:71: p_CaseHybrid[$strict]
                    this.pushFollow(XQueryParser.FOLLOW_p_CaseHybrid_in_p_TypeswitchHybrid5166);
                    p_CaseHybrid180=this.p_CaseHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CaseHybrid180.getTree());


                    break;

                default :
                    if ( cnt83 >= 1 ) {
                        break loop83;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(83, this.input);
                        throw eee;
                }
                cnt83++;
            } while (true);

            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_TypeswitchHybrid5172); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:744:119: (d= DOLLAR v= p_VarName )?
            var alt84=2;
            var LA84_0 = this.input.LA(1);

            if ( (LA84_0==DOLLAR) ) {
                alt84=1;
            }
            switch (alt84) {
                case 1 :
                    // xquery/XQueryParser.g:744:120: d= DOLLAR v= p_VarName
                    d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_TypeswitchHybrid5179); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_TypeswitchHybrid5183);
                    v=this.p_VarName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
                    if ( this.state.backtracking===0 ) {
                       this.av(d, (v?v.stop:null)); 
                    }


                    break;

            }

            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_TypeswitchHybrid5191); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_TypeswitchHybrid5195);
            p_Hybrid181=this.p_Hybrid(strict, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid181.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CaseHybrid_return: (function() {
        XQueryParser.p_CaseHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CaseHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:748:1: p_CaseHybrid[strict] : k= CASE (d= DOLLAR v= p_VarName k= AS )? p_SequenceTypeUnion k= RETURN p_ExprSingle[false] ;
    // $ANTLR start "p_CaseHybrid"
    p_CaseHybrid: function(strict) {
        var retval = new XQueryParser.p_CaseHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;
         var p_SequenceTypeUnion182 = null;
         var p_ExprSingle183 = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:749:9: (k= CASE (d= DOLLAR v= p_VarName k= AS )? p_SequenceTypeUnion k= RETURN p_ExprSingle[false] )
            // xquery/XQueryParser.g:749:11: k= CASE (d= DOLLAR v= p_VarName k= AS )? p_SequenceTypeUnion k= RETURN p_ExprSingle[false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,CASE,XQueryParser.FOLLOW_CASE_in_p_CaseHybrid5225); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:749:33: (d= DOLLAR v= p_VarName k= AS )?
            var alt85=2;
            var LA85_0 = this.input.LA(1);

            if ( (LA85_0==DOLLAR) ) {
                alt85=1;
            }
            switch (alt85) {
                case 1 :
                    // xquery/XQueryParser.g:749:34: d= DOLLAR v= p_VarName k= AS
                    d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_CaseHybrid5232); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_CaseHybrid5236);
                    v=this.p_VarName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
                    if ( this.state.backtracking===0 ) {
                       this.av(d, (v?v.stop:null)); 
                    }
                    k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_CaseHybrid5242); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }


                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_SequenceTypeUnion_in_p_CaseHybrid5248);
            p_SequenceTypeUnion182=this.p_SequenceTypeUnion();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceTypeUnion182.getTree());
            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_CaseHybrid5252); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_CaseHybrid5256);
            p_ExprSingle183=this.p_ExprSingle(false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle183.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SequenceTypeUnion_return: (function() {
        XQueryParser.p_SequenceTypeUnion_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SequenceTypeUnion_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:753:1: p_SequenceTypeUnion : p_SequenceType ( VBAR p_SequenceType )* ;
    // $ANTLR start "p_SequenceTypeUnion"
    p_SequenceTypeUnion: function() {
        var retval = new XQueryParser.p_SequenceTypeUnion_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var VBAR185 = null;
         var p_SequenceType184 = null;
         var p_SequenceType186 = null;

        var VBAR185_tree=null;

        try {
            // xquery/XQueryParser.g:754:9: ( p_SequenceType ( VBAR p_SequenceType )* )
            // xquery/XQueryParser.g:754:11: p_SequenceType ( VBAR p_SequenceType )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_SequenceTypeUnion5283);
            p_SequenceType184=this.p_SequenceType();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType184.getTree());
            // xquery/XQueryParser.g:754:26: ( VBAR p_SequenceType )*
            loop86:
            do {
                var alt86=2;
                var LA86_0 = this.input.LA(1);

                if ( (LA86_0==VBAR) ) {
                    alt86=1;
                }


                switch (alt86) {
                case 1 :
                    // xquery/XQueryParser.g:754:27: VBAR p_SequenceType
                    VBAR185=this.match(this.input,VBAR,XQueryParser.FOLLOW_VBAR_in_p_SequenceTypeUnion5286); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    VBAR185_tree = this.adaptor.create(VBAR185);
                    this.adaptor.addChild(root_0, VBAR185_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_SequenceTypeUnion5288);
                    p_SequenceType186=this.p_SequenceType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType186.getTree());


                    break;

                default :
                    break loop86;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IfHybrid_return: (function() {
        XQueryParser.p_IfHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IfHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:758:1: p_IfHybrid[strict] : k= IF LPAREN p_Expr[true,true] RPAREN k= THEN p_Hybrid[$strict,false] k= ELSE p_Hybrid[$strict,false] ;
    // $ANTLR start "p_IfHybrid"
    p_IfHybrid: function(strict) {
        var retval = new XQueryParser.p_IfHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LPAREN187 = null;
        var RPAREN189 = null;
         var p_Expr188 = null;
         var p_Hybrid190 = null;
         var p_Hybrid191 = null;

        var k_tree=null;
        var LPAREN187_tree=null;
        var RPAREN189_tree=null;

        try {
            // xquery/XQueryParser.g:759:9: (k= IF LPAREN p_Expr[true,true] RPAREN k= THEN p_Hybrid[$strict,false] k= ELSE p_Hybrid[$strict,false] )
            // xquery/XQueryParser.g:759:11: k= IF LPAREN p_Expr[true,true] RPAREN k= THEN p_Hybrid[$strict,false] k= ELSE p_Hybrid[$strict,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,IF,XQueryParser.FOLLOW_IF_in_p_IfHybrid5319); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LPAREN187=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_IfHybrid5323); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN187_tree = this.adaptor.create(LPAREN187);
            this.adaptor.addChild(root_0, LPAREN187_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_IfHybrid5325);
            p_Expr188=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr188.getTree());
            RPAREN189=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_IfHybrid5328); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN189_tree = this.adaptor.create(RPAREN189);
            this.adaptor.addChild(root_0, RPAREN189_tree);
            }
            k=this.match(this.input,THEN,XQueryParser.FOLLOW_THEN_in_p_IfHybrid5332); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_IfHybrid5336);
            p_Hybrid190=this.p_Hybrid(strict, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid190.getTree());
            k=this.match(this.input,ELSE,XQueryParser.FOLLOW_ELSE_in_p_IfHybrid5341); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_IfHybrid5345);
            p_Hybrid191=this.p_Hybrid(strict, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid191.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TryCatchExpr_return: (function() {
        XQueryParser.p_TryCatchExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TryCatchExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:763:1: p_TryCatchExpr : p_TryClause ( p_CatchClause )+ ;
    // $ANTLR start "p_TryCatchExpr"
    p_TryCatchExpr: function() {
        var retval = new XQueryParser.p_TryCatchExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_TryClause192 = null;
         var p_CatchClause193 = null;


        try {
            // xquery/XQueryParser.g:764:9: ( p_TryClause ( p_CatchClause )+ )
            // xquery/XQueryParser.g:764:11: p_TryClause ( p_CatchClause )+
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_TryClause_in_p_TryCatchExpr5372);
            p_TryClause192=this.p_TryClause();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TryClause192.getTree());
            // xquery/XQueryParser.g:764:23: ( p_CatchClause )+
            var cnt87=0;
            loop87:
            do {
                var alt87=2;
                var LA87_0 = this.input.LA(1);

                if ( (LA87_0==CATCH) ) {
                    alt87=1;
                }


                switch (alt87) {
                case 1 :
                    // xquery/XQueryParser.g:764:23: p_CatchClause
                    this.pushFollow(XQueryParser.FOLLOW_p_CatchClause_in_p_TryCatchExpr5374);
                    p_CatchClause193=this.p_CatchClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CatchClause193.getTree());


                    break;

                default :
                    if ( cnt87 >= 1 ) {
                        break loop87;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(87, this.input);
                        throw eee;
                }
                cnt87++;
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TryClause_return: (function() {
        XQueryParser.p_TryClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TryClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:768:1: p_TryClause : k= TRY LBRACKET p_TryTargetExpr RBRACKET ;
    // $ANTLR start "p_TryClause"
    p_TryClause: function() {
        var retval = new XQueryParser.p_TryClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET194 = null;
        var RBRACKET196 = null;
         var p_TryTargetExpr195 = null;

        var k_tree=null;
        var LBRACKET194_tree=null;
        var RBRACKET196_tree=null;

        try {
            // xquery/XQueryParser.g:769:9: (k= TRY LBRACKET p_TryTargetExpr RBRACKET )
            // xquery/XQueryParser.g:769:11: k= TRY LBRACKET p_TryTargetExpr RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TRY,XQueryParser.FOLLOW_TRY_in_p_TryClause5403); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LBRACKET194=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_TryClause5407); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET194_tree = this.adaptor.create(LBRACKET194);
            this.adaptor.addChild(root_0, LBRACKET194_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_TryTargetExpr_in_p_TryClause5409);
            p_TryTargetExpr195=this.p_TryTargetExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TryTargetExpr195.getTree());
            RBRACKET196=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_TryClause5411); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET196_tree = this.adaptor.create(RBRACKET196);
            this.adaptor.addChild(root_0, RBRACKET196_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TryTargetExpr_return: (function() {
        XQueryParser.p_TryTargetExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TryTargetExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:773:1: p_TryTargetExpr : p_Expr[false,false] ;
    // $ANTLR start "p_TryTargetExpr"
    p_TryTargetExpr: function() {
        var retval = new XQueryParser.p_TryTargetExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Expr197 = null;


        try {
            // xquery/XQueryParser.g:774:9: ( p_Expr[false,false] )
            // xquery/XQueryParser.g:774:11: p_Expr[false,false]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_TryTargetExpr5437);
            p_Expr197=this.p_Expr(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr197.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CatchClause_return: (function() {
        XQueryParser.p_CatchClause_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CatchClause_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:778:1: p_CatchClause : k= CATCH p_CatchErrorList LBRACKET p_Expr[false,false] RBRACKET ;
    // $ANTLR start "p_CatchClause"
    p_CatchClause: function() {
        var retval = new XQueryParser.p_CatchClause_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET199 = null;
        var RBRACKET201 = null;
         var p_CatchErrorList198 = null;
         var p_Expr200 = null;

        var k_tree=null;
        var LBRACKET199_tree=null;
        var RBRACKET201_tree=null;

        try {
            // xquery/XQueryParser.g:779:9: (k= CATCH p_CatchErrorList LBRACKET p_Expr[false,false] RBRACKET )
            // xquery/XQueryParser.g:779:11: k= CATCH p_CatchErrorList LBRACKET p_Expr[false,false] RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,CATCH,XQueryParser.FOLLOW_CATCH_in_p_CatchClause5466); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_CatchErrorList_in_p_CatchClause5470);
            p_CatchErrorList198=this.p_CatchErrorList();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CatchErrorList198.getTree());
            LBRACKET199=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_CatchClause5472); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET199_tree = this.adaptor.create(LBRACKET199);
            this.adaptor.addChild(root_0, LBRACKET199_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_CatchClause5474);
            p_Expr200=this.p_Expr(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr200.getTree());
            RBRACKET201=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_CatchClause5477); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET201_tree = this.adaptor.create(RBRACKET201);
            this.adaptor.addChild(root_0, RBRACKET201_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CatchErrorList_return: (function() {
        XQueryParser.p_CatchErrorList_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CatchErrorList_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:783:1: p_CatchErrorList : ( p_NameTest ( VBAR p_NameTest )* | {...}? => () );
    // $ANTLR start "p_CatchErrorList"
    p_CatchErrorList: function() {
        var retval = new XQueryParser.p_CatchErrorList_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var VBAR203 = null;
         var p_NameTest202 = null;
         var p_NameTest204 = null;

        var VBAR203_tree=null;

        try {
            // xquery/XQueryParser.g:784:9: ( p_NameTest ( VBAR p_NameTest )* | {...}? => () )
            var alt89=2;
            var LA89_0 = this.input.LA(1);

            if ( ((LA89_0>=ANCESTOR && LA89_0<=SKIP)||(LA89_0>=VALUE && LA89_0<=QUOT_ER)||LA89_0==STAR||(LA89_0>=APOS && LA89_0<=QUOT)||LA89_0==L_NCName||LA89_0==EXPLICITLY) ) {
                alt89=1;
            }
            else if ( (LA89_0==LBRACKET) && ((this.lc(MLS)))) {
                alt89=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 89, 0, this.input);

                throw nvae;
            }
            switch (alt89) {
                case 1 :
                    // xquery/XQueryParser.g:784:11: p_NameTest ( VBAR p_NameTest )*
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_NameTest_in_p_CatchErrorList5503);
                    p_NameTest202=this.p_NameTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NameTest202.getTree());
                    // xquery/XQueryParser.g:784:22: ( VBAR p_NameTest )*
                    loop88:
                    do {
                        var alt88=2;
                        var LA88_0 = this.input.LA(1);

                        if ( (LA88_0==VBAR) ) {
                            alt88=1;
                        }


                        switch (alt88) {
                        case 1 :
                            // xquery/XQueryParser.g:784:23: VBAR p_NameTest
                            VBAR203=this.match(this.input,VBAR,XQueryParser.FOLLOW_VBAR_in_p_CatchErrorList5506); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            VBAR203_tree = this.adaptor.create(VBAR203);
                            this.adaptor.addChild(root_0, VBAR203_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_NameTest_in_p_CatchErrorList5508);
                            p_NameTest204=this.p_NameTest();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NameTest204.getTree());


                            break;

                        default :
                            break loop88;
                        }
                    } while (true);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:785:11: {...}? => ()
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(MLS))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "p_CatchErrorList", "this.lc(MLS)");
                    }
                    // xquery/XQueryParser.g:785:29: ()
                    // xquery/XQueryParser.g:785:43: 




                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_OrExpr_return: (function() {
        XQueryParser.p_OrExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_OrExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:789:1: p_OrExpr : p_AndExpr (k= OR p_AndExpr )* ;
    // $ANTLR start "p_OrExpr"
    p_OrExpr: function() {
        var retval = new XQueryParser.p_OrExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_AndExpr205 = null;
         var p_AndExpr206 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:790:9: ( p_AndExpr (k= OR p_AndExpr )* )
            // xquery/XQueryParser.g:790:11: p_AndExpr (k= OR p_AndExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_AndExpr_in_p_OrExpr5553);
            p_AndExpr205=this.p_AndExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AndExpr205.getTree());
            // xquery/XQueryParser.g:790:21: (k= OR p_AndExpr )*
            loop90:
            do {
                var alt90=2;
                var LA90_0 = this.input.LA(1);

                if ( (LA90_0==OR) ) {
                    alt90=1;
                }


                switch (alt90) {
                case 1 :
                    // xquery/XQueryParser.g:790:23: k= OR p_AndExpr
                    k=this.match(this.input,OR,XQueryParser.FOLLOW_OR_in_p_OrExpr5559); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_AndExpr_in_p_OrExpr5563);
                    p_AndExpr206=this.p_AndExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AndExpr206.getTree());


                    break;

                default :
                    break loop90;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AndExpr_return: (function() {
        XQueryParser.p_AndExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AndExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:794:1: p_AndExpr : p_ComparisonExpr (k= AND p_ComparisonExpr )* ;
    // $ANTLR start "p_AndExpr"
    p_AndExpr: function() {
        var retval = new XQueryParser.p_AndExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_ComparisonExpr207 = null;
         var p_ComparisonExpr208 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:795:9: ( p_ComparisonExpr (k= AND p_ComparisonExpr )* )
            // xquery/XQueryParser.g:795:11: p_ComparisonExpr (k= AND p_ComparisonExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ComparisonExpr_in_p_AndExpr5592);
            p_ComparisonExpr207=this.p_ComparisonExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ComparisonExpr207.getTree());
            // xquery/XQueryParser.g:795:28: (k= AND p_ComparisonExpr )*
            loop91:
            do {
                var alt91=2;
                var LA91_0 = this.input.LA(1);

                if ( (LA91_0==AND) ) {
                    alt91=1;
                }


                switch (alt91) {
                case 1 :
                    // xquery/XQueryParser.g:795:30: k= AND p_ComparisonExpr
                    k=this.match(this.input,AND,XQueryParser.FOLLOW_AND_in_p_AndExpr5598); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ComparisonExpr_in_p_AndExpr5602);
                    p_ComparisonExpr208=this.p_ComparisonExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ComparisonExpr208.getTree());


                    break;

                default :
                    break loop91;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ComparisonExpr_return: (function() {
        XQueryParser.p_ComparisonExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ComparisonExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:800:1: p_ComparisonExpr : p_FTContainsExpr ( ( p_ValueComp | p_GeneralComp | p_NodeComp ) p_FTContainsExpr )? ;
    // $ANTLR start "p_ComparisonExpr"
    p_ComparisonExpr: function() {
        var retval = new XQueryParser.p_ComparisonExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_FTContainsExpr209 = null;
         var p_ValueComp210 = null;
         var p_GeneralComp211 = null;
         var p_NodeComp212 = null;
         var p_FTContainsExpr213 = null;


        try {
            // xquery/XQueryParser.g:801:9: ( p_FTContainsExpr ( ( p_ValueComp | p_GeneralComp | p_NodeComp ) p_FTContainsExpr )? )
            // xquery/XQueryParser.g:801:11: p_FTContainsExpr ( ( p_ValueComp | p_GeneralComp | p_NodeComp ) p_FTContainsExpr )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_FTContainsExpr_in_p_ComparisonExpr5632);
            p_FTContainsExpr209=this.p_FTContainsExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTContainsExpr209.getTree());
            // xquery/XQueryParser.g:801:28: ( ( p_ValueComp | p_GeneralComp | p_NodeComp ) p_FTContainsExpr )?
            var alt93=2;
            var LA93_0 = this.input.LA(1);

            if ( (LA93_0==EQ||LA93_0==GE||LA93_0==GT||LA93_0==IS||LA93_0==LE||LA93_0==LT||LA93_0==NE||LA93_0==EQUAL||LA93_0==NOTEQUAL||(LA93_0>=SMALLER && LA93_0<=GREATER_GREATER)) ) {
                alt93=1;
            }
            switch (alt93) {
                case 1 :
                    // xquery/XQueryParser.g:801:30: ( p_ValueComp | p_GeneralComp | p_NodeComp ) p_FTContainsExpr
                    // xquery/XQueryParser.g:801:30: ( p_ValueComp | p_GeneralComp | p_NodeComp )
                    var alt92=3;
                    switch ( this.input.LA(1) ) {
                    case EQ:
                    case GE:
                    case GT:
                    case LE:
                    case LT:
                    case NE:
                        alt92=1;
                        break;
                    case EQUAL:
                    case NOTEQUAL:
                    case SMALLER:
                    case GREATER:
                    case SMALLEREQ:
                    case GREATEREQ:
                        alt92=2;
                        break;
                    case IS:
                    case SMALLER_SMALLER:
                    case GREATER_GREATER:
                        alt92=3;
                        break;
                    default:
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 92, 0, this.input);

                        throw nvae;
                    }

                    switch (alt92) {
                        case 1 :
                            // xquery/XQueryParser.g:801:31: p_ValueComp
                            this.pushFollow(XQueryParser.FOLLOW_p_ValueComp_in_p_ComparisonExpr5637);
                            p_ValueComp210=this.p_ValueComp();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ValueComp210.getTree());


                            break;
                        case 2 :
                            // xquery/XQueryParser.g:801:45: p_GeneralComp
                            this.pushFollow(XQueryParser.FOLLOW_p_GeneralComp_in_p_ComparisonExpr5641);
                            p_GeneralComp211=this.p_GeneralComp();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_GeneralComp211.getTree());


                            break;
                        case 3 :
                            // xquery/XQueryParser.g:801:61: p_NodeComp
                            this.pushFollow(XQueryParser.FOLLOW_p_NodeComp_in_p_ComparisonExpr5645);
                            p_NodeComp212=this.p_NodeComp();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NodeComp212.getTree());


                            break;

                    }

                    this.pushFollow(XQueryParser.FOLLOW_p_FTContainsExpr_in_p_ComparisonExpr5648);
                    p_FTContainsExpr213=this.p_FTContainsExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTContainsExpr213.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_RangeExpr_return: (function() {
        XQueryParser.p_RangeExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_RangeExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:805:1: p_RangeExpr : p_AdditiveExpr (k= TO p_AdditiveExpr )? ;
    // $ANTLR start "p_RangeExpr"
    p_RangeExpr: function() {
        var retval = new XQueryParser.p_RangeExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_AdditiveExpr214 = null;
         var p_AdditiveExpr215 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:806:9: ( p_AdditiveExpr (k= TO p_AdditiveExpr )? )
            // xquery/XQueryParser.g:806:11: p_AdditiveExpr (k= TO p_AdditiveExpr )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_RangeExpr5677);
            p_AdditiveExpr214=this.p_AdditiveExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr214.getTree());
            // xquery/XQueryParser.g:806:26: (k= TO p_AdditiveExpr )?
            var alt94=2;
            var LA94_0 = this.input.LA(1);

            if ( (LA94_0==TO) ) {
                alt94=1;
            }
            switch (alt94) {
                case 1 :
                    // xquery/XQueryParser.g:806:28: k= TO p_AdditiveExpr
                    k=this.match(this.input,TO,XQueryParser.FOLLOW_TO_in_p_RangeExpr5683); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_RangeExpr5687);
                    p_AdditiveExpr215=this.p_AdditiveExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr215.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AdditiveExpr_return: (function() {
        XQueryParser.p_AdditiveExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AdditiveExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:810:1: p_AdditiveExpr : p_MultiplicativeExpr ( (o= PLUS | o= MINUS ) p_MultiplicativeExpr )* ;
    // $ANTLR start "p_AdditiveExpr"
    p_AdditiveExpr: function() {
        var retval = new XQueryParser.p_AdditiveExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var o = null;
         var p_MultiplicativeExpr216 = null;
         var p_MultiplicativeExpr217 = null;

        var o_tree=null;

        try {
            // xquery/XQueryParser.g:811:9: ( p_MultiplicativeExpr ( (o= PLUS | o= MINUS ) p_MultiplicativeExpr )* )
            // xquery/XQueryParser.g:811:11: p_MultiplicativeExpr ( (o= PLUS | o= MINUS ) p_MultiplicativeExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_MultiplicativeExpr_in_p_AdditiveExpr5716);
            p_MultiplicativeExpr216=this.p_MultiplicativeExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_MultiplicativeExpr216.getTree());
            // xquery/XQueryParser.g:811:32: ( (o= PLUS | o= MINUS ) p_MultiplicativeExpr )*
            loop96:
            do {
                var alt96=2;
                var LA96_0 = this.input.LA(1);

                if ( ((LA96_0>=PLUS && LA96_0<=MINUS)) ) {
                    alt96=1;
                }


                switch (alt96) {
                case 1 :
                    // xquery/XQueryParser.g:811:34: (o= PLUS | o= MINUS ) p_MultiplicativeExpr
                    // xquery/XQueryParser.g:811:34: (o= PLUS | o= MINUS )
                    var alt95=2;
                    var LA95_0 = this.input.LA(1);

                    if ( (LA95_0==PLUS) ) {
                        alt95=1;
                    }
                    else if ( (LA95_0==MINUS) ) {
                        alt95=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 95, 0, this.input);

                        throw nvae;
                    }
                    switch (alt95) {
                        case 1 :
                            // xquery/XQueryParser.g:811:35: o= PLUS
                            o=this.match(this.input,PLUS,XQueryParser.FOLLOW_PLUS_in_p_AdditiveExpr5723); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            o_tree = this.adaptor.create(o);
                            this.adaptor.addChild(root_0, o_tree);
                            }
                            if ( this.state.backtracking===0 ) {
                              this.ao(o);
                            }


                            break;
                        case 2 :
                            // xquery/XQueryParser.g:811:59: o= MINUS
                            o=this.match(this.input,MINUS,XQueryParser.FOLLOW_MINUS_in_p_AdditiveExpr5731); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            o_tree = this.adaptor.create(o);
                            this.adaptor.addChild(root_0, o_tree);
                            }
                            if ( this.state.backtracking===0 ) {
                              this.ao(o);
                            }


                            break;

                    }

                    this.pushFollow(XQueryParser.FOLLOW_p_MultiplicativeExpr_in_p_AdditiveExpr5736);
                    p_MultiplicativeExpr217=this.p_MultiplicativeExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_MultiplicativeExpr217.getTree());


                    break;

                default :
                    break loop96;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_MultiplicativeExpr_return: (function() {
        XQueryParser.p_MultiplicativeExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_MultiplicativeExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:815:1: p_MultiplicativeExpr : p_UnionExpr ( (o= STAR | (k= DIV | k= IDIV | k= MOD ) ) p_UnionExpr )* ;
    // $ANTLR start "p_MultiplicativeExpr"
    p_MultiplicativeExpr: function() {
        var retval = new XQueryParser.p_MultiplicativeExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var o = null;
        var k = null;
         var p_UnionExpr218 = null;
         var p_UnionExpr219 = null;

        var o_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:816:9: ( p_UnionExpr ( (o= STAR | (k= DIV | k= IDIV | k= MOD ) ) p_UnionExpr )* )
            // xquery/XQueryParser.g:816:11: p_UnionExpr ( (o= STAR | (k= DIV | k= IDIV | k= MOD ) ) p_UnionExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_UnionExpr_in_p_MultiplicativeExpr5765);
            p_UnionExpr218=this.p_UnionExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_UnionExpr218.getTree());
            // xquery/XQueryParser.g:816:23: ( (o= STAR | (k= DIV | k= IDIV | k= MOD ) ) p_UnionExpr )*
            loop99:
            do {
                var alt99=2;
                var LA99_0 = this.input.LA(1);

                if ( (LA99_0==DIV||LA99_0==IDIV||LA99_0==MOD||LA99_0==STAR) ) {
                    alt99=1;
                }


                switch (alt99) {
                case 1 :
                    // xquery/XQueryParser.g:816:25: (o= STAR | (k= DIV | k= IDIV | k= MOD ) ) p_UnionExpr
                    // xquery/XQueryParser.g:816:25: (o= STAR | (k= DIV | k= IDIV | k= MOD ) )
                    var alt98=2;
                    var LA98_0 = this.input.LA(1);

                    if ( (LA98_0==STAR) ) {
                        alt98=1;
                    }
                    else if ( (LA98_0==DIV||LA98_0==IDIV||LA98_0==MOD) ) {
                        alt98=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 98, 0, this.input);

                        throw nvae;
                    }
                    switch (alt98) {
                        case 1 :
                            // xquery/XQueryParser.g:816:26: o= STAR
                            o=this.match(this.input,STAR,XQueryParser.FOLLOW_STAR_in_p_MultiplicativeExpr5772); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            o_tree = this.adaptor.create(o);
                            this.adaptor.addChild(root_0, o_tree);
                            }
                            if ( this.state.backtracking===0 ) {
                              this.ao(o);
                            }


                            break;
                        case 2 :
                            // xquery/XQueryParser.g:816:50: (k= DIV | k= IDIV | k= MOD )
                            // xquery/XQueryParser.g:816:50: (k= DIV | k= IDIV | k= MOD )
                            var alt97=3;
                            switch ( this.input.LA(1) ) {
                            case DIV:
                                alt97=1;
                                break;
                            case IDIV:
                                alt97=2;
                                break;
                            case MOD:
                                alt97=3;
                                break;
                            default:
                                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var nvae =
                                    new org.antlr.runtime.NoViableAltException("", 97, 0, this.input);

                                throw nvae;
                            }

                            switch (alt97) {
                                case 1 :
                                    // xquery/XQueryParser.g:816:51: k= DIV
                                    k=this.match(this.input,DIV,XQueryParser.FOLLOW_DIV_in_p_MultiplicativeExpr5781); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    k_tree = this.adaptor.create(k);
                                    this.adaptor.addChild(root_0, k_tree);
                                    }


                                    break;
                                case 2 :
                                    // xquery/XQueryParser.g:816:59: k= IDIV
                                    k=this.match(this.input,IDIV,XQueryParser.FOLLOW_IDIV_in_p_MultiplicativeExpr5787); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    k_tree = this.adaptor.create(k);
                                    this.adaptor.addChild(root_0, k_tree);
                                    }


                                    break;
                                case 3 :
                                    // xquery/XQueryParser.g:816:68: k= MOD
                                    k=this.match(this.input,MOD,XQueryParser.FOLLOW_MOD_in_p_MultiplicativeExpr5793); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    k_tree = this.adaptor.create(k);
                                    this.adaptor.addChild(root_0, k_tree);
                                    }


                                    break;

                            }

                            if ( this.state.backtracking===0 ) {
                              this.ak(k);
                            }


                            break;

                    }

                    this.pushFollow(XQueryParser.FOLLOW_p_UnionExpr_in_p_MultiplicativeExpr5799);
                    p_UnionExpr219=this.p_UnionExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_UnionExpr219.getTree());


                    break;

                default :
                    break loop99;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_UnionExpr_return: (function() {
        XQueryParser.p_UnionExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_UnionExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:820:1: p_UnionExpr : p_IntersectExceptExpr ( (k= UNION | VBAR ) p_IntersectExceptExpr )* ;
    // $ANTLR start "p_UnionExpr"
    p_UnionExpr: function() {
        var retval = new XQueryParser.p_UnionExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var VBAR221 = null;
         var p_IntersectExceptExpr220 = null;
         var p_IntersectExceptExpr222 = null;

        var k_tree=null;
        var VBAR221_tree=null;

        try {
            // xquery/XQueryParser.g:821:9: ( p_IntersectExceptExpr ( (k= UNION | VBAR ) p_IntersectExceptExpr )* )
            // xquery/XQueryParser.g:821:11: p_IntersectExceptExpr ( (k= UNION | VBAR ) p_IntersectExceptExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_IntersectExceptExpr_in_p_UnionExpr5828);
            p_IntersectExceptExpr220=this.p_IntersectExceptExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IntersectExceptExpr220.getTree());
            // xquery/XQueryParser.g:821:33: ( (k= UNION | VBAR ) p_IntersectExceptExpr )*
            loop101:
            do {
                var alt101=2;
                var LA101_0 = this.input.LA(1);

                if ( (LA101_0==UNION||LA101_0==VBAR) ) {
                    alt101=1;
                }


                switch (alt101) {
                case 1 :
                    // xquery/XQueryParser.g:821:35: (k= UNION | VBAR ) p_IntersectExceptExpr
                    // xquery/XQueryParser.g:821:35: (k= UNION | VBAR )
                    var alt100=2;
                    var LA100_0 = this.input.LA(1);

                    if ( (LA100_0==UNION) ) {
                        alt100=1;
                    }
                    else if ( (LA100_0==VBAR) ) {
                        alt100=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 100, 0, this.input);

                        throw nvae;
                    }
                    switch (alt100) {
                        case 1 :
                            // xquery/XQueryParser.g:821:36: k= UNION
                            k=this.match(this.input,UNION,XQueryParser.FOLLOW_UNION_in_p_UnionExpr5835); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }
                            if ( this.state.backtracking===0 ) {
                              this.ak(k);
                            }


                            break;
                        case 2 :
                            // xquery/XQueryParser.g:821:61: VBAR
                            VBAR221=this.match(this.input,VBAR,XQueryParser.FOLLOW_VBAR_in_p_UnionExpr5841); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            VBAR221_tree = this.adaptor.create(VBAR221);
                            this.adaptor.addChild(root_0, VBAR221_tree);
                            }


                            break;

                    }

                    this.pushFollow(XQueryParser.FOLLOW_p_IntersectExceptExpr_in_p_UnionExpr5844);
                    p_IntersectExceptExpr222=this.p_IntersectExceptExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IntersectExceptExpr222.getTree());


                    break;

                default :
                    break loop101;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IntersectExceptExpr_return: (function() {
        XQueryParser.p_IntersectExceptExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IntersectExceptExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:825:1: p_IntersectExceptExpr : p_InstanceofExpr ( (k= INTERSECT | k= EXCEPT ) p_InstanceofExpr )* ;
    // $ANTLR start "p_IntersectExceptExpr"
    p_IntersectExceptExpr: function() {
        var retval = new XQueryParser.p_IntersectExceptExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_InstanceofExpr223 = null;
         var p_InstanceofExpr224 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:826:9: ( p_InstanceofExpr ( (k= INTERSECT | k= EXCEPT ) p_InstanceofExpr )* )
            // xquery/XQueryParser.g:826:11: p_InstanceofExpr ( (k= INTERSECT | k= EXCEPT ) p_InstanceofExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_InstanceofExpr_in_p_IntersectExceptExpr5873);
            p_InstanceofExpr223=this.p_InstanceofExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InstanceofExpr223.getTree());
            // xquery/XQueryParser.g:826:28: ( (k= INTERSECT | k= EXCEPT ) p_InstanceofExpr )*
            loop103:
            do {
                var alt103=2;
                var LA103_0 = this.input.LA(1);

                if ( (LA103_0==EXCEPT||LA103_0==INTERSECT) ) {
                    alt103=1;
                }


                switch (alt103) {
                case 1 :
                    // xquery/XQueryParser.g:826:30: (k= INTERSECT | k= EXCEPT ) p_InstanceofExpr
                    // xquery/XQueryParser.g:826:30: (k= INTERSECT | k= EXCEPT )
                    var alt102=2;
                    var LA102_0 = this.input.LA(1);

                    if ( (LA102_0==INTERSECT) ) {
                        alt102=1;
                    }
                    else if ( (LA102_0==EXCEPT) ) {
                        alt102=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 102, 0, this.input);

                        throw nvae;
                    }
                    switch (alt102) {
                        case 1 :
                            // xquery/XQueryParser.g:826:31: k= INTERSECT
                            k=this.match(this.input,INTERSECT,XQueryParser.FOLLOW_INTERSECT_in_p_IntersectExceptExpr5880); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }


                            break;
                        case 2 :
                            // xquery/XQueryParser.g:826:45: k= EXCEPT
                            k=this.match(this.input,EXCEPT,XQueryParser.FOLLOW_EXCEPT_in_p_IntersectExceptExpr5886); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }


                            break;

                    }

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_InstanceofExpr_in_p_IntersectExceptExpr5891);
                    p_InstanceofExpr224=this.p_InstanceofExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InstanceofExpr224.getTree());


                    break;

                default :
                    break loop103;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_InstanceofExpr_return: (function() {
        XQueryParser.p_InstanceofExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_InstanceofExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:830:1: p_InstanceofExpr : p_TreatExpr (k= INSTANCE k= OF p_SequenceType )? ;
    // $ANTLR start "p_InstanceofExpr"
    p_InstanceofExpr: function() {
        var retval = new XQueryParser.p_InstanceofExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_TreatExpr225 = null;
         var p_SequenceType226 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:831:9: ( p_TreatExpr (k= INSTANCE k= OF p_SequenceType )? )
            // xquery/XQueryParser.g:831:11: p_TreatExpr (k= INSTANCE k= OF p_SequenceType )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_TreatExpr_in_p_InstanceofExpr5920);
            p_TreatExpr225=this.p_TreatExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TreatExpr225.getTree());
            // xquery/XQueryParser.g:831:23: (k= INSTANCE k= OF p_SequenceType )?
            var alt104=2;
            var LA104_0 = this.input.LA(1);

            if ( (LA104_0==INSTANCE) ) {
                alt104=1;
            }
            switch (alt104) {
                case 1 :
                    // xquery/XQueryParser.g:831:25: k= INSTANCE k= OF p_SequenceType
                    k=this.match(this.input,INSTANCE,XQueryParser.FOLLOW_INSTANCE_in_p_InstanceofExpr5926); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    k=this.match(this.input,OF,XQueryParser.FOLLOW_OF_in_p_InstanceofExpr5932); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_InstanceofExpr5936);
                    p_SequenceType226=this.p_SequenceType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType226.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TreatExpr_return: (function() {
        XQueryParser.p_TreatExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TreatExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:835:1: p_TreatExpr : p_CastableExpr (k= TREAT k= AS p_SequenceType )? ;
    // $ANTLR start "p_TreatExpr"
    p_TreatExpr: function() {
        var retval = new XQueryParser.p_TreatExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_CastableExpr227 = null;
         var p_SequenceType228 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:836:9: ( p_CastableExpr (k= TREAT k= AS p_SequenceType )? )
            // xquery/XQueryParser.g:836:11: p_CastableExpr (k= TREAT k= AS p_SequenceType )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_CastableExpr_in_p_TreatExpr5964);
            p_CastableExpr227=this.p_CastableExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CastableExpr227.getTree());
            // xquery/XQueryParser.g:836:26: (k= TREAT k= AS p_SequenceType )?
            var alt105=2;
            var LA105_0 = this.input.LA(1);

            if ( (LA105_0==TREAT) ) {
                alt105=1;
            }
            switch (alt105) {
                case 1 :
                    // xquery/XQueryParser.g:836:28: k= TREAT k= AS p_SequenceType
                    k=this.match(this.input,TREAT,XQueryParser.FOLLOW_TREAT_in_p_TreatExpr5970); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_TreatExpr5976); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_TreatExpr5980);
                    p_SequenceType228=this.p_SequenceType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType228.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CastableExpr_return: (function() {
        XQueryParser.p_CastableExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CastableExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:840:1: p_CastableExpr : p_CastExpr (k= CASTABLE k= AS p_SingleType )? ;
    // $ANTLR start "p_CastableExpr"
    p_CastableExpr: function() {
        var retval = new XQueryParser.p_CastableExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_CastExpr229 = null;
         var p_SingleType230 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:841:9: ( p_CastExpr (k= CASTABLE k= AS p_SingleType )? )
            // xquery/XQueryParser.g:841:11: p_CastExpr (k= CASTABLE k= AS p_SingleType )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_CastExpr_in_p_CastableExpr6017);
            p_CastExpr229=this.p_CastExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CastExpr229.getTree());
            // xquery/XQueryParser.g:841:22: (k= CASTABLE k= AS p_SingleType )?
            var alt106=2;
            var LA106_0 = this.input.LA(1);

            if ( (LA106_0==CASTABLE) ) {
                alt106=1;
            }
            switch (alt106) {
                case 1 :
                    // xquery/XQueryParser.g:841:24: k= CASTABLE k= AS p_SingleType
                    k=this.match(this.input,CASTABLE,XQueryParser.FOLLOW_CASTABLE_in_p_CastableExpr6023); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_CastableExpr6029); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SingleType_in_p_CastableExpr6033);
                    p_SingleType230=this.p_SingleType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SingleType230.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CastExpr_return: (function() {
        XQueryParser.p_CastExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CastExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:845:1: p_CastExpr : p_UnaryExpr (k= CAST k= AS p_SingleType )? ;
    // $ANTLR start "p_CastExpr"
    p_CastExpr: function() {
        var retval = new XQueryParser.p_CastExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_UnaryExpr231 = null;
         var p_SingleType232 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:846:9: ( p_UnaryExpr (k= CAST k= AS p_SingleType )? )
            // xquery/XQueryParser.g:846:11: p_UnaryExpr (k= CAST k= AS p_SingleType )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_UnaryExpr_in_p_CastExpr6070);
            p_UnaryExpr231=this.p_UnaryExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_UnaryExpr231.getTree());
            // xquery/XQueryParser.g:846:23: (k= CAST k= AS p_SingleType )?
            var alt107=2;
            var LA107_0 = this.input.LA(1);

            if ( (LA107_0==CAST) ) {
                alt107=1;
            }
            switch (alt107) {
                case 1 :
                    // xquery/XQueryParser.g:846:25: k= CAST k= AS p_SingleType
                    k=this.match(this.input,CAST,XQueryParser.FOLLOW_CAST_in_p_CastExpr6076); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_CastExpr6082); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SingleType_in_p_CastExpr6086);
                    p_SingleType232=this.p_SingleType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SingleType232.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_UnaryExpr_return: (function() {
        XQueryParser.p_UnaryExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_UnaryExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:850:1: p_UnaryExpr : (o= PLUS | o= MINUS )* p_ValueExpr -> ^( UnaryExpr ( PLUS )* p_ValueExpr ) ;
    // $ANTLR start "p_UnaryExpr"
    p_UnaryExpr: function() {
        var retval = new XQueryParser.p_UnaryExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var o = null;
         var p_ValueExpr233 = null;

        var o_tree=null;
        var stream_PLUS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token PLUS");
        var stream_MINUS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token MINUS");
        var stream_p_ValueExpr=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_ValueExpr");
        try {
            // xquery/XQueryParser.g:851:9: ( (o= PLUS | o= MINUS )* p_ValueExpr -> ^( UnaryExpr ( PLUS )* p_ValueExpr ) )
            // xquery/XQueryParser.g:851:11: (o= PLUS | o= MINUS )* p_ValueExpr
            // xquery/XQueryParser.g:851:11: (o= PLUS | o= MINUS )*
            loop108:
            do {
                var alt108=3;
                var LA108_0 = this.input.LA(1);

                if ( (LA108_0==PLUS) ) {
                    alt108=1;
                }
                else if ( (LA108_0==MINUS) ) {
                    alt108=2;
                }


                switch (alt108) {
                case 1 :
                    // xquery/XQueryParser.g:851:12: o= PLUS
                    o=this.match(this.input,PLUS,XQueryParser.FOLLOW_PLUS_in_p_UnaryExpr6118); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_PLUS.add(o);

                    if ( this.state.backtracking===0 ) {
                      this.ao(o);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:851:36: o= MINUS
                    o=this.match(this.input,MINUS,XQueryParser.FOLLOW_MINUS_in_p_UnaryExpr6126); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_MINUS.add(o);

                    if ( this.state.backtracking===0 ) {
                      this.ao(o);
                    }


                    break;

                default :
                    break loop108;
                }
            } while (true);

            this.pushFollow(XQueryParser.FOLLOW_p_ValueExpr_in_p_UnaryExpr6131);
            p_ValueExpr233=this.p_ValueExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_ValueExpr.add(p_ValueExpr233.getTree());


            // AST REWRITE
            // elements: p_ValueExpr, PLUS
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 852:17: -> ^( UnaryExpr ( PLUS )* p_ValueExpr )
            {
                // xquery/XQueryParser.g:852:20: ^( UnaryExpr ( PLUS )* p_ValueExpr )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(UnaryExpr, "UnaryExpr"), root_1);

                // xquery/XQueryParser.g:852:32: ( PLUS )*
                while ( stream_PLUS.hasNext() ) {
                    this.adaptor.addChild(root_1, stream_PLUS.nextNode());

                }
                stream_PLUS.reset();
                this.adaptor.addChild(root_1, stream_p_ValueExpr.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ValueExpr_return: (function() {
        XQueryParser.p_ValueExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ValueExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:856:1: p_ValueExpr : ( ( VALIDATE ( p_ValidationMode | TYPE )? )=> p_ValidateExpr | p_PathExpr | p_ExtensionExpr );
    // $ANTLR start "p_ValueExpr"
    p_ValueExpr: function() {
        var retval = new XQueryParser.p_ValueExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ValidateExpr234 = null;
         var p_PathExpr235 = null;
         var p_ExtensionExpr236 = null;


        try {
            // xquery/XQueryParser.g:857:9: ( ( VALIDATE ( p_ValidationMode | TYPE )? )=> p_ValidateExpr | p_PathExpr | p_ExtensionExpr )
            var alt109=3;
            switch ( this.input.LA(1) ) {
            case VALIDATE:
                var LA109_1 = this.input.LA(2);

                if ( (LA109_1==LAX) && (this.synpred6_XQueryParser())) {
                    alt109=1;
                }
                else if ( (LA109_1==STRICT) && (this.synpred6_XQueryParser())) {
                    alt109=1;
                }
                else if ( (LA109_1==TYPE) && (this.synpred6_XQueryParser())) {
                    alt109=1;
                }
                else if ( (LA109_1==LBRACKET) && (this.synpred6_XQueryParser())) {
                    alt109=1;
                }
                else if ( (LA109_1==EOF||(LA109_1>=AND && LA109_1<=ASCENDING)||(LA109_1>=CASE && LA109_1<=CASTABLE)||LA109_1==COLLATION||LA109_1==DEFAULT||(LA109_1>=DESCENDING && LA109_1<=DIV)||LA109_1==EMPTY||LA109_1==EQ||LA109_1==EXCEPT||LA109_1==FOR||LA109_1==GE||(LA109_1>=GT && LA109_1<=IDIV)||(LA109_1>=INSTANCE && LA109_1<=IS)||LA109_1==LE||(LA109_1>=LET && LA109_1<=MOD)||LA109_1==NE||(LA109_1>=OR && LA109_1<=ORDER)||(LA109_1>=RETURN && LA109_1<=SATISFIES)||LA109_1==STABLE||(LA109_1>=TO && LA109_1<=TREAT)||LA109_1==UNION||LA109_1==WHERE||LA109_1==COUNT||(LA109_1>=END && LA109_1<=GROUP)||LA109_1==ONLY||LA109_1==START||(LA109_1>=AFTER && LA109_1<=BEFORE)||LA109_1==INTO||LA109_1==MODIFY||LA109_1==WITH||LA109_1==CONTAINS||LA109_1==PARAGRAPHS||LA109_1==SENTENCES||LA109_1==TIMES||LA109_1==WORDS||(LA109_1>=CONCAT && LA109_1<=RPAREN)||(LA109_1>=RBRACKET && LA109_1<=EQUAL)||LA109_1==NOTEQUAL||LA109_1==COMMA||(LA109_1>=STAR && LA109_1<=SLASH_SLASH)||LA109_1==COLON||(LA109_1>=SEMICOLON && LA109_1<=VBAR)) ) {
                    alt109=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 109, 1, this.input);

                    throw nvae;
                }
                break;
            case ANCESTOR:
            case ANCESTOR_OR_SELF:
            case AND:
            case AS:
            case ASCENDING:
            case AT:
            case ATTRIBUTE:
            case BASE_URI:
            case BOUNDARY_SPACE:
            case BY:
            case CASE:
            case CAST:
            case CASTABLE:
            case CHILD:
            case COLLATION:
            case COMMENT:
            case CONSTRUCTION:
            case COPY_NAMESPACES:
            case DECLARE:
            case DEFAULT:
            case DESCENDANT:
            case DESCENDANT_OR_SELF:
            case DESCENDING:
            case DIV:
            case DOCUMENT:
            case DOCUMENT_NODE:
            case ELEMENT:
            case ELSE:
            case EMPTY:
            case EMPTY_SEQUENCE:
            case ENCODING:
            case EQ:
            case EVERY:
            case EXCEPT:
            case EXTERNAL:
            case FOLLOWING:
            case FOLLOWING_SIBLING:
            case FOR:
            case FUNCTION:
            case GE:
            case GREATEST:
            case GT:
            case IDIV:
            case IF:
            case IMPORT:
            case IN:
            case INHERIT:
            case INSTANCE:
            case INTERSECT:
            case IS:
            case ITEM:
            case LAX:
            case LE:
            case LEAST:
            case LET:
            case LT:
            case MOD:
            case MODULE:
            case NAMESPACE:
            case NE:
            case NO_INHERIT:
            case NO_PRESERVE:
            case NODE:
            case OF:
            case OPTION:
            case OR:
            case ORDER:
            case ORDERED:
            case ORDERING:
            case PARENT:
            case PRECEDING:
            case PRECEDING_SIBLING:
            case PRESERVE:
            case PROCESSING_INSTRUCTION:
            case RETURN:
            case SATISFIES:
            case SCHEMA:
            case SCHEMA_ATTRIBUTE:
            case SCHEMA_ELEMENT:
            case SELF:
            case SOME:
            case STABLE:
            case STRICT:
            case STRIP:
            case TEXT:
            case THEN:
            case TO:
            case TREAT:
            case TYPESWITCH:
            case UNION:
            case UNORDERED:
            case VARIABLE:
            case VERSION:
            case WHERE:
            case XQUERY:
            case ALLOWING:
            case CATCH:
            case CONTEXT:
            case COUNT:
            case DECIMAL_FORMAT:
            case DECIMAL_SEPARATOR:
            case DIGIT:
            case END:
            case GROUP:
            case GROUPING_SEPARATOR:
            case INFINITY:
            case MINUS_SIGN:
            case NAMESPACE_NODE:
            case NAN:
            case NEXT:
            case ONLY:
            case PATTERN_SEPARATOR:
            case PERCENT:
            case PER_MILLE:
            case PREVIOUS:
            case SLIDING:
            case START:
            case SWITCH:
            case TRY:
            case TUMBLING:
            case TYPE:
            case WHEN:
            case WINDOW:
            case ZERO_DIGIT:
            case AFTER:
            case BEFORE:
            case COPY:
            case DELETE:
            case FIRST:
            case INSERT:
            case INTO:
            case LAST:
            case MODIFY:
            case NODES:
            case RENAME:
            case REPLACE:
            case REVALIDATION:
            case SKIP:
            case UPDATING:
            case VALUE:
            case WITH:
            case ALL:
            case ANY:
            case CONTAINS:
            case CONTENT:
            case DIACRITICS:
            case DIFFERENT:
            case DISTANCE:
            case ENTIRE:
            case EXACTLY:
            case FROM:
            case FT_OPTION:
            case FTAND:
            case FTNOT:
            case FTOR:
            case INSENSITIVE:
            case LANGUAGE:
            case LEVELS:
            case LOWERCASE:
            case MOST:
            case NO:
            case NOT:
            case OCCURS:
            case PARAGRAPH:
            case PARAGRAPHS:
            case PHRASE:
            case RELATIONSHIP:
            case SAME:
            case SCORE:
            case SENSITIVE:
            case SENTENCE:
            case SENTENCES:
            case STEMMING:
            case STOP:
            case THESAURUS:
            case TIMES:
            case UPPERCASE:
            case USING:
            case WEIGHT:
            case WILDCARDS:
            case WITHOUT:
            case WORD:
            case WORDS:
            case BREAK:
            case CONTINUE:
            case EXIT:
            case LOOP:
            case RETURNING:
            case WHILE:
            case CHECK:
            case COLLECTION:
            case CONSTRAINT:
            case FOREACH:
            case FOREIGN:
            case INDEX:
            case INTEGRITY:
            case KEY:
            case ON:
            case UNIQUE:
            case BINARY:
            case AMP_ER:
            case APOS_ER:
            case QUOT_ER:
            case LPAREN:
            case DOLLAR:
            case LBRACKET:
            case STAR:
            case SMALLER:
            case SLASH:
            case SLASH_SLASH:
            case DOT:
            case DOT_DOT:
            case ATTR_SIGN:
            case APOS:
            case QUOT:
            case L_NCName:
            case L_DirCommentConstructor:
            case L_DirPIConstructor:
            case L_IntegerLiteral:
            case L_DecimalLiteral:
            case L_DoubleLiteral:
            case EXPLICITLY:
                alt109=2;
                break;
            case L_Pragma:
                alt109=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 109, 0, this.input);

                throw nvae;
            }

            switch (alt109) {
                case 1 :
                    // xquery/XQueryParser.g:857:11: ( VALIDATE ( p_ValidationMode | TYPE )? )=> p_ValidateExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ValidateExpr_in_p_ValueExpr6201);
                    p_ValidateExpr234=this.p_ValidateExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ValidateExpr234.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:858:11: p_PathExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_PathExpr_in_p_ValueExpr6213);
                    p_PathExpr235=this.p_PathExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PathExpr235.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:859:11: p_ExtensionExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ExtensionExpr_in_p_ValueExpr6225);
                    p_ExtensionExpr236=this.p_ExtensionExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExtensionExpr236.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_GeneralComp_return: (function() {
        XQueryParser.p_GeneralComp_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_GeneralComp_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:863:1: p_GeneralComp : ( EQUAL | NOTEQUAL | SMALLER | SMALLEREQ | GREATER | GREATEREQ );
    // $ANTLR start "p_GeneralComp"
    p_GeneralComp: function() {
        var retval = new XQueryParser.p_GeneralComp_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set237 = null;

        var set237_tree=null;

        try {
            // xquery/XQueryParser.g:864:9: ( EQUAL | NOTEQUAL | SMALLER | SMALLEREQ | GREATER | GREATEREQ )
            // xquery/XQueryParser.g:
            root_0 = this.adaptor.nil();

            set237=this.input.LT(1);
            if ( this.input.LA(1)==EQUAL||this.input.LA(1)==NOTEQUAL||(this.input.LA(1)>=SMALLER && this.input.LA(1)<=GREATEREQ) ) {
                this.input.consume();
                if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set237));
                this.state.errorRecovery=false;this.state.failed=false;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                throw mse;
            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ValueComp_return: (function() {
        XQueryParser.p_ValueComp_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ValueComp_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:868:1: p_ValueComp : (k= EQ | k= NE | k= LT | k= LE | k= GT | k= GE ) ;
    // $ANTLR start "p_ValueComp"
    p_ValueComp: function() {
        var retval = new XQueryParser.p_ValueComp_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:869:9: ( (k= EQ | k= NE | k= LT | k= LE | k= GT | k= GE ) )
            // xquery/XQueryParser.g:869:11: (k= EQ | k= NE | k= LT | k= LE | k= GT | k= GE )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:869:11: (k= EQ | k= NE | k= LT | k= LE | k= GT | k= GE )
            var alt110=6;
            switch ( this.input.LA(1) ) {
            case EQ:
                alt110=1;
                break;
            case NE:
                alt110=2;
                break;
            case LT:
                alt110=3;
                break;
            case LE:
                alt110=4;
                break;
            case GT:
                alt110=5;
                break;
            case GE:
                alt110=6;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 110, 0, this.input);

                throw nvae;
            }

            switch (alt110) {
                case 1 :
                    // xquery/XQueryParser.g:869:12: k= EQ
                    k=this.match(this.input,EQ,XQueryParser.FOLLOW_EQ_in_p_ValueComp6300); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:869:19: k= NE
                    k=this.match(this.input,NE,XQueryParser.FOLLOW_NE_in_p_ValueComp6306); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:869:26: k= LT
                    k=this.match(this.input,LT,XQueryParser.FOLLOW_LT_in_p_ValueComp6312); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 4 :
                    // xquery/XQueryParser.g:869:33: k= LE
                    k=this.match(this.input,LE,XQueryParser.FOLLOW_LE_in_p_ValueComp6318); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 5 :
                    // xquery/XQueryParser.g:869:40: k= GT
                    k=this.match(this.input,GT,XQueryParser.FOLLOW_GT_in_p_ValueComp6324); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 6 :
                    // xquery/XQueryParser.g:869:47: k= GE
                    k=this.match(this.input,GE,XQueryParser.FOLLOW_GE_in_p_ValueComp6330); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NodeComp_return: (function() {
        XQueryParser.p_NodeComp_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NodeComp_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:873:1: p_NodeComp : (k= IS | SMALLER_SMALLER | GREATER_GREATER );
    // $ANTLR start "p_NodeComp"
    p_NodeComp: function() {
        var retval = new XQueryParser.p_NodeComp_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SMALLER_SMALLER238 = null;
        var GREATER_GREATER239 = null;

        var k_tree=null;
        var SMALLER_SMALLER238_tree=null;
        var GREATER_GREATER239_tree=null;

        try {
            // xquery/XQueryParser.g:874:9: (k= IS | SMALLER_SMALLER | GREATER_GREATER )
            var alt111=3;
            switch ( this.input.LA(1) ) {
            case IS:
                alt111=1;
                break;
            case SMALLER_SMALLER:
                alt111=2;
                break;
            case GREATER_GREATER:
                alt111=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 111, 0, this.input);

                throw nvae;
            }

            switch (alt111) {
                case 1 :
                    // xquery/XQueryParser.g:874:11: k= IS
                    root_0 = this.adaptor.nil();

                    k=this.match(this.input,IS,XQueryParser.FOLLOW_IS_in_p_NodeComp6361); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:874:33: SMALLER_SMALLER
                    root_0 = this.adaptor.nil();

                    SMALLER_SMALLER238=this.match(this.input,SMALLER_SMALLER,XQueryParser.FOLLOW_SMALLER_SMALLER_in_p_NodeComp6367); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    SMALLER_SMALLER238_tree = this.adaptor.create(SMALLER_SMALLER238);
                    this.adaptor.addChild(root_0, SMALLER_SMALLER238_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:874:51: GREATER_GREATER
                    root_0 = this.adaptor.nil();

                    GREATER_GREATER239=this.match(this.input,GREATER_GREATER,XQueryParser.FOLLOW_GREATER_GREATER_in_p_NodeComp6371); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    GREATER_GREATER239_tree = this.adaptor.create(GREATER_GREATER239);
                    this.adaptor.addChild(root_0, GREATER_GREATER239_tree);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ValidateExpr_return: (function() {
        XQueryParser.p_ValidateExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ValidateExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:878:1: p_ValidateExpr : k= VALIDATE ( p_ValidationMode | k= TYPE p_TypeName )? LBRACKET p_Expr[true,true] RBRACKET ;
    // $ANTLR start "p_ValidateExpr"
    p_ValidateExpr: function() {
        var retval = new XQueryParser.p_ValidateExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET242 = null;
        var RBRACKET244 = null;
         var p_ValidationMode240 = null;
         var p_TypeName241 = null;
         var p_Expr243 = null;

        var k_tree=null;
        var LBRACKET242_tree=null;
        var RBRACKET244_tree=null;

        try {
            // xquery/XQueryParser.g:879:9: (k= VALIDATE ( p_ValidationMode | k= TYPE p_TypeName )? LBRACKET p_Expr[true,true] RBRACKET )
            // xquery/XQueryParser.g:879:11: k= VALIDATE ( p_ValidationMode | k= TYPE p_TypeName )? LBRACKET p_Expr[true,true] RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,VALIDATE,XQueryParser.FOLLOW_VALIDATE_in_p_ValidateExpr6399); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:879:37: ( p_ValidationMode | k= TYPE p_TypeName )?
            var alt112=3;
            var LA112_0 = this.input.LA(1);

            if ( (LA112_0==LAX||LA112_0==STRICT) ) {
                alt112=1;
            }
            else if ( (LA112_0==TYPE) ) {
                alt112=2;
            }
            switch (alt112) {
                case 1 :
                    // xquery/XQueryParser.g:879:39: p_ValidationMode
                    this.pushFollow(XQueryParser.FOLLOW_p_ValidationMode_in_p_ValidateExpr6405);
                    p_ValidationMode240=this.p_ValidationMode();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ValidationMode240.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:879:58: k= TYPE p_TypeName
                    k=this.match(this.input,TYPE,XQueryParser.FOLLOW_TYPE_in_p_ValidateExpr6411); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeName_in_p_ValidateExpr6415);
                    p_TypeName241=this.p_TypeName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeName241.getTree());


                    break;

            }

            LBRACKET242=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_ValidateExpr6420); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET242_tree = this.adaptor.create(LBRACKET242);
            this.adaptor.addChild(root_0, LBRACKET242_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_ValidateExpr6422);
            p_Expr243=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr243.getTree());
            RBRACKET244=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_ValidateExpr6425); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET244_tree = this.adaptor.create(RBRACKET244);
            this.adaptor.addChild(root_0, RBRACKET244_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ValidationMode_return: (function() {
        XQueryParser.p_ValidationMode_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ValidationMode_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:883:1: p_ValidationMode : (k= LAX | k= STRICT ) ;
    // $ANTLR start "p_ValidationMode"
    p_ValidationMode: function() {
        var retval = new XQueryParser.p_ValidationMode_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:884:9: ( (k= LAX | k= STRICT ) )
            // xquery/XQueryParser.g:884:11: (k= LAX | k= STRICT )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:884:11: (k= LAX | k= STRICT )
            var alt113=2;
            var LA113_0 = this.input.LA(1);

            if ( (LA113_0==LAX) ) {
                alt113=1;
            }
            else if ( (LA113_0==STRICT) ) {
                alt113=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 113, 0, this.input);

                throw nvae;
            }
            switch (alt113) {
                case 1 :
                    // xquery/XQueryParser.g:884:12: k= LAX
                    k=this.match(this.input,LAX,XQueryParser.FOLLOW_LAX_in_p_ValidationMode6454); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:884:20: k= STRICT
                    k=this.match(this.input,STRICT,XQueryParser.FOLLOW_STRICT_in_p_ValidationMode6460); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }


                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ExtensionExpr_return: (function() {
        XQueryParser.p_ExtensionExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ExtensionExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:888:1: p_ExtensionExpr : ( L_Pragma )+ LBRACKET ( p_Expr[true,true] )? RBRACKET ;
    // $ANTLR start "p_ExtensionExpr"
    p_ExtensionExpr: function() {
        var retval = new XQueryParser.p_ExtensionExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_Pragma245 = null;
        var LBRACKET246 = null;
        var RBRACKET248 = null;
         var p_Expr247 = null;

        var L_Pragma245_tree=null;
        var LBRACKET246_tree=null;
        var RBRACKET248_tree=null;

        try {
            // xquery/XQueryParser.g:889:9: ( ( L_Pragma )+ LBRACKET ( p_Expr[true,true] )? RBRACKET )
            // xquery/XQueryParser.g:889:11: ( L_Pragma )+ LBRACKET ( p_Expr[true,true] )? RBRACKET
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:889:11: ( L_Pragma )+
            var cnt114=0;
            loop114:
            do {
                var alt114=2;
                var LA114_0 = this.input.LA(1);

                if ( (LA114_0==L_Pragma) ) {
                    alt114=1;
                }


                switch (alt114) {
                case 1 :
                    // xquery/XQueryParser.g:889:11: L_Pragma
                    L_Pragma245=this.match(this.input,L_Pragma,XQueryParser.FOLLOW_L_Pragma_in_p_ExtensionExpr6489); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_Pragma245_tree = this.adaptor.create(L_Pragma245);
                    this.adaptor.addChild(root_0, L_Pragma245_tree);
                    }


                    break;

                default :
                    if ( cnt114 >= 1 ) {
                        break loop114;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(114, this.input);
                        throw eee;
                }
                cnt114++;
            } while (true);

            LBRACKET246=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_ExtensionExpr6492); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET246_tree = this.adaptor.create(LBRACKET246);
            this.adaptor.addChild(root_0, LBRACKET246_tree);
            }
            // xquery/XQueryParser.g:889:30: ( p_Expr[true,true] )?
            var alt115=2;
            var LA115_0 = this.input.LA(1);

            if ( ((LA115_0>=ANCESTOR && LA115_0<=QUOT_ER)||LA115_0==LPAREN||(LA115_0>=DOLLAR && LA115_0<=LBRACKET)||(LA115_0>=STAR && LA115_0<=SMALLER)||(LA115_0>=SLASH && LA115_0<=DOT_DOT)||LA115_0==ATTR_SIGN||(LA115_0>=APOS && LA115_0<=QUOT)||LA115_0==L_NCName||(LA115_0>=L_Pragma && LA115_0<=L_DoubleLiteral)||LA115_0==EXPLICITLY) ) {
                alt115=1;
            }
            switch (alt115) {
                case 1 :
                    // xquery/XQueryParser.g:889:30: p_Expr[true,true]
                    this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_ExtensionExpr6494);
                    p_Expr247=this.p_Expr(true, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr247.getTree());


                    break;

            }

            RBRACKET248=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_ExtensionExpr6498); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET248_tree = this.adaptor.create(RBRACKET248);
            this.adaptor.addChild(root_0, RBRACKET248_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PathExpr_return: (function() {
        XQueryParser.p_PathExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PathExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:901:1: p_PathExpr : ( ( SLASH p_RelativePathExpr )=> ( SLASH p_RelativePathExpr ) | SLASH | SLASH_SLASH p_RelativePathExpr | p_RelativePathExpr );
    // $ANTLR start "p_PathExpr"
    p_PathExpr: function() {
        var retval = new XQueryParser.p_PathExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SLASH249 = null;
        var SLASH251 = null;
        var SLASH_SLASH252 = null;
         var p_RelativePathExpr250 = null;
         var p_RelativePathExpr253 = null;
         var p_RelativePathExpr254 = null;

        var SLASH249_tree=null;
        var SLASH251_tree=null;
        var SLASH_SLASH252_tree=null;

        try {
            // xquery/XQueryParser.g:902:9: ( ( SLASH p_RelativePathExpr )=> ( SLASH p_RelativePathExpr ) | SLASH | SLASH_SLASH p_RelativePathExpr | p_RelativePathExpr )
            var alt116=4;
            alt116 = this.dfa116.predict(this.input);
            switch (alt116) {
                case 1 :
                    // xquery/XQueryParser.g:902:11: ( SLASH p_RelativePathExpr )=> ( SLASH p_RelativePathExpr )
                    root_0 = this.adaptor.nil();

                    // xquery/XQueryParser.g:902:41: ( SLASH p_RelativePathExpr )
                    // xquery/XQueryParser.g:902:42: SLASH p_RelativePathExpr
                    SLASH249=this.match(this.input,SLASH,XQueryParser.FOLLOW_SLASH_in_p_PathExpr6541); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    SLASH249_tree = this.adaptor.create(SLASH249);
                    this.adaptor.addChild(root_0, SLASH249_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_RelativePathExpr_in_p_PathExpr6543);
                    p_RelativePathExpr250=this.p_RelativePathExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_RelativePathExpr250.getTree());





                    break;
                case 2 :
                    // xquery/XQueryParser.g:903:11: SLASH
                    root_0 = this.adaptor.nil();

                    SLASH251=this.match(this.input,SLASH,XQueryParser.FOLLOW_SLASH_in_p_PathExpr6556); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    SLASH251_tree = this.adaptor.create(SLASH251);
                    this.adaptor.addChild(root_0, SLASH251_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:904:11: SLASH_SLASH p_RelativePathExpr
                    root_0 = this.adaptor.nil();

                    SLASH_SLASH252=this.match(this.input,SLASH_SLASH,XQueryParser.FOLLOW_SLASH_SLASH_in_p_PathExpr6568); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    SLASH_SLASH252_tree = this.adaptor.create(SLASH_SLASH252);
                    this.adaptor.addChild(root_0, SLASH_SLASH252_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_RelativePathExpr_in_p_PathExpr6570);
                    p_RelativePathExpr253=this.p_RelativePathExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_RelativePathExpr253.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:905:11: p_RelativePathExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_RelativePathExpr_in_p_PathExpr6582);
                    p_RelativePathExpr254=this.p_RelativePathExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_RelativePathExpr254.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_RelativePathExpr_return: (function() {
        XQueryParser.p_RelativePathExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_RelativePathExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:909:1: p_RelativePathExpr : p_StepExpr ( ( SLASH | SLASH_SLASH ) p_StepExpr )* ;
    // $ANTLR start "p_RelativePathExpr"
    p_RelativePathExpr: function() {
        var retval = new XQueryParser.p_RelativePathExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set256 = null;
         var p_StepExpr255 = null;
         var p_StepExpr257 = null;

        var set256_tree=null;

        try {
            // xquery/XQueryParser.g:910:9: ( p_StepExpr ( ( SLASH | SLASH_SLASH ) p_StepExpr )* )
            // xquery/XQueryParser.g:910:11: p_StepExpr ( ( SLASH | SLASH_SLASH ) p_StepExpr )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_StepExpr_in_p_RelativePathExpr6610);
            p_StepExpr255=this.p_StepExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StepExpr255.getTree());
            // xquery/XQueryParser.g:910:22: ( ( SLASH | SLASH_SLASH ) p_StepExpr )*
            loop117:
            do {
                var alt117=2;
                var LA117_0 = this.input.LA(1);

                if ( ((LA117_0>=SLASH && LA117_0<=SLASH_SLASH)) ) {
                    alt117=1;
                }


                switch (alt117) {
                case 1 :
                    // xquery/XQueryParser.g:910:23: ( SLASH | SLASH_SLASH ) p_StepExpr
                    set256=this.input.LT(1);
                    if ( (this.input.LA(1)>=SLASH && this.input.LA(1)<=SLASH_SLASH) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set256));
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }

                    this.pushFollow(XQueryParser.FOLLOW_p_StepExpr_in_p_RelativePathExpr6621);
                    p_StepExpr257=this.p_StepExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StepExpr257.getTree());


                    break;

                default :
                    break loop117;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_StepExpr_return: (function() {
        XQueryParser.p_StepExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_StepExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:914:1: p_StepExpr : ( ( LBRACKET | LPAREN | SMALLER | QUOT | APOS | DOLLAR )=> p_PostfixExpr | ( ( ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET ) | ( ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET ) | ( ( DOCUMENT | TEXT | COMMENT ) LBRACKET ) )=> p_PostfixExpr | ( p_KindTest )=> p_AxisStep | ( p_QName LPAREN )=> p_PostfixExpr | ( p_PrimaryExpr )=> p_PostfixExpr | p_AxisStep );
    // $ANTLR start "p_StepExpr"
    p_StepExpr: function() {
        var retval = new XQueryParser.p_StepExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_PostfixExpr258 = null;
         var p_PostfixExpr259 = null;
         var p_AxisStep260 = null;
         var p_PostfixExpr261 = null;
         var p_PostfixExpr262 = null;
         var p_AxisStep263 = null;


        try {
            // xquery/XQueryParser.g:915:9: ( ( LBRACKET | LPAREN | SMALLER | QUOT | APOS | DOLLAR )=> p_PostfixExpr | ( ( ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET ) | ( ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET ) | ( ( DOCUMENT | TEXT | COMMENT ) LBRACKET ) )=> p_PostfixExpr | ( p_KindTest )=> p_AxisStep | ( p_QName LPAREN )=> p_PostfixExpr | ( p_PrimaryExpr )=> p_PostfixExpr | p_AxisStep )
            var alt118=6;
            alt118 = this.dfa118.predict(this.input);
            switch (alt118) {
                case 1 :
                    // xquery/XQueryParser.g:915:11: ( LBRACKET | LPAREN | SMALLER | QUOT | APOS | DOLLAR )=> p_PostfixExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_PostfixExpr_in_p_StepExpr6675);
                    p_PostfixExpr258=this.p_PostfixExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PostfixExpr258.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:916:11: ( ( ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET ) | ( ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET ) | ( ( DOCUMENT | TEXT | COMMENT ) LBRACKET ) )=> p_PostfixExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_PostfixExpr_in_p_StepExpr6789);
                    p_PostfixExpr259=this.p_PostfixExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PostfixExpr259.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:921:11: ( p_KindTest )=> p_AxisStep
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AxisStep_in_p_StepExpr6807);
                    p_AxisStep260=this.p_AxisStep();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AxisStep260.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:922:11: ( p_QName LPAREN )=> p_PostfixExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_PostfixExpr_in_p_StepExpr6828);
                    p_PostfixExpr261=this.p_PostfixExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PostfixExpr261.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:923:11: ( p_PrimaryExpr )=> p_PostfixExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_PostfixExpr_in_p_StepExpr6846);
                    p_PostfixExpr262=this.p_PostfixExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PostfixExpr262.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:924:11: p_AxisStep
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AxisStep_in_p_StepExpr6858);
                    p_AxisStep263=this.p_AxisStep();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AxisStep263.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AxisStep_return: (function() {
        XQueryParser.p_AxisStep_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AxisStep_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:928:1: p_AxisStep : ( p_ReverseStep | p_ForwardStep ) p_PredicateList ;
    // $ANTLR start "p_AxisStep"
    p_AxisStep: function() {
        var retval = new XQueryParser.p_AxisStep_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ReverseStep264 = null;
         var p_ForwardStep265 = null;
         var p_PredicateList266 = null;


        try {
            // xquery/XQueryParser.g:929:9: ( ( p_ReverseStep | p_ForwardStep ) p_PredicateList )
            // xquery/XQueryParser.g:929:11: ( p_ReverseStep | p_ForwardStep ) p_PredicateList
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:929:11: ( p_ReverseStep | p_ForwardStep )
            var alt119=2;
            switch ( this.input.LA(1) ) {
            case PARENT:
                var LA119_1 = this.input.LA(2);

                if ( (LA119_1==COLON_COLON) ) {
                    alt119=1;
                }
                else if ( (LA119_1==EOF||(LA119_1>=AND && LA119_1<=ASCENDING)||(LA119_1>=BY && LA119_1<=CASTABLE)||LA119_1==COLLATION||LA119_1==DEFAULT||(LA119_1>=DESCENDING && LA119_1<=DIV)||LA119_1==EMPTY||LA119_1==EQ||LA119_1==EXCEPT||LA119_1==FOR||LA119_1==GE||(LA119_1>=GT && LA119_1<=IDIV)||(LA119_1>=INSTANCE && LA119_1<=IS)||LA119_1==LE||(LA119_1>=LET && LA119_1<=MOD)||LA119_1==NE||(LA119_1>=OR && LA119_1<=ORDER)||(LA119_1>=RETURN && LA119_1<=SATISFIES)||LA119_1==STABLE||(LA119_1>=TO && LA119_1<=TREAT)||LA119_1==UNION||LA119_1==WHERE||LA119_1==COUNT||(LA119_1>=END && LA119_1<=GROUP)||LA119_1==ONLY||LA119_1==START||(LA119_1>=AFTER && LA119_1<=BEFORE)||LA119_1==INTO||LA119_1==MODIFY||LA119_1==WITH||LA119_1==CONTAINS||LA119_1==PARAGRAPHS||LA119_1==SENTENCES||LA119_1==TIMES||LA119_1==WORDS||LA119_1==CONCAT||LA119_1==RPAREN||(LA119_1>=RBRACKET && LA119_1<=EQUAL)||LA119_1==NOTEQUAL||LA119_1==COMMA||(LA119_1>=STAR && LA119_1<=SLASH_SLASH)||LA119_1==COLON||(LA119_1>=SEMICOLON && LA119_1<=VBAR)) ) {
                    alt119=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 119, 1, this.input);

                    throw nvae;
                }
                break;
            case ANCESTOR:
                var LA119_2 = this.input.LA(2);

                if ( (LA119_2==COLON_COLON) ) {
                    alt119=1;
                }
                else if ( (LA119_2==EOF||(LA119_2>=AND && LA119_2<=ASCENDING)||(LA119_2>=BY && LA119_2<=CASTABLE)||LA119_2==COLLATION||LA119_2==DEFAULT||(LA119_2>=DESCENDING && LA119_2<=DIV)||LA119_2==EMPTY||LA119_2==EQ||LA119_2==EXCEPT||LA119_2==FOR||LA119_2==GE||(LA119_2>=GT && LA119_2<=IDIV)||(LA119_2>=INSTANCE && LA119_2<=IS)||LA119_2==LE||(LA119_2>=LET && LA119_2<=MOD)||LA119_2==NE||(LA119_2>=OR && LA119_2<=ORDER)||(LA119_2>=RETURN && LA119_2<=SATISFIES)||LA119_2==STABLE||(LA119_2>=TO && LA119_2<=TREAT)||LA119_2==UNION||LA119_2==WHERE||LA119_2==COUNT||(LA119_2>=END && LA119_2<=GROUP)||LA119_2==ONLY||LA119_2==START||(LA119_2>=AFTER && LA119_2<=BEFORE)||LA119_2==INTO||LA119_2==MODIFY||LA119_2==WITH||LA119_2==CONTAINS||LA119_2==PARAGRAPHS||LA119_2==SENTENCES||LA119_2==TIMES||LA119_2==WORDS||LA119_2==CONCAT||LA119_2==RPAREN||(LA119_2>=RBRACKET && LA119_2<=EQUAL)||LA119_2==NOTEQUAL||LA119_2==COMMA||(LA119_2>=STAR && LA119_2<=SLASH_SLASH)||LA119_2==COLON||(LA119_2>=SEMICOLON && LA119_2<=VBAR)) ) {
                    alt119=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 119, 2, this.input);

                    throw nvae;
                }
                break;
            case PRECEDING_SIBLING:
                var LA119_3 = this.input.LA(2);

                if ( (LA119_3==COLON_COLON) ) {
                    alt119=1;
                }
                else if ( (LA119_3==EOF||(LA119_3>=AND && LA119_3<=ASCENDING)||(LA119_3>=BY && LA119_3<=CASTABLE)||LA119_3==COLLATION||LA119_3==DEFAULT||(LA119_3>=DESCENDING && LA119_3<=DIV)||LA119_3==EMPTY||LA119_3==EQ||LA119_3==EXCEPT||LA119_3==FOR||LA119_3==GE||(LA119_3>=GT && LA119_3<=IDIV)||(LA119_3>=INSTANCE && LA119_3<=IS)||LA119_3==LE||(LA119_3>=LET && LA119_3<=MOD)||LA119_3==NE||(LA119_3>=OR && LA119_3<=ORDER)||(LA119_3>=RETURN && LA119_3<=SATISFIES)||LA119_3==STABLE||(LA119_3>=TO && LA119_3<=TREAT)||LA119_3==UNION||LA119_3==WHERE||LA119_3==COUNT||(LA119_3>=END && LA119_3<=GROUP)||LA119_3==ONLY||LA119_3==START||(LA119_3>=AFTER && LA119_3<=BEFORE)||LA119_3==INTO||LA119_3==MODIFY||LA119_3==WITH||LA119_3==CONTAINS||LA119_3==PARAGRAPHS||LA119_3==SENTENCES||LA119_3==TIMES||LA119_3==WORDS||LA119_3==CONCAT||LA119_3==RPAREN||(LA119_3>=RBRACKET && LA119_3<=EQUAL)||LA119_3==NOTEQUAL||LA119_3==COMMA||(LA119_3>=STAR && LA119_3<=SLASH_SLASH)||LA119_3==COLON||(LA119_3>=SEMICOLON && LA119_3<=VBAR)) ) {
                    alt119=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 119, 3, this.input);

                    throw nvae;
                }
                break;
            case PRECEDING:
                var LA119_4 = this.input.LA(2);

                if ( (LA119_4==COLON_COLON) ) {
                    alt119=1;
                }
                else if ( (LA119_4==EOF||(LA119_4>=AND && LA119_4<=ASCENDING)||(LA119_4>=BY && LA119_4<=CASTABLE)||LA119_4==COLLATION||LA119_4==DEFAULT||(LA119_4>=DESCENDING && LA119_4<=DIV)||LA119_4==EMPTY||LA119_4==EQ||LA119_4==EXCEPT||LA119_4==FOR||LA119_4==GE||(LA119_4>=GT && LA119_4<=IDIV)||(LA119_4>=INSTANCE && LA119_4<=IS)||LA119_4==LE||(LA119_4>=LET && LA119_4<=MOD)||LA119_4==NE||(LA119_4>=OR && LA119_4<=ORDER)||(LA119_4>=RETURN && LA119_4<=SATISFIES)||LA119_4==STABLE||(LA119_4>=TO && LA119_4<=TREAT)||LA119_4==UNION||LA119_4==WHERE||LA119_4==COUNT||(LA119_4>=END && LA119_4<=GROUP)||LA119_4==ONLY||LA119_4==START||(LA119_4>=AFTER && LA119_4<=BEFORE)||LA119_4==INTO||LA119_4==MODIFY||LA119_4==WITH||LA119_4==CONTAINS||LA119_4==PARAGRAPHS||LA119_4==SENTENCES||LA119_4==TIMES||LA119_4==WORDS||LA119_4==CONCAT||LA119_4==RPAREN||(LA119_4>=RBRACKET && LA119_4<=EQUAL)||LA119_4==NOTEQUAL||LA119_4==COMMA||(LA119_4>=STAR && LA119_4<=SLASH_SLASH)||LA119_4==COLON||(LA119_4>=SEMICOLON && LA119_4<=VBAR)) ) {
                    alt119=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 119, 4, this.input);

                    throw nvae;
                }
                break;
            case ANCESTOR_OR_SELF:
                var LA119_5 = this.input.LA(2);

                if ( (LA119_5==COLON_COLON) ) {
                    alt119=1;
                }
                else if ( (LA119_5==EOF||(LA119_5>=AND && LA119_5<=ASCENDING)||(LA119_5>=BY && LA119_5<=CASTABLE)||LA119_5==COLLATION||LA119_5==DEFAULT||(LA119_5>=DESCENDING && LA119_5<=DIV)||LA119_5==EMPTY||LA119_5==EQ||LA119_5==EXCEPT||LA119_5==FOR||LA119_5==GE||(LA119_5>=GT && LA119_5<=IDIV)||(LA119_5>=INSTANCE && LA119_5<=IS)||LA119_5==LE||(LA119_5>=LET && LA119_5<=MOD)||LA119_5==NE||(LA119_5>=OR && LA119_5<=ORDER)||(LA119_5>=RETURN && LA119_5<=SATISFIES)||LA119_5==STABLE||(LA119_5>=TO && LA119_5<=TREAT)||LA119_5==UNION||LA119_5==WHERE||LA119_5==COUNT||(LA119_5>=END && LA119_5<=GROUP)||LA119_5==ONLY||LA119_5==START||(LA119_5>=AFTER && LA119_5<=BEFORE)||LA119_5==INTO||LA119_5==MODIFY||LA119_5==WITH||LA119_5==CONTAINS||LA119_5==PARAGRAPHS||LA119_5==SENTENCES||LA119_5==TIMES||LA119_5==WORDS||LA119_5==CONCAT||LA119_5==RPAREN||(LA119_5>=RBRACKET && LA119_5<=EQUAL)||LA119_5==NOTEQUAL||LA119_5==COMMA||(LA119_5>=STAR && LA119_5<=SLASH_SLASH)||LA119_5==COLON||(LA119_5>=SEMICOLON && LA119_5<=VBAR)) ) {
                    alt119=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 119, 5, this.input);

                    throw nvae;
                }
                break;
            case DOT_DOT:
                alt119=1;
                break;
            case AND:
            case AS:
            case ASCENDING:
            case AT:
            case ATTRIBUTE:
            case BASE_URI:
            case BOUNDARY_SPACE:
            case BY:
            case CASE:
            case CAST:
            case CASTABLE:
            case CHILD:
            case COLLATION:
            case COMMENT:
            case CONSTRUCTION:
            case COPY_NAMESPACES:
            case DECLARE:
            case DEFAULT:
            case DESCENDANT:
            case DESCENDANT_OR_SELF:
            case DESCENDING:
            case DIV:
            case DOCUMENT:
            case DOCUMENT_NODE:
            case ELEMENT:
            case ELSE:
            case EMPTY:
            case EMPTY_SEQUENCE:
            case ENCODING:
            case EQ:
            case EVERY:
            case EXCEPT:
            case EXTERNAL:
            case FOLLOWING:
            case FOLLOWING_SIBLING:
            case FOR:
            case FUNCTION:
            case GE:
            case GREATEST:
            case GT:
            case IDIV:
            case IF:
            case IMPORT:
            case IN:
            case INHERIT:
            case INSTANCE:
            case INTERSECT:
            case IS:
            case ITEM:
            case LAX:
            case LE:
            case LEAST:
            case LET:
            case LT:
            case MOD:
            case MODULE:
            case NAMESPACE:
            case NE:
            case NO_INHERIT:
            case NO_PRESERVE:
            case NODE:
            case OF:
            case OPTION:
            case OR:
            case ORDER:
            case ORDERED:
            case ORDERING:
            case PRESERVE:
            case PROCESSING_INSTRUCTION:
            case RETURN:
            case SATISFIES:
            case SCHEMA:
            case SCHEMA_ATTRIBUTE:
            case SCHEMA_ELEMENT:
            case SELF:
            case SOME:
            case STABLE:
            case STRICT:
            case STRIP:
            case TEXT:
            case THEN:
            case TO:
            case TREAT:
            case TYPESWITCH:
            case UNION:
            case UNORDERED:
            case VALIDATE:
            case VARIABLE:
            case VERSION:
            case WHERE:
            case XQUERY:
            case ALLOWING:
            case CATCH:
            case CONTEXT:
            case COUNT:
            case DECIMAL_FORMAT:
            case DECIMAL_SEPARATOR:
            case DIGIT:
            case END:
            case GROUP:
            case GROUPING_SEPARATOR:
            case INFINITY:
            case MINUS_SIGN:
            case NAMESPACE_NODE:
            case NAN:
            case NEXT:
            case ONLY:
            case PATTERN_SEPARATOR:
            case PERCENT:
            case PER_MILLE:
            case PREVIOUS:
            case SLIDING:
            case START:
            case SWITCH:
            case TRY:
            case TUMBLING:
            case TYPE:
            case WHEN:
            case WINDOW:
            case ZERO_DIGIT:
            case AFTER:
            case BEFORE:
            case COPY:
            case DELETE:
            case FIRST:
            case INSERT:
            case INTO:
            case LAST:
            case MODIFY:
            case NODES:
            case RENAME:
            case REPLACE:
            case REVALIDATION:
            case SKIP:
            case VALUE:
            case WITH:
            case ALL:
            case ANY:
            case CONTAINS:
            case CONTENT:
            case DIACRITICS:
            case DIFFERENT:
            case DISTANCE:
            case ENTIRE:
            case EXACTLY:
            case FROM:
            case FT_OPTION:
            case FTAND:
            case FTNOT:
            case FTOR:
            case INSENSITIVE:
            case LANGUAGE:
            case LEVELS:
            case LOWERCASE:
            case MOST:
            case NO:
            case NOT:
            case OCCURS:
            case PARAGRAPH:
            case PARAGRAPHS:
            case PHRASE:
            case RELATIONSHIP:
            case SAME:
            case SCORE:
            case SENSITIVE:
            case SENTENCE:
            case SENTENCES:
            case STEMMING:
            case STOP:
            case THESAURUS:
            case TIMES:
            case UPPERCASE:
            case USING:
            case WEIGHT:
            case WILDCARDS:
            case WITHOUT:
            case WORD:
            case WORDS:
            case BREAK:
            case CONTINUE:
            case EXIT:
            case LOOP:
            case RETURNING:
            case WHILE:
            case CHECK:
            case COLLECTION:
            case CONSTRAINT:
            case FOREACH:
            case FOREIGN:
            case INDEX:
            case INTEGRITY:
            case KEY:
            case ON:
            case UNIQUE:
            case BINARY:
            case AMP_ER:
            case APOS_ER:
            case QUOT_ER:
            case STAR:
            case ATTR_SIGN:
            case APOS:
            case QUOT:
            case L_NCName:
            case EXPLICITLY:
                alt119=2;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 119, 0, this.input);

                throw nvae;
            }

            switch (alt119) {
                case 1 :
                    // xquery/XQueryParser.g:929:12: p_ReverseStep
                    this.pushFollow(XQueryParser.FOLLOW_p_ReverseStep_in_p_AxisStep6885);
                    p_ReverseStep264=this.p_ReverseStep();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ReverseStep264.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:929:28: p_ForwardStep
                    this.pushFollow(XQueryParser.FOLLOW_p_ForwardStep_in_p_AxisStep6889);
                    p_ForwardStep265=this.p_ForwardStep();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ForwardStep265.getTree());


                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_PredicateList_in_p_AxisStep6892);
            p_PredicateList266=this.p_PredicateList();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PredicateList266.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ForwardStep_return: (function() {
        XQueryParser.p_ForwardStep_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ForwardStep_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:933:1: p_ForwardStep : ( p_ForwardAxis p_NodeTest | p_AbbrevForwardStep );
    // $ANTLR start "p_ForwardStep"
    p_ForwardStep: function() {
        var retval = new XQueryParser.p_ForwardStep_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ForwardAxis267 = null;
         var p_NodeTest268 = null;
         var p_AbbrevForwardStep269 = null;


        try {
            // xquery/XQueryParser.g:934:9: ( p_ForwardAxis p_NodeTest | p_AbbrevForwardStep )
            var alt120=2;
            alt120 = this.dfa120.predict(this.input);
            switch (alt120) {
                case 1 :
                    // xquery/XQueryParser.g:934:11: p_ForwardAxis p_NodeTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ForwardAxis_in_p_ForwardStep6918);
                    p_ForwardAxis267=this.p_ForwardAxis();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ForwardAxis267.getTree());
                    this.pushFollow(XQueryParser.FOLLOW_p_NodeTest_in_p_ForwardStep6920);
                    p_NodeTest268=this.p_NodeTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NodeTest268.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:935:11: p_AbbrevForwardStep
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AbbrevForwardStep_in_p_ForwardStep6932);
                    p_AbbrevForwardStep269=this.p_AbbrevForwardStep();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AbbrevForwardStep269.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ForwardAxis_return: (function() {
        XQueryParser.p_ForwardAxis_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ForwardAxis_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:939:1: p_ForwardAxis : ( CHILD COLON_COLON | DESCENDANT COLON_COLON | ATTRIBUTE COLON_COLON | SELF COLON_COLON | DESCENDANT_OR_SELF COLON_COLON | FOLLOWING_SIBLING COLON_COLON | FOLLOWING COLON_COLON );
    // $ANTLR start "p_ForwardAxis"
    p_ForwardAxis: function() {
        var retval = new XQueryParser.p_ForwardAxis_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var CHILD270 = null;
        var COLON_COLON271 = null;
        var DESCENDANT272 = null;
        var COLON_COLON273 = null;
        var ATTRIBUTE274 = null;
        var COLON_COLON275 = null;
        var SELF276 = null;
        var COLON_COLON277 = null;
        var DESCENDANT_OR_SELF278 = null;
        var COLON_COLON279 = null;
        var FOLLOWING_SIBLING280 = null;
        var COLON_COLON281 = null;
        var FOLLOWING282 = null;
        var COLON_COLON283 = null;

        var CHILD270_tree=null;
        var COLON_COLON271_tree=null;
        var DESCENDANT272_tree=null;
        var COLON_COLON273_tree=null;
        var ATTRIBUTE274_tree=null;
        var COLON_COLON275_tree=null;
        var SELF276_tree=null;
        var COLON_COLON277_tree=null;
        var DESCENDANT_OR_SELF278_tree=null;
        var COLON_COLON279_tree=null;
        var FOLLOWING_SIBLING280_tree=null;
        var COLON_COLON281_tree=null;
        var FOLLOWING282_tree=null;
        var COLON_COLON283_tree=null;

        try {
            // xquery/XQueryParser.g:940:9: ( CHILD COLON_COLON | DESCENDANT COLON_COLON | ATTRIBUTE COLON_COLON | SELF COLON_COLON | DESCENDANT_OR_SELF COLON_COLON | FOLLOWING_SIBLING COLON_COLON | FOLLOWING COLON_COLON )
            var alt121=7;
            switch ( this.input.LA(1) ) {
            case CHILD:
                alt121=1;
                break;
            case DESCENDANT:
                alt121=2;
                break;
            case ATTRIBUTE:
                alt121=3;
                break;
            case SELF:
                alt121=4;
                break;
            case DESCENDANT_OR_SELF:
                alt121=5;
                break;
            case FOLLOWING_SIBLING:
                alt121=6;
                break;
            case FOLLOWING:
                alt121=7;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 121, 0, this.input);

                throw nvae;
            }

            switch (alt121) {
                case 1 :
                    // xquery/XQueryParser.g:940:11: CHILD COLON_COLON
                    root_0 = this.adaptor.nil();

                    CHILD270=this.match(this.input,CHILD,XQueryParser.FOLLOW_CHILD_in_p_ForwardAxis6958); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    CHILD270_tree = this.adaptor.create(CHILD270);
                    this.adaptor.addChild(root_0, CHILD270_tree);
                    }
                    COLON_COLON271=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ForwardAxis6960); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON271_tree = this.adaptor.create(COLON_COLON271);
                    this.adaptor.addChild(root_0, COLON_COLON271_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:941:11: DESCENDANT COLON_COLON
                    root_0 = this.adaptor.nil();

                    DESCENDANT272=this.match(this.input,DESCENDANT,XQueryParser.FOLLOW_DESCENDANT_in_p_ForwardAxis6972); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    DESCENDANT272_tree = this.adaptor.create(DESCENDANT272);
                    this.adaptor.addChild(root_0, DESCENDANT272_tree);
                    }
                    COLON_COLON273=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ForwardAxis6974); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON273_tree = this.adaptor.create(COLON_COLON273);
                    this.adaptor.addChild(root_0, COLON_COLON273_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:942:11: ATTRIBUTE COLON_COLON
                    root_0 = this.adaptor.nil();

                    ATTRIBUTE274=this.match(this.input,ATTRIBUTE,XQueryParser.FOLLOW_ATTRIBUTE_in_p_ForwardAxis6986); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ATTRIBUTE274_tree = this.adaptor.create(ATTRIBUTE274);
                    this.adaptor.addChild(root_0, ATTRIBUTE274_tree);
                    }
                    COLON_COLON275=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ForwardAxis6988); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON275_tree = this.adaptor.create(COLON_COLON275);
                    this.adaptor.addChild(root_0, COLON_COLON275_tree);
                    }


                    break;
                case 4 :
                    // xquery/XQueryParser.g:943:11: SELF COLON_COLON
                    root_0 = this.adaptor.nil();

                    SELF276=this.match(this.input,SELF,XQueryParser.FOLLOW_SELF_in_p_ForwardAxis7000); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    SELF276_tree = this.adaptor.create(SELF276);
                    this.adaptor.addChild(root_0, SELF276_tree);
                    }
                    COLON_COLON277=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ForwardAxis7002); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON277_tree = this.adaptor.create(COLON_COLON277);
                    this.adaptor.addChild(root_0, COLON_COLON277_tree);
                    }


                    break;
                case 5 :
                    // xquery/XQueryParser.g:944:11: DESCENDANT_OR_SELF COLON_COLON
                    root_0 = this.adaptor.nil();

                    DESCENDANT_OR_SELF278=this.match(this.input,DESCENDANT_OR_SELF,XQueryParser.FOLLOW_DESCENDANT_OR_SELF_in_p_ForwardAxis7014); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    DESCENDANT_OR_SELF278_tree = this.adaptor.create(DESCENDANT_OR_SELF278);
                    this.adaptor.addChild(root_0, DESCENDANT_OR_SELF278_tree);
                    }
                    COLON_COLON279=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ForwardAxis7016); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON279_tree = this.adaptor.create(COLON_COLON279);
                    this.adaptor.addChild(root_0, COLON_COLON279_tree);
                    }


                    break;
                case 6 :
                    // xquery/XQueryParser.g:945:11: FOLLOWING_SIBLING COLON_COLON
                    root_0 = this.adaptor.nil();

                    FOLLOWING_SIBLING280=this.match(this.input,FOLLOWING_SIBLING,XQueryParser.FOLLOW_FOLLOWING_SIBLING_in_p_ForwardAxis7028); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    FOLLOWING_SIBLING280_tree = this.adaptor.create(FOLLOWING_SIBLING280);
                    this.adaptor.addChild(root_0, FOLLOWING_SIBLING280_tree);
                    }
                    COLON_COLON281=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ForwardAxis7030); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON281_tree = this.adaptor.create(COLON_COLON281);
                    this.adaptor.addChild(root_0, COLON_COLON281_tree);
                    }


                    break;
                case 7 :
                    // xquery/XQueryParser.g:946:11: FOLLOWING COLON_COLON
                    root_0 = this.adaptor.nil();

                    FOLLOWING282=this.match(this.input,FOLLOWING,XQueryParser.FOLLOW_FOLLOWING_in_p_ForwardAxis7042); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    FOLLOWING282_tree = this.adaptor.create(FOLLOWING282);
                    this.adaptor.addChild(root_0, FOLLOWING282_tree);
                    }
                    COLON_COLON283=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ForwardAxis7044); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON283_tree = this.adaptor.create(COLON_COLON283);
                    this.adaptor.addChild(root_0, COLON_COLON283_tree);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AbbrevForwardStep_return: (function() {
        XQueryParser.p_AbbrevForwardStep_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AbbrevForwardStep_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:950:1: p_AbbrevForwardStep : ( ATTR_SIGN )? p_NodeTest ;
    // $ANTLR start "p_AbbrevForwardStep"
    p_AbbrevForwardStep: function() {
        var retval = new XQueryParser.p_AbbrevForwardStep_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ATTR_SIGN284 = null;
         var p_NodeTest285 = null;

        var ATTR_SIGN284_tree=null;

        try {
            // xquery/XQueryParser.g:951:9: ( ( ATTR_SIGN )? p_NodeTest )
            // xquery/XQueryParser.g:951:11: ( ATTR_SIGN )? p_NodeTest
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:951:11: ( ATTR_SIGN )?
            var alt122=2;
            var LA122_0 = this.input.LA(1);

            if ( (LA122_0==ATTR_SIGN) ) {
                alt122=1;
            }
            switch (alt122) {
                case 1 :
                    // xquery/XQueryParser.g:951:11: ATTR_SIGN
                    ATTR_SIGN284=this.match(this.input,ATTR_SIGN,XQueryParser.FOLLOW_ATTR_SIGN_in_p_AbbrevForwardStep7070); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ATTR_SIGN284_tree = this.adaptor.create(ATTR_SIGN284);
                    this.adaptor.addChild(root_0, ATTR_SIGN284_tree);
                    }


                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_NodeTest_in_p_AbbrevForwardStep7073);
            p_NodeTest285=this.p_NodeTest();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NodeTest285.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ReverseStep_return: (function() {
        XQueryParser.p_ReverseStep_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ReverseStep_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:955:1: p_ReverseStep : ( p_ReverseAxis p_NodeTest | p_AbbrevReverseStep );
    // $ANTLR start "p_ReverseStep"
    p_ReverseStep: function() {
        var retval = new XQueryParser.p_ReverseStep_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ReverseAxis286 = null;
         var p_NodeTest287 = null;
         var p_AbbrevReverseStep288 = null;


        try {
            // xquery/XQueryParser.g:956:9: ( p_ReverseAxis p_NodeTest | p_AbbrevReverseStep )
            var alt123=2;
            var LA123_0 = this.input.LA(1);

            if ( ((LA123_0>=ANCESTOR && LA123_0<=ANCESTOR_OR_SELF)||(LA123_0>=PARENT && LA123_0<=PRECEDING_SIBLING)) ) {
                alt123=1;
            }
            else if ( (LA123_0==DOT_DOT) ) {
                alt123=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 123, 0, this.input);

                throw nvae;
            }
            switch (alt123) {
                case 1 :
                    // xquery/XQueryParser.g:956:11: p_ReverseAxis p_NodeTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ReverseAxis_in_p_ReverseStep7099);
                    p_ReverseAxis286=this.p_ReverseAxis();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ReverseAxis286.getTree());
                    this.pushFollow(XQueryParser.FOLLOW_p_NodeTest_in_p_ReverseStep7101);
                    p_NodeTest287=this.p_NodeTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NodeTest287.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:957:11: p_AbbrevReverseStep
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AbbrevReverseStep_in_p_ReverseStep7113);
                    p_AbbrevReverseStep288=this.p_AbbrevReverseStep();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AbbrevReverseStep288.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ReverseAxis_return: (function() {
        XQueryParser.p_ReverseAxis_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ReverseAxis_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:961:1: p_ReverseAxis : ( PARENT COLON_COLON | ANCESTOR COLON_COLON | PRECEDING_SIBLING COLON_COLON | PRECEDING COLON_COLON | ANCESTOR_OR_SELF COLON_COLON );
    // $ANTLR start "p_ReverseAxis"
    p_ReverseAxis: function() {
        var retval = new XQueryParser.p_ReverseAxis_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var PARENT289 = null;
        var COLON_COLON290 = null;
        var ANCESTOR291 = null;
        var COLON_COLON292 = null;
        var PRECEDING_SIBLING293 = null;
        var COLON_COLON294 = null;
        var PRECEDING295 = null;
        var COLON_COLON296 = null;
        var ANCESTOR_OR_SELF297 = null;
        var COLON_COLON298 = null;

        var PARENT289_tree=null;
        var COLON_COLON290_tree=null;
        var ANCESTOR291_tree=null;
        var COLON_COLON292_tree=null;
        var PRECEDING_SIBLING293_tree=null;
        var COLON_COLON294_tree=null;
        var PRECEDING295_tree=null;
        var COLON_COLON296_tree=null;
        var ANCESTOR_OR_SELF297_tree=null;
        var COLON_COLON298_tree=null;

        try {
            // xquery/XQueryParser.g:962:9: ( PARENT COLON_COLON | ANCESTOR COLON_COLON | PRECEDING_SIBLING COLON_COLON | PRECEDING COLON_COLON | ANCESTOR_OR_SELF COLON_COLON )
            var alt124=5;
            switch ( this.input.LA(1) ) {
            case PARENT:
                alt124=1;
                break;
            case ANCESTOR:
                alt124=2;
                break;
            case PRECEDING_SIBLING:
                alt124=3;
                break;
            case PRECEDING:
                alt124=4;
                break;
            case ANCESTOR_OR_SELF:
                alt124=5;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 124, 0, this.input);

                throw nvae;
            }

            switch (alt124) {
                case 1 :
                    // xquery/XQueryParser.g:962:11: PARENT COLON_COLON
                    root_0 = this.adaptor.nil();

                    PARENT289=this.match(this.input,PARENT,XQueryParser.FOLLOW_PARENT_in_p_ReverseAxis7139); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    PARENT289_tree = this.adaptor.create(PARENT289);
                    this.adaptor.addChild(root_0, PARENT289_tree);
                    }
                    COLON_COLON290=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ReverseAxis7141); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON290_tree = this.adaptor.create(COLON_COLON290);
                    this.adaptor.addChild(root_0, COLON_COLON290_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:963:11: ANCESTOR COLON_COLON
                    root_0 = this.adaptor.nil();

                    ANCESTOR291=this.match(this.input,ANCESTOR,XQueryParser.FOLLOW_ANCESTOR_in_p_ReverseAxis7153); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ANCESTOR291_tree = this.adaptor.create(ANCESTOR291);
                    this.adaptor.addChild(root_0, ANCESTOR291_tree);
                    }
                    COLON_COLON292=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ReverseAxis7155); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON292_tree = this.adaptor.create(COLON_COLON292);
                    this.adaptor.addChild(root_0, COLON_COLON292_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:964:11: PRECEDING_SIBLING COLON_COLON
                    root_0 = this.adaptor.nil();

                    PRECEDING_SIBLING293=this.match(this.input,PRECEDING_SIBLING,XQueryParser.FOLLOW_PRECEDING_SIBLING_in_p_ReverseAxis7167); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    PRECEDING_SIBLING293_tree = this.adaptor.create(PRECEDING_SIBLING293);
                    this.adaptor.addChild(root_0, PRECEDING_SIBLING293_tree);
                    }
                    COLON_COLON294=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ReverseAxis7169); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON294_tree = this.adaptor.create(COLON_COLON294);
                    this.adaptor.addChild(root_0, COLON_COLON294_tree);
                    }


                    break;
                case 4 :
                    // xquery/XQueryParser.g:965:11: PRECEDING COLON_COLON
                    root_0 = this.adaptor.nil();

                    PRECEDING295=this.match(this.input,PRECEDING,XQueryParser.FOLLOW_PRECEDING_in_p_ReverseAxis7181); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    PRECEDING295_tree = this.adaptor.create(PRECEDING295);
                    this.adaptor.addChild(root_0, PRECEDING295_tree);
                    }
                    COLON_COLON296=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ReverseAxis7183); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON296_tree = this.adaptor.create(COLON_COLON296);
                    this.adaptor.addChild(root_0, COLON_COLON296_tree);
                    }


                    break;
                case 5 :
                    // xquery/XQueryParser.g:966:11: ANCESTOR_OR_SELF COLON_COLON
                    root_0 = this.adaptor.nil();

                    ANCESTOR_OR_SELF297=this.match(this.input,ANCESTOR_OR_SELF,XQueryParser.FOLLOW_ANCESTOR_OR_SELF_in_p_ReverseAxis7195); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ANCESTOR_OR_SELF297_tree = this.adaptor.create(ANCESTOR_OR_SELF297);
                    this.adaptor.addChild(root_0, ANCESTOR_OR_SELF297_tree);
                    }
                    COLON_COLON298=this.match(this.input,COLON_COLON,XQueryParser.FOLLOW_COLON_COLON_in_p_ReverseAxis7197); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON_COLON298_tree = this.adaptor.create(COLON_COLON298);
                    this.adaptor.addChild(root_0, COLON_COLON298_tree);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AbbrevReverseStep_return: (function() {
        XQueryParser.p_AbbrevReverseStep_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AbbrevReverseStep_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:970:1: p_AbbrevReverseStep : DOT_DOT ;
    // $ANTLR start "p_AbbrevReverseStep"
    p_AbbrevReverseStep: function() {
        var retval = new XQueryParser.p_AbbrevReverseStep_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var DOT_DOT299 = null;

        var DOT_DOT299_tree=null;

        try {
            // xquery/XQueryParser.g:971:9: ( DOT_DOT )
            // xquery/XQueryParser.g:971:11: DOT_DOT
            root_0 = this.adaptor.nil();

            DOT_DOT299=this.match(this.input,DOT_DOT,XQueryParser.FOLLOW_DOT_DOT_in_p_AbbrevReverseStep7223); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            DOT_DOT299_tree = this.adaptor.create(DOT_DOT299);
            this.adaptor.addChild(root_0, DOT_DOT299_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NodeTest_return: (function() {
        XQueryParser.p_NodeTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NodeTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:975:1: p_NodeTest : ( p_KindTest | p_NameTest );
    // $ANTLR start "p_NodeTest"
    p_NodeTest: function() {
        var retval = new XQueryParser.p_NodeTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_KindTest300 = null;
         var p_NameTest301 = null;


        try {
            // xquery/XQueryParser.g:976:9: ( p_KindTest | p_NameTest )
            var alt125=2;
            alt125 = this.dfa125.predict(this.input);
            switch (alt125) {
                case 1 :
                    // xquery/XQueryParser.g:976:11: p_KindTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_KindTest_in_p_NodeTest7249);
                    p_KindTest300=this.p_KindTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_KindTest300.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:976:24: p_NameTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_NameTest_in_p_NodeTest7253);
                    p_NameTest301=this.p_NameTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NameTest301.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NameTest_return: (function() {
        XQueryParser.p_NameTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NameTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:980:1: p_NameTest : ( ( p_Wildcard )=> p_Wildcard | ( p_NCName COLON )=> p_QName | ( p_NCName )=> p_QName );
    // $ANTLR start "p_NameTest"
    p_NameTest: function() {
        var retval = new XQueryParser.p_NameTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Wildcard302 = null;
         var p_QName303 = null;
         var p_QName304 = null;


        try {
            // xquery/XQueryParser.g:981:9: ( ( p_Wildcard )=> p_Wildcard | ( p_NCName COLON )=> p_QName | ( p_NCName )=> p_QName )
            var alt126=3;
            var LA126_0 = this.input.LA(1);

            if ( (LA126_0==STAR) && (this.synpred13_XQueryParser())) {
                alt126=1;
            }
            else if ( ((LA126_0>=ANCESTOR && LA126_0<=SKIP)||(LA126_0>=VALUE && LA126_0<=QUOT_ER)||LA126_0==L_NCName||LA126_0==EXPLICITLY) ) {
                var LA126_2 = this.input.LA(2);

                if ( (LA126_2==COLON) && (this.synpred13_XQueryParser())) {
                    alt126=1;
                }
                else if ( (this.synpred14_XQueryParser()) ) {
                    alt126=2;
                }
                else if ( (this.synpred15_XQueryParser()) ) {
                    alt126=3;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 126, 2, this.input);

                    throw nvae;
                }
            }
            else if ( (LA126_0==QUOT) && (this.synpred13_XQueryParser())) {
                alt126=1;
            }
            else if ( (LA126_0==APOS) && (this.synpred13_XQueryParser())) {
                alt126=1;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 126, 0, this.input);

                throw nvae;
            }
            switch (alt126) {
                case 1 :
                    // xquery/XQueryParser.g:981:11: ( p_Wildcard )=> p_Wildcard
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_Wildcard_in_p_NameTest7285);
                    p_Wildcard302=this.p_Wildcard();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Wildcard302.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:982:11: ( p_NCName COLON )=> p_QName
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_NameTest7306);
                    p_QName303=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName303.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:983:11: ( p_NCName )=> p_QName
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_NameTest7324);
                    p_QName304=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName304.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Wildcard_return: (function() {
        XQueryParser.p_Wildcard_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Wildcard_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:987:1: p_Wildcard : ( STAR ( COLON p_NCName )? | p_NCName COLON STAR | p_StringLiteral COLON STAR );
    // $ANTLR start "p_Wildcard"
    p_Wildcard: function() {
        var retval = new XQueryParser.p_Wildcard_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var STAR305 = null;
        var COLON306 = null;
        var COLON309 = null;
        var STAR310 = null;
        var COLON312 = null;
        var STAR313 = null;
         var p_NCName307 = null;
         var p_NCName308 = null;
         var p_StringLiteral311 = null;

        var STAR305_tree=null;
        var COLON306_tree=null;
        var COLON309_tree=null;
        var STAR310_tree=null;
        var COLON312_tree=null;
        var STAR313_tree=null;

        this.setWsExplicit(true);
        try {
            // xquery/XQueryParser.g:988:9: ( STAR ( COLON p_NCName )? | p_NCName COLON STAR | p_StringLiteral COLON STAR )
            var alt128=3;
            switch ( this.input.LA(1) ) {
            case STAR:
                alt128=1;
                break;
            case ANCESTOR:
            case ANCESTOR_OR_SELF:
            case AND:
            case AS:
            case ASCENDING:
            case AT:
            case ATTRIBUTE:
            case BASE_URI:
            case BOUNDARY_SPACE:
            case BY:
            case CASE:
            case CAST:
            case CASTABLE:
            case CHILD:
            case COLLATION:
            case COMMENT:
            case CONSTRUCTION:
            case COPY_NAMESPACES:
            case DECLARE:
            case DEFAULT:
            case DESCENDANT:
            case DESCENDANT_OR_SELF:
            case DESCENDING:
            case DIV:
            case DOCUMENT:
            case DOCUMENT_NODE:
            case ELEMENT:
            case ELSE:
            case EMPTY:
            case EMPTY_SEQUENCE:
            case ENCODING:
            case EQ:
            case EVERY:
            case EXCEPT:
            case EXTERNAL:
            case FOLLOWING:
            case FOLLOWING_SIBLING:
            case FOR:
            case FUNCTION:
            case GE:
            case GREATEST:
            case GT:
            case IDIV:
            case IF:
            case IMPORT:
            case IN:
            case INHERIT:
            case INSTANCE:
            case INTERSECT:
            case IS:
            case ITEM:
            case LAX:
            case LE:
            case LEAST:
            case LET:
            case LT:
            case MOD:
            case MODULE:
            case NAMESPACE:
            case NE:
            case NO_INHERIT:
            case NO_PRESERVE:
            case NODE:
            case OF:
            case OPTION:
            case OR:
            case ORDER:
            case ORDERED:
            case ORDERING:
            case PARENT:
            case PRECEDING:
            case PRECEDING_SIBLING:
            case PRESERVE:
            case PROCESSING_INSTRUCTION:
            case RETURN:
            case SATISFIES:
            case SCHEMA:
            case SCHEMA_ATTRIBUTE:
            case SCHEMA_ELEMENT:
            case SELF:
            case SOME:
            case STABLE:
            case STRICT:
            case STRIP:
            case TEXT:
            case THEN:
            case TO:
            case TREAT:
            case TYPESWITCH:
            case UNION:
            case UNORDERED:
            case VALIDATE:
            case VARIABLE:
            case VERSION:
            case WHERE:
            case XQUERY:
            case ALLOWING:
            case CATCH:
            case CONTEXT:
            case COUNT:
            case DECIMAL_FORMAT:
            case DECIMAL_SEPARATOR:
            case DIGIT:
            case END:
            case GROUP:
            case GROUPING_SEPARATOR:
            case INFINITY:
            case MINUS_SIGN:
            case NAMESPACE_NODE:
            case NAN:
            case NEXT:
            case ONLY:
            case PATTERN_SEPARATOR:
            case PERCENT:
            case PER_MILLE:
            case PREVIOUS:
            case SLIDING:
            case START:
            case SWITCH:
            case TRY:
            case TUMBLING:
            case TYPE:
            case WHEN:
            case WINDOW:
            case ZERO_DIGIT:
            case AFTER:
            case BEFORE:
            case COPY:
            case DELETE:
            case FIRST:
            case INSERT:
            case INTO:
            case LAST:
            case MODIFY:
            case NODES:
            case RENAME:
            case REPLACE:
            case REVALIDATION:
            case SKIP:
            case VALUE:
            case WITH:
            case ALL:
            case ANY:
            case CONTAINS:
            case CONTENT:
            case DIACRITICS:
            case DIFFERENT:
            case DISTANCE:
            case ENTIRE:
            case EXACTLY:
            case FROM:
            case FT_OPTION:
            case FTAND:
            case FTNOT:
            case FTOR:
            case INSENSITIVE:
            case LANGUAGE:
            case LEVELS:
            case LOWERCASE:
            case MOST:
            case NO:
            case NOT:
            case OCCURS:
            case PARAGRAPH:
            case PARAGRAPHS:
            case PHRASE:
            case RELATIONSHIP:
            case SAME:
            case SCORE:
            case SENSITIVE:
            case SENTENCE:
            case SENTENCES:
            case STEMMING:
            case STOP:
            case THESAURUS:
            case TIMES:
            case UPPERCASE:
            case USING:
            case WEIGHT:
            case WILDCARDS:
            case WITHOUT:
            case WORD:
            case WORDS:
            case BREAK:
            case CONTINUE:
            case EXIT:
            case LOOP:
            case RETURNING:
            case WHILE:
            case CHECK:
            case COLLECTION:
            case CONSTRAINT:
            case FOREACH:
            case FOREIGN:
            case INDEX:
            case INTEGRITY:
            case KEY:
            case ON:
            case UNIQUE:
            case BINARY:
            case AMP_ER:
            case APOS_ER:
            case QUOT_ER:
            case L_NCName:
            case EXPLICITLY:
                alt128=2;
                break;
            case APOS:
            case QUOT:
                alt128=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 128, 0, this.input);

                throw nvae;
            }

            switch (alt128) {
                case 1 :
                    // xquery/XQueryParser.g:988:11: STAR ( COLON p_NCName )?
                    root_0 = this.adaptor.nil();

                    STAR305=this.match(this.input,STAR,XQueryParser.FOLLOW_STAR_in_p_Wildcard7354); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    STAR305_tree = this.adaptor.create(STAR305);
                    this.adaptor.addChild(root_0, STAR305_tree);
                    }
                    // xquery/XQueryParser.g:988:16: ( COLON p_NCName )?
                    var alt127=2;
                    var LA127_0 = this.input.LA(1);

                    if ( (LA127_0==COLON) ) {
                        alt127=1;
                    }
                    switch (alt127) {
                        case 1 :
                            // xquery/XQueryParser.g:988:17: COLON p_NCName
                            COLON306=this.match(this.input,COLON,XQueryParser.FOLLOW_COLON_in_p_Wildcard7357); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COLON306_tree = this.adaptor.create(COLON306);
                            this.adaptor.addChild(root_0, COLON306_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_p_Wildcard7359);
                            p_NCName307=this.p_NCName();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NCName307.getTree());


                            break;

                    }



                    break;
                case 2 :
                    // xquery/XQueryParser.g:989:11: p_NCName COLON STAR
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_p_Wildcard7373);
                    p_NCName308=this.p_NCName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NCName308.getTree());
                    COLON309=this.match(this.input,COLON,XQueryParser.FOLLOW_COLON_in_p_Wildcard7375); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON309_tree = this.adaptor.create(COLON309);
                    this.adaptor.addChild(root_0, COLON309_tree);
                    }
                    STAR310=this.match(this.input,STAR,XQueryParser.FOLLOW_STAR_in_p_Wildcard7377); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    STAR310_tree = this.adaptor.create(STAR310);
                    this.adaptor.addChild(root_0, STAR310_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:990:11: p_StringLiteral COLON STAR
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_Wildcard7389);
                    p_StringLiteral311=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral311.getTree());
                    COLON312=this.match(this.input,COLON,XQueryParser.FOLLOW_COLON_in_p_Wildcard7391); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COLON312_tree = this.adaptor.create(COLON312);
                    this.adaptor.addChild(root_0, COLON312_tree);
                    }
                    STAR313=this.match(this.input,STAR,XQueryParser.FOLLOW_STAR_in_p_Wildcard7393); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    STAR313_tree = this.adaptor.create(STAR313);
                    this.adaptor.addChild(root_0, STAR313_tree);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
            this.setWsExplicit(false);
        }
        return retval;
    },

    // inline static return class
    p_PostfixExpr_return: (function() {
        XQueryParser.p_PostfixExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PostfixExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:995:1: p_PostfixExpr : p_PrimaryExpr ( p_Predicate )* ;
    // $ANTLR start "p_PostfixExpr"
    p_PostfixExpr: function() {
        var retval = new XQueryParser.p_PostfixExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_PrimaryExpr314 = null;
         var p_Predicate315 = null;


        try {
            // xquery/XQueryParser.g:996:9: ( p_PrimaryExpr ( p_Predicate )* )
            // xquery/XQueryParser.g:996:11: p_PrimaryExpr ( p_Predicate )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_PrimaryExpr_in_p_PostfixExpr7431);
            p_PrimaryExpr314=this.p_PrimaryExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PrimaryExpr314.getTree());
            // xquery/XQueryParser.g:996:25: ( p_Predicate )*
            loop129:
            do {
                var alt129=2;
                var LA129_0 = this.input.LA(1);

                if ( (LA129_0==LSQUARE) ) {
                    alt129=1;
                }


                switch (alt129) {
                case 1 :
                    // xquery/XQueryParser.g:996:26: p_Predicate
                    this.pushFollow(XQueryParser.FOLLOW_p_Predicate_in_p_PostfixExpr7434);
                    p_Predicate315=this.p_Predicate();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Predicate315.getTree());


                    break;

                default :
                    break loop129;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ArgumentList_return: (function() {
        XQueryParser.p_ArgumentList_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ArgumentList_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1003:1: p_ArgumentList : LPAREN ( p_Argument ( COMMA p_Argument )* )? RPAREN ;
    // $ANTLR start "p_ArgumentList"
    p_ArgumentList: function() {
        var retval = new XQueryParser.p_ArgumentList_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LPAREN316 = null;
        var COMMA318 = null;
        var RPAREN320 = null;
         var p_Argument317 = null;
         var p_Argument319 = null;

        var LPAREN316_tree=null;
        var COMMA318_tree=null;
        var RPAREN320_tree=null;

        try {
            // xquery/XQueryParser.g:1004:9: ( LPAREN ( p_Argument ( COMMA p_Argument )* )? RPAREN )
            // xquery/XQueryParser.g:1004:11: LPAREN ( p_Argument ( COMMA p_Argument )* )? RPAREN
            root_0 = this.adaptor.nil();

            LPAREN316=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_ArgumentList7475); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN316_tree = this.adaptor.create(LPAREN316);
            this.adaptor.addChild(root_0, LPAREN316_tree);
            }
            // xquery/XQueryParser.g:1004:18: ( p_Argument ( COMMA p_Argument )* )?
            var alt131=2;
            var LA131_0 = this.input.LA(1);

            if ( ((LA131_0>=ANCESTOR && LA131_0<=QUOT_ER)||LA131_0==LPAREN||(LA131_0>=DOLLAR && LA131_0<=LBRACKET)||(LA131_0>=QUESTION && LA131_0<=SMALLER)||(LA131_0>=SLASH && LA131_0<=DOT_DOT)||LA131_0==ATTR_SIGN||(LA131_0>=APOS && LA131_0<=QUOT)||LA131_0==L_NCName||(LA131_0>=L_Pragma && LA131_0<=L_DoubleLiteral)||LA131_0==EXPLICITLY) ) {
                alt131=1;
            }
            switch (alt131) {
                case 1 :
                    // xquery/XQueryParser.g:1004:19: p_Argument ( COMMA p_Argument )*
                    this.pushFollow(XQueryParser.FOLLOW_p_Argument_in_p_ArgumentList7478);
                    p_Argument317=this.p_Argument();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Argument317.getTree());
                    // xquery/XQueryParser.g:1004:30: ( COMMA p_Argument )*
                    loop130:
                    do {
                        var alt130=2;
                        var LA130_0 = this.input.LA(1);

                        if ( (LA130_0==COMMA) ) {
                            alt130=1;
                        }


                        switch (alt130) {
                        case 1 :
                            // xquery/XQueryParser.g:1004:31: COMMA p_Argument
                            COMMA318=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_ArgumentList7481); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COMMA318_tree = this.adaptor.create(COMMA318);
                            this.adaptor.addChild(root_0, COMMA318_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_Argument_in_p_ArgumentList7483);
                            p_Argument319=this.p_Argument();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Argument319.getTree());


                            break;

                        default :
                            break loop130;
                        }
                    } while (true);



                    break;

            }

            RPAREN320=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_ArgumentList7489); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN320_tree = this.adaptor.create(RPAREN320);
            this.adaptor.addChild(root_0, RPAREN320_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PredicateList_return: (function() {
        XQueryParser.p_PredicateList_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PredicateList_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1008:1: p_PredicateList : ( p_Predicate )* ;
    // $ANTLR start "p_PredicateList"
    p_PredicateList: function() {
        var retval = new XQueryParser.p_PredicateList_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Predicate321 = null;


        try {
            // xquery/XQueryParser.g:1009:9: ( ( p_Predicate )* )
            // xquery/XQueryParser.g:1009:11: ( p_Predicate )*
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1009:11: ( p_Predicate )*
            loop132:
            do {
                var alt132=2;
                var LA132_0 = this.input.LA(1);

                if ( (LA132_0==LSQUARE) ) {
                    alt132=1;
                }


                switch (alt132) {
                case 1 :
                    // xquery/XQueryParser.g:1009:11: p_Predicate
                    this.pushFollow(XQueryParser.FOLLOW_p_Predicate_in_p_PredicateList7515);
                    p_Predicate321=this.p_Predicate();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Predicate321.getTree());


                    break;

                default :
                    break loop132;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Predicate_return: (function() {
        XQueryParser.p_Predicate_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Predicate_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1013:1: p_Predicate : LSQUARE p_Expr[true,true] RSQUARE ;
    // $ANTLR start "p_Predicate"
    p_Predicate: function() {
        var retval = new XQueryParser.p_Predicate_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LSQUARE322 = null;
        var RSQUARE324 = null;
         var p_Expr323 = null;

        var LSQUARE322_tree=null;
        var RSQUARE324_tree=null;

        try {
            // xquery/XQueryParser.g:1014:9: ( LSQUARE p_Expr[true,true] RSQUARE )
            // xquery/XQueryParser.g:1014:11: LSQUARE p_Expr[true,true] RSQUARE
            root_0 = this.adaptor.nil();

            LSQUARE322=this.match(this.input,LSQUARE,XQueryParser.FOLLOW_LSQUARE_in_p_Predicate7542); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LSQUARE322_tree = this.adaptor.create(LSQUARE322);
            this.adaptor.addChild(root_0, LSQUARE322_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_Predicate7544);
            p_Expr323=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr323.getTree());
            RSQUARE324=this.match(this.input,RSQUARE,XQueryParser.FOLLOW_RSQUARE_in_p_Predicate7547); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RSQUARE324_tree = this.adaptor.create(RSQUARE324);
            this.adaptor.addChild(root_0, RSQUARE324_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PrimaryExpr_return: (function() {
        XQueryParser.p_PrimaryExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PrimaryExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1019:1: p_PrimaryExpr : ( ( LPAREN )=> p_ParenthesizedExpr | p_Literal | p_VarRef | p_ContextItemExpr | p_FunctionCall | p_OrderedExpr | p_UnorderedExpr | p_Constructor | p_BlockExpr );
    // $ANTLR start "p_PrimaryExpr"
    p_PrimaryExpr: function() {
        var retval = new XQueryParser.p_PrimaryExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ParenthesizedExpr325 = null;
         var p_Literal326 = null;
         var p_VarRef327 = null;
         var p_ContextItemExpr328 = null;
         var p_FunctionCall329 = null;
         var p_OrderedExpr330 = null;
         var p_UnorderedExpr331 = null;
         var p_Constructor332 = null;
         var p_BlockExpr333 = null;


        try {
            // xquery/XQueryParser.g:1020:9: ( ( LPAREN )=> p_ParenthesizedExpr | p_Literal | p_VarRef | p_ContextItemExpr | p_FunctionCall | p_OrderedExpr | p_UnorderedExpr | p_Constructor | p_BlockExpr )
            var alt133=9;
            alt133 = this.dfa133.predict(this.input);
            switch (alt133) {
                case 1 :
                    // xquery/XQueryParser.g:1020:11: ( LPAREN )=> p_ParenthesizedExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ParenthesizedExpr_in_p_PrimaryExpr7580);
                    p_ParenthesizedExpr325=this.p_ParenthesizedExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ParenthesizedExpr325.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1021:11: p_Literal
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_Literal_in_p_PrimaryExpr7592);
                    p_Literal326=this.p_Literal();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Literal326.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1022:11: p_VarRef
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_VarRef_in_p_PrimaryExpr7604);
                    p_VarRef327=this.p_VarRef();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_VarRef327.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1023:11: p_ContextItemExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ContextItemExpr_in_p_PrimaryExpr7616);
                    p_ContextItemExpr328=this.p_ContextItemExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ContextItemExpr328.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1024:11: p_FunctionCall
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FunctionCall_in_p_PrimaryExpr7628);
                    p_FunctionCall329=this.p_FunctionCall();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FunctionCall329.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:1025:11: p_OrderedExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_OrderedExpr_in_p_PrimaryExpr7640);
                    p_OrderedExpr330=this.p_OrderedExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OrderedExpr330.getTree());


                    break;
                case 7 :
                    // xquery/XQueryParser.g:1026:11: p_UnorderedExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_UnorderedExpr_in_p_PrimaryExpr7652);
                    p_UnorderedExpr331=this.p_UnorderedExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_UnorderedExpr331.getTree());


                    break;
                case 8 :
                    // xquery/XQueryParser.g:1027:11: p_Constructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_Constructor_in_p_PrimaryExpr7664);
                    p_Constructor332=this.p_Constructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Constructor332.getTree());


                    break;
                case 9 :
                    // xquery/XQueryParser.g:1030:11: p_BlockExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_BlockExpr_in_p_PrimaryExpr7678);
                    p_BlockExpr333=this.p_BlockExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_BlockExpr333.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Literal_return: (function() {
        XQueryParser.p_Literal_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Literal_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1034:1: p_Literal : ( p_NumericLiteral | p_StringLiteral );
    // $ANTLR start "p_Literal"
    p_Literal: function() {
        var retval = new XQueryParser.p_Literal_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_NumericLiteral334 = null;
         var p_StringLiteral335 = null;


        try {
            // xquery/XQueryParser.g:1035:9: ( p_NumericLiteral | p_StringLiteral )
            var alt134=2;
            var LA134_0 = this.input.LA(1);

            if ( ((LA134_0>=L_IntegerLiteral && LA134_0<=L_DoubleLiteral)) ) {
                alt134=1;
            }
            else if ( ((LA134_0>=APOS && LA134_0<=QUOT)) ) {
                alt134=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 134, 0, this.input);

                throw nvae;
            }
            switch (alt134) {
                case 1 :
                    // xquery/XQueryParser.g:1035:11: p_NumericLiteral
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_NumericLiteral_in_p_Literal7704);
                    p_NumericLiteral334=this.p_NumericLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NumericLiteral334.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1035:30: p_StringLiteral
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_Literal7708);
                    p_StringLiteral335=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral335.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NumericLiteral_return: (function() {
        XQueryParser.p_NumericLiteral_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NumericLiteral_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1039:1: p_NumericLiteral : (d+= L_IntegerLiteral | d+= L_DecimalLiteral | d+= L_DoubleLiteral );
    // $ANTLR start "p_NumericLiteral"
    p_NumericLiteral: function() {
        var retval = new XQueryParser.p_NumericLiteral_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
        var list_d=null;

        var d_tree=null;

        try {
            // xquery/XQueryParser.g:1040:9: (d+= L_IntegerLiteral | d+= L_DecimalLiteral | d+= L_DoubleLiteral )
            var alt135=3;
            switch ( this.input.LA(1) ) {
            case L_IntegerLiteral:
                alt135=1;
                break;
            case L_DecimalLiteral:
                alt135=2;
                break;
            case L_DoubleLiteral:
                alt135=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 135, 0, this.input);

                throw nvae;
            }

            switch (alt135) {
                case 1 :
                    // xquery/XQueryParser.g:1040:11: d+= L_IntegerLiteral
                    root_0 = this.adaptor.nil();

                    d=this.match(this.input,L_IntegerLiteral,XQueryParser.FOLLOW_L_IntegerLiteral_in_p_NumericLiteral7736); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    if (org.antlr.lang.isNull(list_d)) list_d = [];
                    list_d.push(d);

                    if ( this.state.backtracking===0 ) {
                      this.ad(list_d);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1040:48: d+= L_DecimalLiteral
                    root_0 = this.adaptor.nil();

                    d=this.match(this.input,L_DecimalLiteral,XQueryParser.FOLLOW_L_DecimalLiteral_in_p_NumericLiteral7744); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    if (org.antlr.lang.isNull(list_d)) list_d = [];
                    list_d.push(d);

                    if ( this.state.backtracking===0 ) {
                      this.ad(list_d);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1040:85: d+= L_DoubleLiteral
                    root_0 = this.adaptor.nil();

                    d=this.match(this.input,L_DoubleLiteral,XQueryParser.FOLLOW_L_DoubleLiteral_in_p_NumericLiteral7752); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    if (org.antlr.lang.isNull(list_d)) list_d = [];
                    list_d.push(d);

                    if ( this.state.backtracking===0 ) {
                      this.ad(list_d);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_VarRef_return: (function() {
        XQueryParser.p_VarRef_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_VarRef_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1044:1: p_VarRef : d= DOLLAR v= p_VarName ;
    // $ANTLR start "p_VarRef"
    p_VarRef: function() {
        var retval = new XQueryParser.p_VarRef_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
         var v = null;

        var d_tree=null;

        try {
            // xquery/XQueryParser.g:1045:9: (d= DOLLAR v= p_VarName )
            // xquery/XQueryParser.g:1045:11: d= DOLLAR v= p_VarName
            root_0 = this.adaptor.nil();

            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_VarRef7790); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_VarRef7794);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_VarName_return: (function() {
        XQueryParser.p_VarName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_VarName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1049:1: p_VarName : p_QName ;
    // $ANTLR start "p_VarName"
    p_VarName: function() {
        var retval = new XQueryParser.p_VarName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName336 = null;


        try {
            // xquery/XQueryParser.g:1050:9: ( p_QName )
            // xquery/XQueryParser.g:1050:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_VarName7822);
            p_QName336=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName336.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ParenthesizedExpr_return: (function() {
        XQueryParser.p_ParenthesizedExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ParenthesizedExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1054:1: p_ParenthesizedExpr : LPAREN ( p_Expr[true,true] )? RPAREN ;
    // $ANTLR start "p_ParenthesizedExpr"
    p_ParenthesizedExpr: function() {
        var retval = new XQueryParser.p_ParenthesizedExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LPAREN337 = null;
        var RPAREN339 = null;
         var p_Expr338 = null;

        var LPAREN337_tree=null;
        var RPAREN339_tree=null;

        try {
            // xquery/XQueryParser.g:1055:9: ( LPAREN ( p_Expr[true,true] )? RPAREN )
            // xquery/XQueryParser.g:1055:11: LPAREN ( p_Expr[true,true] )? RPAREN
            root_0 = this.adaptor.nil();

            LPAREN337=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_ParenthesizedExpr7848); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN337_tree = this.adaptor.create(LPAREN337);
            this.adaptor.addChild(root_0, LPAREN337_tree);
            }
            // xquery/XQueryParser.g:1055:18: ( p_Expr[true,true] )?
            var alt136=2;
            var LA136_0 = this.input.LA(1);

            if ( ((LA136_0>=ANCESTOR && LA136_0<=QUOT_ER)||LA136_0==LPAREN||(LA136_0>=DOLLAR && LA136_0<=LBRACKET)||(LA136_0>=STAR && LA136_0<=SMALLER)||(LA136_0>=SLASH && LA136_0<=DOT_DOT)||LA136_0==ATTR_SIGN||(LA136_0>=APOS && LA136_0<=QUOT)||LA136_0==L_NCName||(LA136_0>=L_Pragma && LA136_0<=L_DoubleLiteral)||LA136_0==EXPLICITLY) ) {
                alt136=1;
            }
            switch (alt136) {
                case 1 :
                    // xquery/XQueryParser.g:1055:18: p_Expr[true,true]
                    this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_ParenthesizedExpr7850);
                    p_Expr338=this.p_Expr(true, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr338.getTree());


                    break;

            }

            RPAREN339=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_ParenthesizedExpr7854); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN339_tree = this.adaptor.create(RPAREN339);
            this.adaptor.addChild(root_0, RPAREN339_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ContextItemExpr_return: (function() {
        XQueryParser.p_ContextItemExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ContextItemExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1059:1: p_ContextItemExpr : DOT ;
    // $ANTLR start "p_ContextItemExpr"
    p_ContextItemExpr: function() {
        var retval = new XQueryParser.p_ContextItemExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var DOT340 = null;

        var DOT340_tree=null;

        try {
            // xquery/XQueryParser.g:1060:9: ( DOT )
            // xquery/XQueryParser.g:1060:11: DOT
            root_0 = this.adaptor.nil();

            DOT340=this.match(this.input,DOT,XQueryParser.FOLLOW_DOT_in_p_ContextItemExpr7880); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            DOT340_tree = this.adaptor.create(DOT340);
            this.adaptor.addChild(root_0, DOT340_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_OrderedExpr_return: (function() {
        XQueryParser.p_OrderedExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_OrderedExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1064:1: p_OrderedExpr : k= ORDERED LBRACKET p_Expr[true,true] RBRACKET ;
    // $ANTLR start "p_OrderedExpr"
    p_OrderedExpr: function() {
        var retval = new XQueryParser.p_OrderedExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET341 = null;
        var RBRACKET343 = null;
         var p_Expr342 = null;

        var k_tree=null;
        var LBRACKET341_tree=null;
        var RBRACKET343_tree=null;

        try {
            // xquery/XQueryParser.g:1065:9: (k= ORDERED LBRACKET p_Expr[true,true] RBRACKET )
            // xquery/XQueryParser.g:1065:11: k= ORDERED LBRACKET p_Expr[true,true] RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,ORDERED,XQueryParser.FOLLOW_ORDERED_in_p_OrderedExpr7908); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LBRACKET341=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_OrderedExpr7912); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET341_tree = this.adaptor.create(LBRACKET341);
            this.adaptor.addChild(root_0, LBRACKET341_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_OrderedExpr7914);
            p_Expr342=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr342.getTree());
            RBRACKET343=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_OrderedExpr7917); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET343_tree = this.adaptor.create(RBRACKET343);
            this.adaptor.addChild(root_0, RBRACKET343_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_UnorderedExpr_return: (function() {
        XQueryParser.p_UnorderedExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_UnorderedExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1069:1: p_UnorderedExpr : k= UNORDERED LBRACKET p_Expr[true,true] RBRACKET ;
    // $ANTLR start "p_UnorderedExpr"
    p_UnorderedExpr: function() {
        var retval = new XQueryParser.p_UnorderedExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET344 = null;
        var RBRACKET346 = null;
         var p_Expr345 = null;

        var k_tree=null;
        var LBRACKET344_tree=null;
        var RBRACKET346_tree=null;

        try {
            // xquery/XQueryParser.g:1070:9: (k= UNORDERED LBRACKET p_Expr[true,true] RBRACKET )
            // xquery/XQueryParser.g:1070:11: k= UNORDERED LBRACKET p_Expr[true,true] RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,UNORDERED,XQueryParser.FOLLOW_UNORDERED_in_p_UnorderedExpr7945); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LBRACKET344=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_UnorderedExpr7949); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET344_tree = this.adaptor.create(LBRACKET344);
            this.adaptor.addChild(root_0, LBRACKET344_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_UnorderedExpr7951);
            p_Expr345=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr345.getTree());
            RBRACKET346=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_UnorderedExpr7954); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET346_tree = this.adaptor.create(RBRACKET346);
            this.adaptor.addChild(root_0, RBRACKET346_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FunctionCall_return: (function() {
        XQueryParser.p_FunctionCall_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FunctionCall_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1075:1: p_FunctionCall : f= pg_FQName p_ArgumentList ;
    // $ANTLR start "p_FunctionCall"
    p_FunctionCall: function() {
        var retval = new XQueryParser.p_FunctionCall_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var f = null;
         var p_ArgumentList347 = null;


        try {
            // xquery/XQueryParser.g:1076:9: (f= pg_FQName p_ArgumentList )
            // xquery/XQueryParser.g:1076:11: f= pg_FQName p_ArgumentList
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_pg_FQName_in_p_FunctionCall7983);
            f=this.pg_FQName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, f.getTree());
            if ( this.state.backtracking===0 ) {
              this.af((f?f.start:null), (f?f.stop:null));
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ArgumentList_in_p_FunctionCall7988);
            p_ArgumentList347=this.p_ArgumentList();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ArgumentList347.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Argument_return: (function() {
        XQueryParser.p_Argument_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Argument_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1080:1: p_Argument : ( p_ExprSingle[true] | p_ArgumentPlaceholder );
    // $ANTLR start "p_Argument"
    p_Argument: function() {
        var retval = new XQueryParser.p_Argument_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle348 = null;
         var p_ArgumentPlaceholder349 = null;


        try {
            // xquery/XQueryParser.g:1081:9: ( p_ExprSingle[true] | p_ArgumentPlaceholder )
            var alt137=2;
            var LA137_0 = this.input.LA(1);

            if ( ((LA137_0>=ANCESTOR && LA137_0<=QUOT_ER)||LA137_0==LPAREN||(LA137_0>=DOLLAR && LA137_0<=LBRACKET)||(LA137_0>=STAR && LA137_0<=SMALLER)||(LA137_0>=SLASH && LA137_0<=DOT_DOT)||LA137_0==ATTR_SIGN||(LA137_0>=APOS && LA137_0<=QUOT)||LA137_0==L_NCName||(LA137_0>=L_Pragma && LA137_0<=L_DoubleLiteral)||LA137_0==EXPLICITLY) ) {
                alt137=1;
            }
            else if ( (LA137_0==QUESTION) ) {
                alt137=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 137, 0, this.input);

                throw nvae;
            }
            switch (alt137) {
                case 1 :
                    // xquery/XQueryParser.g:1081:11: p_ExprSingle[true]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_Argument8014);
                    p_ExprSingle348=this.p_ExprSingle(true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle348.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1081:32: p_ArgumentPlaceholder
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ArgumentPlaceholder_in_p_Argument8019);
                    p_ArgumentPlaceholder349=this.p_ArgumentPlaceholder();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ArgumentPlaceholder349.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ArgumentPlaceholder_return: (function() {
        XQueryParser.p_ArgumentPlaceholder_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ArgumentPlaceholder_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1085:1: p_ArgumentPlaceholder : QUESTION ;
    // $ANTLR start "p_ArgumentPlaceholder"
    p_ArgumentPlaceholder: function() {
        var retval = new XQueryParser.p_ArgumentPlaceholder_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var QUESTION350 = null;

        var QUESTION350_tree=null;

        try {
            // xquery/XQueryParser.g:1086:9: ( QUESTION )
            // xquery/XQueryParser.g:1086:11: QUESTION
            root_0 = this.adaptor.nil();

            QUESTION350=this.match(this.input,QUESTION,XQueryParser.FOLLOW_QUESTION_in_p_ArgumentPlaceholder8045); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            QUESTION350_tree = this.adaptor.create(QUESTION350);
            this.adaptor.addChild(root_0, QUESTION350_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Constructor_return: (function() {
        XQueryParser.p_Constructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Constructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1090:1: p_Constructor : ( p_DirectConstructor | p_ComputedConstructor );
    // $ANTLR start "p_Constructor"
    p_Constructor: function() {
        var retval = new XQueryParser.p_Constructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_DirectConstructor351 = null;
         var p_ComputedConstructor352 = null;


        try {
            // xquery/XQueryParser.g:1091:9: ( p_DirectConstructor | p_ComputedConstructor )
            var alt138=2;
            var LA138_0 = this.input.LA(1);

            if ( (LA138_0==SMALLER||(LA138_0>=L_DirCommentConstructor && LA138_0<=L_DirPIConstructor)) ) {
                alt138=1;
            }
            else if ( (LA138_0==ATTRIBUTE||LA138_0==COMMENT||LA138_0==DOCUMENT||LA138_0==ELEMENT||LA138_0==NAMESPACE||LA138_0==PROCESSING_INSTRUCTION||LA138_0==TEXT) ) {
                alt138=2;
            }
            else if ( (LA138_0==BINARY) && ((this.lc(MLS)))) {
                alt138=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 138, 0, this.input);

                throw nvae;
            }
            switch (alt138) {
                case 1 :
                    // xquery/XQueryParser.g:1091:11: p_DirectConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_DirectConstructor_in_p_Constructor8071);
                    p_DirectConstructor351=this.p_DirectConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DirectConstructor351.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1092:11: p_ComputedConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ComputedConstructor_in_p_Constructor8083);
                    p_ComputedConstructor352=this.p_ComputedConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ComputedConstructor352.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DirectConstructor_return: (function() {
        XQueryParser.p_DirectConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DirectConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1096:1: p_DirectConstructor : ( p_DirElemConstructor | p_DirCommentConstructor | p_DirPIConstructor );
    // $ANTLR start "p_DirectConstructor"
    p_DirectConstructor: function() {
        var retval = new XQueryParser.p_DirectConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_DirElemConstructor353 = null;
         var p_DirCommentConstructor354 = null;
         var p_DirPIConstructor355 = null;


        try {
            // xquery/XQueryParser.g:1097:9: ( p_DirElemConstructor | p_DirCommentConstructor | p_DirPIConstructor )
            var alt139=3;
            switch ( this.input.LA(1) ) {
            case SMALLER:
                alt139=1;
                break;
            case L_DirCommentConstructor:
                alt139=2;
                break;
            case L_DirPIConstructor:
                alt139=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 139, 0, this.input);

                throw nvae;
            }

            switch (alt139) {
                case 1 :
                    // xquery/XQueryParser.g:1097:11: p_DirElemConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_DirElemConstructor_in_p_DirectConstructor8109);
                    p_DirElemConstructor353=this.p_DirElemConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DirElemConstructor353.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1098:11: p_DirCommentConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_DirCommentConstructor_in_p_DirectConstructor8121);
                    p_DirCommentConstructor354=this.p_DirCommentConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DirCommentConstructor354.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1099:11: p_DirPIConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_DirPIConstructor_in_p_DirectConstructor8133);
                    p_DirPIConstructor355=this.p_DirPIConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DirPIConstructor355.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DirElemConstructor_return: (function() {
        XQueryParser.p_DirElemConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DirElemConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1103:1: p_DirElemConstructor : SMALLER ts= p_QName p_DirAttributeList ( EMPTY_CLOSE_TAG | ( GREATER ( pm_DirElemContent )* CLOSE_TAG te= p_QName ( S )? GREATER ) ) -> ^( DirElemConstructor ^( DirAttributeList ( p_DirAttributeList )* ) ^( DirElemContent ( pm_DirElemContent )* ) ) ;
    // $ANTLR start "p_DirElemConstructor"
    p_DirElemConstructor: function() {
        var retval = new XQueryParser.p_DirElemConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SMALLER356 = null;
        var EMPTY_CLOSE_TAG358 = null;
        var GREATER359 = null;
        var CLOSE_TAG361 = null;
        var S362 = null;
        var GREATER363 = null;
         var ts = null;
         var te = null;
         var p_DirAttributeList357 = null;
         var pm_DirElemContent360 = null;

        var SMALLER356_tree=null;
        var EMPTY_CLOSE_TAG358_tree=null;
        var GREATER359_tree=null;
        var CLOSE_TAG361_tree=null;
        var S362_tree=null;
        var GREATER363_tree=null;
        var stream_CLOSE_TAG=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token CLOSE_TAG");
        var stream_GREATER=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token GREATER");
        var stream_S=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token S");
        var stream_EMPTY_CLOSE_TAG=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EMPTY_CLOSE_TAG");
        var stream_SMALLER=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token SMALLER");
        var stream_p_DirAttributeList=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_DirAttributeList");
        var stream_pm_DirElemContent=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pm_DirElemContent");
        var stream_p_QName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_QName");
        try {
            // xquery/XQueryParser.g:1104:9: ( SMALLER ts= p_QName p_DirAttributeList ( EMPTY_CLOSE_TAG | ( GREATER ( pm_DirElemContent )* CLOSE_TAG te= p_QName ( S )? GREATER ) ) -> ^( DirElemConstructor ^( DirAttributeList ( p_DirAttributeList )* ) ^( DirElemContent ( pm_DirElemContent )* ) ) )
            // xquery/XQueryParser.g:1104:11: SMALLER ts= p_QName p_DirAttributeList ( EMPTY_CLOSE_TAG | ( GREATER ( pm_DirElemContent )* CLOSE_TAG te= p_QName ( S )? GREATER ) )
            SMALLER356=this.match(this.input,SMALLER,XQueryParser.FOLLOW_SMALLER_in_p_DirElemConstructor8160); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_SMALLER.add(SMALLER356);

            if ( this.state.backtracking===0 ) {
              this.pushXMLLexer();
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_DirElemConstructor8176);
            ts=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_QName.add(ts.getTree());
            if ( this.state.backtracking===0 ) {
              this.at((ts?ts.start:null), (ts?ts.stop:null));
            }
            this.pushFollow(XQueryParser.FOLLOW_p_DirAttributeList_in_p_DirElemConstructor8181);
            p_DirAttributeList357=this.p_DirAttributeList();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_DirAttributeList.add(p_DirAttributeList357.getTree());
            // xquery/XQueryParser.g:1106:11: ( EMPTY_CLOSE_TAG | ( GREATER ( pm_DirElemContent )* CLOSE_TAG te= p_QName ( S )? GREATER ) )
            var alt142=2;
            var LA142_0 = this.input.LA(1);

            if ( (LA142_0==EMPTY_CLOSE_TAG) ) {
                alt142=1;
            }
            else if ( (LA142_0==GREATER) ) {
                alt142=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 142, 0, this.input);

                throw nvae;
            }
            switch (alt142) {
                case 1 :
                    // xquery/XQueryParser.g:1106:12: EMPTY_CLOSE_TAG
                    EMPTY_CLOSE_TAG358=this.match(this.input,EMPTY_CLOSE_TAG,XQueryParser.FOLLOW_EMPTY_CLOSE_TAG_in_p_DirElemConstructor8195); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_EMPTY_CLOSE_TAG.add(EMPTY_CLOSE_TAG358);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1106:30: ( GREATER ( pm_DirElemContent )* CLOSE_TAG te= p_QName ( S )? GREATER )
                    // xquery/XQueryParser.g:1106:30: ( GREATER ( pm_DirElemContent )* CLOSE_TAG te= p_QName ( S )? GREATER )
                    // xquery/XQueryParser.g:1106:31: GREATER ( pm_DirElemContent )* CLOSE_TAG te= p_QName ( S )? GREATER
                    GREATER359=this.match(this.input,GREATER,XQueryParser.FOLLOW_GREATER_in_p_DirElemConstructor8200); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_GREATER.add(GREATER359);

                    // xquery/XQueryParser.g:1106:39: ( pm_DirElemContent )*
                    loop140:
                    do {
                        var alt140=2;
                        var LA140_0 = this.input.LA(1);

                        if ( ((LA140_0>=L_ElementContentChar && LA140_0<=ESCAPE_RBRACKET)||LA140_0==LBRACKET||LA140_0==SMALLER||(LA140_0>=L_DirCommentConstructor && LA140_0<=L_DirPIConstructor)) ) {
                            alt140=1;
                        }


                        switch (alt140) {
                        case 1 :
                            // xquery/XQueryParser.g:1106:39: pm_DirElemContent
                            this.pushFollow(XQueryParser.FOLLOW_pm_DirElemContent_in_p_DirElemConstructor8202);
                            pm_DirElemContent360=this.pm_DirElemContent();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_pm_DirElemContent.add(pm_DirElemContent360.getTree());


                            break;

                        default :
                            break loop140;
                        }
                    } while (true);

                    CLOSE_TAG361=this.match(this.input,CLOSE_TAG,XQueryParser.FOLLOW_CLOSE_TAG_in_p_DirElemConstructor8205); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_CLOSE_TAG.add(CLOSE_TAG361);

                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_DirElemConstructor8209);
                    te=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_QName.add(te.getTree());
                    if ( this.state.backtracking===0 ) {
                      this.at((te?te.start:null), (te?te.stop:null));
                    }
                    // xquery/XQueryParser.g:1106:111: ( S )?
                    var alt141=2;
                    var LA141_0 = this.input.LA(1);

                    if ( (LA141_0==S) ) {
                        alt141=1;
                    }
                    switch (alt141) {
                        case 1 :
                            // xquery/XQueryParser.g:1106:111: S
                            S362=this.match(this.input,S,XQueryParser.FOLLOW_S_in_p_DirElemConstructor8213); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_S.add(S362);



                            break;

                    }

                    GREATER363=this.match(this.input,GREATER,XQueryParser.FOLLOW_GREATER_in_p_DirElemConstructor8216); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_GREATER.add(GREATER363);






                    break;

            }



            // AST REWRITE
            // elements: p_DirAttributeList, pm_DirElemContent
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 1107:17: -> ^( DirElemConstructor ^( DirAttributeList ( p_DirAttributeList )* ) ^( DirElemContent ( pm_DirElemContent )* ) )
            {
                // xquery/XQueryParser.g:1107:20: ^( DirElemConstructor ^( DirAttributeList ( p_DirAttributeList )* ) ^( DirElemContent ( pm_DirElemContent )* ) )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(DirElemConstructor, "DirElemConstructor"), root_1);

                // xquery/XQueryParser.g:1107:41: ^( DirAttributeList ( p_DirAttributeList )* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(DirAttributeList, "DirAttributeList"), root_2);

                // xquery/XQueryParser.g:1107:60: ( p_DirAttributeList )*
                while ( stream_p_DirAttributeList.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_p_DirAttributeList.nextTree());

                }
                stream_p_DirAttributeList.reset();

                this.adaptor.addChild(root_1, root_2);
                }
                // xquery/XQueryParser.g:1107:81: ^( DirElemContent ( pm_DirElemContent )* )
                {
                var root_2 = this.adaptor.nil();
                root_2 = this.adaptor.becomeRoot(this.adaptor.create(DirElemContent, "DirElemContent"), root_2);

                // xquery/XQueryParser.g:1107:98: ( pm_DirElemContent )*
                while ( stream_pm_DirElemContent.hasNext() ) {
                    this.adaptor.addChild(root_2, stream_pm_DirElemContent.nextTree());

                }
                stream_pm_DirElemContent.reset();

                this.adaptor.addChild(root_1, root_2);
                }

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
            this.popLexer(); 
        }
        return retval;
    },

    // inline static return class
    p_DirAttributeList_return: (function() {
        XQueryParser.p_DirAttributeList_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DirAttributeList_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1112:1: p_DirAttributeList : ( S (t= p_QName ( S )? EQUAL ( S )? v= p_DirAttributeValue )? )* ;
    // $ANTLR start "p_DirAttributeList"
    p_DirAttributeList: function() {
        var retval = new XQueryParser.p_DirAttributeList_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var S364 = null;
        var S365 = null;
        var EQUAL366 = null;
        var S367 = null;
         var t = null;
         var v = null;

        var S364_tree=null;
        var S365_tree=null;
        var EQUAL366_tree=null;
        var S367_tree=null;

        try {
            // xquery/XQueryParser.g:1113:9: ( ( S (t= p_QName ( S )? EQUAL ( S )? v= p_DirAttributeValue )? )* )
            // xquery/XQueryParser.g:1113:11: ( S (t= p_QName ( S )? EQUAL ( S )? v= p_DirAttributeValue )? )*
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1113:11: ( S (t= p_QName ( S )? EQUAL ( S )? v= p_DirAttributeValue )? )*
            loop146:
            do {
                var alt146=2;
                var LA146_0 = this.input.LA(1);

                if ( (LA146_0==S) ) {
                    alt146=1;
                }


                switch (alt146) {
                case 1 :
                    // xquery/XQueryParser.g:1113:12: S (t= p_QName ( S )? EQUAL ( S )? v= p_DirAttributeValue )?
                    S364=this.match(this.input,S,XQueryParser.FOLLOW_S_in_p_DirAttributeList8293); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    S364_tree = this.adaptor.create(S364);
                    this.adaptor.addChild(root_0, S364_tree);
                    }
                    // xquery/XQueryParser.g:1113:14: (t= p_QName ( S )? EQUAL ( S )? v= p_DirAttributeValue )?
                    var alt145=2;
                    var LA145_0 = this.input.LA(1);

                    if ( ((LA145_0>=ANCESTOR && LA145_0<=SKIP)||(LA145_0>=VALUE && LA145_0<=QUOT_ER)||LA145_0==L_NCName||LA145_0==EXPLICITLY) ) {
                        alt145=1;
                    }
                    switch (alt145) {
                        case 1 :
                            // xquery/XQueryParser.g:1113:15: t= p_QName ( S )? EQUAL ( S )? v= p_DirAttributeValue
                            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_DirAttributeList8298);
                            t=this.p_QName();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, t.getTree());
                            if ( this.state.backtracking===0 ) {
                              this.at((t?t.start:null), (t?t.stop:null));
                            }
                            // xquery/XQueryParser.g:1113:55: ( S )?
                            var alt143=2;
                            var LA143_0 = this.input.LA(1);

                            if ( (LA143_0==S) ) {
                                alt143=1;
                            }
                            switch (alt143) {
                                case 1 :
                                    // xquery/XQueryParser.g:1113:55: S
                                    S365=this.match(this.input,S,XQueryParser.FOLLOW_S_in_p_DirAttributeList8302); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    S365_tree = this.adaptor.create(S365);
                                    this.adaptor.addChild(root_0, S365_tree);
                                    }


                                    break;

                            }

                            EQUAL366=this.match(this.input,EQUAL,XQueryParser.FOLLOW_EQUAL_in_p_DirAttributeList8305); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            EQUAL366_tree = this.adaptor.create(EQUAL366);
                            this.adaptor.addChild(root_0, EQUAL366_tree);
                            }
                            // xquery/XQueryParser.g:1113:64: ( S )?
                            var alt144=2;
                            var LA144_0 = this.input.LA(1);

                            if ( (LA144_0==S) ) {
                                alt144=1;
                            }
                            switch (alt144) {
                                case 1 :
                                    // xquery/XQueryParser.g:1113:64: S
                                    S367=this.match(this.input,S,XQueryParser.FOLLOW_S_in_p_DirAttributeList8307); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    S367_tree = this.adaptor.create(S367);
                                    this.adaptor.addChild(root_0, S367_tree);
                                    }


                                    break;

                            }

                            this.pushFollow(XQueryParser.FOLLOW_p_DirAttributeValue_in_p_DirAttributeList8312);
                            v=this.p_DirAttributeValue();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
                            if ( this.state.backtracking===0 ) {
                              this.addString((v?v.start:null), (v?v.stop:null));
                            }


                            break;

                    }



                    break;

                default :
                    break loop146;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DirAttributeValue_return: (function() {
        XQueryParser.p_DirAttributeValue_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DirAttributeValue_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1117:1: p_DirAttributeValue : ( ( QUOT ( ESCAPE_QUOT | APOS | p_QuotAttrValueContent )* QUOT ) -> ^( DirAttributeValue ( p_QuotAttrValueContent )* ) | ( APOS ( ESCAPE_APOS | QUOT | p_AposAttrValueContent )* APOS ) -> ^( DirAttributeValue ( p_AposAttrValueContent )* ) );
    // $ANTLR start "p_DirAttributeValue"
    p_DirAttributeValue: function() {
        var retval = new XQueryParser.p_DirAttributeValue_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var QUOT368 = null;
        var ESCAPE_QUOT369 = null;
        var APOS370 = null;
        var QUOT372 = null;
        var APOS373 = null;
        var ESCAPE_APOS374 = null;
        var QUOT375 = null;
        var APOS377 = null;
         var p_QuotAttrValueContent371 = null;
         var p_AposAttrValueContent376 = null;

        var QUOT368_tree=null;
        var ESCAPE_QUOT369_tree=null;
        var APOS370_tree=null;
        var QUOT372_tree=null;
        var APOS373_tree=null;
        var ESCAPE_APOS374_tree=null;
        var QUOT375_tree=null;
        var APOS377_tree=null;
        var stream_ESCAPE_QUOT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ESCAPE_QUOT");
        var stream_APOS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token APOS");
        var stream_ESCAPE_APOS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ESCAPE_APOS");
        var stream_QUOT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token QUOT");
        var stream_p_QuotAttrValueContent=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_QuotAttrValueContent");
        var stream_p_AposAttrValueContent=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_AposAttrValueContent");
        try {
            // xquery/XQueryParser.g:1118:9: ( ( QUOT ( ESCAPE_QUOT | APOS | p_QuotAttrValueContent )* QUOT ) -> ^( DirAttributeValue ( p_QuotAttrValueContent )* ) | ( APOS ( ESCAPE_APOS | QUOT | p_AposAttrValueContent )* APOS ) -> ^( DirAttributeValue ( p_AposAttrValueContent )* ) )
            var alt149=2;
            var LA149_0 = this.input.LA(1);

            if ( (LA149_0==QUOT) ) {
                alt149=1;
            }
            else if ( (LA149_0==APOS) ) {
                alt149=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 149, 0, this.input);

                throw nvae;
            }
            switch (alt149) {
                case 1 :
                    // xquery/XQueryParser.g:1118:11: ( QUOT ( ESCAPE_QUOT | APOS | p_QuotAttrValueContent )* QUOT )
                    // xquery/XQueryParser.g:1118:11: ( QUOT ( ESCAPE_QUOT | APOS | p_QuotAttrValueContent )* QUOT )
                    // xquery/XQueryParser.g:1118:12: QUOT ( ESCAPE_QUOT | APOS | p_QuotAttrValueContent )* QUOT
                    QUOT368=this.match(this.input,QUOT,XQueryParser.FOLLOW_QUOT_in_p_DirAttributeValue8345); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_QUOT.add(QUOT368);

                    // xquery/XQueryParser.g:1118:17: ( ESCAPE_QUOT | APOS | p_QuotAttrValueContent )*
                    loop147:
                    do {
                        var alt147=4;
                        switch ( this.input.LA(1) ) {
                        case ESCAPE_QUOT:
                            alt147=1;
                            break;
                        case APOS:
                            alt147=2;
                            break;
                        case L_QuotAttrContentChar:
                        case L_PredefinedEntityRef:
                        case L_CharRef:
                        case ESCAPE_LBRACKET:
                        case ESCAPE_RBRACKET:
                        case LBRACKET:
                            alt147=3;
                            break;

                        }

                        switch (alt147) {
                        case 1 :
                            // xquery/XQueryParser.g:1118:18: ESCAPE_QUOT
                            ESCAPE_QUOT369=this.match(this.input,ESCAPE_QUOT,XQueryParser.FOLLOW_ESCAPE_QUOT_in_p_DirAttributeValue8348); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_ESCAPE_QUOT.add(ESCAPE_QUOT369);



                            break;
                        case 2 :
                            // xquery/XQueryParser.g:1118:32: APOS
                            APOS370=this.match(this.input,APOS,XQueryParser.FOLLOW_APOS_in_p_DirAttributeValue8352); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_APOS.add(APOS370);



                            break;
                        case 3 :
                            // xquery/XQueryParser.g:1118:39: p_QuotAttrValueContent
                            this.pushFollow(XQueryParser.FOLLOW_p_QuotAttrValueContent_in_p_DirAttributeValue8356);
                            p_QuotAttrValueContent371=this.p_QuotAttrValueContent();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_QuotAttrValueContent.add(p_QuotAttrValueContent371.getTree());


                            break;

                        default :
                            break loop147;
                        }
                    } while (true);

                    QUOT372=this.match(this.input,QUOT,XQueryParser.FOLLOW_QUOT_in_p_DirAttributeValue8360); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_QUOT.add(QUOT372);






                    // AST REWRITE
                    // elements: p_QuotAttrValueContent
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1119:17: -> ^( DirAttributeValue ( p_QuotAttrValueContent )* )
                    {
                        // xquery/XQueryParser.g:1119:20: ^( DirAttributeValue ( p_QuotAttrValueContent )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(DirAttributeValue, "DirAttributeValue"), root_1);

                        // xquery/XQueryParser.g:1119:40: ( p_QuotAttrValueContent )*
                        while ( stream_p_QuotAttrValueContent.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_p_QuotAttrValueContent.nextTree());

                        }
                        stream_p_QuotAttrValueContent.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // xquery/XQueryParser.g:1120:11: ( APOS ( ESCAPE_APOS | QUOT | p_AposAttrValueContent )* APOS )
                    // xquery/XQueryParser.g:1120:11: ( APOS ( ESCAPE_APOS | QUOT | p_AposAttrValueContent )* APOS )
                    // xquery/XQueryParser.g:1120:12: APOS ( ESCAPE_APOS | QUOT | p_AposAttrValueContent )* APOS
                    APOS373=this.match(this.input,APOS,XQueryParser.FOLLOW_APOS_in_p_DirAttributeValue8399); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_APOS.add(APOS373);

                    // xquery/XQueryParser.g:1120:17: ( ESCAPE_APOS | QUOT | p_AposAttrValueContent )*
                    loop148:
                    do {
                        var alt148=4;
                        switch ( this.input.LA(1) ) {
                        case ESCAPE_APOS:
                            alt148=1;
                            break;
                        case QUOT:
                            alt148=2;
                            break;
                        case L_AposAttrContentChar:
                        case L_PredefinedEntityRef:
                        case L_CharRef:
                        case ESCAPE_LBRACKET:
                        case ESCAPE_RBRACKET:
                        case LBRACKET:
                            alt148=3;
                            break;

                        }

                        switch (alt148) {
                        case 1 :
                            // xquery/XQueryParser.g:1120:18: ESCAPE_APOS
                            ESCAPE_APOS374=this.match(this.input,ESCAPE_APOS,XQueryParser.FOLLOW_ESCAPE_APOS_in_p_DirAttributeValue8402); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_ESCAPE_APOS.add(ESCAPE_APOS374);



                            break;
                        case 2 :
                            // xquery/XQueryParser.g:1120:32: QUOT
                            QUOT375=this.match(this.input,QUOT,XQueryParser.FOLLOW_QUOT_in_p_DirAttributeValue8406); if (this.state.failed) return retval; 
                            if ( this.state.backtracking===0 ) stream_QUOT.add(QUOT375);



                            break;
                        case 3 :
                            // xquery/XQueryParser.g:1120:39: p_AposAttrValueContent
                            this.pushFollow(XQueryParser.FOLLOW_p_AposAttrValueContent_in_p_DirAttributeValue8410);
                            p_AposAttrValueContent376=this.p_AposAttrValueContent();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_AposAttrValueContent.add(p_AposAttrValueContent376.getTree());


                            break;

                        default :
                            break loop148;
                        }
                    } while (true);

                    APOS377=this.match(this.input,APOS,XQueryParser.FOLLOW_APOS_in_p_DirAttributeValue8414); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_APOS.add(APOS377);






                    // AST REWRITE
                    // elements: p_AposAttrValueContent
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1121:17: -> ^( DirAttributeValue ( p_AposAttrValueContent )* )
                    {
                        // xquery/XQueryParser.g:1121:20: ^( DirAttributeValue ( p_AposAttrValueContent )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(DirAttributeValue, "DirAttributeValue"), root_1);

                        // xquery/XQueryParser.g:1121:40: ( p_AposAttrValueContent )*
                        while ( stream_p_AposAttrValueContent.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_p_AposAttrValueContent.nextTree());

                        }
                        stream_p_AposAttrValueContent.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_QuotAttrValueContent_return: (function() {
        XQueryParser.p_QuotAttrValueContent_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_QuotAttrValueContent_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1125:1: p_QuotAttrValueContent : ( p_QuotAttrContentChar | pm_CommonContent );
    // $ANTLR start "p_QuotAttrValueContent"
    p_QuotAttrValueContent: function() {
        var retval = new XQueryParser.p_QuotAttrValueContent_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QuotAttrContentChar378 = null;
         var pm_CommonContent379 = null;


        try {
            // xquery/XQueryParser.g:1126:9: ( p_QuotAttrContentChar | pm_CommonContent )
            var alt150=2;
            var LA150_0 = this.input.LA(1);

            if ( (LA150_0==L_QuotAttrContentChar) ) {
                alt150=1;
            }
            else if ( ((LA150_0>=L_PredefinedEntityRef && LA150_0<=ESCAPE_RBRACKET)||LA150_0==LBRACKET) ) {
                alt150=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 150, 0, this.input);

                throw nvae;
            }
            switch (alt150) {
                case 1 :
                    // xquery/XQueryParser.g:1126:11: p_QuotAttrContentChar
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_QuotAttrContentChar_in_p_QuotAttrValueContent8466);
                    p_QuotAttrContentChar378=this.p_QuotAttrContentChar();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QuotAttrContentChar378.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1126:35: pm_CommonContent
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CommonContent_in_p_QuotAttrValueContent8470);
                    pm_CommonContent379=this.pm_CommonContent();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CommonContent379.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AposAttrValueContent_return: (function() {
        XQueryParser.p_AposAttrValueContent_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AposAttrValueContent_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1130:1: p_AposAttrValueContent : ( p_AposAttrContentChar | pm_CommonContent );
    // $ANTLR start "p_AposAttrValueContent"
    p_AposAttrValueContent: function() {
        var retval = new XQueryParser.p_AposAttrValueContent_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_AposAttrContentChar380 = null;
         var pm_CommonContent381 = null;


        try {
            // xquery/XQueryParser.g:1131:9: ( p_AposAttrContentChar | pm_CommonContent )
            var alt151=2;
            var LA151_0 = this.input.LA(1);

            if ( (LA151_0==L_AposAttrContentChar) ) {
                alt151=1;
            }
            else if ( ((LA151_0>=L_PredefinedEntityRef && LA151_0<=ESCAPE_RBRACKET)||LA151_0==LBRACKET) ) {
                alt151=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 151, 0, this.input);

                throw nvae;
            }
            switch (alt151) {
                case 1 :
                    // xquery/XQueryParser.g:1131:11: p_AposAttrContentChar
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AposAttrContentChar_in_p_AposAttrValueContent8496);
                    p_AposAttrContentChar380=this.p_AposAttrContentChar();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AposAttrContentChar380.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1131:35: pm_CommonContent
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CommonContent_in_p_AposAttrValueContent8500);
                    pm_CommonContent381=this.pm_CommonContent();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CommonContent381.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_DirElemContent_return: (function() {
        XQueryParser.pm_DirElemContent_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_DirElemContent_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1135:1: pm_DirElemContent : ( p_DirectConstructor | p_CDataSection | pm_CommonContent | p_ElementContentChar );
    // $ANTLR start "pm_DirElemContent"
    pm_DirElemContent: function() {
        var retval = new XQueryParser.pm_DirElemContent_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_DirectConstructor382 = null;
         var p_CDataSection383 = null;
         var pm_CommonContent384 = null;
         var p_ElementContentChar385 = null;


        try {
            // xquery/XQueryParser.g:1136:9: ( p_DirectConstructor | p_CDataSection | pm_CommonContent | p_ElementContentChar )
            var alt152=4;
            switch ( this.input.LA(1) ) {
            case SMALLER:
            case L_DirCommentConstructor:
            case L_DirPIConstructor:
                alt152=1;
                break;
            case L_CDataSection:
                alt152=2;
                break;
            case L_PredefinedEntityRef:
            case L_CharRef:
            case ESCAPE_LBRACKET:
            case ESCAPE_RBRACKET:
            case LBRACKET:
                alt152=3;
                break;
            case L_ElementContentChar:
                alt152=4;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 152, 0, this.input);

                throw nvae;
            }

            switch (alt152) {
                case 1 :
                    // xquery/XQueryParser.g:1136:11: p_DirectConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_DirectConstructor_in_pm_DirElemContent8526);
                    p_DirectConstructor382=this.p_DirectConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DirectConstructor382.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1137:11: p_CDataSection
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_CDataSection_in_pm_DirElemContent8538);
                    p_CDataSection383=this.p_CDataSection();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CDataSection383.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1138:11: pm_CommonContent
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CommonContent_in_pm_DirElemContent8550);
                    pm_CommonContent384=this.pm_CommonContent();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CommonContent384.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1139:11: p_ElementContentChar
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ElementContentChar_in_pm_DirElemContent8562);
                    p_ElementContentChar385=this.p_ElementContentChar();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ElementContentChar385.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_CommonContent_return: (function() {
        XQueryParser.pm_CommonContent_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_CommonContent_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1145:1: pm_CommonContent : ( L_PredefinedEntityRef | L_CharRef | ESCAPE_LBRACKET | ESCAPE_RBRACKET | pg_EnclosedExprXml );
    // $ANTLR start "pm_CommonContent"
    pm_CommonContent: function() {
        var retval = new XQueryParser.pm_CommonContent_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_PredefinedEntityRef386 = null;
        var L_CharRef387 = null;
        var ESCAPE_LBRACKET388 = null;
        var ESCAPE_RBRACKET389 = null;
         var pg_EnclosedExprXml390 = null;

        var L_PredefinedEntityRef386_tree=null;
        var L_CharRef387_tree=null;
        var ESCAPE_LBRACKET388_tree=null;
        var ESCAPE_RBRACKET389_tree=null;

        try {
            // xquery/XQueryParser.g:1146:9: ( L_PredefinedEntityRef | L_CharRef | ESCAPE_LBRACKET | ESCAPE_RBRACKET | pg_EnclosedExprXml )
            var alt153=5;
            switch ( this.input.LA(1) ) {
            case L_PredefinedEntityRef:
                alt153=1;
                break;
            case L_CharRef:
                alt153=2;
                break;
            case ESCAPE_LBRACKET:
                alt153=3;
                break;
            case ESCAPE_RBRACKET:
                alt153=4;
                break;
            case LBRACKET:
                alt153=5;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 153, 0, this.input);

                throw nvae;
            }

            switch (alt153) {
                case 1 :
                    // xquery/XQueryParser.g:1146:11: L_PredefinedEntityRef
                    root_0 = this.adaptor.nil();

                    L_PredefinedEntityRef386=this.match(this.input,L_PredefinedEntityRef,XQueryParser.FOLLOW_L_PredefinedEntityRef_in_pm_CommonContent8590); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_PredefinedEntityRef386_tree = this.adaptor.create(L_PredefinedEntityRef386);
                    this.adaptor.addChild(root_0, L_PredefinedEntityRef386_tree);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1147:11: L_CharRef
                    root_0 = this.adaptor.nil();

                    L_CharRef387=this.match(this.input,L_CharRef,XQueryParser.FOLLOW_L_CharRef_in_pm_CommonContent8602); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_CharRef387_tree = this.adaptor.create(L_CharRef387);
                    this.adaptor.addChild(root_0, L_CharRef387_tree);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1148:11: ESCAPE_LBRACKET
                    root_0 = this.adaptor.nil();

                    ESCAPE_LBRACKET388=this.match(this.input,ESCAPE_LBRACKET,XQueryParser.FOLLOW_ESCAPE_LBRACKET_in_pm_CommonContent8614); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ESCAPE_LBRACKET388_tree = this.adaptor.create(ESCAPE_LBRACKET388);
                    this.adaptor.addChild(root_0, ESCAPE_LBRACKET388_tree);
                    }


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1149:11: ESCAPE_RBRACKET
                    root_0 = this.adaptor.nil();

                    ESCAPE_RBRACKET389=this.match(this.input,ESCAPE_RBRACKET,XQueryParser.FOLLOW_ESCAPE_RBRACKET_in_pm_CommonContent8626); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ESCAPE_RBRACKET389_tree = this.adaptor.create(ESCAPE_RBRACKET389);
                    this.adaptor.addChild(root_0, ESCAPE_RBRACKET389_tree);
                    }


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1150:11: pg_EnclosedExprXml
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pg_EnclosedExprXml_in_pm_CommonContent8638);
                    pg_EnclosedExprXml390=this.pg_EnclosedExprXml();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pg_EnclosedExprXml390.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pg_EnclosedExprXml_return: (function() {
        XQueryParser.pg_EnclosedExprXml_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_EnclosedExprXml_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1158:1: pg_EnclosedExprXml : LBRACKET p_StatementsAndOptionalExpr RBRACKET ;
    // $ANTLR start "pg_EnclosedExprXml"
    pg_EnclosedExprXml: function() {
        var retval = new XQueryParser.pg_EnclosedExprXml_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LBRACKET391 = null;
        var RBRACKET393 = null;
         var p_StatementsAndOptionalExpr392 = null;

        var LBRACKET391_tree=null;
        var RBRACKET393_tree=null;

        try {
            // xquery/XQueryParser.g:1159:9: ( LBRACKET p_StatementsAndOptionalExpr RBRACKET )
            // xquery/XQueryParser.g:1159:13: LBRACKET p_StatementsAndOptionalExpr RBRACKET
            root_0 = this.adaptor.nil();

            LBRACKET391=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pg_EnclosedExprXml8670); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET391_tree = this.adaptor.create(LBRACKET391);
            this.adaptor.addChild(root_0, LBRACKET391_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.pushXQueryLexer();
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_pg_EnclosedExprXml8686);
            p_StatementsAndOptionalExpr392=this.p_StatementsAndOptionalExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndOptionalExpr392.getTree());
            RBRACKET393=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pg_EnclosedExprXml8700); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET393_tree = this.adaptor.create(RBRACKET393);
            this.adaptor.addChild(root_0, RBRACKET393_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.popLexer();
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DirCommentConstructor_return: (function() {
        XQueryParser.p_DirCommentConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DirCommentConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1166:1: p_DirCommentConstructor : c= L_DirCommentConstructor ;
    // $ANTLR start "p_DirCommentConstructor"
    p_DirCommentConstructor: function() {
        var retval = new XQueryParser.p_DirCommentConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var c = null;

        var c_tree=null;

        try {
            // xquery/XQueryParser.g:1167:9: (c= L_DirCommentConstructor )
            // xquery/XQueryParser.g:1167:11: c= L_DirCommentConstructor
            root_0 = this.adaptor.nil();

            c=this.match(this.input,L_DirCommentConstructor,XQueryParser.FOLLOW_L_DirCommentConstructor_in_p_DirCommentConstructor8731); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            c_tree = this.adaptor.create(c);
            this.adaptor.addChild(root_0, c_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ac(c);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DirPIConstructor_return: (function() {
        XQueryParser.p_DirPIConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DirPIConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1174:1: p_DirPIConstructor : L_DirPIConstructor ;
    // $ANTLR start "p_DirPIConstructor"
    p_DirPIConstructor: function() {
        var retval = new XQueryParser.p_DirPIConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_DirPIConstructor394 = null;

        var L_DirPIConstructor394_tree=null;

        try {
            // xquery/XQueryParser.g:1175:9: ( L_DirPIConstructor )
            // xquery/XQueryParser.g:1175:11: L_DirPIConstructor
            root_0 = this.adaptor.nil();

            L_DirPIConstructor394=this.match(this.input,L_DirPIConstructor,XQueryParser.FOLLOW_L_DirPIConstructor_in_p_DirPIConstructor8765); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            L_DirPIConstructor394_tree = this.adaptor.create(L_DirPIConstructor394);
            this.adaptor.addChild(root_0, L_DirPIConstructor394_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CDataSection_return: (function() {
        XQueryParser.p_CDataSection_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CDataSection_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1182:1: p_CDataSection : L_CDataSection ;
    // $ANTLR start "p_CDataSection"
    p_CDataSection: function() {
        var retval = new XQueryParser.p_CDataSection_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_CDataSection395 = null;

        var L_CDataSection395_tree=null;

        try {
            // xquery/XQueryParser.g:1183:9: ( L_CDataSection )
            // xquery/XQueryParser.g:1183:11: L_CDataSection
            root_0 = this.adaptor.nil();

            L_CDataSection395=this.match(this.input,L_CDataSection,XQueryParser.FOLLOW_L_CDataSection_in_p_CDataSection8798); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            L_CDataSection395_tree = this.adaptor.create(L_CDataSection395);
            this.adaptor.addChild(root_0, L_CDataSection395_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ComputedConstructor_return: (function() {
        XQueryParser.p_ComputedConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ComputedConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1190:1: p_ComputedConstructor : ( pm_CompDocConstructor | pm_CompElemConstructor | pm_CompAttrConstructor | p_CompNamespaceConstructor | p_CompTextConstructor | pm_CompCommentConstructor | pm_CompPIConstructor | {...}? => p_CompBinaryConstructor );
    // $ANTLR start "p_ComputedConstructor"
    p_ComputedConstructor: function() {
        var retval = new XQueryParser.p_ComputedConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var pm_CompDocConstructor396 = null;
         var pm_CompElemConstructor397 = null;
         var pm_CompAttrConstructor398 = null;
         var p_CompNamespaceConstructor399 = null;
         var p_CompTextConstructor400 = null;
         var pm_CompCommentConstructor401 = null;
         var pm_CompPIConstructor402 = null;
         var p_CompBinaryConstructor403 = null;


        try {
            // xquery/XQueryParser.g:1191:9: ( pm_CompDocConstructor | pm_CompElemConstructor | pm_CompAttrConstructor | p_CompNamespaceConstructor | p_CompTextConstructor | pm_CompCommentConstructor | pm_CompPIConstructor | {...}? => p_CompBinaryConstructor )
            var alt154=8;
            var LA154_0 = this.input.LA(1);

            if ( (LA154_0==DOCUMENT) ) {
                alt154=1;
            }
            else if ( (LA154_0==ELEMENT) ) {
                alt154=2;
            }
            else if ( (LA154_0==ATTRIBUTE) ) {
                alt154=3;
            }
            else if ( (LA154_0==NAMESPACE) ) {
                alt154=4;
            }
            else if ( (LA154_0==TEXT) ) {
                alt154=5;
            }
            else if ( (LA154_0==COMMENT) ) {
                alt154=6;
            }
            else if ( (LA154_0==PROCESSING_INSTRUCTION) ) {
                alt154=7;
            }
            else if ( (LA154_0==BINARY) && ((this.lc(MLS)))) {
                alt154=8;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 154, 0, this.input);

                throw nvae;
            }
            switch (alt154) {
                case 1 :
                    // xquery/XQueryParser.g:1191:11: pm_CompDocConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CompDocConstructor_in_p_ComputedConstructor8830);
                    pm_CompDocConstructor396=this.pm_CompDocConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CompDocConstructor396.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1192:11: pm_CompElemConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CompElemConstructor_in_p_ComputedConstructor8842);
                    pm_CompElemConstructor397=this.pm_CompElemConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CompElemConstructor397.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1193:11: pm_CompAttrConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CompAttrConstructor_in_p_ComputedConstructor8854);
                    pm_CompAttrConstructor398=this.pm_CompAttrConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CompAttrConstructor398.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1194:11: p_CompNamespaceConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_CompNamespaceConstructor_in_p_ComputedConstructor8866);
                    p_CompNamespaceConstructor399=this.p_CompNamespaceConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CompNamespaceConstructor399.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1195:11: p_CompTextConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_CompTextConstructor_in_p_ComputedConstructor8878);
                    p_CompTextConstructor400=this.p_CompTextConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CompTextConstructor400.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:1196:11: pm_CompCommentConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CompCommentConstructor_in_p_ComputedConstructor8890);
                    pm_CompCommentConstructor401=this.pm_CompCommentConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CompCommentConstructor401.getTree());


                    break;
                case 7 :
                    // xquery/XQueryParser.g:1197:11: pm_CompPIConstructor
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pm_CompPIConstructor_in_p_ComputedConstructor8902);
                    pm_CompPIConstructor402=this.pm_CompPIConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_CompPIConstructor402.getTree());


                    break;
                case 8 :
                    // xquery/XQueryParser.g:1198:11: {...}? => p_CompBinaryConstructor
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(MLS))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "p_ComputedConstructor", "this.lc(MLS)");
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_CompBinaryConstructor_in_p_ComputedConstructor8917);
                    p_CompBinaryConstructor403=this.p_CompBinaryConstructor();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CompBinaryConstructor403.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_CompDocConstructor_return: (function() {
        XQueryParser.pm_CompDocConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_CompDocConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1203:1: pm_CompDocConstructor : k= DOCUMENT LBRACKET p_StatementsAndOptionalExpr RBRACKET ;
    // $ANTLR start "pm_CompDocConstructor"
    pm_CompDocConstructor: function() {
        var retval = new XQueryParser.pm_CompDocConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET404 = null;
        var RBRACKET406 = null;
         var p_StatementsAndOptionalExpr405 = null;

        var k_tree=null;
        var LBRACKET404_tree=null;
        var RBRACKET406_tree=null;

        try {
            // xquery/XQueryParser.g:1204:9: (k= DOCUMENT LBRACKET p_StatementsAndOptionalExpr RBRACKET )
            // xquery/XQueryParser.g:1204:11: k= DOCUMENT LBRACKET p_StatementsAndOptionalExpr RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DOCUMENT,XQueryParser.FOLLOW_DOCUMENT_in_pm_CompDocConstructor8946); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LBRACKET404=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompDocConstructor8950); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET404_tree = this.adaptor.create(LBRACKET404);
            this.adaptor.addChild(root_0, LBRACKET404_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompDocConstructor8952);
            p_StatementsAndOptionalExpr405=this.p_StatementsAndOptionalExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndOptionalExpr405.getTree());
            RBRACKET406=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompDocConstructor8954); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET406_tree = this.adaptor.create(RBRACKET406);
            this.adaptor.addChild(root_0, RBRACKET406_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_CompElemConstructor_return: (function() {
        XQueryParser.pm_CompElemConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_CompElemConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1208:1: pm_CompElemConstructor : k= ELEMENT ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET pm_ContentExpr RBRACKET ;
    // $ANTLR start "pm_CompElemConstructor"
    pm_CompElemConstructor: function() {
        var retval = new XQueryParser.pm_CompElemConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET408 = null;
        var RBRACKET410 = null;
        var LBRACKET411 = null;
        var RBRACKET413 = null;
         var p_QName407 = null;
         var p_Expr409 = null;
         var pm_ContentExpr412 = null;

        var k_tree=null;
        var LBRACKET408_tree=null;
        var RBRACKET410_tree=null;
        var LBRACKET411_tree=null;
        var RBRACKET413_tree=null;

        try {
            // xquery/XQueryParser.g:1209:9: (k= ELEMENT ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET pm_ContentExpr RBRACKET )
            // xquery/XQueryParser.g:1209:11: k= ELEMENT ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET pm_ContentExpr RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,ELEMENT,XQueryParser.FOLLOW_ELEMENT_in_pm_CompElemConstructor8990); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:1209:36: ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) )
            var alt155=2;
            var LA155_0 = this.input.LA(1);

            if ( ((LA155_0>=ANCESTOR && LA155_0<=SKIP)||(LA155_0>=VALUE && LA155_0<=QUOT_ER)||LA155_0==L_NCName||LA155_0==EXPLICITLY) ) {
                alt155=1;
            }
            else if ( (LA155_0==LBRACKET) ) {
                alt155=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 155, 0, this.input);

                throw nvae;
            }
            switch (alt155) {
                case 1 :
                    // xquery/XQueryParser.g:1209:37: p_QName
                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_pm_CompElemConstructor8995);
                    p_QName407=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName407.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1209:47: ( LBRACKET p_Expr[true,true] RBRACKET )
                    // xquery/XQueryParser.g:1209:47: ( LBRACKET p_Expr[true,true] RBRACKET )
                    // xquery/XQueryParser.g:1209:48: LBRACKET p_Expr[true,true] RBRACKET
                    LBRACKET408=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompElemConstructor9000); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LBRACKET408_tree = this.adaptor.create(LBRACKET408);
                    this.adaptor.addChild(root_0, LBRACKET408_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_pm_CompElemConstructor9002);
                    p_Expr409=this.p_Expr(true, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr409.getTree());
                    RBRACKET410=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompElemConstructor9005); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RBRACKET410_tree = this.adaptor.create(RBRACKET410);
                    this.adaptor.addChild(root_0, RBRACKET410_tree);
                    }





                    break;

            }

            LBRACKET411=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompElemConstructor9009); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET411_tree = this.adaptor.create(LBRACKET411);
            this.adaptor.addChild(root_0, LBRACKET411_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_pm_ContentExpr_in_pm_CompElemConstructor9011);
            pm_ContentExpr412=this.pm_ContentExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pm_ContentExpr412.getTree());
            RBRACKET413=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompElemConstructor9013); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET413_tree = this.adaptor.create(RBRACKET413);
            this.adaptor.addChild(root_0, RBRACKET413_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_ContentExpr_return: (function() {
        XQueryParser.pm_ContentExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_ContentExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1214:1: pm_ContentExpr : p_StatementsAndOptionalExpr ;
    // $ANTLR start "pm_ContentExpr"
    pm_ContentExpr: function() {
        var retval = new XQueryParser.pm_ContentExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_StatementsAndOptionalExpr414 = null;


        try {
            // xquery/XQueryParser.g:1215:9: ( p_StatementsAndOptionalExpr )
            // xquery/XQueryParser.g:1215:11: p_StatementsAndOptionalExpr
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_pm_ContentExpr9040);
            p_StatementsAndOptionalExpr414=this.p_StatementsAndOptionalExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndOptionalExpr414.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_CompAttrConstructor_return: (function() {
        XQueryParser.pm_CompAttrConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_CompAttrConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1220:1: pm_CompAttrConstructor : k= ATTRIBUTE ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET p_StatementsAndOptionalExpr RBRACKET ;
    // $ANTLR start "pm_CompAttrConstructor"
    pm_CompAttrConstructor: function() {
        var retval = new XQueryParser.pm_CompAttrConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET416 = null;
        var RBRACKET418 = null;
        var LBRACKET419 = null;
        var RBRACKET421 = null;
         var p_QName415 = null;
         var p_Expr417 = null;
         var p_StatementsAndOptionalExpr420 = null;

        var k_tree=null;
        var LBRACKET416_tree=null;
        var RBRACKET418_tree=null;
        var LBRACKET419_tree=null;
        var RBRACKET421_tree=null;

        try {
            // xquery/XQueryParser.g:1221:9: (k= ATTRIBUTE ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET p_StatementsAndOptionalExpr RBRACKET )
            // xquery/XQueryParser.g:1221:11: k= ATTRIBUTE ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET p_StatementsAndOptionalExpr RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,ATTRIBUTE,XQueryParser.FOLLOW_ATTRIBUTE_in_pm_CompAttrConstructor9069); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:1221:38: ( p_QName | ( LBRACKET p_Expr[true,true] RBRACKET ) )
            var alt156=2;
            var LA156_0 = this.input.LA(1);

            if ( ((LA156_0>=ANCESTOR && LA156_0<=SKIP)||(LA156_0>=VALUE && LA156_0<=QUOT_ER)||LA156_0==L_NCName||LA156_0==EXPLICITLY) ) {
                alt156=1;
            }
            else if ( (LA156_0==LBRACKET) ) {
                alt156=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 156, 0, this.input);

                throw nvae;
            }
            switch (alt156) {
                case 1 :
                    // xquery/XQueryParser.g:1221:39: p_QName
                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_pm_CompAttrConstructor9074);
                    p_QName415=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName415.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1221:49: ( LBRACKET p_Expr[true,true] RBRACKET )
                    // xquery/XQueryParser.g:1221:49: ( LBRACKET p_Expr[true,true] RBRACKET )
                    // xquery/XQueryParser.g:1221:50: LBRACKET p_Expr[true,true] RBRACKET
                    LBRACKET416=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompAttrConstructor9079); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LBRACKET416_tree = this.adaptor.create(LBRACKET416);
                    this.adaptor.addChild(root_0, LBRACKET416_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_pm_CompAttrConstructor9081);
                    p_Expr417=this.p_Expr(true, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr417.getTree());
                    RBRACKET418=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompAttrConstructor9084); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RBRACKET418_tree = this.adaptor.create(RBRACKET418);
                    this.adaptor.addChild(root_0, RBRACKET418_tree);
                    }





                    break;

            }

            LBRACKET419=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompAttrConstructor9088); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET419_tree = this.adaptor.create(LBRACKET419);
            this.adaptor.addChild(root_0, LBRACKET419_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompAttrConstructor9090);
            p_StatementsAndOptionalExpr420=this.p_StatementsAndOptionalExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndOptionalExpr420.getTree());
            RBRACKET421=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompAttrConstructor9092); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET421_tree = this.adaptor.create(RBRACKET421);
            this.adaptor.addChild(root_0, RBRACKET421_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CompNamespaceConstructor_return: (function() {
        XQueryParser.p_CompNamespaceConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CompNamespaceConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1225:1: p_CompNamespaceConstructor : k= NAMESPACE ( p_Prefix | ( LBRACKET p_PrefixExpr RBRACKET ) ) LBRACKET ( p_URIExpr )? RBRACKET ;
    // $ANTLR start "p_CompNamespaceConstructor"
    p_CompNamespaceConstructor: function() {
        var retval = new XQueryParser.p_CompNamespaceConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET423 = null;
        var RBRACKET425 = null;
        var LBRACKET426 = null;
        var RBRACKET428 = null;
         var p_Prefix422 = null;
         var p_PrefixExpr424 = null;
         var p_URIExpr427 = null;

        var k_tree=null;
        var LBRACKET423_tree=null;
        var RBRACKET425_tree=null;
        var LBRACKET426_tree=null;
        var RBRACKET428_tree=null;

        try {
            // xquery/XQueryParser.g:1226:9: (k= NAMESPACE ( p_Prefix | ( LBRACKET p_PrefixExpr RBRACKET ) ) LBRACKET ( p_URIExpr )? RBRACKET )
            // xquery/XQueryParser.g:1226:11: k= NAMESPACE ( p_Prefix | ( LBRACKET p_PrefixExpr RBRACKET ) ) LBRACKET ( p_URIExpr )? RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,NAMESPACE,XQueryParser.FOLLOW_NAMESPACE_in_p_CompNamespaceConstructor9120); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:1226:38: ( p_Prefix | ( LBRACKET p_PrefixExpr RBRACKET ) )
            var alt157=2;
            var LA157_0 = this.input.LA(1);

            if ( ((LA157_0>=ANCESTOR && LA157_0<=SKIP)||(LA157_0>=VALUE && LA157_0<=QUOT_ER)||LA157_0==L_NCName||LA157_0==EXPLICITLY) ) {
                alt157=1;
            }
            else if ( (LA157_0==LBRACKET) ) {
                alt157=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 157, 0, this.input);

                throw nvae;
            }
            switch (alt157) {
                case 1 :
                    // xquery/XQueryParser.g:1226:39: p_Prefix
                    this.pushFollow(XQueryParser.FOLLOW_p_Prefix_in_p_CompNamespaceConstructor9125);
                    p_Prefix422=this.p_Prefix();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Prefix422.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1226:50: ( LBRACKET p_PrefixExpr RBRACKET )
                    // xquery/XQueryParser.g:1226:50: ( LBRACKET p_PrefixExpr RBRACKET )
                    // xquery/XQueryParser.g:1226:51: LBRACKET p_PrefixExpr RBRACKET
                    LBRACKET423=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_CompNamespaceConstructor9130); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LBRACKET423_tree = this.adaptor.create(LBRACKET423);
                    this.adaptor.addChild(root_0, LBRACKET423_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_PrefixExpr_in_p_CompNamespaceConstructor9132);
                    p_PrefixExpr424=this.p_PrefixExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PrefixExpr424.getTree());
                    RBRACKET425=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_CompNamespaceConstructor9134); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RBRACKET425_tree = this.adaptor.create(RBRACKET425);
                    this.adaptor.addChild(root_0, RBRACKET425_tree);
                    }





                    break;

            }

            LBRACKET426=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_CompNamespaceConstructor9138); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET426_tree = this.adaptor.create(LBRACKET426);
            this.adaptor.addChild(root_0, LBRACKET426_tree);
            }
            // xquery/XQueryParser.g:1226:93: ( p_URIExpr )?
            var alt158=2;
            var LA158_0 = this.input.LA(1);

            if ( ((LA158_0>=ANCESTOR && LA158_0<=QUOT_ER)||LA158_0==LPAREN||(LA158_0>=DOLLAR && LA158_0<=LBRACKET)||(LA158_0>=STAR && LA158_0<=SMALLER)||(LA158_0>=SLASH && LA158_0<=DOT_DOT)||LA158_0==ATTR_SIGN||(LA158_0>=APOS && LA158_0<=QUOT)||LA158_0==L_NCName||(LA158_0>=L_Pragma && LA158_0<=L_DoubleLiteral)||LA158_0==EXPLICITLY) ) {
                alt158=1;
            }
            switch (alt158) {
                case 1 :
                    // xquery/XQueryParser.g:1226:93: p_URIExpr
                    this.pushFollow(XQueryParser.FOLLOW_p_URIExpr_in_p_CompNamespaceConstructor9140);
                    p_URIExpr427=this.p_URIExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_URIExpr427.getTree());


                    break;

            }

            RBRACKET428=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_CompNamespaceConstructor9143); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET428_tree = this.adaptor.create(RBRACKET428);
            this.adaptor.addChild(root_0, RBRACKET428_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Prefix_return: (function() {
        XQueryParser.p_Prefix_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Prefix_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1230:1: p_Prefix : p_NCName ;
    // $ANTLR start "p_Prefix"
    p_Prefix: function() {
        var retval = new XQueryParser.p_Prefix_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_NCName429 = null;


        try {
            // xquery/XQueryParser.g:1231:9: ( p_NCName )
            // xquery/XQueryParser.g:1231:11: p_NCName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_p_Prefix9169);
            p_NCName429=this.p_NCName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NCName429.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PrefixExpr_return: (function() {
        XQueryParser.p_PrefixExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PrefixExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1235:1: p_PrefixExpr : p_Expr[true,true] ;
    // $ANTLR start "p_PrefixExpr"
    p_PrefixExpr: function() {
        var retval = new XQueryParser.p_PrefixExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Expr430 = null;


        try {
            // xquery/XQueryParser.g:1236:9: ( p_Expr[true,true] )
            // xquery/XQueryParser.g:1236:11: p_Expr[true,true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_PrefixExpr9195);
            p_Expr430=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr430.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_URIExpr_return: (function() {
        XQueryParser.p_URIExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_URIExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1240:1: p_URIExpr : p_Expr[true,true] ;
    // $ANTLR start "p_URIExpr"
    p_URIExpr: function() {
        var retval = new XQueryParser.p_URIExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Expr431 = null;


        try {
            // xquery/XQueryParser.g:1241:9: ( p_Expr[true,true] )
            // xquery/XQueryParser.g:1241:11: p_Expr[true,true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_URIExpr9222);
            p_Expr431=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr431.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CompTextConstructor_return: (function() {
        XQueryParser.p_CompTextConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CompTextConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1245:1: p_CompTextConstructor : k= TEXT LBRACKET p_Expr[true,true] RBRACKET ;
    // $ANTLR start "p_CompTextConstructor"
    p_CompTextConstructor: function() {
        var retval = new XQueryParser.p_CompTextConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET432 = null;
        var RBRACKET434 = null;
         var p_Expr433 = null;

        var k_tree=null;
        var LBRACKET432_tree=null;
        var RBRACKET434_tree=null;

        try {
            // xquery/XQueryParser.g:1246:9: (k= TEXT LBRACKET p_Expr[true,true] RBRACKET )
            // xquery/XQueryParser.g:1246:11: k= TEXT LBRACKET p_Expr[true,true] RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TEXT,XQueryParser.FOLLOW_TEXT_in_p_CompTextConstructor9251); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LBRACKET432=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_CompTextConstructor9255); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET432_tree = this.adaptor.create(LBRACKET432);
            this.adaptor.addChild(root_0, LBRACKET432_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_CompTextConstructor9257);
            p_Expr433=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr433.getTree());
            RBRACKET434=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_CompTextConstructor9260); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET434_tree = this.adaptor.create(RBRACKET434);
            this.adaptor.addChild(root_0, RBRACKET434_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CompBinaryConstructor_return: (function() {
        XQueryParser.p_CompBinaryConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CompBinaryConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1250:1: p_CompBinaryConstructor : k= BINARY LBRACKET p_Expr[true,true] RBRACKET ;
    // $ANTLR start "p_CompBinaryConstructor"
    p_CompBinaryConstructor: function() {
        var retval = new XQueryParser.p_CompBinaryConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET435 = null;
        var RBRACKET437 = null;
         var p_Expr436 = null;

        var k_tree=null;
        var LBRACKET435_tree=null;
        var RBRACKET437_tree=null;

        try {
            // xquery/XQueryParser.g:1251:9: (k= BINARY LBRACKET p_Expr[true,true] RBRACKET )
            // xquery/XQueryParser.g:1251:11: k= BINARY LBRACKET p_Expr[true,true] RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,BINARY,XQueryParser.FOLLOW_BINARY_in_p_CompBinaryConstructor9288); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LBRACKET435=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_CompBinaryConstructor9292); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET435_tree = this.adaptor.create(LBRACKET435);
            this.adaptor.addChild(root_0, LBRACKET435_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_CompBinaryConstructor9294);
            p_Expr436=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr436.getTree());
            RBRACKET437=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_CompBinaryConstructor9297); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET437_tree = this.adaptor.create(RBRACKET437);
            this.adaptor.addChild(root_0, RBRACKET437_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_CompCommentConstructor_return: (function() {
        XQueryParser.pm_CompCommentConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_CompCommentConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1256:1: pm_CompCommentConstructor : k= COMMENT LBRACKET p_StatementsAndOptionalExpr RBRACKET ;
    // $ANTLR start "pm_CompCommentConstructor"
    pm_CompCommentConstructor: function() {
        var retval = new XQueryParser.pm_CompCommentConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET438 = null;
        var RBRACKET440 = null;
         var p_StatementsAndOptionalExpr439 = null;

        var k_tree=null;
        var LBRACKET438_tree=null;
        var RBRACKET440_tree=null;

        try {
            // xquery/XQueryParser.g:1257:9: (k= COMMENT LBRACKET p_StatementsAndOptionalExpr RBRACKET )
            // xquery/XQueryParser.g:1257:11: k= COMMENT LBRACKET p_StatementsAndOptionalExpr RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,COMMENT,XQueryParser.FOLLOW_COMMENT_in_pm_CompCommentConstructor9326); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LBRACKET438=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompCommentConstructor9330); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET438_tree = this.adaptor.create(LBRACKET438);
            this.adaptor.addChild(root_0, LBRACKET438_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompCommentConstructor9332);
            p_StatementsAndOptionalExpr439=this.p_StatementsAndOptionalExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndOptionalExpr439.getTree());
            RBRACKET440=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompCommentConstructor9334); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET440_tree = this.adaptor.create(RBRACKET440);
            this.adaptor.addChild(root_0, RBRACKET440_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_CompPIConstructor_return: (function() {
        XQueryParser.pm_CompPIConstructor_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_CompPIConstructor_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1262:1: pm_CompPIConstructor : k= PROCESSING_INSTRUCTION ( p_NCName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET p_StatementsAndOptionalExpr RBRACKET ;
    // $ANTLR start "pm_CompPIConstructor"
    pm_CompPIConstructor: function() {
        var retval = new XQueryParser.pm_CompPIConstructor_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LBRACKET442 = null;
        var RBRACKET444 = null;
        var LBRACKET445 = null;
        var RBRACKET447 = null;
         var p_NCName441 = null;
         var p_Expr443 = null;
         var p_StatementsAndOptionalExpr446 = null;

        var k_tree=null;
        var LBRACKET442_tree=null;
        var RBRACKET444_tree=null;
        var LBRACKET445_tree=null;
        var RBRACKET447_tree=null;

        try {
            // xquery/XQueryParser.g:1263:9: (k= PROCESSING_INSTRUCTION ( p_NCName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET p_StatementsAndOptionalExpr RBRACKET )
            // xquery/XQueryParser.g:1263:11: k= PROCESSING_INSTRUCTION ( p_NCName | ( LBRACKET p_Expr[true,true] RBRACKET ) ) LBRACKET p_StatementsAndOptionalExpr RBRACKET
            root_0 = this.adaptor.nil();

            k=this.match(this.input,PROCESSING_INSTRUCTION,XQueryParser.FOLLOW_PROCESSING_INSTRUCTION_in_pm_CompPIConstructor9363); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:1263:51: ( p_NCName | ( LBRACKET p_Expr[true,true] RBRACKET ) )
            var alt159=2;
            var LA159_0 = this.input.LA(1);

            if ( ((LA159_0>=ANCESTOR && LA159_0<=SKIP)||(LA159_0>=VALUE && LA159_0<=QUOT_ER)||LA159_0==L_NCName||LA159_0==EXPLICITLY) ) {
                alt159=1;
            }
            else if ( (LA159_0==LBRACKET) ) {
                alt159=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 159, 0, this.input);

                throw nvae;
            }
            switch (alt159) {
                case 1 :
                    // xquery/XQueryParser.g:1263:52: p_NCName
                    this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_pm_CompPIConstructor9368);
                    p_NCName441=this.p_NCName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NCName441.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1263:63: ( LBRACKET p_Expr[true,true] RBRACKET )
                    // xquery/XQueryParser.g:1263:63: ( LBRACKET p_Expr[true,true] RBRACKET )
                    // xquery/XQueryParser.g:1263:64: LBRACKET p_Expr[true,true] RBRACKET
                    LBRACKET442=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompPIConstructor9373); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LBRACKET442_tree = this.adaptor.create(LBRACKET442);
                    this.adaptor.addChild(root_0, LBRACKET442_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_pm_CompPIConstructor9375);
                    p_Expr443=this.p_Expr(true, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr443.getTree());
                    RBRACKET444=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompPIConstructor9378); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RBRACKET444_tree = this.adaptor.create(RBRACKET444);
                    this.adaptor.addChild(root_0, RBRACKET444_tree);
                    }





                    break;

            }

            LBRACKET445=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_pm_CompPIConstructor9382); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET445_tree = this.adaptor.create(LBRACKET445);
            this.adaptor.addChild(root_0, LBRACKET445_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompPIConstructor9384);
            p_StatementsAndOptionalExpr446=this.p_StatementsAndOptionalExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndOptionalExpr446.getTree());
            RBRACKET447=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_pm_CompPIConstructor9386); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET447_tree = this.adaptor.create(RBRACKET447);
            this.adaptor.addChild(root_0, RBRACKET447_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SingleType_return: (function() {
        XQueryParser.p_SingleType_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SingleType_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1285:1: p_SingleType : p_AtomicOrUnionType ( QUESTION )? ;
    // $ANTLR start "p_SingleType"
    p_SingleType: function() {
        var retval = new XQueryParser.p_SingleType_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var QUESTION449 = null;
         var p_AtomicOrUnionType448 = null;

        var QUESTION449_tree=null;

        try {
            // xquery/XQueryParser.g:1286:9: ( p_AtomicOrUnionType ( QUESTION )? )
            // xquery/XQueryParser.g:1286:11: p_AtomicOrUnionType ( QUESTION )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_AtomicOrUnionType_in_p_SingleType9430);
            p_AtomicOrUnionType448=this.p_AtomicOrUnionType();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AtomicOrUnionType448.getTree());
            // xquery/XQueryParser.g:1286:31: ( QUESTION )?
            var alt160=2;
            var LA160_0 = this.input.LA(1);

            if ( (LA160_0==QUESTION) ) {
                alt160=1;
            }
            switch (alt160) {
                case 1 :
                    // xquery/XQueryParser.g:1286:31: QUESTION
                    QUESTION449=this.match(this.input,QUESTION,XQueryParser.FOLLOW_QUESTION_in_p_SingleType9432); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    QUESTION449_tree = this.adaptor.create(QUESTION449);
                    this.adaptor.addChild(root_0, QUESTION449_tree);
                    }


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TypeDeclaration_return: (function() {
        XQueryParser.p_TypeDeclaration_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TypeDeclaration_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1290:1: p_TypeDeclaration : k= AS st= p_SequenceType -> ^( TypeDeclaration $st) ;
    // $ANTLR start "p_TypeDeclaration"
    p_TypeDeclaration: function() {
        var retval = new XQueryParser.p_TypeDeclaration_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var st = null;

        var k_tree=null;
        var stream_AS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token AS");
        var stream_p_SequenceType=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_SequenceType");
        try {
            // xquery/XQueryParser.g:1291:9: (k= AS st= p_SequenceType -> ^( TypeDeclaration $st) )
            // xquery/XQueryParser.g:1291:11: k= AS st= p_SequenceType
            k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_TypeDeclaration9461); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_AS.add(k);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_TypeDeclaration9467);
            st=this.p_SequenceType();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_SequenceType.add(st.getTree());


            // AST REWRITE
            // elements: st
            // token labels: 
            // rule labels: retval, st
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_st=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token st",st!=null?st.tree:null);

            root_0 = this.adaptor.nil();
            // 1292:17: -> ^( TypeDeclaration $st)
            {
                // xquery/XQueryParser.g:1292:20: ^( TypeDeclaration $st)
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(TypeDeclaration, "TypeDeclaration"), root_1);

                this.adaptor.addChild(root_1, stream_st.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SequenceType_return: (function() {
        XQueryParser.p_SequenceType_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SequenceType_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1296:1: p_SequenceType : (k= EMPTY_SEQUENCE l= LPAREN r= RPAREN -> ^( SequenceType ^( EmptySequenceTest $k $l $r) ) | it= p_ItemType ( ( p_OccurrenceIndicator )=>oi= p_OccurrenceIndicator )? -> ^( SequenceType $it ( $oi)? ) );
    // $ANTLR start "p_SequenceType"
    p_SequenceType: function() {
        var retval = new XQueryParser.p_SequenceType_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var l = null;
        var r = null;
         var it = null;
         var oi = null;

        var k_tree=null;
        var l_tree=null;
        var r_tree=null;
        var stream_EMPTY_SEQUENCE=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EMPTY_SEQUENCE");
        var stream_RPAREN=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RPAREN");
        var stream_LPAREN=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LPAREN");
        var stream_p_ItemType=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_ItemType");
        var stream_p_OccurrenceIndicator=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_OccurrenceIndicator");
        try {
            // xquery/XQueryParser.g:1297:9: (k= EMPTY_SEQUENCE l= LPAREN r= RPAREN -> ^( SequenceType ^( EmptySequenceTest $k $l $r) ) | it= p_ItemType ( ( p_OccurrenceIndicator )=>oi= p_OccurrenceIndicator )? -> ^( SequenceType $it ( $oi)? ) )
            var alt162=2;
            var LA162_0 = this.input.LA(1);

            if ( (LA162_0==EMPTY_SEQUENCE) ) {
                var LA162_1 = this.input.LA(2);

                if ( (LA162_1==LPAREN) ) {
                    alt162=1;
                }
                else if ( (LA162_1==EOF||(LA162_1>=AND && LA162_1<=AT)||LA162_1==CASE||LA162_1==COLLATION||LA162_1==DEFAULT||(LA162_1>=DESCENDING && LA162_1<=DIV)||LA162_1==EMPTY||LA162_1==EQ||(LA162_1>=EXCEPT && LA162_1<=EXTERNAL)||LA162_1==FOR||LA162_1==GE||(LA162_1>=GT && LA162_1<=IDIV)||LA162_1==IN||(LA162_1>=INSTANCE && LA162_1<=IS)||LA162_1==LE||(LA162_1>=LET && LA162_1<=MOD)||LA162_1==NE||(LA162_1>=OR && LA162_1<=ORDER)||(LA162_1>=RETURN && LA162_1<=SATISFIES)||LA162_1==STABLE||LA162_1==TO||LA162_1==UNION||LA162_1==WHERE||LA162_1==ALLOWING||LA162_1==COUNT||(LA162_1>=END && LA162_1<=GROUP)||LA162_1==ONLY||LA162_1==START||(LA162_1>=AFTER && LA162_1<=BEFORE)||LA162_1==INTO||LA162_1==MODIFY||LA162_1==WITH||LA162_1==CONTAINS||LA162_1==PARAGRAPHS||LA162_1==SCORE||LA162_1==SENTENCES||LA162_1==TIMES||LA162_1==WORDS||LA162_1==CONCAT||LA162_1==RPAREN||(LA162_1>=LBRACKET && LA162_1<=RBRACKET)||(LA162_1>=RSQUARE && LA162_1<=NOTEQUAL)||(LA162_1>=COMMA && LA162_1<=GREATER_GREATER)||LA162_1==COLON||(LA162_1>=SEMICOLON && LA162_1<=VBAR)) ) {
                    alt162=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 162, 1, this.input);

                    throw nvae;
                }
            }
            else if ( ((LA162_0>=ANCESTOR && LA162_0<=EMPTY)||(LA162_0>=ENCODING && LA162_0<=SKIP)||(LA162_0>=VALUE && LA162_0<=QUOT_ER)||LA162_0==LPAREN||LA162_0==L_NCName||LA162_0==EXPLICITLY) ) {
                alt162=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 162, 0, this.input);

                throw nvae;
            }
            switch (alt162) {
                case 1 :
                    // xquery/XQueryParser.g:1297:11: k= EMPTY_SEQUENCE l= LPAREN r= RPAREN
                    k=this.match(this.input,EMPTY_SEQUENCE,XQueryParser.FOLLOW_EMPTY_SEQUENCE_in_p_SequenceType9520); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_EMPTY_SEQUENCE.add(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    l=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_SequenceType9526); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_LPAREN.add(l);

                    r=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_SequenceType9530); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_RPAREN.add(r);



                    // AST REWRITE
                    // elements: l, k, r
                    // token labels: r, l, k
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_r=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token r",r);
                    var stream_l=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token l",l);
                    var stream_k=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token k",k);
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1298:17: -> ^( SequenceType ^( EmptySequenceTest $k $l $r) )
                    {
                        // xquery/XQueryParser.g:1298:20: ^( SequenceType ^( EmptySequenceTest $k $l $r) )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(SequenceType, "SequenceType"), root_1);

                        // xquery/XQueryParser.g:1298:35: ^( EmptySequenceTest $k $l $r)
                        {
                        var root_2 = this.adaptor.nil();
                        root_2 = this.adaptor.becomeRoot(this.adaptor.create(EmptySequenceTest, "EmptySequenceTest"), root_2);

                        this.adaptor.addChild(root_2, stream_k.nextNode());
                        this.adaptor.addChild(root_2, stream_l.nextNode());
                        this.adaptor.addChild(root_2, stream_r.nextNode());

                        this.adaptor.addChild(root_1, root_2);
                        }

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // xquery/XQueryParser.g:1299:11: it= p_ItemType ( ( p_OccurrenceIndicator )=>oi= p_OccurrenceIndicator )?
                    this.pushFollow(XQueryParser.FOLLOW_p_ItemType_in_p_SequenceType9579);
                    it=this.p_ItemType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_ItemType.add(it.getTree());
                    // xquery/XQueryParser.g:1299:25: ( ( p_OccurrenceIndicator )=>oi= p_OccurrenceIndicator )?
                    var alt161=2;
                    alt161 = this.dfa161.predict(this.input);
                    switch (alt161) {
                        case 1 :
                            // xquery/XQueryParser.g:1299:26: ( p_OccurrenceIndicator )=>oi= p_OccurrenceIndicator
                            this.pushFollow(XQueryParser.FOLLOW_p_OccurrenceIndicator_in_p_SequenceType9590);
                            oi=this.p_OccurrenceIndicator();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) stream_p_OccurrenceIndicator.add(oi.getTree());


                            break;

                    }



                    // AST REWRITE
                    // elements: oi, it
                    // token labels: 
                    // rule labels: retval, it, oi
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
                    var stream_it=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token it",it!=null?it.tree:null);
                    var stream_oi=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token oi",oi!=null?oi.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1300:17: -> ^( SequenceType $it ( $oi)? )
                    {
                        // xquery/XQueryParser.g:1300:20: ^( SequenceType $it ( $oi)? )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(SequenceType, "SequenceType"), root_1);

                        this.adaptor.addChild(root_1, stream_it.nextTree());
                        // xquery/XQueryParser.g:1300:39: ( $oi)?
                        if ( stream_oi.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_oi.nextTree());

                        }
                        stream_oi.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_OccurrenceIndicator_return: (function() {
        XQueryParser.p_OccurrenceIndicator_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_OccurrenceIndicator_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1304:1: p_OccurrenceIndicator : ( QUESTION | STAR | PLUS );
    // $ANTLR start "p_OccurrenceIndicator"
    p_OccurrenceIndicator: function() {
        var retval = new XQueryParser.p_OccurrenceIndicator_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set450 = null;

        var set450_tree=null;

        try {
            // xquery/XQueryParser.g:1305:9: ( QUESTION | STAR | PLUS )
            // xquery/XQueryParser.g:
            root_0 = this.adaptor.nil();

            set450=this.input.LT(1);
            if ( (this.input.LA(1)>=QUESTION && this.input.LA(1)<=PLUS) ) {
                this.input.consume();
                if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set450));
                this.state.errorRecovery=false;this.state.failed=false;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                throw mse;
            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ItemType_return: (function() {
        XQueryParser.p_ItemType_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ItemType_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1309:1: p_ItemType : ( p_KindTest -> ^( KindTest p_KindTest ) | {...}? => ( BINARY LPAREN RPAREN ) -> ^( BinaryTest BINARY LPAREN RPAREN ) | ( ITEM LPAREN RPAREN ) -> ^( ItemTest ITEM LPAREN RPAREN ) | p_AtomicOrUnionType | p_ParenthesizedItemType );
    // $ANTLR start "p_ItemType"
    p_ItemType: function() {
        var retval = new XQueryParser.p_ItemType_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var BINARY452 = null;
        var LPAREN453 = null;
        var RPAREN454 = null;
        var ITEM455 = null;
        var LPAREN456 = null;
        var RPAREN457 = null;
         var p_KindTest451 = null;
         var p_AtomicOrUnionType458 = null;
         var p_ParenthesizedItemType459 = null;

        var BINARY452_tree=null;
        var LPAREN453_tree=null;
        var RPAREN454_tree=null;
        var ITEM455_tree=null;
        var LPAREN456_tree=null;
        var RPAREN457_tree=null;
        var stream_RPAREN=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token RPAREN");
        var stream_ITEM=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token ITEM");
        var stream_BINARY=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token BINARY");
        var stream_LPAREN=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token LPAREN");
        var stream_p_KindTest=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_KindTest");
        try {
            // xquery/XQueryParser.g:1310:9: ( p_KindTest -> ^( KindTest p_KindTest ) | {...}? => ( BINARY LPAREN RPAREN ) -> ^( BinaryTest BINARY LPAREN RPAREN ) | ( ITEM LPAREN RPAREN ) -> ^( ItemTest ITEM LPAREN RPAREN ) | p_AtomicOrUnionType | p_ParenthesizedItemType )
            var alt163=5;
            alt163 = this.dfa163.predict(this.input);
            switch (alt163) {
                case 1 :
                    // xquery/XQueryParser.g:1310:11: p_KindTest
                    this.pushFollow(XQueryParser.FOLLOW_p_KindTest_in_p_ItemType9692);
                    p_KindTest451=this.p_KindTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_KindTest.add(p_KindTest451.getTree());


                    // AST REWRITE
                    // elements: p_KindTest
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1311:17: -> ^( KindTest p_KindTest )
                    {
                        // xquery/XQueryParser.g:1311:20: ^( KindTest p_KindTest )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(KindTest, "KindTest"), root_1);

                        this.adaptor.addChild(root_1, stream_p_KindTest.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // xquery/XQueryParser.g:1312:11: {...}? => ( BINARY LPAREN RPAREN )
                    if ( !((this.lc(MLS))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "p_ItemType", "this.lc(MLS)");
                    }
                    // xquery/XQueryParser.g:1312:29: ( BINARY LPAREN RPAREN )
                    // xquery/XQueryParser.g:1312:30: BINARY LPAREN RPAREN
                    BINARY452=this.match(this.input,BINARY,XQueryParser.FOLLOW_BINARY_in_p_ItemType9732); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_BINARY.add(BINARY452);

                    LPAREN453=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_ItemType9734); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_LPAREN.add(LPAREN453);

                    RPAREN454=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_ItemType9736); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_RPAREN.add(RPAREN454);






                    // AST REWRITE
                    // elements: LPAREN, RPAREN, BINARY
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1313:17: -> ^( BinaryTest BINARY LPAREN RPAREN )
                    {
                        // xquery/XQueryParser.g:1313:20: ^( BinaryTest BINARY LPAREN RPAREN )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(BinaryTest, "BinaryTest"), root_1);

                        this.adaptor.addChild(root_1, stream_BINARY.nextNode());
                        this.adaptor.addChild(root_1, stream_LPAREN.nextNode());
                        this.adaptor.addChild(root_1, stream_RPAREN.nextNode());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 3 :
                    // xquery/XQueryParser.g:1314:11: ( ITEM LPAREN RPAREN )
                    // xquery/XQueryParser.g:1314:11: ( ITEM LPAREN RPAREN )
                    // xquery/XQueryParser.g:1314:12: ITEM LPAREN RPAREN
                    ITEM455=this.match(this.input,ITEM,XQueryParser.FOLLOW_ITEM_in_p_ItemType9778); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_ITEM.add(ITEM455);

                    LPAREN456=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_ItemType9780); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_LPAREN.add(LPAREN456);

                    RPAREN457=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_ItemType9782); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_RPAREN.add(RPAREN457);






                    // AST REWRITE
                    // elements: ITEM, RPAREN, LPAREN
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1315:17: -> ^( ItemTest ITEM LPAREN RPAREN )
                    {
                        // xquery/XQueryParser.g:1315:20: ^( ItemTest ITEM LPAREN RPAREN )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(ItemTest, "ItemTest"), root_1);

                        this.adaptor.addChild(root_1, stream_ITEM.nextNode());
                        this.adaptor.addChild(root_1, stream_LPAREN.nextNode());
                        this.adaptor.addChild(root_1, stream_RPAREN.nextNode());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 4 :
                    // xquery/XQueryParser.g:1319:11: p_AtomicOrUnionType
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AtomicOrUnionType_in_p_ItemType9826);
                    p_AtomicOrUnionType458=this.p_AtomicOrUnionType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AtomicOrUnionType458.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1320:11: p_ParenthesizedItemType
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ParenthesizedItemType_in_p_ItemType9838);
                    p_ParenthesizedItemType459=this.p_ParenthesizedItemType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ParenthesizedItemType459.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AtomicOrUnionType_return: (function() {
        XQueryParser.p_AtomicOrUnionType_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AtomicOrUnionType_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1324:1: p_AtomicOrUnionType : p_QName -> ^( AtomicOrUnionType p_QName ) ;
    // $ANTLR start "p_AtomicOrUnionType"
    p_AtomicOrUnionType: function() {
        var retval = new XQueryParser.p_AtomicOrUnionType_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName460 = null;

        var stream_p_QName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_QName");
        try {
            // xquery/XQueryParser.g:1325:9: ( p_QName -> ^( AtomicOrUnionType p_QName ) )
            // xquery/XQueryParser.g:1325:11: p_QName
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_AtomicOrUnionType9864);
            p_QName460=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_QName.add(p_QName460.getTree());


            // AST REWRITE
            // elements: p_QName
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 1326:17: -> ^( AtomicOrUnionType p_QName )
            {
                // xquery/XQueryParser.g:1326:20: ^( AtomicOrUnionType p_QName )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(AtomicOrUnionType, "AtomicOrUnionType"), root_1);

                this.adaptor.addChild(root_1, stream_p_QName.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_KindTest_return: (function() {
        XQueryParser.p_KindTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_KindTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1330:1: p_KindTest : ( p_DocumentTest | p_ElementTest | p_AttributeTest | p_SchemaElementTest | p_SchemaAttributeTest | p_PITest | p_CommentTest | p_TextTest | p_NamespaceNodeTest | p_AnyKindTest );
    // $ANTLR start "p_KindTest"
    p_KindTest: function() {
        var retval = new XQueryParser.p_KindTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_DocumentTest461 = null;
         var p_ElementTest462 = null;
         var p_AttributeTest463 = null;
         var p_SchemaElementTest464 = null;
         var p_SchemaAttributeTest465 = null;
         var p_PITest466 = null;
         var p_CommentTest467 = null;
         var p_TextTest468 = null;
         var p_NamespaceNodeTest469 = null;
         var p_AnyKindTest470 = null;


        try {
            // xquery/XQueryParser.g:1331:9: ( p_DocumentTest | p_ElementTest | p_AttributeTest | p_SchemaElementTest | p_SchemaAttributeTest | p_PITest | p_CommentTest | p_TextTest | p_NamespaceNodeTest | p_AnyKindTest )
            var alt164=10;
            switch ( this.input.LA(1) ) {
            case DOCUMENT_NODE:
                alt164=1;
                break;
            case ELEMENT:
                alt164=2;
                break;
            case ATTRIBUTE:
                alt164=3;
                break;
            case SCHEMA_ELEMENT:
                alt164=4;
                break;
            case SCHEMA_ATTRIBUTE:
                alt164=5;
                break;
            case PROCESSING_INSTRUCTION:
                alt164=6;
                break;
            case COMMENT:
                alt164=7;
                break;
            case TEXT:
                alt164=8;
                break;
            case NAMESPACE_NODE:
                alt164=9;
                break;
            case NODE:
                alt164=10;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 164, 0, this.input);

                throw nvae;
            }

            switch (alt164) {
                case 1 :
                    // xquery/XQueryParser.g:1331:11: p_DocumentTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_DocumentTest_in_p_KindTest9914);
                    p_DocumentTest461=this.p_DocumentTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DocumentTest461.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1332:11: p_ElementTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ElementTest_in_p_KindTest9926);
                    p_ElementTest462=this.p_ElementTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ElementTest462.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1333:11: p_AttributeTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AttributeTest_in_p_KindTest9938);
                    p_AttributeTest463=this.p_AttributeTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AttributeTest463.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1334:11: p_SchemaElementTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_SchemaElementTest_in_p_KindTest9950);
                    p_SchemaElementTest464=this.p_SchemaElementTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SchemaElementTest464.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1335:11: p_SchemaAttributeTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_SchemaAttributeTest_in_p_KindTest9962);
                    p_SchemaAttributeTest465=this.p_SchemaAttributeTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SchemaAttributeTest465.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:1336:11: p_PITest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_PITest_in_p_KindTest9974);
                    p_PITest466=this.p_PITest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PITest466.getTree());


                    break;
                case 7 :
                    // xquery/XQueryParser.g:1337:11: p_CommentTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_CommentTest_in_p_KindTest9986);
                    p_CommentTest467=this.p_CommentTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CommentTest467.getTree());


                    break;
                case 8 :
                    // xquery/XQueryParser.g:1338:11: p_TextTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_TextTest_in_p_KindTest9998);
                    p_TextTest468=this.p_TextTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TextTest468.getTree());


                    break;
                case 9 :
                    // xquery/XQueryParser.g:1339:11: p_NamespaceNodeTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_NamespaceNodeTest_in_p_KindTest10010);
                    p_NamespaceNodeTest469=this.p_NamespaceNodeTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NamespaceNodeTest469.getTree());


                    break;
                case 10 :
                    // xquery/XQueryParser.g:1340:11: p_AnyKindTest
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AnyKindTest_in_p_KindTest10022);
                    p_AnyKindTest470=this.p_AnyKindTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AnyKindTest470.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AnyKindTest_return: (function() {
        XQueryParser.p_AnyKindTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AnyKindTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1344:1: p_AnyKindTest : NODE LPAREN RPAREN ;
    // $ANTLR start "p_AnyKindTest"
    p_AnyKindTest: function() {
        var retval = new XQueryParser.p_AnyKindTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var NODE471 = null;
        var LPAREN472 = null;
        var RPAREN473 = null;

        var NODE471_tree=null;
        var LPAREN472_tree=null;
        var RPAREN473_tree=null;

        try {
            // xquery/XQueryParser.g:1345:9: ( NODE LPAREN RPAREN )
            // xquery/XQueryParser.g:1345:11: NODE LPAREN RPAREN
            root_0 = this.adaptor.nil();

            NODE471=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_AnyKindTest10048); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            NODE471_tree = this.adaptor.create(NODE471);
            this.adaptor.addChild(root_0, NODE471_tree);
            }
            LPAREN472=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_AnyKindTest10050); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN472_tree = this.adaptor.create(LPAREN472);
            this.adaptor.addChild(root_0, LPAREN472_tree);
            }
            RPAREN473=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_AnyKindTest10052); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN473_tree = this.adaptor.create(RPAREN473);
            this.adaptor.addChild(root_0, RPAREN473_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DocumentTest_return: (function() {
        XQueryParser.p_DocumentTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DocumentTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1349:1: p_DocumentTest : DOCUMENT_NODE LPAREN ( p_ElementTest | p_SchemaElementTest )? RPAREN ;
    // $ANTLR start "p_DocumentTest"
    p_DocumentTest: function() {
        var retval = new XQueryParser.p_DocumentTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var DOCUMENT_NODE474 = null;
        var LPAREN475 = null;
        var RPAREN478 = null;
         var p_ElementTest476 = null;
         var p_SchemaElementTest477 = null;

        var DOCUMENT_NODE474_tree=null;
        var LPAREN475_tree=null;
        var RPAREN478_tree=null;

        try {
            // xquery/XQueryParser.g:1350:9: ( DOCUMENT_NODE LPAREN ( p_ElementTest | p_SchemaElementTest )? RPAREN )
            // xquery/XQueryParser.g:1350:11: DOCUMENT_NODE LPAREN ( p_ElementTest | p_SchemaElementTest )? RPAREN
            root_0 = this.adaptor.nil();

            DOCUMENT_NODE474=this.match(this.input,DOCUMENT_NODE,XQueryParser.FOLLOW_DOCUMENT_NODE_in_p_DocumentTest10078); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            DOCUMENT_NODE474_tree = this.adaptor.create(DOCUMENT_NODE474);
            this.adaptor.addChild(root_0, DOCUMENT_NODE474_tree);
            }
            LPAREN475=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_DocumentTest10080); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN475_tree = this.adaptor.create(LPAREN475);
            this.adaptor.addChild(root_0, LPAREN475_tree);
            }
            // xquery/XQueryParser.g:1350:32: ( p_ElementTest | p_SchemaElementTest )?
            var alt165=3;
            var LA165_0 = this.input.LA(1);

            if ( (LA165_0==ELEMENT) ) {
                alt165=1;
            }
            else if ( (LA165_0==SCHEMA_ELEMENT) ) {
                alt165=2;
            }
            switch (alt165) {
                case 1 :
                    // xquery/XQueryParser.g:1350:33: p_ElementTest
                    this.pushFollow(XQueryParser.FOLLOW_p_ElementTest_in_p_DocumentTest10083);
                    p_ElementTest476=this.p_ElementTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ElementTest476.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1350:49: p_SchemaElementTest
                    this.pushFollow(XQueryParser.FOLLOW_p_SchemaElementTest_in_p_DocumentTest10087);
                    p_SchemaElementTest477=this.p_SchemaElementTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SchemaElementTest477.getTree());


                    break;

            }

            RPAREN478=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_DocumentTest10091); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN478_tree = this.adaptor.create(RPAREN478);
            this.adaptor.addChild(root_0, RPAREN478_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TextTest_return: (function() {
        XQueryParser.p_TextTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TextTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1354:1: p_TextTest : TEXT LPAREN RPAREN ;
    // $ANTLR start "p_TextTest"
    p_TextTest: function() {
        var retval = new XQueryParser.p_TextTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var TEXT479 = null;
        var LPAREN480 = null;
        var RPAREN481 = null;

        var TEXT479_tree=null;
        var LPAREN480_tree=null;
        var RPAREN481_tree=null;

        try {
            // xquery/XQueryParser.g:1355:9: ( TEXT LPAREN RPAREN )
            // xquery/XQueryParser.g:1355:11: TEXT LPAREN RPAREN
            root_0 = this.adaptor.nil();

            TEXT479=this.match(this.input,TEXT,XQueryParser.FOLLOW_TEXT_in_p_TextTest10117); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            TEXT479_tree = this.adaptor.create(TEXT479);
            this.adaptor.addChild(root_0, TEXT479_tree);
            }
            LPAREN480=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_TextTest10119); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN480_tree = this.adaptor.create(LPAREN480);
            this.adaptor.addChild(root_0, LPAREN480_tree);
            }
            RPAREN481=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_TextTest10121); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN481_tree = this.adaptor.create(RPAREN481);
            this.adaptor.addChild(root_0, RPAREN481_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CommentTest_return: (function() {
        XQueryParser.p_CommentTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CommentTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1359:1: p_CommentTest : COMMENT LPAREN RPAREN ;
    // $ANTLR start "p_CommentTest"
    p_CommentTest: function() {
        var retval = new XQueryParser.p_CommentTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var COMMENT482 = null;
        var LPAREN483 = null;
        var RPAREN484 = null;

        var COMMENT482_tree=null;
        var LPAREN483_tree=null;
        var RPAREN484_tree=null;

        try {
            // xquery/XQueryParser.g:1360:9: ( COMMENT LPAREN RPAREN )
            // xquery/XQueryParser.g:1360:11: COMMENT LPAREN RPAREN
            root_0 = this.adaptor.nil();

            COMMENT482=this.match(this.input,COMMENT,XQueryParser.FOLLOW_COMMENT_in_p_CommentTest10147); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            COMMENT482_tree = this.adaptor.create(COMMENT482);
            this.adaptor.addChild(root_0, COMMENT482_tree);
            }
            LPAREN483=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_CommentTest10149); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN483_tree = this.adaptor.create(LPAREN483);
            this.adaptor.addChild(root_0, LPAREN483_tree);
            }
            RPAREN484=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_CommentTest10151); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN484_tree = this.adaptor.create(RPAREN484);
            this.adaptor.addChild(root_0, RPAREN484_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NamespaceNodeTest_return: (function() {
        XQueryParser.p_NamespaceNodeTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NamespaceNodeTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1364:1: p_NamespaceNodeTest : NAMESPACE_NODE LPAREN RPAREN ;
    // $ANTLR start "p_NamespaceNodeTest"
    p_NamespaceNodeTest: function() {
        var retval = new XQueryParser.p_NamespaceNodeTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var NAMESPACE_NODE485 = null;
        var LPAREN486 = null;
        var RPAREN487 = null;

        var NAMESPACE_NODE485_tree=null;
        var LPAREN486_tree=null;
        var RPAREN487_tree=null;

        try {
            // xquery/XQueryParser.g:1365:9: ( NAMESPACE_NODE LPAREN RPAREN )
            // xquery/XQueryParser.g:1365:11: NAMESPACE_NODE LPAREN RPAREN
            root_0 = this.adaptor.nil();

            NAMESPACE_NODE485=this.match(this.input,NAMESPACE_NODE,XQueryParser.FOLLOW_NAMESPACE_NODE_in_p_NamespaceNodeTest10177); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            NAMESPACE_NODE485_tree = this.adaptor.create(NAMESPACE_NODE485);
            this.adaptor.addChild(root_0, NAMESPACE_NODE485_tree);
            }
            LPAREN486=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_NamespaceNodeTest10179); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN486_tree = this.adaptor.create(LPAREN486);
            this.adaptor.addChild(root_0, LPAREN486_tree);
            }
            RPAREN487=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_NamespaceNodeTest10181); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN487_tree = this.adaptor.create(RPAREN487);
            this.adaptor.addChild(root_0, RPAREN487_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_PITest_return: (function() {
        XQueryParser.p_PITest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_PITest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1369:1: p_PITest : PROCESSING_INSTRUCTION LPAREN ( p_NCName | p_StringLiteral )? RPAREN ;
    // $ANTLR start "p_PITest"
    p_PITest: function() {
        var retval = new XQueryParser.p_PITest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var PROCESSING_INSTRUCTION488 = null;
        var LPAREN489 = null;
        var RPAREN492 = null;
         var p_NCName490 = null;
         var p_StringLiteral491 = null;

        var PROCESSING_INSTRUCTION488_tree=null;
        var LPAREN489_tree=null;
        var RPAREN492_tree=null;

        try {
            // xquery/XQueryParser.g:1370:9: ( PROCESSING_INSTRUCTION LPAREN ( p_NCName | p_StringLiteral )? RPAREN )
            // xquery/XQueryParser.g:1370:11: PROCESSING_INSTRUCTION LPAREN ( p_NCName | p_StringLiteral )? RPAREN
            root_0 = this.adaptor.nil();

            PROCESSING_INSTRUCTION488=this.match(this.input,PROCESSING_INSTRUCTION,XQueryParser.FOLLOW_PROCESSING_INSTRUCTION_in_p_PITest10207); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            PROCESSING_INSTRUCTION488_tree = this.adaptor.create(PROCESSING_INSTRUCTION488);
            this.adaptor.addChild(root_0, PROCESSING_INSTRUCTION488_tree);
            }
            LPAREN489=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_PITest10209); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN489_tree = this.adaptor.create(LPAREN489);
            this.adaptor.addChild(root_0, LPAREN489_tree);
            }
            // xquery/XQueryParser.g:1370:41: ( p_NCName | p_StringLiteral )?
            var alt166=3;
            var LA166_0 = this.input.LA(1);

            if ( ((LA166_0>=ANCESTOR && LA166_0<=SKIP)||(LA166_0>=VALUE && LA166_0<=QUOT_ER)||LA166_0==L_NCName||LA166_0==EXPLICITLY) ) {
                alt166=1;
            }
            else if ( ((LA166_0>=APOS && LA166_0<=QUOT)) ) {
                alt166=2;
            }
            switch (alt166) {
                case 1 :
                    // xquery/XQueryParser.g:1370:42: p_NCName
                    this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_p_PITest10212);
                    p_NCName490=this.p_NCName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NCName490.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1370:53: p_StringLiteral
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_PITest10216);
                    p_StringLiteral491=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral491.getTree());


                    break;

            }

            RPAREN492=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_PITest10220); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN492_tree = this.adaptor.create(RPAREN492);
            this.adaptor.addChild(root_0, RPAREN492_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AttributeTest_return: (function() {
        XQueryParser.p_AttributeTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AttributeTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1374:1: p_AttributeTest : ATTRIBUTE LPAREN ( p_AttribNameOrWildcard ( COMMA p_TypeName )? )? RPAREN ;
    // $ANTLR start "p_AttributeTest"
    p_AttributeTest: function() {
        var retval = new XQueryParser.p_AttributeTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ATTRIBUTE493 = null;
        var LPAREN494 = null;
        var COMMA496 = null;
        var RPAREN498 = null;
         var p_AttribNameOrWildcard495 = null;
         var p_TypeName497 = null;

        var ATTRIBUTE493_tree=null;
        var LPAREN494_tree=null;
        var COMMA496_tree=null;
        var RPAREN498_tree=null;

        try {
            // xquery/XQueryParser.g:1375:9: ( ATTRIBUTE LPAREN ( p_AttribNameOrWildcard ( COMMA p_TypeName )? )? RPAREN )
            // xquery/XQueryParser.g:1375:11: ATTRIBUTE LPAREN ( p_AttribNameOrWildcard ( COMMA p_TypeName )? )? RPAREN
            root_0 = this.adaptor.nil();

            ATTRIBUTE493=this.match(this.input,ATTRIBUTE,XQueryParser.FOLLOW_ATTRIBUTE_in_p_AttributeTest10246); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            ATTRIBUTE493_tree = this.adaptor.create(ATTRIBUTE493);
            this.adaptor.addChild(root_0, ATTRIBUTE493_tree);
            }
            LPAREN494=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_AttributeTest10248); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN494_tree = this.adaptor.create(LPAREN494);
            this.adaptor.addChild(root_0, LPAREN494_tree);
            }
            // xquery/XQueryParser.g:1375:28: ( p_AttribNameOrWildcard ( COMMA p_TypeName )? )?
            var alt168=2;
            var LA168_0 = this.input.LA(1);

            if ( ((LA168_0>=ANCESTOR && LA168_0<=SKIP)||(LA168_0>=VALUE && LA168_0<=QUOT_ER)||LA168_0==STAR||LA168_0==L_NCName||LA168_0==EXPLICITLY) ) {
                alt168=1;
            }
            switch (alt168) {
                case 1 :
                    // xquery/XQueryParser.g:1375:29: p_AttribNameOrWildcard ( COMMA p_TypeName )?
                    this.pushFollow(XQueryParser.FOLLOW_p_AttribNameOrWildcard_in_p_AttributeTest10251);
                    p_AttribNameOrWildcard495=this.p_AttribNameOrWildcard();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AttribNameOrWildcard495.getTree());
                    // xquery/XQueryParser.g:1375:52: ( COMMA p_TypeName )?
                    var alt167=2;
                    var LA167_0 = this.input.LA(1);

                    if ( (LA167_0==COMMA) ) {
                        alt167=1;
                    }
                    switch (alt167) {
                        case 1 :
                            // xquery/XQueryParser.g:1375:53: COMMA p_TypeName
                            COMMA496=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_AttributeTest10254); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COMMA496_tree = this.adaptor.create(COMMA496);
                            this.adaptor.addChild(root_0, COMMA496_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_TypeName_in_p_AttributeTest10256);
                            p_TypeName497=this.p_TypeName();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeName497.getTree());


                            break;

                    }



                    break;

            }

            RPAREN498=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_AttributeTest10262); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN498_tree = this.adaptor.create(RPAREN498);
            this.adaptor.addChild(root_0, RPAREN498_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AttribNameOrWildcard_return: (function() {
        XQueryParser.p_AttribNameOrWildcard_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AttribNameOrWildcard_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1379:1: p_AttribNameOrWildcard : ( p_AttributeName | STAR );
    // $ANTLR start "p_AttribNameOrWildcard"
    p_AttribNameOrWildcard: function() {
        var retval = new XQueryParser.p_AttribNameOrWildcard_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var STAR500 = null;
         var p_AttributeName499 = null;

        var STAR500_tree=null;

        try {
            // xquery/XQueryParser.g:1380:9: ( p_AttributeName | STAR )
            var alt169=2;
            var LA169_0 = this.input.LA(1);

            if ( ((LA169_0>=ANCESTOR && LA169_0<=SKIP)||(LA169_0>=VALUE && LA169_0<=QUOT_ER)||LA169_0==L_NCName||LA169_0==EXPLICITLY) ) {
                alt169=1;
            }
            else if ( (LA169_0==STAR) ) {
                alt169=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 169, 0, this.input);

                throw nvae;
            }
            switch (alt169) {
                case 1 :
                    // xquery/XQueryParser.g:1380:11: p_AttributeName
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AttributeName_in_p_AttribNameOrWildcard10290);
                    p_AttributeName499=this.p_AttributeName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AttributeName499.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1380:29: STAR
                    root_0 = this.adaptor.nil();

                    STAR500=this.match(this.input,STAR,XQueryParser.FOLLOW_STAR_in_p_AttribNameOrWildcard10294); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    STAR500_tree = this.adaptor.create(STAR500);
                    this.adaptor.addChild(root_0, STAR500_tree);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SchemaAttributeTest_return: (function() {
        XQueryParser.p_SchemaAttributeTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SchemaAttributeTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1384:1: p_SchemaAttributeTest : SCHEMA_ATTRIBUTE LPAREN p_AttributeDeclaration RPAREN ;
    // $ANTLR start "p_SchemaAttributeTest"
    p_SchemaAttributeTest: function() {
        var retval = new XQueryParser.p_SchemaAttributeTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SCHEMA_ATTRIBUTE501 = null;
        var LPAREN502 = null;
        var RPAREN504 = null;
         var p_AttributeDeclaration503 = null;

        var SCHEMA_ATTRIBUTE501_tree=null;
        var LPAREN502_tree=null;
        var RPAREN504_tree=null;

        try {
            // xquery/XQueryParser.g:1385:9: ( SCHEMA_ATTRIBUTE LPAREN p_AttributeDeclaration RPAREN )
            // xquery/XQueryParser.g:1385:11: SCHEMA_ATTRIBUTE LPAREN p_AttributeDeclaration RPAREN
            root_0 = this.adaptor.nil();

            SCHEMA_ATTRIBUTE501=this.match(this.input,SCHEMA_ATTRIBUTE,XQueryParser.FOLLOW_SCHEMA_ATTRIBUTE_in_p_SchemaAttributeTest10320); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SCHEMA_ATTRIBUTE501_tree = this.adaptor.create(SCHEMA_ATTRIBUTE501);
            this.adaptor.addChild(root_0, SCHEMA_ATTRIBUTE501_tree);
            }
            LPAREN502=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_SchemaAttributeTest10322); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN502_tree = this.adaptor.create(LPAREN502);
            this.adaptor.addChild(root_0, LPAREN502_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_AttributeDeclaration_in_p_SchemaAttributeTest10324);
            p_AttributeDeclaration503=this.p_AttributeDeclaration();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AttributeDeclaration503.getTree());
            RPAREN504=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_SchemaAttributeTest10326); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN504_tree = this.adaptor.create(RPAREN504);
            this.adaptor.addChild(root_0, RPAREN504_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AttributeDeclaration_return: (function() {
        XQueryParser.p_AttributeDeclaration_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AttributeDeclaration_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1389:1: p_AttributeDeclaration : p_AttributeName ;
    // $ANTLR start "p_AttributeDeclaration"
    p_AttributeDeclaration: function() {
        var retval = new XQueryParser.p_AttributeDeclaration_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_AttributeName505 = null;


        try {
            // xquery/XQueryParser.g:1390:9: ( p_AttributeName )
            // xquery/XQueryParser.g:1390:11: p_AttributeName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_AttributeName_in_p_AttributeDeclaration10352);
            p_AttributeName505=this.p_AttributeName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AttributeName505.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ElementTest_return: (function() {
        XQueryParser.p_ElementTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ElementTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1394:1: p_ElementTest : ELEMENT LPAREN ( p_ElementNameOrWildcard ( COMMA p_TypeName ( QUESTION )? )? )? RPAREN ;
    // $ANTLR start "p_ElementTest"
    p_ElementTest: function() {
        var retval = new XQueryParser.p_ElementTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ELEMENT506 = null;
        var LPAREN507 = null;
        var COMMA509 = null;
        var QUESTION511 = null;
        var RPAREN512 = null;
         var p_ElementNameOrWildcard508 = null;
         var p_TypeName510 = null;

        var ELEMENT506_tree=null;
        var LPAREN507_tree=null;
        var COMMA509_tree=null;
        var QUESTION511_tree=null;
        var RPAREN512_tree=null;

        try {
            // xquery/XQueryParser.g:1395:9: ( ELEMENT LPAREN ( p_ElementNameOrWildcard ( COMMA p_TypeName ( QUESTION )? )? )? RPAREN )
            // xquery/XQueryParser.g:1395:11: ELEMENT LPAREN ( p_ElementNameOrWildcard ( COMMA p_TypeName ( QUESTION )? )? )? RPAREN
            root_0 = this.adaptor.nil();

            ELEMENT506=this.match(this.input,ELEMENT,XQueryParser.FOLLOW_ELEMENT_in_p_ElementTest10378); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            ELEMENT506_tree = this.adaptor.create(ELEMENT506);
            this.adaptor.addChild(root_0, ELEMENT506_tree);
            }
            LPAREN507=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_ElementTest10380); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN507_tree = this.adaptor.create(LPAREN507);
            this.adaptor.addChild(root_0, LPAREN507_tree);
            }
            // xquery/XQueryParser.g:1395:26: ( p_ElementNameOrWildcard ( COMMA p_TypeName ( QUESTION )? )? )?
            var alt172=2;
            var LA172_0 = this.input.LA(1);

            if ( ((LA172_0>=ANCESTOR && LA172_0<=SKIP)||(LA172_0>=VALUE && LA172_0<=QUOT_ER)||LA172_0==STAR||LA172_0==L_NCName||LA172_0==EXPLICITLY) ) {
                alt172=1;
            }
            switch (alt172) {
                case 1 :
                    // xquery/XQueryParser.g:1395:27: p_ElementNameOrWildcard ( COMMA p_TypeName ( QUESTION )? )?
                    this.pushFollow(XQueryParser.FOLLOW_p_ElementNameOrWildcard_in_p_ElementTest10383);
                    p_ElementNameOrWildcard508=this.p_ElementNameOrWildcard();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ElementNameOrWildcard508.getTree());
                    // xquery/XQueryParser.g:1395:51: ( COMMA p_TypeName ( QUESTION )? )?
                    var alt171=2;
                    var LA171_0 = this.input.LA(1);

                    if ( (LA171_0==COMMA) ) {
                        alt171=1;
                    }
                    switch (alt171) {
                        case 1 :
                            // xquery/XQueryParser.g:1395:52: COMMA p_TypeName ( QUESTION )?
                            COMMA509=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_ElementTest10386); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COMMA509_tree = this.adaptor.create(COMMA509);
                            this.adaptor.addChild(root_0, COMMA509_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_TypeName_in_p_ElementTest10388);
                            p_TypeName510=this.p_TypeName();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeName510.getTree());
                            // xquery/XQueryParser.g:1395:69: ( QUESTION )?
                            var alt170=2;
                            var LA170_0 = this.input.LA(1);

                            if ( (LA170_0==QUESTION) ) {
                                alt170=1;
                            }
                            switch (alt170) {
                                case 1 :
                                    // xquery/XQueryParser.g:1395:69: QUESTION
                                    QUESTION511=this.match(this.input,QUESTION,XQueryParser.FOLLOW_QUESTION_in_p_ElementTest10390); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    QUESTION511_tree = this.adaptor.create(QUESTION511);
                                    this.adaptor.addChild(root_0, QUESTION511_tree);
                                    }


                                    break;

                            }



                            break;

                    }



                    break;

            }

            RPAREN512=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_ElementTest10397); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN512_tree = this.adaptor.create(RPAREN512);
            this.adaptor.addChild(root_0, RPAREN512_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ElementNameOrWildcard_return: (function() {
        XQueryParser.p_ElementNameOrWildcard_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ElementNameOrWildcard_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1399:1: p_ElementNameOrWildcard : ( p_QName | STAR );
    // $ANTLR start "p_ElementNameOrWildcard"
    p_ElementNameOrWildcard: function() {
        var retval = new XQueryParser.p_ElementNameOrWildcard_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var STAR514 = null;
         var p_QName513 = null;

        var STAR514_tree=null;

        try {
            // xquery/XQueryParser.g:1400:9: ( p_QName | STAR )
            var alt173=2;
            var LA173_0 = this.input.LA(1);

            if ( ((LA173_0>=ANCESTOR && LA173_0<=SKIP)||(LA173_0>=VALUE && LA173_0<=QUOT_ER)||LA173_0==L_NCName||LA173_0==EXPLICITLY) ) {
                alt173=1;
            }
            else if ( (LA173_0==STAR) ) {
                alt173=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 173, 0, this.input);

                throw nvae;
            }
            switch (alt173) {
                case 1 :
                    // xquery/XQueryParser.g:1400:11: p_QName
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ElementNameOrWildcard10423);
                    p_QName513=this.p_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName513.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1400:21: STAR
                    root_0 = this.adaptor.nil();

                    STAR514=this.match(this.input,STAR,XQueryParser.FOLLOW_STAR_in_p_ElementNameOrWildcard10427); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    STAR514_tree = this.adaptor.create(STAR514);
                    this.adaptor.addChild(root_0, STAR514_tree);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SchemaElementTest_return: (function() {
        XQueryParser.p_SchemaElementTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SchemaElementTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1403:1: p_SchemaElementTest : SCHEMA_ELEMENT LPAREN p_ElementDeclaration RPAREN ;
    // $ANTLR start "p_SchemaElementTest"
    p_SchemaElementTest: function() {
        var retval = new XQueryParser.p_SchemaElementTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SCHEMA_ELEMENT515 = null;
        var LPAREN516 = null;
        var RPAREN518 = null;
         var p_ElementDeclaration517 = null;

        var SCHEMA_ELEMENT515_tree=null;
        var LPAREN516_tree=null;
        var RPAREN518_tree=null;

        try {
            // xquery/XQueryParser.g:1404:9: ( SCHEMA_ELEMENT LPAREN p_ElementDeclaration RPAREN )
            // xquery/XQueryParser.g:1404:11: SCHEMA_ELEMENT LPAREN p_ElementDeclaration RPAREN
            root_0 = this.adaptor.nil();

            SCHEMA_ELEMENT515=this.match(this.input,SCHEMA_ELEMENT,XQueryParser.FOLLOW_SCHEMA_ELEMENT_in_p_SchemaElementTest10445); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SCHEMA_ELEMENT515_tree = this.adaptor.create(SCHEMA_ELEMENT515);
            this.adaptor.addChild(root_0, SCHEMA_ELEMENT515_tree);
            }
            LPAREN516=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_SchemaElementTest10447); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN516_tree = this.adaptor.create(LPAREN516);
            this.adaptor.addChild(root_0, LPAREN516_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ElementDeclaration_in_p_SchemaElementTest10449);
            p_ElementDeclaration517=this.p_ElementDeclaration();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ElementDeclaration517.getTree());
            RPAREN518=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_SchemaElementTest10451); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN518_tree = this.adaptor.create(RPAREN518);
            this.adaptor.addChild(root_0, RPAREN518_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ElementDeclaration_return: (function() {
        XQueryParser.p_ElementDeclaration_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ElementDeclaration_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1408:1: p_ElementDeclaration : p_ElementName ;
    // $ANTLR start "p_ElementDeclaration"
    p_ElementDeclaration: function() {
        var retval = new XQueryParser.p_ElementDeclaration_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ElementName519 = null;


        try {
            // xquery/XQueryParser.g:1409:9: ( p_ElementName )
            // xquery/XQueryParser.g:1409:11: p_ElementName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ElementName_in_p_ElementDeclaration10477);
            p_ElementName519=this.p_ElementName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ElementName519.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AttributeName_return: (function() {
        XQueryParser.p_AttributeName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AttributeName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1413:1: p_AttributeName : p_QName ;
    // $ANTLR start "p_AttributeName"
    p_AttributeName: function() {
        var retval = new XQueryParser.p_AttributeName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName520 = null;


        try {
            // xquery/XQueryParser.g:1414:9: ( p_QName )
            // xquery/XQueryParser.g:1414:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_AttributeName10503);
            p_QName520=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName520.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ElementName_return: (function() {
        XQueryParser.p_ElementName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ElementName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1418:1: p_ElementName : p_QName ;
    // $ANTLR start "p_ElementName"
    p_ElementName: function() {
        var retval = new XQueryParser.p_ElementName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName521 = null;


        try {
            // xquery/XQueryParser.g:1419:9: ( p_QName )
            // xquery/XQueryParser.g:1419:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ElementName10529);
            p_QName521=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName521.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TypeName_return: (function() {
        XQueryParser.p_TypeName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TypeName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1423:1: p_TypeName : p_QName ;
    // $ANTLR start "p_TypeName"
    p_TypeName: function() {
        var retval = new XQueryParser.p_TypeName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName522 = null;


        try {
            // xquery/XQueryParser.g:1424:9: ( p_QName )
            // xquery/XQueryParser.g:1424:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_TypeName10555);
            p_QName522=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName522.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FunctionTest_return: (function() {
        XQueryParser.p_FunctionTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FunctionTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1428:1: p_FunctionTest : ( p_Annotation )* ( p_AnyFunctionTest | p_TypedFunctionTest ) ;
    // $ANTLR start "p_FunctionTest"
    p_FunctionTest: function() {
        var retval = new XQueryParser.p_FunctionTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Annotation523 = null;
         var p_AnyFunctionTest524 = null;
         var p_TypedFunctionTest525 = null;


        try {
            // xquery/XQueryParser.g:1429:9: ( ( p_Annotation )* ( p_AnyFunctionTest | p_TypedFunctionTest ) )
            // xquery/XQueryParser.g:1429:11: ( p_Annotation )* ( p_AnyFunctionTest | p_TypedFunctionTest )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1429:11: ( p_Annotation )*
            loop174:
            do {
                var alt174=2;
                var LA174_0 = this.input.LA(1);

                if ( (LA174_0==ANN_PERCENT) ) {
                    alt174=1;
                }


                switch (alt174) {
                case 1 :
                    // xquery/XQueryParser.g:1429:11: p_Annotation
                    this.pushFollow(XQueryParser.FOLLOW_p_Annotation_in_p_FunctionTest10581);
                    p_Annotation523=this.p_Annotation();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Annotation523.getTree());


                    break;

                default :
                    break loop174;
                }
            } while (true);

            // xquery/XQueryParser.g:1429:25: ( p_AnyFunctionTest | p_TypedFunctionTest )
            var alt175=2;
            var LA175_0 = this.input.LA(1);

            if ( (LA175_0==FUNCTION) ) {
                var LA175_1 = this.input.LA(2);

                if ( (LA175_1==LPAREN) ) {
                    var LA175_2 = this.input.LA(3);

                    if ( (LA175_2==STAR) ) {
                        alt175=1;
                    }
                    else if ( ((LA175_2>=ANCESTOR && LA175_2<=SKIP)||(LA175_2>=VALUE && LA175_2<=QUOT_ER)||(LA175_2>=LPAREN && LA175_2<=RPAREN)||LA175_2==L_NCName||LA175_2==EXPLICITLY) ) {
                        alt175=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 175, 2, this.input);

                        throw nvae;
                    }
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 175, 1, this.input);

                    throw nvae;
                }
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 175, 0, this.input);

                throw nvae;
            }
            switch (alt175) {
                case 1 :
                    // xquery/XQueryParser.g:1429:26: p_AnyFunctionTest
                    this.pushFollow(XQueryParser.FOLLOW_p_AnyFunctionTest_in_p_FunctionTest10585);
                    p_AnyFunctionTest524=this.p_AnyFunctionTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AnyFunctionTest524.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1429:46: p_TypedFunctionTest
                    this.pushFollow(XQueryParser.FOLLOW_p_TypedFunctionTest_in_p_FunctionTest10589);
                    p_TypedFunctionTest525=this.p_TypedFunctionTest();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypedFunctionTest525.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AnyFunctionTest_return: (function() {
        XQueryParser.p_AnyFunctionTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AnyFunctionTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1433:1: p_AnyFunctionTest : FUNCTION LPAREN STAR RPAREN ;
    // $ANTLR start "p_AnyFunctionTest"
    p_AnyFunctionTest: function() {
        var retval = new XQueryParser.p_AnyFunctionTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var FUNCTION526 = null;
        var LPAREN527 = null;
        var STAR528 = null;
        var RPAREN529 = null;

        var FUNCTION526_tree=null;
        var LPAREN527_tree=null;
        var STAR528_tree=null;
        var RPAREN529_tree=null;

        try {
            // xquery/XQueryParser.g:1434:9: ( FUNCTION LPAREN STAR RPAREN )
            // xquery/XQueryParser.g:1434:11: FUNCTION LPAREN STAR RPAREN
            root_0 = this.adaptor.nil();

            FUNCTION526=this.match(this.input,FUNCTION,XQueryParser.FOLLOW_FUNCTION_in_p_AnyFunctionTest10616); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            FUNCTION526_tree = this.adaptor.create(FUNCTION526);
            this.adaptor.addChild(root_0, FUNCTION526_tree);
            }
            LPAREN527=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_AnyFunctionTest10618); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN527_tree = this.adaptor.create(LPAREN527);
            this.adaptor.addChild(root_0, LPAREN527_tree);
            }
            STAR528=this.match(this.input,STAR,XQueryParser.FOLLOW_STAR_in_p_AnyFunctionTest10620); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            STAR528_tree = this.adaptor.create(STAR528);
            this.adaptor.addChild(root_0, STAR528_tree);
            }
            RPAREN529=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_AnyFunctionTest10622); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN529_tree = this.adaptor.create(RPAREN529);
            this.adaptor.addChild(root_0, RPAREN529_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TypedFunctionTest_return: (function() {
        XQueryParser.p_TypedFunctionTest_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TypedFunctionTest_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1438:1: p_TypedFunctionTest : FUNCTION LPAREN ( p_SequenceType ( COMMA p_SequenceType )* )? RPAREN AS p_SequenceType ;
    // $ANTLR start "p_TypedFunctionTest"
    p_TypedFunctionTest: function() {
        var retval = new XQueryParser.p_TypedFunctionTest_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var FUNCTION530 = null;
        var LPAREN531 = null;
        var COMMA533 = null;
        var RPAREN535 = null;
        var AS536 = null;
         var p_SequenceType532 = null;
         var p_SequenceType534 = null;
         var p_SequenceType537 = null;

        var FUNCTION530_tree=null;
        var LPAREN531_tree=null;
        var COMMA533_tree=null;
        var RPAREN535_tree=null;
        var AS536_tree=null;

        try {
            // xquery/XQueryParser.g:1439:9: ( FUNCTION LPAREN ( p_SequenceType ( COMMA p_SequenceType )* )? RPAREN AS p_SequenceType )
            // xquery/XQueryParser.g:1439:11: FUNCTION LPAREN ( p_SequenceType ( COMMA p_SequenceType )* )? RPAREN AS p_SequenceType
            root_0 = this.adaptor.nil();

            FUNCTION530=this.match(this.input,FUNCTION,XQueryParser.FOLLOW_FUNCTION_in_p_TypedFunctionTest10648); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            FUNCTION530_tree = this.adaptor.create(FUNCTION530);
            this.adaptor.addChild(root_0, FUNCTION530_tree);
            }
            LPAREN531=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_TypedFunctionTest10650); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN531_tree = this.adaptor.create(LPAREN531);
            this.adaptor.addChild(root_0, LPAREN531_tree);
            }
            // xquery/XQueryParser.g:1439:27: ( p_SequenceType ( COMMA p_SequenceType )* )?
            var alt177=2;
            var LA177_0 = this.input.LA(1);

            if ( ((LA177_0>=ANCESTOR && LA177_0<=SKIP)||(LA177_0>=VALUE && LA177_0<=QUOT_ER)||LA177_0==LPAREN||LA177_0==L_NCName||LA177_0==EXPLICITLY) ) {
                alt177=1;
            }
            switch (alt177) {
                case 1 :
                    // xquery/XQueryParser.g:1439:28: p_SequenceType ( COMMA p_SequenceType )*
                    this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_TypedFunctionTest10653);
                    p_SequenceType532=this.p_SequenceType();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType532.getTree());
                    // xquery/XQueryParser.g:1439:43: ( COMMA p_SequenceType )*
                    loop176:
                    do {
                        var alt176=2;
                        var LA176_0 = this.input.LA(1);

                        if ( (LA176_0==COMMA) ) {
                            alt176=1;
                        }


                        switch (alt176) {
                        case 1 :
                            // xquery/XQueryParser.g:1439:44: COMMA p_SequenceType
                            COMMA533=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_TypedFunctionTest10656); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COMMA533_tree = this.adaptor.create(COMMA533);
                            this.adaptor.addChild(root_0, COMMA533_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_TypedFunctionTest10658);
                            p_SequenceType534=this.p_SequenceType();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType534.getTree());


                            break;

                        default :
                            break loop176;
                        }
                    } while (true);



                    break;

            }

            RPAREN535=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_TypedFunctionTest10664); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN535_tree = this.adaptor.create(RPAREN535);
            this.adaptor.addChild(root_0, RPAREN535_tree);
            }
            AS536=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_TypedFunctionTest10666); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            AS536_tree = this.adaptor.create(AS536);
            this.adaptor.addChild(root_0, AS536_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_TypedFunctionTest10668);
            p_SequenceType537=this.p_SequenceType();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType537.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ParenthesizedItemType_return: (function() {
        XQueryParser.p_ParenthesizedItemType_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ParenthesizedItemType_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1443:1: p_ParenthesizedItemType : LPAREN p_ItemType RPAREN ;
    // $ANTLR start "p_ParenthesizedItemType"
    p_ParenthesizedItemType: function() {
        var retval = new XQueryParser.p_ParenthesizedItemType_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LPAREN538 = null;
        var RPAREN540 = null;
         var p_ItemType539 = null;

        var LPAREN538_tree=null;
        var RPAREN540_tree=null;

        try {
            // xquery/XQueryParser.g:1444:9: ( LPAREN p_ItemType RPAREN )
            // xquery/XQueryParser.g:1444:11: LPAREN p_ItemType RPAREN
            root_0 = this.adaptor.nil();

            LPAREN538=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_ParenthesizedItemType10694); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN538_tree = this.adaptor.create(LPAREN538);
            this.adaptor.addChild(root_0, LPAREN538_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ItemType_in_p_ParenthesizedItemType10696);
            p_ItemType539=this.p_ItemType();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ItemType539.getTree());
            RPAREN540=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_ParenthesizedItemType10698); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN540_tree = this.adaptor.create(RPAREN540);
            this.adaptor.addChild(root_0, RPAREN540_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_StringLiteral_return: (function() {
        XQueryParser.p_StringLiteral_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_StringLiteral_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1473:1: p_StringLiteral : ( QUOT pg_QuotStringLiteralContent QUOT -> ^( StringLiteral ( pg_QuotStringLiteralContent )* ) | APOS pg_AposStringLiteralContent APOS -> ^( StringLiteral ( pg_AposStringLiteralContent )* ) );
    // $ANTLR start "p_StringLiteral"
    p_StringLiteral: function() {
        var retval = new XQueryParser.p_StringLiteral_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var QUOT541 = null;
        var QUOT543 = null;
        var APOS544 = null;
        var APOS546 = null;
         var pg_QuotStringLiteralContent542 = null;
         var pg_AposStringLiteralContent545 = null;

        var QUOT541_tree=null;
        var QUOT543_tree=null;
        var APOS544_tree=null;
        var APOS546_tree=null;
        var stream_APOS=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token APOS");
        var stream_QUOT=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token QUOT");
        var stream_pg_QuotStringLiteralContent=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pg_QuotStringLiteralContent");
        var stream_pg_AposStringLiteralContent=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pg_AposStringLiteralContent");
        try {
            // xquery/XQueryParser.g:1474:9: ( QUOT pg_QuotStringLiteralContent QUOT -> ^( StringLiteral ( pg_QuotStringLiteralContent )* ) | APOS pg_AposStringLiteralContent APOS -> ^( StringLiteral ( pg_AposStringLiteralContent )* ) )
            var alt178=2;
            var LA178_0 = this.input.LA(1);

            if ( (LA178_0==QUOT) ) {
                alt178=1;
            }
            else if ( (LA178_0==APOS) ) {
                alt178=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 178, 0, this.input);

                throw nvae;
            }
            switch (alt178) {
                case 1 :
                    // xquery/XQueryParser.g:1474:11: QUOT pg_QuotStringLiteralContent QUOT
                    QUOT541=this.match(this.input,QUOT,XQueryParser.FOLLOW_QUOT_in_p_StringLiteral10749); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_QUOT.add(QUOT541);

                    if ( this.state.backtracking===0 ) {
                       this.pushStringLexer(false);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_pg_QuotStringLiteralContent_in_p_StringLiteral10753);
                    pg_QuotStringLiteralContent542=this.pg_QuotStringLiteralContent();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_pg_QuotStringLiteralContent.add(pg_QuotStringLiteralContent542.getTree());
                    QUOT543=this.match(this.input,QUOT,XQueryParser.FOLLOW_QUOT_in_p_StringLiteral10755); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_QUOT.add(QUOT543);

                    if ( this.state.backtracking===0 ) {
                       this.popLexer(); 
                    }


                    // AST REWRITE
                    // elements: pg_QuotStringLiteralContent
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1475:17: -> ^( StringLiteral ( pg_QuotStringLiteralContent )* )
                    {
                        // xquery/XQueryParser.g:1475:20: ^( StringLiteral ( pg_QuotStringLiteralContent )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(StringLiteral, "StringLiteral"), root_1);

                        // xquery/XQueryParser.g:1475:36: ( pg_QuotStringLiteralContent )*
                        while ( stream_pg_QuotStringLiteralContent.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_pg_QuotStringLiteralContent.nextTree());

                        }
                        stream_pg_QuotStringLiteralContent.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;
                case 2 :
                    // xquery/XQueryParser.g:1476:11: APOS pg_AposStringLiteralContent APOS
                    APOS544=this.match(this.input,APOS,XQueryParser.FOLLOW_APOS_in_p_StringLiteral10794); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_APOS.add(APOS544);

                    if ( this.state.backtracking===0 ) {
                      this.pushStringLexer(true);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_pg_AposStringLiteralContent_in_p_StringLiteral10798);
                    pg_AposStringLiteralContent545=this.pg_AposStringLiteralContent();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_pg_AposStringLiteralContent.add(pg_AposStringLiteralContent545.getTree());
                    APOS546=this.match(this.input,APOS,XQueryParser.FOLLOW_APOS_in_p_StringLiteral10800); if (this.state.failed) return retval; 
                    if ( this.state.backtracking===0 ) stream_APOS.add(APOS546);

                    if ( this.state.backtracking===0 ) {
                       this.popLexer(); 
                    }


                    // AST REWRITE
                    // elements: pg_AposStringLiteralContent
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1477:17: -> ^( StringLiteral ( pg_AposStringLiteralContent )* )
                    {
                        // xquery/XQueryParser.g:1477:20: ^( StringLiteral ( pg_AposStringLiteralContent )* )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(StringLiteral, "StringLiteral"), root_1);

                        // xquery/XQueryParser.g:1477:36: ( pg_AposStringLiteralContent )*
                        while ( stream_pg_AposStringLiteralContent.hasNext() ) {
                            this.adaptor.addChild(root_1, stream_pg_AposStringLiteralContent.nextTree());

                        }
                        stream_pg_AposStringLiteralContent.reset();

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
             this.addString(retval.start, retval.stop); 
        }
        return retval;
    },

    // inline static return class
    pg_QuotStringLiteralContent_return: (function() {
        XQueryParser.pg_QuotStringLiteralContent_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_QuotStringLiteralContent_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1483:1: pg_QuotStringLiteralContent : ( ESCAPE_QUOT | L_CharRef | L_PredefinedEntityRef | ~ ( QUOT | AMP ) )* ;
    // $ANTLR start "pg_QuotStringLiteralContent"
    pg_QuotStringLiteralContent: function() {
        var retval = new XQueryParser.pg_QuotStringLiteralContent_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set547 = null;

        var set547_tree=null;

        try {
            // xquery/XQueryParser.g:1484:9: ( ( ESCAPE_QUOT | L_CharRef | L_PredefinedEntityRef | ~ ( QUOT | AMP ) )* )
            // xquery/XQueryParser.g:1484:11: ( ESCAPE_QUOT | L_CharRef | L_PredefinedEntityRef | ~ ( QUOT | AMP ) )*
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1484:11: ( ESCAPE_QUOT | L_CharRef | L_PredefinedEntityRef | ~ ( QUOT | AMP ) )*
            loop179:
            do {
                var alt179=2;
                var LA179_0 = this.input.LA(1);

                if ( ((LA179_0>=L_QuotAttrContentChar && LA179_0<=HASH)||(LA179_0>=COMMA && LA179_0<=APOS)||(LA179_0>=NCNameStartChar && LA179_0<=EXPLICITLY)) ) {
                    alt179=1;
                }


                switch (alt179) {
                case 1 :
                    // xquery/XQueryParser.g:
                    set547=this.input.LT(1);
                    if ( (this.input.LA(1)>=L_QuotAttrContentChar && this.input.LA(1)<=HASH)||(this.input.LA(1)>=COMMA && this.input.LA(1)<=APOS)||(this.input.LA(1)>=NCNameStartChar && this.input.LA(1)<=EXPLICITLY) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set547));
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }



                    break;

                default :
                    break loop179;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pg_AposStringLiteralContent_return: (function() {
        XQueryParser.pg_AposStringLiteralContent_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_AposStringLiteralContent_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1491:1: pg_AposStringLiteralContent : ( ESCAPE_APOS | L_CharRef | L_PredefinedEntityRef | ~ ( APOS | AMP ) )* ;
    // $ANTLR start "pg_AposStringLiteralContent"
    pg_AposStringLiteralContent: function() {
        var retval = new XQueryParser.pg_AposStringLiteralContent_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set548 = null;

        var set548_tree=null;

        try {
            // xquery/XQueryParser.g:1492:9: ( ( ESCAPE_APOS | L_CharRef | L_PredefinedEntityRef | ~ ( APOS | AMP ) )* )
            // xquery/XQueryParser.g:1492:11: ( ESCAPE_APOS | L_CharRef | L_PredefinedEntityRef | ~ ( APOS | AMP ) )*
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1492:11: ( ESCAPE_APOS | L_CharRef | L_PredefinedEntityRef | ~ ( APOS | AMP ) )*
            loop180:
            do {
                var alt180=2;
                var LA180_0 = this.input.LA(1);

                if ( ((LA180_0>=L_QuotAttrContentChar && LA180_0<=HASH)||(LA180_0>=COMMA && LA180_0<=CHARREF_HEX)||(LA180_0>=QUOT && LA180_0<=EXPLICITLY)) ) {
                    alt180=1;
                }


                switch (alt180) {
                case 1 :
                    // xquery/XQueryParser.g:
                    set548=this.input.LT(1);
                    if ( (this.input.LA(1)>=L_QuotAttrContentChar && this.input.LA(1)<=HASH)||(this.input.LA(1)>=COMMA && this.input.LA(1)<=CHARREF_HEX)||(this.input.LA(1)>=QUOT && this.input.LA(1)<=EXPLICITLY) ) {
                        this.input.consume();
                        if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set548));
                        this.state.errorRecovery=false;this.state.failed=false;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        throw mse;
                    }



                    break;

                default :
                    break loop180;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ElementContentChar_return: (function() {
        XQueryParser.p_ElementContentChar_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ElementContentChar_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1506:1: p_ElementContentChar : L_ElementContentChar ;
    // $ANTLR start "p_ElementContentChar"
    p_ElementContentChar: function() {
        var retval = new XQueryParser.p_ElementContentChar_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_ElementContentChar549 = null;

        var L_ElementContentChar549_tree=null;

        try {
            // xquery/XQueryParser.g:1507:9: ( L_ElementContentChar )
            // xquery/XQueryParser.g:1507:11: L_ElementContentChar
            root_0 = this.adaptor.nil();

            L_ElementContentChar549=this.match(this.input,L_ElementContentChar,XQueryParser.FOLLOW_L_ElementContentChar_in_p_ElementContentChar10975); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            L_ElementContentChar549_tree = this.adaptor.create(L_ElementContentChar549);
            this.adaptor.addChild(root_0, L_ElementContentChar549_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_QuotAttrContentChar_return: (function() {
        XQueryParser.p_QuotAttrContentChar_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_QuotAttrContentChar_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1511:1: p_QuotAttrContentChar : L_QuotAttrContentChar -> ^( AttributeValueChar L_QuotAttrContentChar ) ;
    // $ANTLR start "p_QuotAttrContentChar"
    p_QuotAttrContentChar: function() {
        var retval = new XQueryParser.p_QuotAttrContentChar_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_QuotAttrContentChar550 = null;

        var L_QuotAttrContentChar550_tree=null;
        var stream_L_QuotAttrContentChar=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token L_QuotAttrContentChar");

        try {
            // xquery/XQueryParser.g:1512:9: ( L_QuotAttrContentChar -> ^( AttributeValueChar L_QuotAttrContentChar ) )
            // xquery/XQueryParser.g:1512:11: L_QuotAttrContentChar
            L_QuotAttrContentChar550=this.match(this.input,L_QuotAttrContentChar,XQueryParser.FOLLOW_L_QuotAttrContentChar_in_p_QuotAttrContentChar11001); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_L_QuotAttrContentChar.add(L_QuotAttrContentChar550);



            // AST REWRITE
            // elements: L_QuotAttrContentChar
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 1513:17: -> ^( AttributeValueChar L_QuotAttrContentChar )
            {
                // xquery/XQueryParser.g:1513:20: ^( AttributeValueChar L_QuotAttrContentChar )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(AttributeValueChar, "AttributeValueChar"), root_1);

                this.adaptor.addChild(root_1, stream_L_QuotAttrContentChar.nextNode());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AposAttrContentChar_return: (function() {
        XQueryParser.p_AposAttrContentChar_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AposAttrContentChar_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1517:1: p_AposAttrContentChar : L_AposAttrContentChar -> ^( AttributeValueChar L_AposAttrContentChar ) ;
    // $ANTLR start "p_AposAttrContentChar"
    p_AposAttrContentChar: function() {
        var retval = new XQueryParser.p_AposAttrContentChar_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_AposAttrContentChar551 = null;

        var L_AposAttrContentChar551_tree=null;
        var stream_L_AposAttrContentChar=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token L_AposAttrContentChar");

        try {
            // xquery/XQueryParser.g:1518:9: ( L_AposAttrContentChar -> ^( AttributeValueChar L_AposAttrContentChar ) )
            // xquery/XQueryParser.g:1518:11: L_AposAttrContentChar
            L_AposAttrContentChar551=this.match(this.input,L_AposAttrContentChar,XQueryParser.FOLLOW_L_AposAttrContentChar_in_p_AposAttrContentChar11051); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_L_AposAttrContentChar.add(L_AposAttrContentChar551);



            // AST REWRITE
            // elements: L_AposAttrContentChar
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

            root_0 = this.adaptor.nil();
            // 1519:17: -> ^( AttributeValueChar L_AposAttrContentChar )
            {
                // xquery/XQueryParser.g:1519:20: ^( AttributeValueChar L_AposAttrContentChar )
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(AttributeValueChar, "AttributeValueChar"), root_1);

                this.adaptor.addChild(root_1, stream_L_AposAttrContentChar.nextNode());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_QName_return: (function() {
        XQueryParser.p_QName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_QName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1537:1: p_QName : ( pg_QName | p_NCName -> ^( QName p_NCName ) );
    // $ANTLR start "p_QName"
    p_QName: function() {
        var retval = new XQueryParser.p_QName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var pg_QName552 = null;
         var p_NCName553 = null;

        var stream_p_NCName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_NCName");
        this.setWsExplicit(true);
        try {
            // xquery/XQueryParser.g:1539:9: ( pg_QName | p_NCName -> ^( QName p_NCName ) )
            var alt181=2;
            var LA181_0 = this.input.LA(1);

            if ( ((LA181_0>=ANCESTOR && LA181_0<=SKIP)||(LA181_0>=VALUE && LA181_0<=QUOT_ER)||LA181_0==L_NCName||LA181_0==EXPLICITLY) ) {
                var LA181_1 = this.input.LA(2);

                if ( (LA181_1==COLON) ) {
                    alt181=1;
                }
                else if ( (LA181_1==EOF||(LA181_1>=AND && LA181_1<=AT)||(LA181_1>=BY && LA181_1<=CASTABLE)||LA181_1==COLLATION||LA181_1==DEFAULT||(LA181_1>=DESCENDING && LA181_1<=DIV)||LA181_1==EMPTY||LA181_1==EQ||(LA181_1>=EXCEPT && LA181_1<=EXTERNAL)||(LA181_1>=FOR && LA181_1<=GE)||(LA181_1>=GT && LA181_1<=IDIV)||LA181_1==IN||(LA181_1>=INSTANCE && LA181_1<=IS)||LA181_1==LE||(LA181_1>=LET && LA181_1<=MOD)||LA181_1==NE||LA181_1==NODE||(LA181_1>=OR && LA181_1<=ORDER)||(LA181_1>=RETURN && LA181_1<=SATISFIES)||LA181_1==STABLE||(LA181_1>=TO && LA181_1<=TREAT)||LA181_1==UNION||LA181_1==VARIABLE||LA181_1==WHERE||LA181_1==ALLOWING||LA181_1==COUNT||(LA181_1>=DECIMAL_SEPARATOR && LA181_1<=MINUS_SIGN)||(LA181_1>=NAN && LA181_1<=PREVIOUS)||LA181_1==START||LA181_1==WHEN||(LA181_1>=ZERO_DIGIT && LA181_1<=BEFORE)||LA181_1==INTO||LA181_1==MODIFY||LA181_1==UPDATING||LA181_1==WITH||LA181_1==CONTAINS||LA181_1==PARAGRAPHS||LA181_1==SCORE||LA181_1==SENTENCES||LA181_1==TIMES||LA181_1==WORDS||(LA181_1>=CHECK && LA181_1<=COLLECTION)||(LA181_1>=FOREACH && LA181_1<=ON)||(LA181_1>=CONCAT && LA181_1<=ANN_PERCENT)||(LA181_1>=COMMA && LA181_1<=SLASH_SLASH)||LA181_1==EMPTY_CLOSE_TAG||(LA181_1>=SEMICOLON && LA181_1<=VBAR)||(LA181_1>=APOS && LA181_1<=QUOT)||LA181_1==S) ) {
                    alt181=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 181, 1, this.input);

                    throw nvae;
                }
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 181, 0, this.input);

                throw nvae;
            }
            switch (alt181) {
                case 1 :
                    // xquery/XQueryParser.g:1539:11: pg_QName
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pg_QName_in_p_QName11137);
                    pg_QName552=this.pg_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pg_QName552.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1540:11: p_NCName
                    this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_p_QName11149);
                    p_NCName553=this.p_NCName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_NCName.add(p_NCName553.getTree());


                    // AST REWRITE
                    // elements: p_NCName
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1541:17: -> ^( QName p_NCName )
                    {
                        // xquery/XQueryParser.g:1541:20: ^( QName p_NCName )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(QName, "QName"), root_1);

                        this.adaptor.addChild(root_1, stream_p_NCName.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
            this.setWsExplicit(false);
        }
        return retval;
    },

    // inline static return class
    pg_FQName_return: (function() {
        XQueryParser.pg_FQName_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_FQName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1545:1: pg_FQName : ( pg_QName | p_FNCName -> ^( QName p_FNCName ) );
    // $ANTLR start "pg_FQName"
    pg_FQName: function() {
        var retval = new XQueryParser.pg_FQName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var pg_QName554 = null;
         var p_FNCName555 = null;

        var stream_p_FNCName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_FNCName");
        try {
            // xquery/XQueryParser.g:1546:9: ( pg_QName | p_FNCName -> ^( QName p_FNCName ) )
            var alt182=2;
            switch ( this.input.LA(1) ) {
            case ANCESTOR:
            case ANCESTOR_OR_SELF:
            case AND:
            case AS:
            case ASCENDING:
            case AT:
            case BASE_URI:
            case BOUNDARY_SPACE:
            case BY:
            case CASE:
            case CAST:
            case CASTABLE:
            case CHILD:
            case COLLATION:
            case CONSTRUCTION:
            case COPY_NAMESPACES:
            case DECLARE:
            case DEFAULT:
            case DESCENDANT:
            case DESCENDANT_OR_SELF:
            case DESCENDING:
            case DIV:
            case DOCUMENT:
            case ELSE:
            case EMPTY:
            case ENCODING:
            case EQ:
            case EVERY:
            case EXCEPT:
            case EXTERNAL:
            case FOLLOWING:
            case FOLLOWING_SIBLING:
            case FOR:
            case FUNCTION:
            case GE:
            case GREATEST:
            case GT:
            case IDIV:
            case IMPORT:
            case IN:
            case INHERIT:
            case INSTANCE:
            case INTERSECT:
            case IS:
            case LAX:
            case LE:
            case LEAST:
            case LET:
            case LT:
            case MOD:
            case MODULE:
            case NAMESPACE:
            case NE:
            case NO_INHERIT:
            case NO_PRESERVE:
            case OF:
            case OPTION:
            case OR:
            case ORDER:
            case ORDERED:
            case ORDERING:
            case PARENT:
            case PRECEDING:
            case PRECEDING_SIBLING:
            case PRESERVE:
            case RETURN:
            case SATISFIES:
            case SCHEMA:
            case SELF:
            case SOME:
            case STABLE:
            case STRICT:
            case STRIP:
            case THEN:
            case TO:
            case TREAT:
            case UNION:
            case UNORDERED:
            case VALIDATE:
            case VARIABLE:
            case VERSION:
            case WHERE:
            case XQUERY:
            case ALLOWING:
            case CATCH:
            case CONTEXT:
            case COUNT:
            case DECIMAL_FORMAT:
            case DECIMAL_SEPARATOR:
            case DIGIT:
            case END:
            case GROUP:
            case GROUPING_SEPARATOR:
            case INFINITY:
            case MINUS_SIGN:
            case NAN:
            case NEXT:
            case ONLY:
            case PATTERN_SEPARATOR:
            case PERCENT:
            case PER_MILLE:
            case PREVIOUS:
            case SLIDING:
            case START:
            case TRY:
            case TUMBLING:
            case TYPE:
            case WHEN:
            case WINDOW:
            case ZERO_DIGIT:
            case AFTER:
            case BEFORE:
            case COPY:
            case DELETE:
            case FIRST:
            case INSERT:
            case INTO:
            case LAST:
            case MODIFY:
            case NODES:
            case RENAME:
            case REPLACE:
            case REVALIDATION:
            case SKIP:
            case VALUE:
            case WITH:
            case ALL:
            case ANY:
            case CONTAINS:
            case CONTENT:
            case DIACRITICS:
            case DIFFERENT:
            case DISTANCE:
            case ENTIRE:
            case EXACTLY:
            case FROM:
            case FT_OPTION:
            case FTAND:
            case FTNOT:
            case FTOR:
            case INSENSITIVE:
            case LANGUAGE:
            case LEVELS:
            case LOWERCASE:
            case MOST:
            case NO:
            case NOT:
            case OCCURS:
            case PARAGRAPH:
            case PARAGRAPHS:
            case PHRASE:
            case RELATIONSHIP:
            case SAME:
            case SCORE:
            case SENSITIVE:
            case SENTENCE:
            case SENTENCES:
            case STEMMING:
            case STOP:
            case THESAURUS:
            case TIMES:
            case UPPERCASE:
            case USING:
            case WEIGHT:
            case WILDCARDS:
            case WITHOUT:
            case WORD:
            case WORDS:
            case BREAK:
            case CONTINUE:
            case EXIT:
            case LOOP:
            case RETURNING:
            case CHECK:
            case COLLECTION:
            case CONSTRAINT:
            case FOREACH:
            case FOREIGN:
            case INDEX:
            case INTEGRITY:
            case KEY:
            case ON:
            case UNIQUE:
            case BINARY:
            case AMP_ER:
            case APOS_ER:
            case QUOT_ER:
            case L_NCName:
            case EXPLICITLY:
                var LA182_1 = this.input.LA(2);

                if ( (LA182_1==COLON) ) {
                    alt182=1;
                }
                else if ( (LA182_1==LPAREN) ) {
                    alt182=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 182, 1, this.input);

                    throw nvae;
                }
                break;
            case ATTRIBUTE:
            case COMMENT:
            case DOCUMENT_NODE:
            case ELEMENT:
            case EMPTY_SEQUENCE:
            case IF:
            case ITEM:
            case NODE:
            case PROCESSING_INSTRUCTION:
            case SCHEMA_ATTRIBUTE:
            case SCHEMA_ELEMENT:
            case TEXT:
            case TYPESWITCH:
            case NAMESPACE_NODE:
            case SWITCH:
            case WHILE:
                alt182=1;
                break;
            case UPDATING:
                alt182=2;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 182, 0, this.input);

                throw nvae;
            }

            switch (alt182) {
                case 1 :
                    // xquery/XQueryParser.g:1546:11: pg_QName
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_pg_QName_in_pg_FQName11210);
                    pg_QName554=this.pg_QName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pg_QName554.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1547:11: p_FNCName
                    this.pushFollow(XQueryParser.FOLLOW_p_FNCName_in_pg_FQName11222);
                    p_FNCName555=this.p_FNCName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) stream_p_FNCName.add(p_FNCName555.getTree());


                    // AST REWRITE
                    // elements: p_FNCName
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    if ( this.state.backtracking===0 ) {
                    retval.tree = root_0;
                    var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);

                    root_0 = this.adaptor.nil();
                    // 1548:17: -> ^( QName p_FNCName )
                    {
                        // xquery/XQueryParser.g:1548:20: ^( QName p_FNCName )
                        {
                        var root_1 = this.adaptor.nil();
                        root_1 = this.adaptor.becomeRoot(this.adaptor.create(QName, "QName"), root_1);

                        this.adaptor.addChild(root_1, stream_p_FNCName.nextTree());

                        this.adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;}

                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pg_QName_return: (function() {
        XQueryParser.pg_QName_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_QName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1550:1: pg_QName : nn= p_NCName COLON nl= p_NCName -> ^( QName $nn $nl) ;
    // $ANTLR start "pg_QName"
    pg_QName: function() {
        var retval = new XQueryParser.pg_QName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var COLON556 = null;
         var nn = null;
         var nl = null;

        var COLON556_tree=null;
        var stream_COLON=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token COLON");
        var stream_p_NCName=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule p_NCName");
        try {
            // xquery/XQueryParser.g:1551:9: (nn= p_NCName COLON nl= p_NCName -> ^( QName $nn $nl) )
            // xquery/XQueryParser.g:1551:11: nn= p_NCName COLON nl= p_NCName
            this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_pg_QName11266);
            nn=this.p_NCName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_NCName.add(nn.getTree());
            COLON556=this.match(this.input,COLON,XQueryParser.FOLLOW_COLON_in_pg_QName11268); if (this.state.failed) return retval; 
            if ( this.state.backtracking===0 ) stream_COLON.add(COLON556);

            this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_pg_QName11272);
            nl=this.p_NCName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) stream_p_NCName.add(nl.getTree());


            // AST REWRITE
            // elements: nl, nn
            // token labels: 
            // rule labels: retval, nn, nl
            // token list labels: 
            // rule list labels: 
            if ( this.state.backtracking===0 ) {
            retval.tree = root_0;
            var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
            var stream_nn=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token nn",nn!=null?nn.tree:null);
            var stream_nl=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token nl",nl!=null?nl.tree:null);

            root_0 = this.adaptor.nil();
            // 1552:17: -> ^( QName $nn $nl)
            {
                // xquery/XQueryParser.g:1552:20: ^( QName $nn $nl)
                {
                var root_1 = this.adaptor.nil();
                root_1 = this.adaptor.becomeRoot(this.adaptor.create(QName, "QName"), root_1);

                this.adaptor.addChild(root_1, stream_nn.nextTree());
                this.adaptor.addChild(root_1, stream_nl.nextTree());

                this.adaptor.addChild(root_0, root_1);
                }

            }

            retval.tree = root_0;}


            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NCName_return: (function() {
        XQueryParser.p_NCName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NCName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1582:1: p_NCName : ( L_NCName | ANCESTOR | ANCESTOR_OR_SELF | AND | AS | ASCENDING | AT | ATTRIBUTE | BASE_URI | BOUNDARY_SPACE | BY | CASE | CAST | CASTABLE | CHILD | COLLATION | COMMENT | CONSTRUCTION | COPY_NAMESPACES | DECLARE | DEFAULT | DESCENDANT | DESCENDANT_OR_SELF | DESCENDING | DIV | DOCUMENT | DOCUMENT_NODE | ELEMENT | ELSE | EMPTY | EMPTY_SEQUENCE | ENCODING | EQ | EVERY | EXCEPT | EXTERNAL | FOLLOWING | FOLLOWING_SIBLING | FOR | FUNCTION | GE | GREATEST | GT | IDIV | IF | IMPORT | IN | INHERIT | INSTANCE | INTERSECT | IS | ITEM | LAX | LE | LEAST | LET | LT | MOD | MODULE | NAMESPACE | NE | NO_INHERIT | NO_PRESERVE | NODE | OF | OPTION | OR | ORDER | ORDERED | ORDERING | PARENT | PRECEDING | PRECEDING_SIBLING | PRESERVE | PROCESSING_INSTRUCTION | RETURN | SATISFIES | SCHEMA | SCHEMA_ATTRIBUTE | SCHEMA_ELEMENT | SELF | SOME | STABLE | STRICT | STRIP | SWITCH | TEXT | THEN | TO | TREAT | TYPESWITCH | UNION | UNORDERED | VALIDATE | VARIABLE | VERSION | WHERE | XQUERY | ALLOWING | CATCH | CONTEXT | COUNT | DECIMAL_FORMAT | DECIMAL_SEPARATOR | DIGIT | END | GROUP | GROUPING_SEPARATOR | INFINITY | MINUS_SIGN | NAMESPACE_NODE | NAN | NEXT | ONLY | PATTERN_SEPARATOR | PERCENT | PER_MILLE | PREVIOUS | SLIDING | START | TRY | TUMBLING | TYPE | WHEN | WINDOW | ZERO_DIGIT | AFTER | BEFORE | COPY | DELETE | FIRST | INSERT | INTO | LAST | MODIFY | NODES | RENAME | REPLACE | REVALIDATION | SKIP | VALUE | WITH | ALL | ANY | CONTAINS | CONTENT | DIACRITICS | DIFFERENT | DISTANCE | ENTIRE | EXACTLY | FROM | FT_OPTION | FTAND | FTNOT | FTOR | INSENSITIVE | LANGUAGE | LEVELS | LOWERCASE | MOST | NO | NOT | OCCURS | PARAGRAPH | PARAGRAPHS | PHRASE | RELATIONSHIP | SAME | SCORE | SENSITIVE | SENTENCE | SENTENCES | STEMMING | STOP | THESAURUS | TIMES | UPPERCASE | USING | WEIGHT | WILDCARDS | WITHOUT | WORD | WORDS | BREAK | CONTINUE | EXIT | LOOP | RETURNING | WHILE | CHECK | COLLECTION | CONSTRAINT | EXPLICITLY | FOREACH | FOREIGN | INDEX | INTEGRITY | KEY | ON | UNIQUE | BINARY | AMP_ER | APOS_ER | QUOT_ER );
    // $ANTLR start "p_NCName"
    p_NCName: function() {
        var retval = new XQueryParser.p_NCName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set557 = null;

        var set557_tree=null;

        try {
            // xquery/XQueryParser.g:1583:9: ( L_NCName | ANCESTOR | ANCESTOR_OR_SELF | AND | AS | ASCENDING | AT | ATTRIBUTE | BASE_URI | BOUNDARY_SPACE | BY | CASE | CAST | CASTABLE | CHILD | COLLATION | COMMENT | CONSTRUCTION | COPY_NAMESPACES | DECLARE | DEFAULT | DESCENDANT | DESCENDANT_OR_SELF | DESCENDING | DIV | DOCUMENT | DOCUMENT_NODE | ELEMENT | ELSE | EMPTY | EMPTY_SEQUENCE | ENCODING | EQ | EVERY | EXCEPT | EXTERNAL | FOLLOWING | FOLLOWING_SIBLING | FOR | FUNCTION | GE | GREATEST | GT | IDIV | IF | IMPORT | IN | INHERIT | INSTANCE | INTERSECT | IS | ITEM | LAX | LE | LEAST | LET | LT | MOD | MODULE | NAMESPACE | NE | NO_INHERIT | NO_PRESERVE | NODE | OF | OPTION | OR | ORDER | ORDERED | ORDERING | PARENT | PRECEDING | PRECEDING_SIBLING | PRESERVE | PROCESSING_INSTRUCTION | RETURN | SATISFIES | SCHEMA | SCHEMA_ATTRIBUTE | SCHEMA_ELEMENT | SELF | SOME | STABLE | STRICT | STRIP | SWITCH | TEXT | THEN | TO | TREAT | TYPESWITCH | UNION | UNORDERED | VALIDATE | VARIABLE | VERSION | WHERE | XQUERY | ALLOWING | CATCH | CONTEXT | COUNT | DECIMAL_FORMAT | DECIMAL_SEPARATOR | DIGIT | END | GROUP | GROUPING_SEPARATOR | INFINITY | MINUS_SIGN | NAMESPACE_NODE | NAN | NEXT | ONLY | PATTERN_SEPARATOR | PERCENT | PER_MILLE | PREVIOUS | SLIDING | START | TRY | TUMBLING | TYPE | WHEN | WINDOW | ZERO_DIGIT | AFTER | BEFORE | COPY | DELETE | FIRST | INSERT | INTO | LAST | MODIFY | NODES | RENAME | REPLACE | REVALIDATION | SKIP | VALUE | WITH | ALL | ANY | CONTAINS | CONTENT | DIACRITICS | DIFFERENT | DISTANCE | ENTIRE | EXACTLY | FROM | FT_OPTION | FTAND | FTNOT | FTOR | INSENSITIVE | LANGUAGE | LEVELS | LOWERCASE | MOST | NO | NOT | OCCURS | PARAGRAPH | PARAGRAPHS | PHRASE | RELATIONSHIP | SAME | SCORE | SENSITIVE | SENTENCE | SENTENCES | STEMMING | STOP | THESAURUS | TIMES | UPPERCASE | USING | WEIGHT | WILDCARDS | WITHOUT | WORD | WORDS | BREAK | CONTINUE | EXIT | LOOP | RETURNING | WHILE | CHECK | COLLECTION | CONSTRAINT | EXPLICITLY | FOREACH | FOREIGN | INDEX | INTEGRITY | KEY | ON | UNIQUE | BINARY | AMP_ER | APOS_ER | QUOT_ER )
            // xquery/XQueryParser.g:
            root_0 = this.adaptor.nil();

            set557=this.input.LT(1);
            if ( (this.input.LA(1)>=ANCESTOR && this.input.LA(1)<=SKIP)||(this.input.LA(1)>=VALUE && this.input.LA(1)<=QUOT_ER)||this.input.LA(1)==L_NCName||this.input.LA(1)==EXPLICITLY ) {
                this.input.consume();
                if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set557));
                this.state.errorRecovery=false;this.state.failed=false;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                throw mse;
            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FNCName_return: (function() {
        XQueryParser.p_FNCName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FNCName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1601:1: p_FNCName : ( L_NCName | ANCESTOR | ANCESTOR_OR_SELF | AND | AS | ASCENDING | AT | BASE_URI | BOUNDARY_SPACE | BY | CASE | CAST | CASTABLE | CHILD | COLLATION | CONSTRUCTION | COPY_NAMESPACES | DECLARE | DEFAULT | DESCENDANT | DESCENDANT_OR_SELF | DESCENDING | DIV | DOCUMENT | ELSE | EMPTY | ENCODING | EQ | EVERY | EXCEPT | EXTERNAL | FOLLOWING | FOLLOWING_SIBLING | FOR | FUNCTION | GE | GREATEST | GT | IDIV | IMPORT | IN | INHERIT | INSTANCE | INTERSECT | IS | LAX | LE | LEAST | LET | LT | MOD | MODULE | NAMESPACE | NE | NO_INHERIT | NO_PRESERVE | OF | OPTION | OR | ORDER | ORDERED | ORDERING | PARENT | PRECEDING | PRECEDING_SIBLING | PRESERVE | RETURN | SATISFIES | SCHEMA | SELF | SOME | STABLE | STRICT | STRIP | THEN | TO | TREAT | UNION | UNORDERED | VALIDATE | VARIABLE | VERSION | WHERE | XQUERY | ALLOWING | CATCH | CONTEXT | COUNT | DECIMAL_FORMAT | DECIMAL_SEPARATOR | DIGIT | END | GROUP | GROUPING_SEPARATOR | INFINITY | MINUS_SIGN | NAN | NEXT | ONLY | PATTERN_SEPARATOR | PERCENT | PER_MILLE | PREVIOUS | SLIDING | START | TRY | TUMBLING | TYPE | WHEN | WINDOW | ZERO_DIGIT | AFTER | BEFORE | COPY | DELETE | FIRST | INSERT | INTO | LAST | MODIFY | NODES | RENAME | REPLACE | REVALIDATION | SKIP | UPDATING | VALUE | WITH | ALL | ANY | CONTAINS | CONTENT | DIACRITICS | DIFFERENT | DISTANCE | ENTIRE | EXACTLY | FROM | FT_OPTION | FTAND | FTNOT | FTOR | INSENSITIVE | LANGUAGE | LEVELS | LOWERCASE | MOST | NO | NOT | OCCURS | PARAGRAPH | PARAGRAPHS | PHRASE | RELATIONSHIP | SAME | SCORE | SENSITIVE | SENTENCE | SENTENCES | STEMMING | STOP | THESAURUS | TIMES | UPPERCASE | USING | WEIGHT | WILDCARDS | WITHOUT | WORD | WORDS | BREAK | CONTINUE | EXIT | LOOP | RETURNING | CHECK | COLLECTION | CONSTRAINT | EXPLICITLY | FOREACH | FOREIGN | INDEX | INTEGRITY | KEY | ON | UNIQUE | BINARY | AMP_ER | APOS_ER | QUOT_ER );
    // $ANTLR start "p_FNCName"
    p_FNCName: function() {
        var retval = new XQueryParser.p_FNCName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var set558 = null;

        var set558_tree=null;

        try {
            // xquery/XQueryParser.g:1602:9: ( L_NCName | ANCESTOR | ANCESTOR_OR_SELF | AND | AS | ASCENDING | AT | BASE_URI | BOUNDARY_SPACE | BY | CASE | CAST | CASTABLE | CHILD | COLLATION | CONSTRUCTION | COPY_NAMESPACES | DECLARE | DEFAULT | DESCENDANT | DESCENDANT_OR_SELF | DESCENDING | DIV | DOCUMENT | ELSE | EMPTY | ENCODING | EQ | EVERY | EXCEPT | EXTERNAL | FOLLOWING | FOLLOWING_SIBLING | FOR | FUNCTION | GE | GREATEST | GT | IDIV | IMPORT | IN | INHERIT | INSTANCE | INTERSECT | IS | LAX | LE | LEAST | LET | LT | MOD | MODULE | NAMESPACE | NE | NO_INHERIT | NO_PRESERVE | OF | OPTION | OR | ORDER | ORDERED | ORDERING | PARENT | PRECEDING | PRECEDING_SIBLING | PRESERVE | RETURN | SATISFIES | SCHEMA | SELF | SOME | STABLE | STRICT | STRIP | THEN | TO | TREAT | UNION | UNORDERED | VALIDATE | VARIABLE | VERSION | WHERE | XQUERY | ALLOWING | CATCH | CONTEXT | COUNT | DECIMAL_FORMAT | DECIMAL_SEPARATOR | DIGIT | END | GROUP | GROUPING_SEPARATOR | INFINITY | MINUS_SIGN | NAN | NEXT | ONLY | PATTERN_SEPARATOR | PERCENT | PER_MILLE | PREVIOUS | SLIDING | START | TRY | TUMBLING | TYPE | WHEN | WINDOW | ZERO_DIGIT | AFTER | BEFORE | COPY | DELETE | FIRST | INSERT | INTO | LAST | MODIFY | NODES | RENAME | REPLACE | REVALIDATION | SKIP | UPDATING | VALUE | WITH | ALL | ANY | CONTAINS | CONTENT | DIACRITICS | DIFFERENT | DISTANCE | ENTIRE | EXACTLY | FROM | FT_OPTION | FTAND | FTNOT | FTOR | INSENSITIVE | LANGUAGE | LEVELS | LOWERCASE | MOST | NO | NOT | OCCURS | PARAGRAPH | PARAGRAPHS | PHRASE | RELATIONSHIP | SAME | SCORE | SENSITIVE | SENTENCE | SENTENCES | STEMMING | STOP | THESAURUS | TIMES | UPPERCASE | USING | WEIGHT | WILDCARDS | WITHOUT | WORD | WORDS | BREAK | CONTINUE | EXIT | LOOP | RETURNING | CHECK | COLLECTION | CONSTRAINT | EXPLICITLY | FOREACH | FOREIGN | INDEX | INTEGRITY | KEY | ON | UNIQUE | BINARY | AMP_ER | APOS_ER | QUOT_ER )
            // xquery/XQueryParser.g:
            root_0 = this.adaptor.nil();

            set558=this.input.LT(1);
            if ( (this.input.LA(1)>=ANCESTOR && this.input.LA(1)<=AT)||(this.input.LA(1)>=BASE_URI && this.input.LA(1)<=COLLATION)||(this.input.LA(1)>=CONSTRUCTION && this.input.LA(1)<=DOCUMENT)||(this.input.LA(1)>=ELSE && this.input.LA(1)<=EMPTY)||(this.input.LA(1)>=ENCODING && this.input.LA(1)<=IDIV)||(this.input.LA(1)>=IMPORT && this.input.LA(1)<=IS)||(this.input.LA(1)>=LAX && this.input.LA(1)<=NO_PRESERVE)||(this.input.LA(1)>=OF && this.input.LA(1)<=PRESERVE)||(this.input.LA(1)>=RETURN && this.input.LA(1)<=SCHEMA)||(this.input.LA(1)>=SELF && this.input.LA(1)<=STRIP)||(this.input.LA(1)>=THEN && this.input.LA(1)<=TREAT)||(this.input.LA(1)>=UNION && this.input.LA(1)<=MINUS_SIGN)||(this.input.LA(1)>=NAN && this.input.LA(1)<=START)||(this.input.LA(1)>=TRY && this.input.LA(1)<=RETURNING)||(this.input.LA(1)>=CHECK && this.input.LA(1)<=QUOT_ER)||this.input.LA(1)==L_NCName||this.input.LA(1)==EXPLICITLY ) {
                this.input.consume();
                if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set558));
                this.state.errorRecovery=false;this.state.failed=false;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                throw mse;
            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pg_UpdateExpr_return: (function() {
        XQueryParser.pg_UpdateExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.pg_UpdateExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1639:1: pg_UpdateExpr : ( p_InsertExpr | p_DeleteExpr | p_RenameExpr | p_ReplaceExpr | p_TransformExpr );
    // $ANTLR start "pg_UpdateExpr"
    pg_UpdateExpr: function() {
        var retval = new XQueryParser.pg_UpdateExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_InsertExpr559 = null;
         var p_DeleteExpr560 = null;
         var p_RenameExpr561 = null;
         var p_ReplaceExpr562 = null;
         var p_TransformExpr563 = null;


        try {
            // xquery/XQueryParser.g:1640:9: ( p_InsertExpr | p_DeleteExpr | p_RenameExpr | p_ReplaceExpr | p_TransformExpr )
            var alt183=5;
            switch ( this.input.LA(1) ) {
            case INSERT:
                alt183=1;
                break;
            case DELETE:
                alt183=2;
                break;
            case RENAME:
                alt183=3;
                break;
            case REPLACE:
                alt183=4;
                break;
            case COPY:
                alt183=5;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 183, 0, this.input);

                throw nvae;
            }

            switch (alt183) {
                case 1 :
                    // xquery/XQueryParser.g:1640:11: p_InsertExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_InsertExpr_in_pg_UpdateExpr13263);
                    p_InsertExpr559=this.p_InsertExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InsertExpr559.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1641:11: p_DeleteExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_DeleteExpr_in_pg_UpdateExpr13275);
                    p_DeleteExpr560=this.p_DeleteExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_DeleteExpr560.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1642:11: p_RenameExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_RenameExpr_in_pg_UpdateExpr13287);
                    p_RenameExpr561=this.p_RenameExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_RenameExpr561.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1643:11: p_ReplaceExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ReplaceExpr_in_pg_UpdateExpr13299);
                    p_ReplaceExpr562=this.p_ReplaceExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ReplaceExpr562.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1644:11: p_TransformExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_TransformExpr_in_pg_UpdateExpr13311);
                    p_TransformExpr563=this.p_TransformExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TransformExpr563.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_RevalidationDecl_return: (function() {
        XQueryParser.pm_RevalidationDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_RevalidationDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1648:1: pm_RevalidationDecl : k+= DECLARE k+= REVALIDATION (k+= STRICT | k+= LAX | k+= SKIP ) SEMICOLON ;
    // $ANTLR start "pm_RevalidationDecl"
    pm_RevalidationDecl: function() {
        var retval = new XQueryParser.pm_RevalidationDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SEMICOLON564 = null;
        var k = null;
        var list_k=null;

        var SEMICOLON564_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1649:9: (k+= DECLARE k+= REVALIDATION (k+= STRICT | k+= LAX | k+= SKIP ) SEMICOLON )
            // xquery/XQueryParser.g:1649:11: k+= DECLARE k+= REVALIDATION (k+= STRICT | k+= LAX | k+= SKIP ) SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_RevalidationDecl13339); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            k=this.match(this.input,REVALIDATION,XQueryParser.FOLLOW_REVALIDATION_in_pm_RevalidationDecl13343); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            // xquery/XQueryParser.g:1649:38: (k+= STRICT | k+= LAX | k+= SKIP )
            var alt184=3;
            switch ( this.input.LA(1) ) {
            case STRICT:
                alt184=1;
                break;
            case LAX:
                alt184=2;
                break;
            case SKIP:
                alt184=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 184, 0, this.input);

                throw nvae;
            }

            switch (alt184) {
                case 1 :
                    // xquery/XQueryParser.g:1649:39: k+= STRICT
                    k=this.match(this.input,STRICT,XQueryParser.FOLLOW_STRICT_in_pm_RevalidationDecl13348); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1649:51: k+= LAX
                    k=this.match(this.input,LAX,XQueryParser.FOLLOW_LAX_in_pm_RevalidationDecl13354); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 3 :
                    // xquery/XQueryParser.g:1649:60: k+= SKIP
                    k=this.match(this.input,SKIP,XQueryParser.FOLLOW_SKIP_in_pm_RevalidationDecl13360); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }
            SEMICOLON564=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_RevalidationDecl13365); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON564_tree = this.adaptor.create(SEMICOLON564);
            this.adaptor.addChild(root_0, SEMICOLON564_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_InsertExprTargetChoice_return: (function() {
        XQueryParser.p_InsertExprTargetChoice_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_InsertExprTargetChoice_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1653:1: p_InsertExprTargetChoice : ( ( (k+= AS (k+= FIRST | k+= LAST ) )? k+= INTO ) | ka= AFTER | kb= BEFORE );
    // $ANTLR start "p_InsertExprTargetChoice"
    p_InsertExprTargetChoice: function() {
        var retval = new XQueryParser.p_InsertExprTargetChoice_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ka = null;
        var kb = null;
        var k = null;
        var list_k=null;

        var ka_tree=null;
        var kb_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1654:9: ( ( (k+= AS (k+= FIRST | k+= LAST ) )? k+= INTO ) | ka= AFTER | kb= BEFORE )
            var alt187=3;
            switch ( this.input.LA(1) ) {
            case AS:
            case INTO:
                alt187=1;
                break;
            case AFTER:
                alt187=2;
                break;
            case BEFORE:
                alt187=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 187, 0, this.input);

                throw nvae;
            }

            switch (alt187) {
                case 1 :
                    // xquery/XQueryParser.g:1654:11: ( (k+= AS (k+= FIRST | k+= LAST ) )? k+= INTO )
                    root_0 = this.adaptor.nil();

                    // xquery/XQueryParser.g:1654:11: ( (k+= AS (k+= FIRST | k+= LAST ) )? k+= INTO )
                    // xquery/XQueryParser.g:1654:12: (k+= AS (k+= FIRST | k+= LAST ) )? k+= INTO
                    // xquery/XQueryParser.g:1654:12: (k+= AS (k+= FIRST | k+= LAST ) )?
                    var alt186=2;
                    var LA186_0 = this.input.LA(1);

                    if ( (LA186_0==AS) ) {
                        alt186=1;
                    }
                    switch (alt186) {
                        case 1 :
                            // xquery/XQueryParser.g:1654:13: k+= AS (k+= FIRST | k+= LAST )
                            k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_InsertExprTargetChoice13395); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }
                            if (org.antlr.lang.isNull(list_k)) list_k = [];
                            list_k.push(k);

                            // xquery/XQueryParser.g:1654:19: (k+= FIRST | k+= LAST )
                            var alt185=2;
                            var LA185_0 = this.input.LA(1);

                            if ( (LA185_0==FIRST) ) {
                                alt185=1;
                            }
                            else if ( (LA185_0==LAST) ) {
                                alt185=2;
                            }
                            else {
                                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                                var nvae =
                                    new org.antlr.runtime.NoViableAltException("", 185, 0, this.input);

                                throw nvae;
                            }
                            switch (alt185) {
                                case 1 :
                                    // xquery/XQueryParser.g:1654:20: k+= FIRST
                                    k=this.match(this.input,FIRST,XQueryParser.FOLLOW_FIRST_in_p_InsertExprTargetChoice13400); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    k_tree = this.adaptor.create(k);
                                    this.adaptor.addChild(root_0, k_tree);
                                    }
                                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                                    list_k.push(k);



                                    break;
                                case 2 :
                                    // xquery/XQueryParser.g:1654:31: k+= LAST
                                    k=this.match(this.input,LAST,XQueryParser.FOLLOW_LAST_in_p_InsertExprTargetChoice13406); if (this.state.failed) return retval;
                                    if ( this.state.backtracking===0 ) {
                                    k_tree = this.adaptor.create(k);
                                    this.adaptor.addChild(root_0, k_tree);
                                    }
                                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                                    list_k.push(k);



                                    break;

                            }



                            break;

                    }

                    k=this.match(this.input,INTO,XQueryParser.FOLLOW_INTO_in_p_InsertExprTargetChoice13413); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);




                    if ( this.state.backtracking===0 ) {
                      this.ak(list_k);
                    }


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1655:11: ka= AFTER
                    root_0 = this.adaptor.nil();

                    ka=this.match(this.input,AFTER,XQueryParser.FOLLOW_AFTER_in_p_InsertExprTargetChoice13430); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ka_tree = this.adaptor.create(ka);
                    this.adaptor.addChild(root_0, ka_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(ka);
                    }


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1656:11: kb= BEFORE
                    root_0 = this.adaptor.nil();

                    kb=this.match(this.input,BEFORE,XQueryParser.FOLLOW_BEFORE_in_p_InsertExprTargetChoice13446); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    kb_tree = this.adaptor.create(kb);
                    this.adaptor.addChild(root_0, kb_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(kb);
                    }


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_InsertExpr_return: (function() {
        XQueryParser.p_InsertExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_InsertExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1660:1: p_InsertExpr : k+= INSERT (k+= NODE | k+= NODES ) p_SourceExpr p_InsertExprTargetChoice p_TargetExpr ;
    // $ANTLR start "p_InsertExpr"
    p_InsertExpr: function() {
        var retval = new XQueryParser.p_InsertExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_SourceExpr565 = null;
         var p_InsertExprTargetChoice566 = null;
         var p_TargetExpr567 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1661:9: (k+= INSERT (k+= NODE | k+= NODES ) p_SourceExpr p_InsertExprTargetChoice p_TargetExpr )
            // xquery/XQueryParser.g:1661:11: k+= INSERT (k+= NODE | k+= NODES ) p_SourceExpr p_InsertExprTargetChoice p_TargetExpr
            root_0 = this.adaptor.nil();

            k=this.match(this.input,INSERT,XQueryParser.FOLLOW_INSERT_in_p_InsertExpr13476); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            // xquery/XQueryParser.g:1661:21: (k+= NODE | k+= NODES )
            var alt188=2;
            var LA188_0 = this.input.LA(1);

            if ( (LA188_0==NODE) ) {
                alt188=1;
            }
            else if ( (LA188_0==NODES) ) {
                alt188=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 188, 0, this.input);

                throw nvae;
            }
            switch (alt188) {
                case 1 :
                    // xquery/XQueryParser.g:1661:22: k+= NODE
                    k=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_InsertExpr13481); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1661:32: k+= NODES
                    k=this.match(this.input,NODES,XQueryParser.FOLLOW_NODES_in_p_InsertExpr13487); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_SourceExpr_in_p_InsertExpr13490);
            p_SourceExpr565=this.p_SourceExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SourceExpr565.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_InsertExprTargetChoice_in_p_InsertExpr13492);
            p_InsertExprTargetChoice566=this.p_InsertExprTargetChoice();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InsertExprTargetChoice566.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_TargetExpr_in_p_InsertExpr13494);
            p_TargetExpr567=this.p_TargetExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TargetExpr567.getTree());
            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_DeleteExpr_return: (function() {
        XQueryParser.p_DeleteExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_DeleteExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1665:1: p_DeleteExpr : k+= DELETE (k+= NODE | k+= NODES ) p_TargetExpr ;
    // $ANTLR start "p_DeleteExpr"
    p_DeleteExpr: function() {
        var retval = new XQueryParser.p_DeleteExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_TargetExpr568 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1666:9: (k+= DELETE (k+= NODE | k+= NODES ) p_TargetExpr )
            // xquery/XQueryParser.g:1666:11: k+= DELETE (k+= NODE | k+= NODES ) p_TargetExpr
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DELETE,XQueryParser.FOLLOW_DELETE_in_p_DeleteExpr13524); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            // xquery/XQueryParser.g:1666:21: (k+= NODE | k+= NODES )
            var alt189=2;
            var LA189_0 = this.input.LA(1);

            if ( (LA189_0==NODE) ) {
                alt189=1;
            }
            else if ( (LA189_0==NODES) ) {
                alt189=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 189, 0, this.input);

                throw nvae;
            }
            switch (alt189) {
                case 1 :
                    // xquery/XQueryParser.g:1666:22: k+= NODE
                    k=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_DeleteExpr13529); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1666:32: k+= NODES
                    k=this.match(this.input,NODES,XQueryParser.FOLLOW_NODES_in_p_DeleteExpr13535); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_TargetExpr_in_p_DeleteExpr13538);
            p_TargetExpr568=this.p_TargetExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TargetExpr568.getTree());
            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ReplaceExpr_return: (function() {
        XQueryParser.p_ReplaceExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ReplaceExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1670:1: p_ReplaceExpr : k+= REPLACE (k+= VALUE k+= OF )? k+= NODE p_ExprSingle[true] k+= WITH p_ExprSingle[true] ;
    // $ANTLR start "p_ReplaceExpr"
    p_ReplaceExpr: function() {
        var retval = new XQueryParser.p_ReplaceExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_ExprSingle569 = null;
         var p_ExprSingle570 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1671:9: (k+= REPLACE (k+= VALUE k+= OF )? k+= NODE p_ExprSingle[true] k+= WITH p_ExprSingle[true] )
            // xquery/XQueryParser.g:1671:11: k+= REPLACE (k+= VALUE k+= OF )? k+= NODE p_ExprSingle[true] k+= WITH p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,REPLACE,XQueryParser.FOLLOW_REPLACE_in_p_ReplaceExpr13568); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            // xquery/XQueryParser.g:1671:22: (k+= VALUE k+= OF )?
            var alt190=2;
            var LA190_0 = this.input.LA(1);

            if ( (LA190_0==VALUE) ) {
                alt190=1;
            }
            switch (alt190) {
                case 1 :
                    // xquery/XQueryParser.g:1671:23: k+= VALUE k+= OF
                    k=this.match(this.input,VALUE,XQueryParser.FOLLOW_VALUE_in_p_ReplaceExpr13573); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,OF,XQueryParser.FOLLOW_OF_in_p_ReplaceExpr13577); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            k=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_ReplaceExpr13583); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_ReplaceExpr13585);
            p_ExprSingle569=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle569.getTree());
            k=this.match(this.input,WITH,XQueryParser.FOLLOW_WITH_in_p_ReplaceExpr13590); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_ReplaceExpr13592);
            p_ExprSingle570=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle570.getTree());
            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_RenameExpr_return: (function() {
        XQueryParser.p_RenameExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_RenameExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1675:1: p_RenameExpr : k+= RENAME k+= NODE p_TargetExpr k+= AS p_NewNameExpr ;
    // $ANTLR start "p_RenameExpr"
    p_RenameExpr: function() {
        var retval = new XQueryParser.p_RenameExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_TargetExpr571 = null;
         var p_NewNameExpr572 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1676:9: (k+= RENAME k+= NODE p_TargetExpr k+= AS p_NewNameExpr )
            // xquery/XQueryParser.g:1676:11: k+= RENAME k+= NODE p_TargetExpr k+= AS p_NewNameExpr
            root_0 = this.adaptor.nil();

            k=this.match(this.input,RENAME,XQueryParser.FOLLOW_RENAME_in_p_RenameExpr13623); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            k=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_RenameExpr13627); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_TargetExpr_in_p_RenameExpr13629);
            p_TargetExpr571=this.p_TargetExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TargetExpr571.getTree());
            k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_RenameExpr13633); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_NewNameExpr_in_p_RenameExpr13635);
            p_NewNameExpr572=this.p_NewNameExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_NewNameExpr572.getTree());
            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SourceExpr_return: (function() {
        XQueryParser.p_SourceExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SourceExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1680:1: p_SourceExpr : p_ExprSingle[true] ;
    // $ANTLR start "p_SourceExpr"
    p_SourceExpr: function() {
        var retval = new XQueryParser.p_SourceExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle573 = null;


        try {
            // xquery/XQueryParser.g:1681:9: ( p_ExprSingle[true] )
            // xquery/XQueryParser.g:1681:11: p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_SourceExpr13663);
            p_ExprSingle573=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle573.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TargetExpr_return: (function() {
        XQueryParser.p_TargetExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TargetExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1685:1: p_TargetExpr : p_ExprSingle[true] ;
    // $ANTLR start "p_TargetExpr"
    p_TargetExpr: function() {
        var retval = new XQueryParser.p_TargetExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle574 = null;


        try {
            // xquery/XQueryParser.g:1686:9: ( p_ExprSingle[true] )
            // xquery/XQueryParser.g:1686:11: p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_TargetExpr13690);
            p_ExprSingle574=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle574.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_NewNameExpr_return: (function() {
        XQueryParser.p_NewNameExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_NewNameExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1690:1: p_NewNameExpr : p_ExprSingle[true] ;
    // $ANTLR start "p_NewNameExpr"
    p_NewNameExpr: function() {
        var retval = new XQueryParser.p_NewNameExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_ExprSingle575 = null;


        try {
            // xquery/XQueryParser.g:1691:9: ( p_ExprSingle[true] )
            // xquery/XQueryParser.g:1691:11: p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_NewNameExpr13717);
            p_ExprSingle575=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle575.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TransformExpr_return: (function() {
        XQueryParser.p_TransformExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TransformExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1695:1: p_TransformExpr : k+= COPY d= DOLLAR v= p_VarName BIND p_ExprSingle[true] ( COMMA e= DOLLAR w= p_VarName BIND p_ExprSingle[true] )* k+= MODIFY p_ExprSingle[true] k+= RETURN p_ExprSingle[true] ;
    // $ANTLR start "p_TransformExpr"
    p_TransformExpr: function() {
        var retval = new XQueryParser.p_TransformExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
        var e = null;
        var BIND576 = null;
        var COMMA578 = null;
        var BIND579 = null;
        var k = null;
        var list_k=null;
         var v = null;
         var w = null;
         var p_ExprSingle577 = null;
         var p_ExprSingle580 = null;
         var p_ExprSingle581 = null;
         var p_ExprSingle582 = null;

        var d_tree=null;
        var e_tree=null;
        var BIND576_tree=null;
        var COMMA578_tree=null;
        var BIND579_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1696:9: (k+= COPY d= DOLLAR v= p_VarName BIND p_ExprSingle[true] ( COMMA e= DOLLAR w= p_VarName BIND p_ExprSingle[true] )* k+= MODIFY p_ExprSingle[true] k+= RETURN p_ExprSingle[true] )
            // xquery/XQueryParser.g:1696:11: k+= COPY d= DOLLAR v= p_VarName BIND p_ExprSingle[true] ( COMMA e= DOLLAR w= p_VarName BIND p_ExprSingle[true] )* k+= MODIFY p_ExprSingle[true] k+= RETURN p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,COPY,XQueryParser.FOLLOW_COPY_in_p_TransformExpr13746); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_TransformExpr13750); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_TransformExpr13754);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            BIND576=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_TransformExpr13758); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            BIND576_tree = this.adaptor.create(BIND576);
            this.adaptor.addChild(root_0, BIND576_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_TransformExpr13760);
            p_ExprSingle577=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle577.getTree());
            // xquery/XQueryParser.g:1696:90: ( COMMA e= DOLLAR w= p_VarName BIND p_ExprSingle[true] )*
            loop191:
            do {
                var alt191=2;
                var LA191_0 = this.input.LA(1);

                if ( (LA191_0==COMMA) ) {
                    alt191=1;
                }


                switch (alt191) {
                case 1 :
                    // xquery/XQueryParser.g:1696:91: COMMA e= DOLLAR w= p_VarName BIND p_ExprSingle[true]
                    COMMA578=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_TransformExpr13764); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA578_tree = this.adaptor.create(COMMA578);
                    this.adaptor.addChild(root_0, COMMA578_tree);
                    }
                    e=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_TransformExpr13768); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    e_tree = this.adaptor.create(e);
                    this.adaptor.addChild(root_0, e_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_TransformExpr13772);
                    w=this.p_VarName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, w.getTree());
                    if ( this.state.backtracking===0 ) {
                       this.av(e, (w?w.stop:null)); 
                    }
                    BIND579=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_TransformExpr13776); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    BIND579_tree = this.adaptor.create(BIND579);
                    this.adaptor.addChild(root_0, BIND579_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_TransformExpr13778);
                    p_ExprSingle580=this.p_ExprSingle(true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle580.getTree());


                    break;

                default :
                    break loop191;
                }
            } while (true);

            k=this.match(this.input,MODIFY,XQueryParser.FOLLOW_MODIFY_in_p_TransformExpr13785); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_TransformExpr13787);
            p_ExprSingle581=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle581.getTree());
            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_TransformExpr13792); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_TransformExpr13794);
            p_ExprSingle582=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle582.getTree());
            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    pm_FTOptionDecl_return: (function() {
        XQueryParser.pm_FTOptionDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.pm_FTOptionDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1706:1: pm_FTOptionDecl : k+= DECLARE k+= FT_OPTION p_FTMatchOptions SEMICOLON ;
    // $ANTLR start "pm_FTOptionDecl"
    pm_FTOptionDecl: function() {
        var retval = new XQueryParser.pm_FTOptionDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SEMICOLON584 = null;
        var k = null;
        var list_k=null;
         var p_FTMatchOptions583 = null;

        var SEMICOLON584_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1707:9: (k+= DECLARE k+= FT_OPTION p_FTMatchOptions SEMICOLON )
            // xquery/XQueryParser.g:1707:11: k+= DECLARE k+= FT_OPTION p_FTMatchOptions SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,DECLARE,XQueryParser.FOLLOW_DECLARE_in_pm_FTOptionDecl13832); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            k=this.match(this.input,FT_OPTION,XQueryParser.FOLLOW_FT_OPTION_in_pm_FTOptionDecl13836); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_FTMatchOptions_in_pm_FTOptionDecl13838);
            p_FTMatchOptions583=this.p_FTMatchOptions();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTMatchOptions583.getTree());
            SEMICOLON584=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_pm_FTOptionDecl13840); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON584_tree = this.adaptor.create(SEMICOLON584);
            this.adaptor.addChild(root_0, SEMICOLON584_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTScoreVar_return: (function() {
        XQueryParser.p_FTScoreVar_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTScoreVar_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1711:1: p_FTScoreVar : ks= SCORE d= DOLLAR v= p_VarName ;
    // $ANTLR start "p_FTScoreVar"
    p_FTScoreVar: function() {
        var retval = new XQueryParser.p_FTScoreVar_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ks = null;
        var d = null;
         var v = null;

        var ks_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:1712:9: (ks= SCORE d= DOLLAR v= p_VarName )
            // xquery/XQueryParser.g:1712:11: ks= SCORE d= DOLLAR v= p_VarName
            root_0 = this.adaptor.nil();

            ks=this.match(this.input,SCORE,XQueryParser.FOLLOW_SCORE_in_p_FTScoreVar13870); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            ks_tree = this.adaptor.create(ks);
            this.adaptor.addChild(root_0, ks_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(ks);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_FTScoreVar13876); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_FTScoreVar13880);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTContainsExpr_return: (function() {
        XQueryParser.p_FTContainsExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTContainsExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1716:1: p_FTContainsExpr : p_StringConcatExpr (k+= CONTAINS k+= TEXT p_FTSelection ( p_FTIgnoreOption )? )? ;
    // $ANTLR start "p_FTContainsExpr"
    p_FTContainsExpr: function() {
        var retval = new XQueryParser.p_FTContainsExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_StringConcatExpr585 = null;
         var p_FTSelection586 = null;
         var p_FTIgnoreOption587 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1717:9: ( p_StringConcatExpr (k+= CONTAINS k+= TEXT p_FTSelection ( p_FTIgnoreOption )? )? )
            // xquery/XQueryParser.g:1717:11: p_StringConcatExpr (k+= CONTAINS k+= TEXT p_FTSelection ( p_FTIgnoreOption )? )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_StringConcatExpr_in_p_FTContainsExpr13908);
            p_StringConcatExpr585=this.p_StringConcatExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringConcatExpr585.getTree());
            // xquery/XQueryParser.g:1717:30: (k+= CONTAINS k+= TEXT p_FTSelection ( p_FTIgnoreOption )? )?
            var alt193=2;
            var LA193_0 = this.input.LA(1);

            if ( (LA193_0==CONTAINS) ) {
                alt193=1;
            }
            switch (alt193) {
                case 1 :
                    // xquery/XQueryParser.g:1717:32: k+= CONTAINS k+= TEXT p_FTSelection ( p_FTIgnoreOption )?
                    k=this.match(this.input,CONTAINS,XQueryParser.FOLLOW_CONTAINS_in_p_FTContainsExpr13914); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,TEXT,XQueryParser.FOLLOW_TEXT_in_p_FTContainsExpr13918); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(list_k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_FTSelection_in_p_FTContainsExpr13922);
                    p_FTSelection586=this.p_FTSelection();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTSelection586.getTree());
                    // xquery/XQueryParser.g:1717:81: ( p_FTIgnoreOption )?
                    var alt192=2;
                    var LA192_0 = this.input.LA(1);

                    if ( (LA192_0==WITHOUT) ) {
                        alt192=1;
                    }
                    switch (alt192) {
                        case 1 :
                            // xquery/XQueryParser.g:1717:81: p_FTIgnoreOption
                            this.pushFollow(XQueryParser.FOLLOW_p_FTIgnoreOption_in_p_FTContainsExpr13924);
                            p_FTIgnoreOption587=this.p_FTIgnoreOption();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTIgnoreOption587.getTree());


                            break;

                    }



                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTSelection_return: (function() {
        XQueryParser.p_FTSelection_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTSelection_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1721:1: p_FTSelection : p_FTOr ( p_FTPosFilter )* ;
    // $ANTLR start "p_FTSelection"
    p_FTSelection: function() {
        var retval = new XQueryParser.p_FTSelection_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_FTOr588 = null;
         var p_FTPosFilter589 = null;


        try {
            // xquery/XQueryParser.g:1722:9: ( p_FTOr ( p_FTPosFilter )* )
            // xquery/XQueryParser.g:1722:11: p_FTOr ( p_FTPosFilter )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_FTOr_in_p_FTSelection13954);
            p_FTOr588=this.p_FTOr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTOr588.getTree());
            // xquery/XQueryParser.g:1722:18: ( p_FTPosFilter )*
            loop194:
            do {
                var alt194=2;
                var LA194_0 = this.input.LA(1);

                if ( (LA194_0==AT||LA194_0==ORDERED||LA194_0==WINDOW||(LA194_0>=DIFFERENT && LA194_0<=ENTIRE)||LA194_0==SAME) ) {
                    alt194=1;
                }


                switch (alt194) {
                case 1 :
                    // xquery/XQueryParser.g:1722:18: p_FTPosFilter
                    this.pushFollow(XQueryParser.FOLLOW_p_FTPosFilter_in_p_FTSelection13956);
                    p_FTPosFilter589=this.p_FTPosFilter();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTPosFilter589.getTree());


                    break;

                default :
                    break loop194;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTWeight_return: (function() {
        XQueryParser.p_FTWeight_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTWeight_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1726:1: p_FTWeight : kw= WEIGHT LBRACKET p_Expr[true,true] RBRACKET ;
    // $ANTLR start "p_FTWeight"
    p_FTWeight: function() {
        var retval = new XQueryParser.p_FTWeight_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var kw = null;
        var LBRACKET590 = null;
        var RBRACKET592 = null;
         var p_Expr591 = null;

        var kw_tree=null;
        var LBRACKET590_tree=null;
        var RBRACKET592_tree=null;

        try {
            // xquery/XQueryParser.g:1727:9: (kw= WEIGHT LBRACKET p_Expr[true,true] RBRACKET )
            // xquery/XQueryParser.g:1727:11: kw= WEIGHT LBRACKET p_Expr[true,true] RBRACKET
            root_0 = this.adaptor.nil();

            kw=this.match(this.input,WEIGHT,XQueryParser.FOLLOW_WEIGHT_in_p_FTWeight13985); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            kw_tree = this.adaptor.create(kw);
            this.adaptor.addChild(root_0, kw_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(kw);
            }
            LBRACKET590=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_FTWeight13989); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET590_tree = this.adaptor.create(LBRACKET590);
            this.adaptor.addChild(root_0, LBRACKET590_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_FTWeight13991);
            p_Expr591=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr591.getTree());
            RBRACKET592=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_FTWeight13994); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET592_tree = this.adaptor.create(RBRACKET592);
            this.adaptor.addChild(root_0, RBRACKET592_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTOr_return: (function() {
        XQueryParser.p_FTOr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTOr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1731:1: p_FTOr : p_FTAnd (ko= FTOR p_FTAnd )* ;
    // $ANTLR start "p_FTOr"
    p_FTOr: function() {
        var retval = new XQueryParser.p_FTOr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ko = null;
         var p_FTAnd593 = null;
         var p_FTAnd594 = null;

        var ko_tree=null;

        try {
            // xquery/XQueryParser.g:1732:9: ( p_FTAnd (ko= FTOR p_FTAnd )* )
            // xquery/XQueryParser.g:1732:11: p_FTAnd (ko= FTOR p_FTAnd )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_FTAnd_in_p_FTOr14020);
            p_FTAnd593=this.p_FTAnd();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTAnd593.getTree());
            // xquery/XQueryParser.g:1732:19: (ko= FTOR p_FTAnd )*
            loop195:
            do {
                var alt195=2;
                var LA195_0 = this.input.LA(1);

                if ( (LA195_0==FTOR) ) {
                    alt195=1;
                }


                switch (alt195) {
                case 1 :
                    // xquery/XQueryParser.g:1732:21: ko= FTOR p_FTAnd
                    ko=this.match(this.input,FTOR,XQueryParser.FOLLOW_FTOR_in_p_FTOr14026); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ko_tree = this.adaptor.create(ko);
                    this.adaptor.addChild(root_0, ko_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(ko);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_FTAnd_in_p_FTOr14030);
                    p_FTAnd594=this.p_FTAnd();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTAnd594.getTree());


                    break;

                default :
                    break loop195;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTAnd_return: (function() {
        XQueryParser.p_FTAnd_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTAnd_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1736:1: p_FTAnd : p_FTMildNot (ka= FTAND p_FTMildNot )* ;
    // $ANTLR start "p_FTAnd"
    p_FTAnd: function() {
        var retval = new XQueryParser.p_FTAnd_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ka = null;
         var p_FTMildNot595 = null;
         var p_FTMildNot596 = null;

        var ka_tree=null;

        try {
            // xquery/XQueryParser.g:1737:9: ( p_FTMildNot (ka= FTAND p_FTMildNot )* )
            // xquery/XQueryParser.g:1737:11: p_FTMildNot (ka= FTAND p_FTMildNot )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_FTMildNot_in_p_FTAnd14059);
            p_FTMildNot595=this.p_FTMildNot();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTMildNot595.getTree());
            // xquery/XQueryParser.g:1737:23: (ka= FTAND p_FTMildNot )*
            loop196:
            do {
                var alt196=2;
                var LA196_0 = this.input.LA(1);

                if ( (LA196_0==FTAND) ) {
                    alt196=1;
                }


                switch (alt196) {
                case 1 :
                    // xquery/XQueryParser.g:1737:25: ka= FTAND p_FTMildNot
                    ka=this.match(this.input,FTAND,XQueryParser.FOLLOW_FTAND_in_p_FTAnd14065); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ka_tree = this.adaptor.create(ka);
                    this.adaptor.addChild(root_0, ka_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(ka);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_FTMildNot_in_p_FTAnd14069);
                    p_FTMildNot596=this.p_FTMildNot();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTMildNot596.getTree());


                    break;

                default :
                    break loop196;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTMildNot_return: (function() {
        XQueryParser.p_FTMildNot_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTMildNot_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1741:1: p_FTMildNot : p_FTUnaryNot (k+= NOT k+= IN p_FTUnaryNot )* ;
    // $ANTLR start "p_FTMildNot"
    p_FTMildNot: function() {
        var retval = new XQueryParser.p_FTMildNot_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_FTUnaryNot597 = null;
         var p_FTUnaryNot598 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1742:9: ( p_FTUnaryNot (k+= NOT k+= IN p_FTUnaryNot )* )
            // xquery/XQueryParser.g:1742:11: p_FTUnaryNot (k+= NOT k+= IN p_FTUnaryNot )*
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_FTUnaryNot_in_p_FTMildNot14098);
            p_FTUnaryNot597=this.p_FTUnaryNot();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTUnaryNot597.getTree());
            // xquery/XQueryParser.g:1742:24: (k+= NOT k+= IN p_FTUnaryNot )*
            loop197:
            do {
                var alt197=2;
                var LA197_0 = this.input.LA(1);

                if ( (LA197_0==NOT) ) {
                    alt197=1;
                }


                switch (alt197) {
                case 1 :
                    // xquery/XQueryParser.g:1742:26: k+= NOT k+= IN p_FTUnaryNot
                    k=this.match(this.input,NOT,XQueryParser.FOLLOW_NOT_in_p_FTMildNot14104); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,IN,XQueryParser.FOLLOW_IN_in_p_FTMildNot14108); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    if ( this.state.backtracking===0 ) {
                      this.ak(list_k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_FTUnaryNot_in_p_FTMildNot14112);
                    p_FTUnaryNot598=this.p_FTUnaryNot();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTUnaryNot598.getTree());


                    break;

                default :
                    break loop197;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTUnaryNot_return: (function() {
        XQueryParser.p_FTUnaryNot_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTUnaryNot_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1746:1: p_FTUnaryNot : (kn= FTNOT )? p_FTPrimaryWithOptions ;
    // $ANTLR start "p_FTUnaryNot"
    p_FTUnaryNot: function() {
        var retval = new XQueryParser.p_FTUnaryNot_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var kn = null;
         var p_FTPrimaryWithOptions599 = null;

        var kn_tree=null;

        try {
            // xquery/XQueryParser.g:1747:9: ( (kn= FTNOT )? p_FTPrimaryWithOptions )
            // xquery/XQueryParser.g:1747:11: (kn= FTNOT )? p_FTPrimaryWithOptions
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1747:11: (kn= FTNOT )?
            var alt198=2;
            var LA198_0 = this.input.LA(1);

            if ( (LA198_0==FTNOT) ) {
                alt198=1;
            }
            switch (alt198) {
                case 1 :
                    // xquery/XQueryParser.g:1747:13: kn= FTNOT
                    kn=this.match(this.input,FTNOT,XQueryParser.FOLLOW_FTNOT_in_p_FTUnaryNot14145); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    kn_tree = this.adaptor.create(kn);
                    this.adaptor.addChild(root_0, kn_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(kn);
                    }


                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_FTPrimaryWithOptions_in_p_FTUnaryNot14152);
            p_FTPrimaryWithOptions599=this.p_FTPrimaryWithOptions();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTPrimaryWithOptions599.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTPrimaryWithOptions_return: (function() {
        XQueryParser.p_FTPrimaryWithOptions_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTPrimaryWithOptions_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1751:1: p_FTPrimaryWithOptions : p_FTPrimary ( p_FTMatchOptions )? ( p_FTWeight )? ;
    // $ANTLR start "p_FTPrimaryWithOptions"
    p_FTPrimaryWithOptions: function() {
        var retval = new XQueryParser.p_FTPrimaryWithOptions_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_FTPrimary600 = null;
         var p_FTMatchOptions601 = null;
         var p_FTWeight602 = null;


        try {
            // xquery/XQueryParser.g:1752:9: ( p_FTPrimary ( p_FTMatchOptions )? ( p_FTWeight )? )
            // xquery/XQueryParser.g:1752:11: p_FTPrimary ( p_FTMatchOptions )? ( p_FTWeight )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_FTPrimary_in_p_FTPrimaryWithOptions14178);
            p_FTPrimary600=this.p_FTPrimary();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTPrimary600.getTree());
            // xquery/XQueryParser.g:1752:23: ( p_FTMatchOptions )?
            var alt199=2;
            var LA199_0 = this.input.LA(1);

            if ( (LA199_0==USING) ) {
                alt199=1;
            }
            switch (alt199) {
                case 1 :
                    // xquery/XQueryParser.g:1752:23: p_FTMatchOptions
                    this.pushFollow(XQueryParser.FOLLOW_p_FTMatchOptions_in_p_FTPrimaryWithOptions14180);
                    p_FTMatchOptions601=this.p_FTMatchOptions();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTMatchOptions601.getTree());


                    break;

            }

            // xquery/XQueryParser.g:1752:41: ( p_FTWeight )?
            var alt200=2;
            var LA200_0 = this.input.LA(1);

            if ( (LA200_0==WEIGHT) ) {
                alt200=1;
            }
            switch (alt200) {
                case 1 :
                    // xquery/XQueryParser.g:1752:41: p_FTWeight
                    this.pushFollow(XQueryParser.FOLLOW_p_FTWeight_in_p_FTPrimaryWithOptions14183);
                    p_FTWeight602=this.p_FTWeight();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTWeight602.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTPrimary_return: (function() {
        XQueryParser.p_FTPrimary_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTPrimary_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1759:1: p_FTPrimary : ( ( p_FTWords ( p_FTTimes )? ) | ( LPAREN p_FTSelection RPAREN ) | p_FTExtensionSelection );
    // $ANTLR start "p_FTPrimary"
    p_FTPrimary: function() {
        var retval = new XQueryParser.p_FTPrimary_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LPAREN605 = null;
        var RPAREN607 = null;
         var p_FTWords603 = null;
         var p_FTTimes604 = null;
         var p_FTSelection606 = null;
         var p_FTExtensionSelection608 = null;

        var LPAREN605_tree=null;
        var RPAREN607_tree=null;

        try {
            // xquery/XQueryParser.g:1760:9: ( ( p_FTWords ( p_FTTimes )? ) | ( LPAREN p_FTSelection RPAREN ) | p_FTExtensionSelection )
            var alt202=3;
            switch ( this.input.LA(1) ) {
            case LBRACKET:
            case APOS:
            case QUOT:
                alt202=1;
                break;
            case LPAREN:
                alt202=2;
                break;
            case L_Pragma:
                alt202=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 202, 0, this.input);

                throw nvae;
            }

            switch (alt202) {
                case 1 :
                    // xquery/XQueryParser.g:1760:11: ( p_FTWords ( p_FTTimes )? )
                    root_0 = this.adaptor.nil();

                    // xquery/XQueryParser.g:1760:11: ( p_FTWords ( p_FTTimes )? )
                    // xquery/XQueryParser.g:1760:12: p_FTWords ( p_FTTimes )?
                    this.pushFollow(XQueryParser.FOLLOW_p_FTWords_in_p_FTPrimary14214);
                    p_FTWords603=this.p_FTWords();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTWords603.getTree());
                    // xquery/XQueryParser.g:1760:22: ( p_FTTimes )?
                    var alt201=2;
                    var LA201_0 = this.input.LA(1);

                    if ( (LA201_0==OCCURS) ) {
                        alt201=1;
                    }
                    switch (alt201) {
                        case 1 :
                            // xquery/XQueryParser.g:1760:22: p_FTTimes
                            this.pushFollow(XQueryParser.FOLLOW_p_FTTimes_in_p_FTPrimary14216);
                            p_FTTimes604=this.p_FTTimes();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTTimes604.getTree());


                            break;

                    }






                    break;
                case 2 :
                    // xquery/XQueryParser.g:1761:11: ( LPAREN p_FTSelection RPAREN )
                    root_0 = this.adaptor.nil();

                    // xquery/XQueryParser.g:1761:11: ( LPAREN p_FTSelection RPAREN )
                    // xquery/XQueryParser.g:1761:12: LPAREN p_FTSelection RPAREN
                    LPAREN605=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_FTPrimary14231); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LPAREN605_tree = this.adaptor.create(LPAREN605);
                    this.adaptor.addChild(root_0, LPAREN605_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_FTSelection_in_p_FTPrimary14233);
                    p_FTSelection606=this.p_FTSelection();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTSelection606.getTree());
                    RPAREN607=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_FTPrimary14235); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RPAREN607_tree = this.adaptor.create(RPAREN607);
                    this.adaptor.addChild(root_0, RPAREN607_tree);
                    }





                    break;
                case 3 :
                    // xquery/XQueryParser.g:1762:11: p_FTExtensionSelection
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTExtensionSelection_in_p_FTPrimary14248);
                    p_FTExtensionSelection608=this.p_FTExtensionSelection();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTExtensionSelection608.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTWords_return: (function() {
        XQueryParser.p_FTWords_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTWords_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1766:1: p_FTWords : p_FTWordsValue ( p_FTAnyallOption )? ;
    // $ANTLR start "p_FTWords"
    p_FTWords: function() {
        var retval = new XQueryParser.p_FTWords_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_FTWordsValue609 = null;
         var p_FTAnyallOption610 = null;


        try {
            // xquery/XQueryParser.g:1767:9: ( p_FTWordsValue ( p_FTAnyallOption )? )
            // xquery/XQueryParser.g:1767:11: p_FTWordsValue ( p_FTAnyallOption )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_FTWordsValue_in_p_FTWords14274);
            p_FTWordsValue609=this.p_FTWordsValue();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTWordsValue609.getTree());
            // xquery/XQueryParser.g:1767:26: ( p_FTAnyallOption )?
            var alt203=2;
            var LA203_0 = this.input.LA(1);

            if ( ((LA203_0>=ALL && LA203_0<=ANY)||LA203_0==PHRASE) ) {
                alt203=1;
            }
            switch (alt203) {
                case 1 :
                    // xquery/XQueryParser.g:1767:26: p_FTAnyallOption
                    this.pushFollow(XQueryParser.FOLLOW_p_FTAnyallOption_in_p_FTWords14276);
                    p_FTAnyallOption610=this.p_FTAnyallOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTAnyallOption610.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTWordsValue_return: (function() {
        XQueryParser.p_FTWordsValue_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTWordsValue_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1771:1: p_FTWordsValue : ( p_StringLiteral | ( LBRACKET p_Expr[true,true] RBRACKET ) );
    // $ANTLR start "p_FTWordsValue"
    p_FTWordsValue: function() {
        var retval = new XQueryParser.p_FTWordsValue_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LBRACKET612 = null;
        var RBRACKET614 = null;
         var p_StringLiteral611 = null;
         var p_Expr613 = null;

        var LBRACKET612_tree=null;
        var RBRACKET614_tree=null;

        try {
            // xquery/XQueryParser.g:1772:9: ( p_StringLiteral | ( LBRACKET p_Expr[true,true] RBRACKET ) )
            var alt204=2;
            var LA204_0 = this.input.LA(1);

            if ( ((LA204_0>=APOS && LA204_0<=QUOT)) ) {
                alt204=1;
            }
            else if ( (LA204_0==LBRACKET) ) {
                alt204=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 204, 0, this.input);

                throw nvae;
            }
            switch (alt204) {
                case 1 :
                    // xquery/XQueryParser.g:1772:11: p_StringLiteral
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTWordsValue14303);
                    p_StringLiteral611=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral611.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1773:11: ( LBRACKET p_Expr[true,true] RBRACKET )
                    root_0 = this.adaptor.nil();

                    // xquery/XQueryParser.g:1773:11: ( LBRACKET p_Expr[true,true] RBRACKET )
                    // xquery/XQueryParser.g:1773:12: LBRACKET p_Expr[true,true] RBRACKET
                    LBRACKET612=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_FTWordsValue14316); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LBRACKET612_tree = this.adaptor.create(LBRACKET612);
                    this.adaptor.addChild(root_0, LBRACKET612_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_FTWordsValue14318);
                    p_Expr613=this.p_Expr(true, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr613.getTree());
                    RBRACKET614=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_FTWordsValue14321); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RBRACKET614_tree = this.adaptor.create(RBRACKET614);
                    this.adaptor.addChild(root_0, RBRACKET614_tree);
                    }





                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTExtensionSelection_return: (function() {
        XQueryParser.p_FTExtensionSelection_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTExtensionSelection_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1777:1: p_FTExtensionSelection : ( L_Pragma )+ LBRACKET ( p_FTSelection )? RBRACKET ;
    // $ANTLR start "p_FTExtensionSelection"
    p_FTExtensionSelection: function() {
        var retval = new XQueryParser.p_FTExtensionSelection_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_Pragma615 = null;
        var LBRACKET616 = null;
        var RBRACKET618 = null;
         var p_FTSelection617 = null;

        var L_Pragma615_tree=null;
        var LBRACKET616_tree=null;
        var RBRACKET618_tree=null;

        try {
            // xquery/XQueryParser.g:1778:9: ( ( L_Pragma )+ LBRACKET ( p_FTSelection )? RBRACKET )
            // xquery/XQueryParser.g:1778:11: ( L_Pragma )+ LBRACKET ( p_FTSelection )? RBRACKET
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1778:11: ( L_Pragma )+
            var cnt205=0;
            loop205:
            do {
                var alt205=2;
                var LA205_0 = this.input.LA(1);

                if ( (LA205_0==L_Pragma) ) {
                    alt205=1;
                }


                switch (alt205) {
                case 1 :
                    // xquery/XQueryParser.g:1778:11: L_Pragma
                    L_Pragma615=this.match(this.input,L_Pragma,XQueryParser.FOLLOW_L_Pragma_in_p_FTExtensionSelection14348); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_Pragma615_tree = this.adaptor.create(L_Pragma615);
                    this.adaptor.addChild(root_0, L_Pragma615_tree);
                    }


                    break;

                default :
                    if ( cnt205 >= 1 ) {
                        break loop205;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(205, this.input);
                        throw eee;
                }
                cnt205++;
            } while (true);

            LBRACKET616=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_FTExtensionSelection14351); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET616_tree = this.adaptor.create(LBRACKET616);
            this.adaptor.addChild(root_0, LBRACKET616_tree);
            }
            // xquery/XQueryParser.g:1778:30: ( p_FTSelection )?
            var alt206=2;
            var LA206_0 = this.input.LA(1);

            if ( (LA206_0==FTNOT||LA206_0==LPAREN||LA206_0==LBRACKET||(LA206_0>=APOS && LA206_0<=QUOT)||LA206_0==L_Pragma) ) {
                alt206=1;
            }
            switch (alt206) {
                case 1 :
                    // xquery/XQueryParser.g:1778:30: p_FTSelection
                    this.pushFollow(XQueryParser.FOLLOW_p_FTSelection_in_p_FTExtensionSelection14353);
                    p_FTSelection617=this.p_FTSelection();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTSelection617.getTree());


                    break;

            }

            RBRACKET618=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_FTExtensionSelection14356); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET618_tree = this.adaptor.create(RBRACKET618);
            this.adaptor.addChild(root_0, RBRACKET618_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTAnyallOption_return: (function() {
        XQueryParser.p_FTAnyallOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTAnyallOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1782:1: p_FTAnyallOption : ( (k+= ANY (k+= WORD )? ) | (k+= ALL ( WORDS )? ) | k+= PHRASE ) ;
    // $ANTLR start "p_FTAnyallOption"
    p_FTAnyallOption: function() {
        var retval = new XQueryParser.p_FTAnyallOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var WORDS619 = null;
        var k = null;
        var list_k=null;

        var WORDS619_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1783:9: ( ( (k+= ANY (k+= WORD )? ) | (k+= ALL ( WORDS )? ) | k+= PHRASE ) )
            // xquery/XQueryParser.g:1783:11: ( (k+= ANY (k+= WORD )? ) | (k+= ALL ( WORDS )? ) | k+= PHRASE )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1783:11: ( (k+= ANY (k+= WORD )? ) | (k+= ALL ( WORDS )? ) | k+= PHRASE )
            var alt209=3;
            switch ( this.input.LA(1) ) {
            case ANY:
                alt209=1;
                break;
            case ALL:
                alt209=2;
                break;
            case PHRASE:
                alt209=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 209, 0, this.input);

                throw nvae;
            }

            switch (alt209) {
                case 1 :
                    // xquery/XQueryParser.g:1783:13: (k+= ANY (k+= WORD )? )
                    // xquery/XQueryParser.g:1783:13: (k+= ANY (k+= WORD )? )
                    // xquery/XQueryParser.g:1783:14: k+= ANY (k+= WORD )?
                    k=this.match(this.input,ANY,XQueryParser.FOLLOW_ANY_in_p_FTAnyallOption14387); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    // xquery/XQueryParser.g:1783:22: (k+= WORD )?
                    var alt207=2;
                    var LA207_0 = this.input.LA(1);

                    if ( (LA207_0==WORD) ) {
                        alt207=1;
                    }
                    switch (alt207) {
                        case 1 :
                            // xquery/XQueryParser.g:1783:22: k+= WORD
                            k=this.match(this.input,WORD,XQueryParser.FOLLOW_WORD_in_p_FTAnyallOption14391); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }
                            if (org.antlr.lang.isNull(list_k)) list_k = [];
                            list_k.push(k);



                            break;

                    }






                    break;
                case 2 :
                    // xquery/XQueryParser.g:1783:33: (k+= ALL ( WORDS )? )
                    // xquery/XQueryParser.g:1783:33: (k+= ALL ( WORDS )? )
                    // xquery/XQueryParser.g:1783:34: k+= ALL ( WORDS )?
                    k=this.match(this.input,ALL,XQueryParser.FOLLOW_ALL_in_p_FTAnyallOption14400); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    // xquery/XQueryParser.g:1783:41: ( WORDS )?
                    var alt208=2;
                    var LA208_0 = this.input.LA(1);

                    if ( (LA208_0==WORDS) ) {
                        alt208=1;
                    }
                    switch (alt208) {
                        case 1 :
                            // xquery/XQueryParser.g:1783:41: WORDS
                            WORDS619=this.match(this.input,WORDS,XQueryParser.FOLLOW_WORDS_in_p_FTAnyallOption14402); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            WORDS619_tree = this.adaptor.create(WORDS619);
                            this.adaptor.addChild(root_0, WORDS619_tree);
                            }


                            break;

                    }






                    break;
                case 3 :
                    // xquery/XQueryParser.g:1783:51: k+= PHRASE
                    k=this.match(this.input,PHRASE,XQueryParser.FOLLOW_PHRASE_in_p_FTAnyallOption14410); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTTimes_return: (function() {
        XQueryParser.p_FTTimes_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTTimes_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1787:1: p_FTTimes : k+= OCCURS p_FTRange k+= TIMES ;
    // $ANTLR start "p_FTTimes"
    p_FTTimes: function() {
        var retval = new XQueryParser.p_FTTimes_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_FTRange620 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1788:9: (k+= OCCURS p_FTRange k+= TIMES )
            // xquery/XQueryParser.g:1788:11: k+= OCCURS p_FTRange k+= TIMES
            root_0 = this.adaptor.nil();

            k=this.match(this.input,OCCURS,XQueryParser.FOLLOW_OCCURS_in_p_FTTimes14442); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_FTRange_in_p_FTTimes14444);
            p_FTRange620=this.p_FTRange();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTRange620.getTree());
            k=this.match(this.input,TIMES,XQueryParser.FOLLOW_TIMES_in_p_FTTimes14448); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTRange_return: (function() {
        XQueryParser.p_FTRange_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTRange_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1792:1: p_FTRange : ( (k+= EXACTLY p_AdditiveExpr ) | (k+= AT k+= LEAST p_AdditiveExpr ) | (k+= AT k+= MOST p_AdditiveExpr ) | (k+= FROM p_AdditiveExpr k+= TO p_AdditiveExpr ) ) ;
    // $ANTLR start "p_FTRange"
    p_FTRange: function() {
        var retval = new XQueryParser.p_FTRange_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_AdditiveExpr621 = null;
         var p_AdditiveExpr622 = null;
         var p_AdditiveExpr623 = null;
         var p_AdditiveExpr624 = null;
         var p_AdditiveExpr625 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1793:9: ( ( (k+= EXACTLY p_AdditiveExpr ) | (k+= AT k+= LEAST p_AdditiveExpr ) | (k+= AT k+= MOST p_AdditiveExpr ) | (k+= FROM p_AdditiveExpr k+= TO p_AdditiveExpr ) ) )
            // xquery/XQueryParser.g:1793:11: ( (k+= EXACTLY p_AdditiveExpr ) | (k+= AT k+= LEAST p_AdditiveExpr ) | (k+= AT k+= MOST p_AdditiveExpr ) | (k+= FROM p_AdditiveExpr k+= TO p_AdditiveExpr ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1793:11: ( (k+= EXACTLY p_AdditiveExpr ) | (k+= AT k+= LEAST p_AdditiveExpr ) | (k+= AT k+= MOST p_AdditiveExpr ) | (k+= FROM p_AdditiveExpr k+= TO p_AdditiveExpr ) )
            var alt210=4;
            switch ( this.input.LA(1) ) {
            case EXACTLY:
                alt210=1;
                break;
            case AT:
                var LA210_2 = this.input.LA(2);

                if ( (LA210_2==LEAST) ) {
                    alt210=2;
                }
                else if ( (LA210_2==MOST) ) {
                    alt210=3;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 210, 2, this.input);

                    throw nvae;
                }
                break;
            case FROM:
                alt210=4;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 210, 0, this.input);

                throw nvae;
            }

            switch (alt210) {
                case 1 :
                    // xquery/XQueryParser.g:1793:13: (k+= EXACTLY p_AdditiveExpr )
                    // xquery/XQueryParser.g:1793:13: (k+= EXACTLY p_AdditiveExpr )
                    // xquery/XQueryParser.g:1793:14: k+= EXACTLY p_AdditiveExpr
                    k=this.match(this.input,EXACTLY,XQueryParser.FOLLOW_EXACTLY_in_p_FTRange14481); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_FTRange14483);
                    p_AdditiveExpr621=this.p_AdditiveExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr621.getTree());





                    break;
                case 2 :
                    // xquery/XQueryParser.g:1794:13: (k+= AT k+= LEAST p_AdditiveExpr )
                    // xquery/XQueryParser.g:1794:13: (k+= AT k+= LEAST p_AdditiveExpr )
                    // xquery/XQueryParser.g:1794:14: k+= AT k+= LEAST p_AdditiveExpr
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTRange14501); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,LEAST,XQueryParser.FOLLOW_LEAST_in_p_FTRange14505); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_FTRange14507);
                    p_AdditiveExpr622=this.p_AdditiveExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr622.getTree());





                    break;
                case 3 :
                    // xquery/XQueryParser.g:1795:13: (k+= AT k+= MOST p_AdditiveExpr )
                    // xquery/XQueryParser.g:1795:13: (k+= AT k+= MOST p_AdditiveExpr )
                    // xquery/XQueryParser.g:1795:14: k+= AT k+= MOST p_AdditiveExpr
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTRange14525); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,MOST,XQueryParser.FOLLOW_MOST_in_p_FTRange14529); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_FTRange14531);
                    p_AdditiveExpr623=this.p_AdditiveExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr623.getTree());





                    break;
                case 4 :
                    // xquery/XQueryParser.g:1796:13: (k+= FROM p_AdditiveExpr k+= TO p_AdditiveExpr )
                    // xquery/XQueryParser.g:1796:13: (k+= FROM p_AdditiveExpr k+= TO p_AdditiveExpr )
                    // xquery/XQueryParser.g:1796:14: k+= FROM p_AdditiveExpr k+= TO p_AdditiveExpr
                    k=this.match(this.input,FROM,XQueryParser.FOLLOW_FROM_in_p_FTRange14549); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_FTRange14551);
                    p_AdditiveExpr624=this.p_AdditiveExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr624.getTree());
                    k=this.match(this.input,TO,XQueryParser.FOLLOW_TO_in_p_FTRange14555); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_FTRange14557);
                    p_AdditiveExpr625=this.p_AdditiveExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr625.getTree());





                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTPosFilter_return: (function() {
        XQueryParser.p_FTPosFilter_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTPosFilter_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1800:1: p_FTPosFilter : ( p_FTOrder | p_FTWindow | p_FTDistance | p_FTScope | p_FTContent );
    // $ANTLR start "p_FTPosFilter"
    p_FTPosFilter: function() {
        var retval = new XQueryParser.p_FTPosFilter_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_FTOrder626 = null;
         var p_FTWindow627 = null;
         var p_FTDistance628 = null;
         var p_FTScope629 = null;
         var p_FTContent630 = null;


        try {
            // xquery/XQueryParser.g:1801:9: ( p_FTOrder | p_FTWindow | p_FTDistance | p_FTScope | p_FTContent )
            var alt211=5;
            switch ( this.input.LA(1) ) {
            case ORDERED:
                alt211=1;
                break;
            case WINDOW:
                alt211=2;
                break;
            case DISTANCE:
                alt211=3;
                break;
            case DIFFERENT:
            case SAME:
                alt211=4;
                break;
            case AT:
            case ENTIRE:
                alt211=5;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 211, 0, this.input);

                throw nvae;
            }

            switch (alt211) {
                case 1 :
                    // xquery/XQueryParser.g:1801:11: p_FTOrder
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTOrder_in_p_FTPosFilter14588);
                    p_FTOrder626=this.p_FTOrder();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTOrder626.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1801:23: p_FTWindow
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTWindow_in_p_FTPosFilter14592);
                    p_FTWindow627=this.p_FTWindow();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTWindow627.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1801:36: p_FTDistance
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTDistance_in_p_FTPosFilter14596);
                    p_FTDistance628=this.p_FTDistance();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTDistance628.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1801:51: p_FTScope
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTScope_in_p_FTPosFilter14600);
                    p_FTScope629=this.p_FTScope();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTScope629.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1801:63: p_FTContent
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTContent_in_p_FTPosFilter14604);
                    p_FTContent630=this.p_FTContent();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTContent630.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTOrder_return: (function() {
        XQueryParser.p_FTOrder_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTOrder_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1805:1: p_FTOrder : ko= ORDERED ;
    // $ANTLR start "p_FTOrder"
    p_FTOrder: function() {
        var retval = new XQueryParser.p_FTOrder_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ko = null;

        var ko_tree=null;

        try {
            // xquery/XQueryParser.g:1806:9: (ko= ORDERED )
            // xquery/XQueryParser.g:1806:11: ko= ORDERED
            root_0 = this.adaptor.nil();

            ko=this.match(this.input,ORDERED,XQueryParser.FOLLOW_ORDERED_in_p_FTOrder14632); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            ko_tree = this.adaptor.create(ko);
            this.adaptor.addChild(root_0, ko_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(ko);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTWindow_return: (function() {
        XQueryParser.p_FTWindow_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTWindow_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1810:1: p_FTWindow : kw= WINDOW p_AdditiveExpr p_FTUnit ;
    // $ANTLR start "p_FTWindow"
    p_FTWindow: function() {
        var retval = new XQueryParser.p_FTWindow_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var kw = null;
         var p_AdditiveExpr631 = null;
         var p_FTUnit632 = null;

        var kw_tree=null;

        try {
            // xquery/XQueryParser.g:1811:9: (kw= WINDOW p_AdditiveExpr p_FTUnit )
            // xquery/XQueryParser.g:1811:11: kw= WINDOW p_AdditiveExpr p_FTUnit
            root_0 = this.adaptor.nil();

            kw=this.match(this.input,WINDOW,XQueryParser.FOLLOW_WINDOW_in_p_FTWindow14662); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            kw_tree = this.adaptor.create(kw);
            this.adaptor.addChild(root_0, kw_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(kw);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_AdditiveExpr_in_p_FTWindow14666);
            p_AdditiveExpr631=this.p_AdditiveExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AdditiveExpr631.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_FTUnit_in_p_FTWindow14668);
            p_FTUnit632=this.p_FTUnit();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTUnit632.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTDistance_return: (function() {
        XQueryParser.p_FTDistance_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTDistance_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1815:1: p_FTDistance : kd= DISTANCE p_FTRange p_FTUnit ;
    // $ANTLR start "p_FTDistance"
    p_FTDistance: function() {
        var retval = new XQueryParser.p_FTDistance_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var kd = null;
         var p_FTRange633 = null;
         var p_FTUnit634 = null;

        var kd_tree=null;

        try {
            // xquery/XQueryParser.g:1816:9: (kd= DISTANCE p_FTRange p_FTUnit )
            // xquery/XQueryParser.g:1816:11: kd= DISTANCE p_FTRange p_FTUnit
            root_0 = this.adaptor.nil();

            kd=this.match(this.input,DISTANCE,XQueryParser.FOLLOW_DISTANCE_in_p_FTDistance14696); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            kd_tree = this.adaptor.create(kd);
            this.adaptor.addChild(root_0, kd_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(kd);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_FTRange_in_p_FTDistance14700);
            p_FTRange633=this.p_FTRange();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTRange633.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_FTUnit_in_p_FTDistance14702);
            p_FTUnit634=this.p_FTUnit();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTUnit634.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTUnit_return: (function() {
        XQueryParser.p_FTUnit_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTUnit_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1820:1: p_FTUnit : (k+= WORDS | k+= SENTENCES | k+= PARAGRAPHS ) ;
    // $ANTLR start "p_FTUnit"
    p_FTUnit: function() {
        var retval = new XQueryParser.p_FTUnit_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1821:9: ( (k+= WORDS | k+= SENTENCES | k+= PARAGRAPHS ) )
            // xquery/XQueryParser.g:1821:11: (k+= WORDS | k+= SENTENCES | k+= PARAGRAPHS )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1821:11: (k+= WORDS | k+= SENTENCES | k+= PARAGRAPHS )
            var alt212=3;
            switch ( this.input.LA(1) ) {
            case WORDS:
                alt212=1;
                break;
            case SENTENCES:
                alt212=2;
                break;
            case PARAGRAPHS:
                alt212=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 212, 0, this.input);

                throw nvae;
            }

            switch (alt212) {
                case 1 :
                    // xquery/XQueryParser.g:1821:13: k+= WORDS
                    k=this.match(this.input,WORDS,XQueryParser.FOLLOW_WORDS_in_p_FTUnit14732); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1821:24: k+= SENTENCES
                    k=this.match(this.input,SENTENCES,XQueryParser.FOLLOW_SENTENCES_in_p_FTUnit14738); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 3 :
                    // xquery/XQueryParser.g:1821:39: k+= PARAGRAPHS
                    k=this.match(this.input,PARAGRAPHS,XQueryParser.FOLLOW_PARAGRAPHS_in_p_FTUnit14744); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTScope_return: (function() {
        XQueryParser.p_FTScope_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTScope_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1825:1: p_FTScope : (k+= SAME | k+= DIFFERENT ) p_FTBigUnit ;
    // $ANTLR start "p_FTScope"
    p_FTScope: function() {
        var retval = new XQueryParser.p_FTScope_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_FTBigUnit635 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1826:9: ( (k+= SAME | k+= DIFFERENT ) p_FTBigUnit )
            // xquery/XQueryParser.g:1826:11: (k+= SAME | k+= DIFFERENT ) p_FTBigUnit
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1826:11: (k+= SAME | k+= DIFFERENT )
            var alt213=2;
            var LA213_0 = this.input.LA(1);

            if ( (LA213_0==SAME) ) {
                alt213=1;
            }
            else if ( (LA213_0==DIFFERENT) ) {
                alt213=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 213, 0, this.input);

                throw nvae;
            }
            switch (alt213) {
                case 1 :
                    // xquery/XQueryParser.g:1826:12: k+= SAME
                    k=this.match(this.input,SAME,XQueryParser.FOLLOW_SAME_in_p_FTScope14777); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1826:22: k+= DIFFERENT
                    k=this.match(this.input,DIFFERENT,XQueryParser.FOLLOW_DIFFERENT_in_p_FTScope14783); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_FTBigUnit_in_p_FTScope14788);
            p_FTBigUnit635=this.p_FTBigUnit();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTBigUnit635.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTBigUnit_return: (function() {
        XQueryParser.p_FTBigUnit_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTBigUnit_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1830:1: p_FTBigUnit : (k+= SENTENCE | k+= PARAGRAPH ) ;
    // $ANTLR start "p_FTBigUnit"
    p_FTBigUnit: function() {
        var retval = new XQueryParser.p_FTBigUnit_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1831:9: ( (k+= SENTENCE | k+= PARAGRAPH ) )
            // xquery/XQueryParser.g:1831:11: (k+= SENTENCE | k+= PARAGRAPH )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1831:11: (k+= SENTENCE | k+= PARAGRAPH )
            var alt214=2;
            var LA214_0 = this.input.LA(1);

            if ( (LA214_0==SENTENCE) ) {
                alt214=1;
            }
            else if ( (LA214_0==PARAGRAPH) ) {
                alt214=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 214, 0, this.input);

                throw nvae;
            }
            switch (alt214) {
                case 1 :
                    // xquery/XQueryParser.g:1831:13: k+= SENTENCE
                    k=this.match(this.input,SENTENCE,XQueryParser.FOLLOW_SENTENCE_in_p_FTBigUnit14818); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1831:27: k+= PARAGRAPH
                    k=this.match(this.input,PARAGRAPH,XQueryParser.FOLLOW_PARAGRAPH_in_p_FTBigUnit14824); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTContent_return: (function() {
        XQueryParser.p_FTContent_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTContent_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1835:1: p_FTContent : ( (k+= AT k+= START ) | (k+= AT k+= END ) | (k+= ENTIRE k+= CONTENT ) ) ;
    // $ANTLR start "p_FTContent"
    p_FTContent: function() {
        var retval = new XQueryParser.p_FTContent_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1836:9: ( ( (k+= AT k+= START ) | (k+= AT k+= END ) | (k+= ENTIRE k+= CONTENT ) ) )
            // xquery/XQueryParser.g:1836:11: ( (k+= AT k+= START ) | (k+= AT k+= END ) | (k+= ENTIRE k+= CONTENT ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1836:11: ( (k+= AT k+= START ) | (k+= AT k+= END ) | (k+= ENTIRE k+= CONTENT ) )
            var alt215=3;
            var LA215_0 = this.input.LA(1);

            if ( (LA215_0==AT) ) {
                var LA215_1 = this.input.LA(2);

                if ( (LA215_1==START) ) {
                    alt215=1;
                }
                else if ( (LA215_1==END) ) {
                    alt215=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 215, 1, this.input);

                    throw nvae;
                }
            }
            else if ( (LA215_0==ENTIRE) ) {
                alt215=3;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 215, 0, this.input);

                throw nvae;
            }
            switch (alt215) {
                case 1 :
                    // xquery/XQueryParser.g:1836:13: (k+= AT k+= START )
                    // xquery/XQueryParser.g:1836:13: (k+= AT k+= START )
                    // xquery/XQueryParser.g:1836:14: k+= AT k+= START
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTContent14859); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,START,XQueryParser.FOLLOW_START_in_p_FTContent14863); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;
                case 2 :
                    // xquery/XQueryParser.g:1836:32: (k+= AT k+= END )
                    // xquery/XQueryParser.g:1836:32: (k+= AT k+= END )
                    // xquery/XQueryParser.g:1836:33: k+= AT k+= END
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTContent14871); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,END,XQueryParser.FOLLOW_END_in_p_FTContent14875); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;
                case 3 :
                    // xquery/XQueryParser.g:1836:49: (k+= ENTIRE k+= CONTENT )
                    // xquery/XQueryParser.g:1836:49: (k+= ENTIRE k+= CONTENT )
                    // xquery/XQueryParser.g:1836:50: k+= ENTIRE k+= CONTENT
                    k=this.match(this.input,ENTIRE,XQueryParser.FOLLOW_ENTIRE_in_p_FTContent14883); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,CONTENT,XQueryParser.FOLLOW_CONTENT_in_p_FTContent14887); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTMatchOptions_return: (function() {
        XQueryParser.p_FTMatchOptions_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTMatchOptions_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1840:1: p_FTMatchOptions : (ku= USING p_FTMatchOption )+ ;
    // $ANTLR start "p_FTMatchOptions"
    p_FTMatchOptions: function() {
        var retval = new XQueryParser.p_FTMatchOptions_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ku = null;
         var p_FTMatchOption636 = null;

        var ku_tree=null;

        try {
            // xquery/XQueryParser.g:1841:9: ( (ku= USING p_FTMatchOption )+ )
            // xquery/XQueryParser.g:1841:11: (ku= USING p_FTMatchOption )+
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1841:11: (ku= USING p_FTMatchOption )+
            var cnt216=0;
            loop216:
            do {
                var alt216=2;
                var LA216_0 = this.input.LA(1);

                if ( (LA216_0==USING) ) {
                    alt216=1;
                }


                switch (alt216) {
                case 1 :
                    // xquery/XQueryParser.g:1841:12: ku= USING p_FTMatchOption
                    ku=this.match(this.input,USING,XQueryParser.FOLLOW_USING_in_p_FTMatchOptions14921); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ku_tree = this.adaptor.create(ku);
                    this.adaptor.addChild(root_0, ku_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(ku);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_FTMatchOption_in_p_FTMatchOptions14925);
                    p_FTMatchOption636=this.p_FTMatchOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTMatchOption636.getTree());


                    break;

                default :
                    if ( cnt216 >= 1 ) {
                        break loop216;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(216, this.input);
                        throw eee;
                }
                cnt216++;
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTMatchOption_return: (function() {
        XQueryParser.p_FTMatchOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTMatchOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1845:1: p_FTMatchOption : ( p_FTLanguageOption | p_FTWildCardOption | p_FTThesaurusOption | p_FTStemOption | p_FTCaseOption | p_FTDiacriticsOption | p_FTStopWordOption | p_FTExtensionOption );
    // $ANTLR start "p_FTMatchOption"
    p_FTMatchOption: function() {
        var retval = new XQueryParser.p_FTMatchOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_FTLanguageOption637 = null;
         var p_FTWildCardOption638 = null;
         var p_FTThesaurusOption639 = null;
         var p_FTStemOption640 = null;
         var p_FTCaseOption641 = null;
         var p_FTDiacriticsOption642 = null;
         var p_FTStopWordOption643 = null;
         var p_FTExtensionOption644 = null;


        try {
            // xquery/XQueryParser.g:1846:9: ( p_FTLanguageOption | p_FTWildCardOption | p_FTThesaurusOption | p_FTStemOption | p_FTCaseOption | p_FTDiacriticsOption | p_FTStopWordOption | p_FTExtensionOption )
            var alt217=8;
            alt217 = this.dfa217.predict(this.input);
            switch (alt217) {
                case 1 :
                    // xquery/XQueryParser.g:1846:11: p_FTLanguageOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTLanguageOption_in_p_FTMatchOption14953);
                    p_FTLanguageOption637=this.p_FTLanguageOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTLanguageOption637.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1847:11: p_FTWildCardOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTWildCardOption_in_p_FTMatchOption14965);
                    p_FTWildCardOption638=this.p_FTWildCardOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTWildCardOption638.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1848:11: p_FTThesaurusOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTThesaurusOption_in_p_FTMatchOption14977);
                    p_FTThesaurusOption639=this.p_FTThesaurusOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTThesaurusOption639.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1849:11: p_FTStemOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTStemOption_in_p_FTMatchOption14989);
                    p_FTStemOption640=this.p_FTStemOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTStemOption640.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1850:11: p_FTCaseOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTCaseOption_in_p_FTMatchOption15001);
                    p_FTCaseOption641=this.p_FTCaseOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTCaseOption641.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:1851:11: p_FTDiacriticsOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTDiacriticsOption_in_p_FTMatchOption15013);
                    p_FTDiacriticsOption642=this.p_FTDiacriticsOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTDiacriticsOption642.getTree());


                    break;
                case 7 :
                    // xquery/XQueryParser.g:1852:11: p_FTStopWordOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTStopWordOption_in_p_FTMatchOption15025);
                    p_FTStopWordOption643=this.p_FTStopWordOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTStopWordOption643.getTree());


                    break;
                case 8 :
                    // xquery/XQueryParser.g:1853:11: p_FTExtensionOption
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_FTExtensionOption_in_p_FTMatchOption15037);
                    p_FTExtensionOption644=this.p_FTExtensionOption();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTExtensionOption644.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTCaseOption_return: (function() {
        XQueryParser.p_FTCaseOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTCaseOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1857:1: p_FTCaseOption : ( (k+= CASE k+= INSENSITIVE ) | (k+= CASE k+= SENSITIVE ) | k+= LOWERCASE | k+= UPPERCASE ) ;
    // $ANTLR start "p_FTCaseOption"
    p_FTCaseOption: function() {
        var retval = new XQueryParser.p_FTCaseOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1858:9: ( ( (k+= CASE k+= INSENSITIVE ) | (k+= CASE k+= SENSITIVE ) | k+= LOWERCASE | k+= UPPERCASE ) )
            // xquery/XQueryParser.g:1858:11: ( (k+= CASE k+= INSENSITIVE ) | (k+= CASE k+= SENSITIVE ) | k+= LOWERCASE | k+= UPPERCASE )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1858:11: ( (k+= CASE k+= INSENSITIVE ) | (k+= CASE k+= SENSITIVE ) | k+= LOWERCASE | k+= UPPERCASE )
            var alt218=4;
            switch ( this.input.LA(1) ) {
            case CASE:
                var LA218_1 = this.input.LA(2);

                if ( (LA218_1==INSENSITIVE) ) {
                    alt218=1;
                }
                else if ( (LA218_1==SENSITIVE) ) {
                    alt218=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 218, 1, this.input);

                    throw nvae;
                }
                break;
            case LOWERCASE:
                alt218=3;
                break;
            case UPPERCASE:
                alt218=4;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 218, 0, this.input);

                throw nvae;
            }

            switch (alt218) {
                case 1 :
                    // xquery/XQueryParser.g:1858:13: (k+= CASE k+= INSENSITIVE )
                    // xquery/XQueryParser.g:1858:13: (k+= CASE k+= INSENSITIVE )
                    // xquery/XQueryParser.g:1858:14: k+= CASE k+= INSENSITIVE
                    k=this.match(this.input,CASE,XQueryParser.FOLLOW_CASE_in_p_FTCaseOption15068); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,INSENSITIVE,XQueryParser.FOLLOW_INSENSITIVE_in_p_FTCaseOption15072); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;
                case 2 :
                    // xquery/XQueryParser.g:1859:13: (k+= CASE k+= SENSITIVE )
                    // xquery/XQueryParser.g:1859:13: (k+= CASE k+= SENSITIVE )
                    // xquery/XQueryParser.g:1859:14: k+= CASE k+= SENSITIVE
                    k=this.match(this.input,CASE,XQueryParser.FOLLOW_CASE_in_p_FTCaseOption15090); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,SENSITIVE,XQueryParser.FOLLOW_SENSITIVE_in_p_FTCaseOption15094); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;
                case 3 :
                    // xquery/XQueryParser.g:1860:13: k+= LOWERCASE
                    k=this.match(this.input,LOWERCASE,XQueryParser.FOLLOW_LOWERCASE_in_p_FTCaseOption15111); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 4 :
                    // xquery/XQueryParser.g:1861:13: k+= UPPERCASE
                    k=this.match(this.input,UPPERCASE,XQueryParser.FOLLOW_UPPERCASE_in_p_FTCaseOption15127); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTDiacriticsOption_return: (function() {
        XQueryParser.p_FTDiacriticsOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTDiacriticsOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1865:1: p_FTDiacriticsOption : ( (k+= DIACRITICS k+= INSENSITIVE ) | (k+= DIACRITICS k+= SENSITIVE ) ) ;
    // $ANTLR start "p_FTDiacriticsOption"
    p_FTDiacriticsOption: function() {
        var retval = new XQueryParser.p_FTDiacriticsOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1866:9: ( ( (k+= DIACRITICS k+= INSENSITIVE ) | (k+= DIACRITICS k+= SENSITIVE ) ) )
            // xquery/XQueryParser.g:1866:11: ( (k+= DIACRITICS k+= INSENSITIVE ) | (k+= DIACRITICS k+= SENSITIVE ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1866:11: ( (k+= DIACRITICS k+= INSENSITIVE ) | (k+= DIACRITICS k+= SENSITIVE ) )
            var alt219=2;
            var LA219_0 = this.input.LA(1);

            if ( (LA219_0==DIACRITICS) ) {
                var LA219_1 = this.input.LA(2);

                if ( (LA219_1==INSENSITIVE) ) {
                    alt219=1;
                }
                else if ( (LA219_1==SENSITIVE) ) {
                    alt219=2;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 219, 1, this.input);

                    throw nvae;
                }
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 219, 0, this.input);

                throw nvae;
            }
            switch (alt219) {
                case 1 :
                    // xquery/XQueryParser.g:1866:13: (k+= DIACRITICS k+= INSENSITIVE )
                    // xquery/XQueryParser.g:1866:13: (k+= DIACRITICS k+= INSENSITIVE )
                    // xquery/XQueryParser.g:1866:14: k+= DIACRITICS k+= INSENSITIVE
                    k=this.match(this.input,DIACRITICS,XQueryParser.FOLLOW_DIACRITICS_in_p_FTDiacriticsOption15162); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,INSENSITIVE,XQueryParser.FOLLOW_INSENSITIVE_in_p_FTDiacriticsOption15166); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;
                case 2 :
                    // xquery/XQueryParser.g:1867:13: (k+= DIACRITICS k+= SENSITIVE )
                    // xquery/XQueryParser.g:1867:13: (k+= DIACRITICS k+= SENSITIVE )
                    // xquery/XQueryParser.g:1867:14: k+= DIACRITICS k+= SENSITIVE
                    k=this.match(this.input,DIACRITICS,XQueryParser.FOLLOW_DIACRITICS_in_p_FTDiacriticsOption15184); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,SENSITIVE,XQueryParser.FOLLOW_SENSITIVE_in_p_FTDiacriticsOption15188); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTStemOption_return: (function() {
        XQueryParser.p_FTStemOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTStemOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1871:1: p_FTStemOption : (k+= STEMMING | (k+= NO k+= STEMMING ) ) ;
    // $ANTLR start "p_FTStemOption"
    p_FTStemOption: function() {
        var retval = new XQueryParser.p_FTStemOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1872:9: ( (k+= STEMMING | (k+= NO k+= STEMMING ) ) )
            // xquery/XQueryParser.g:1872:11: (k+= STEMMING | (k+= NO k+= STEMMING ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1872:11: (k+= STEMMING | (k+= NO k+= STEMMING ) )
            var alt220=2;
            var LA220_0 = this.input.LA(1);

            if ( (LA220_0==STEMMING) ) {
                alt220=1;
            }
            else if ( (LA220_0==NO) ) {
                alt220=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 220, 0, this.input);

                throw nvae;
            }
            switch (alt220) {
                case 1 :
                    // xquery/XQueryParser.g:1872:13: k+= STEMMING
                    k=this.match(this.input,STEMMING,XQueryParser.FOLLOW_STEMMING_in_p_FTStemOption15223); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1872:27: (k+= NO k+= STEMMING )
                    // xquery/XQueryParser.g:1872:27: (k+= NO k+= STEMMING )
                    // xquery/XQueryParser.g:1872:28: k+= NO k+= STEMMING
                    k=this.match(this.input,NO,XQueryParser.FOLLOW_NO_in_p_FTStemOption15230); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,STEMMING,XQueryParser.FOLLOW_STEMMING_in_p_FTStemOption15234); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTThesaurusOption_return: (function() {
        XQueryParser.p_FTThesaurusOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTThesaurusOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1876:1: p_FTThesaurusOption : ( (k+= THESAURUS ( p_FTThesaurusID | k+= DEFAULT ) ) | (k+= THESAURUS LPAREN ( p_FTThesaurusID | k+= DEFAULT ) ( COMMA p_FTThesaurusID )* RPAREN ) | (k+= NO k+= THESAURUS ) ) ;
    // $ANTLR start "p_FTThesaurusOption"
    p_FTThesaurusOption: function() {
        var retval = new XQueryParser.p_FTThesaurusOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LPAREN646 = null;
        var COMMA648 = null;
        var RPAREN650 = null;
        var k = null;
        var list_k=null;
         var p_FTThesaurusID645 = null;
         var p_FTThesaurusID647 = null;
         var p_FTThesaurusID649 = null;

        var LPAREN646_tree=null;
        var COMMA648_tree=null;
        var RPAREN650_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1877:9: ( ( (k+= THESAURUS ( p_FTThesaurusID | k+= DEFAULT ) ) | (k+= THESAURUS LPAREN ( p_FTThesaurusID | k+= DEFAULT ) ( COMMA p_FTThesaurusID )* RPAREN ) | (k+= NO k+= THESAURUS ) ) )
            // xquery/XQueryParser.g:1877:11: ( (k+= THESAURUS ( p_FTThesaurusID | k+= DEFAULT ) ) | (k+= THESAURUS LPAREN ( p_FTThesaurusID | k+= DEFAULT ) ( COMMA p_FTThesaurusID )* RPAREN ) | (k+= NO k+= THESAURUS ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1877:11: ( (k+= THESAURUS ( p_FTThesaurusID | k+= DEFAULT ) ) | (k+= THESAURUS LPAREN ( p_FTThesaurusID | k+= DEFAULT ) ( COMMA p_FTThesaurusID )* RPAREN ) | (k+= NO k+= THESAURUS ) )
            var alt224=3;
            var LA224_0 = this.input.LA(1);

            if ( (LA224_0==THESAURUS) ) {
                var LA224_1 = this.input.LA(2);

                if ( (LA224_1==LPAREN) ) {
                    alt224=2;
                }
                else if ( (LA224_1==AT||LA224_1==DEFAULT) ) {
                    alt224=1;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 224, 1, this.input);

                    throw nvae;
                }
            }
            else if ( (LA224_0==NO) ) {
                alt224=3;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 224, 0, this.input);

                throw nvae;
            }
            switch (alt224) {
                case 1 :
                    // xquery/XQueryParser.g:1877:13: (k+= THESAURUS ( p_FTThesaurusID | k+= DEFAULT ) )
                    // xquery/XQueryParser.g:1877:13: (k+= THESAURUS ( p_FTThesaurusID | k+= DEFAULT ) )
                    // xquery/XQueryParser.g:1877:14: k+= THESAURUS ( p_FTThesaurusID | k+= DEFAULT )
                    k=this.match(this.input,THESAURUS,XQueryParser.FOLLOW_THESAURUS_in_p_FTThesaurusOption15270); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    // xquery/XQueryParser.g:1877:27: ( p_FTThesaurusID | k+= DEFAULT )
                    var alt221=2;
                    var LA221_0 = this.input.LA(1);

                    if ( (LA221_0==AT) ) {
                        alt221=1;
                    }
                    else if ( (LA221_0==DEFAULT) ) {
                        alt221=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 221, 0, this.input);

                        throw nvae;
                    }
                    switch (alt221) {
                        case 1 :
                            // xquery/XQueryParser.g:1877:28: p_FTThesaurusID
                            this.pushFollow(XQueryParser.FOLLOW_p_FTThesaurusID_in_p_FTThesaurusOption15273);
                            p_FTThesaurusID645=this.p_FTThesaurusID();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTThesaurusID645.getTree());


                            break;
                        case 2 :
                            // xquery/XQueryParser.g:1877:46: k+= DEFAULT
                            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_FTThesaurusOption15279); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }
                            if (org.antlr.lang.isNull(list_k)) list_k = [];
                            list_k.push(k);



                            break;

                    }






                    break;
                case 2 :
                    // xquery/XQueryParser.g:1878:13: (k+= THESAURUS LPAREN ( p_FTThesaurusID | k+= DEFAULT ) ( COMMA p_FTThesaurusID )* RPAREN )
                    // xquery/XQueryParser.g:1878:13: (k+= THESAURUS LPAREN ( p_FTThesaurusID | k+= DEFAULT ) ( COMMA p_FTThesaurusID )* RPAREN )
                    // xquery/XQueryParser.g:1878:14: k+= THESAURUS LPAREN ( p_FTThesaurusID | k+= DEFAULT ) ( COMMA p_FTThesaurusID )* RPAREN
                    k=this.match(this.input,THESAURUS,XQueryParser.FOLLOW_THESAURUS_in_p_FTThesaurusOption15298); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    LPAREN646=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_FTThesaurusOption15300); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LPAREN646_tree = this.adaptor.create(LPAREN646);
                    this.adaptor.addChild(root_0, LPAREN646_tree);
                    }
                    // xquery/XQueryParser.g:1878:34: ( p_FTThesaurusID | k+= DEFAULT )
                    var alt222=2;
                    var LA222_0 = this.input.LA(1);

                    if ( (LA222_0==AT) ) {
                        alt222=1;
                    }
                    else if ( (LA222_0==DEFAULT) ) {
                        alt222=2;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 222, 0, this.input);

                        throw nvae;
                    }
                    switch (alt222) {
                        case 1 :
                            // xquery/XQueryParser.g:1878:35: p_FTThesaurusID
                            this.pushFollow(XQueryParser.FOLLOW_p_FTThesaurusID_in_p_FTThesaurusOption15303);
                            p_FTThesaurusID647=this.p_FTThesaurusID();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTThesaurusID647.getTree());


                            break;
                        case 2 :
                            // xquery/XQueryParser.g:1878:53: k+= DEFAULT
                            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_FTThesaurusOption15309); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            k_tree = this.adaptor.create(k);
                            this.adaptor.addChild(root_0, k_tree);
                            }
                            if (org.antlr.lang.isNull(list_k)) list_k = [];
                            list_k.push(k);



                            break;

                    }

                    // xquery/XQueryParser.g:1878:65: ( COMMA p_FTThesaurusID )*
                    loop223:
                    do {
                        var alt223=2;
                        var LA223_0 = this.input.LA(1);

                        if ( (LA223_0==COMMA) ) {
                            alt223=1;
                        }


                        switch (alt223) {
                        case 1 :
                            // xquery/XQueryParser.g:1878:66: COMMA p_FTThesaurusID
                            COMMA648=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_FTThesaurusOption15313); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COMMA648_tree = this.adaptor.create(COMMA648);
                            this.adaptor.addChild(root_0, COMMA648_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_FTThesaurusID_in_p_FTThesaurusOption15315);
                            p_FTThesaurusID649=this.p_FTThesaurusID();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTThesaurusID649.getTree());


                            break;

                        default :
                            break loop223;
                        }
                    } while (true);

                    RPAREN650=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_FTThesaurusOption15319); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RPAREN650_tree = this.adaptor.create(RPAREN650);
                    this.adaptor.addChild(root_0, RPAREN650_tree);
                    }





                    break;
                case 3 :
                    // xquery/XQueryParser.g:1879:13: (k+= NO k+= THESAURUS )
                    // xquery/XQueryParser.g:1879:13: (k+= NO k+= THESAURUS )
                    // xquery/XQueryParser.g:1879:14: k+= NO k+= THESAURUS
                    k=this.match(this.input,NO,XQueryParser.FOLLOW_NO_in_p_FTThesaurusOption15337); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,THESAURUS,XQueryParser.FOLLOW_THESAURUS_in_p_FTThesaurusOption15341); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTThesaurusID_return: (function() {
        XQueryParser.p_FTThesaurusID_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTThesaurusID_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1883:1: p_FTThesaurusID : k+= AT p_StringLiteral (k+= RELATIONSHIP p_StringLiteral )? ( p_FTLiteralRange k+= LEVELS )? ;
    // $ANTLR start "p_FTThesaurusID"
    p_FTThesaurusID: function() {
        var retval = new XQueryParser.p_FTThesaurusID_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_StringLiteral651 = null;
         var p_StringLiteral652 = null;
         var p_FTLiteralRange653 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1884:9: (k+= AT p_StringLiteral (k+= RELATIONSHIP p_StringLiteral )? ( p_FTLiteralRange k+= LEVELS )? )
            // xquery/XQueryParser.g:1884:11: k+= AT p_StringLiteral (k+= RELATIONSHIP p_StringLiteral )? ( p_FTLiteralRange k+= LEVELS )?
            root_0 = this.adaptor.nil();

            k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTThesaurusID15374); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTThesaurusID15376);
            p_StringLiteral651=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral651.getTree());
            // xquery/XQueryParser.g:1884:33: (k+= RELATIONSHIP p_StringLiteral )?
            var alt225=2;
            var LA225_0 = this.input.LA(1);

            if ( (LA225_0==RELATIONSHIP) ) {
                alt225=1;
            }
            switch (alt225) {
                case 1 :
                    // xquery/XQueryParser.g:1884:34: k+= RELATIONSHIP p_StringLiteral
                    k=this.match(this.input,RELATIONSHIP,XQueryParser.FOLLOW_RELATIONSHIP_in_p_FTThesaurusID15381); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTThesaurusID15383);
                    p_StringLiteral652=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral652.getTree());


                    break;

            }

            // xquery/XQueryParser.g:1884:68: ( p_FTLiteralRange k+= LEVELS )?
            var alt226=2;
            var LA226_0 = this.input.LA(1);

            if ( ((LA226_0>=EXACTLY && LA226_0<=FROM)) ) {
                alt226=1;
            }
            else if ( (LA226_0==AT) ) {
                var LA226_2 = this.input.LA(2);

                if ( (LA226_2==LEAST||LA226_2==MOST) ) {
                    alt226=1;
                }
            }
            switch (alt226) {
                case 1 :
                    // xquery/XQueryParser.g:1884:69: p_FTLiteralRange k+= LEVELS
                    this.pushFollow(XQueryParser.FOLLOW_p_FTLiteralRange_in_p_FTThesaurusID15388);
                    p_FTLiteralRange653=this.p_FTLiteralRange();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTLiteralRange653.getTree());
                    k=this.match(this.input,LEVELS,XQueryParser.FOLLOW_LEVELS_in_p_FTThesaurusID15392); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTLiteralRange_return: (function() {
        XQueryParser.p_FTLiteralRange_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTLiteralRange_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1888:1: p_FTLiteralRange : ( (k+= EXACTLY L_IntegerLiteral ) | (k+= AT k+= LEAST L_IntegerLiteral ) | (k+= AT k+= MOST L_IntegerLiteral ) | (k+= FROM L_IntegerLiteral TO L_IntegerLiteral ) ) ;
    // $ANTLR start "p_FTLiteralRange"
    p_FTLiteralRange: function() {
        var retval = new XQueryParser.p_FTLiteralRange_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var L_IntegerLiteral654 = null;
        var L_IntegerLiteral655 = null;
        var L_IntegerLiteral656 = null;
        var L_IntegerLiteral657 = null;
        var TO658 = null;
        var L_IntegerLiteral659 = null;
        var k = null;
        var list_k=null;

        var L_IntegerLiteral654_tree=null;
        var L_IntegerLiteral655_tree=null;
        var L_IntegerLiteral656_tree=null;
        var L_IntegerLiteral657_tree=null;
        var TO658_tree=null;
        var L_IntegerLiteral659_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1889:9: ( ( (k+= EXACTLY L_IntegerLiteral ) | (k+= AT k+= LEAST L_IntegerLiteral ) | (k+= AT k+= MOST L_IntegerLiteral ) | (k+= FROM L_IntegerLiteral TO L_IntegerLiteral ) ) )
            // xquery/XQueryParser.g:1889:11: ( (k+= EXACTLY L_IntegerLiteral ) | (k+= AT k+= LEAST L_IntegerLiteral ) | (k+= AT k+= MOST L_IntegerLiteral ) | (k+= FROM L_IntegerLiteral TO L_IntegerLiteral ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1889:11: ( (k+= EXACTLY L_IntegerLiteral ) | (k+= AT k+= LEAST L_IntegerLiteral ) | (k+= AT k+= MOST L_IntegerLiteral ) | (k+= FROM L_IntegerLiteral TO L_IntegerLiteral ) )
            var alt227=4;
            switch ( this.input.LA(1) ) {
            case EXACTLY:
                alt227=1;
                break;
            case AT:
                var LA227_2 = this.input.LA(2);

                if ( (LA227_2==LEAST) ) {
                    alt227=2;
                }
                else if ( (LA227_2==MOST) ) {
                    alt227=3;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 227, 2, this.input);

                    throw nvae;
                }
                break;
            case FROM:
                alt227=4;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 227, 0, this.input);

                throw nvae;
            }

            switch (alt227) {
                case 1 :
                    // xquery/XQueryParser.g:1889:13: (k+= EXACTLY L_IntegerLiteral )
                    // xquery/XQueryParser.g:1889:13: (k+= EXACTLY L_IntegerLiteral )
                    // xquery/XQueryParser.g:1889:14: k+= EXACTLY L_IntegerLiteral
                    k=this.match(this.input,EXACTLY,XQueryParser.FOLLOW_EXACTLY_in_p_FTLiteralRange15427); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    L_IntegerLiteral654=this.match(this.input,L_IntegerLiteral,XQueryParser.FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15429); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_IntegerLiteral654_tree = this.adaptor.create(L_IntegerLiteral654);
                    this.adaptor.addChild(root_0, L_IntegerLiteral654_tree);
                    }





                    break;
                case 2 :
                    // xquery/XQueryParser.g:1890:13: (k+= AT k+= LEAST L_IntegerLiteral )
                    // xquery/XQueryParser.g:1890:13: (k+= AT k+= LEAST L_IntegerLiteral )
                    // xquery/XQueryParser.g:1890:14: k+= AT k+= LEAST L_IntegerLiteral
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTLiteralRange15447); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,LEAST,XQueryParser.FOLLOW_LEAST_in_p_FTLiteralRange15451); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    L_IntegerLiteral655=this.match(this.input,L_IntegerLiteral,XQueryParser.FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15453); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_IntegerLiteral655_tree = this.adaptor.create(L_IntegerLiteral655);
                    this.adaptor.addChild(root_0, L_IntegerLiteral655_tree);
                    }





                    break;
                case 3 :
                    // xquery/XQueryParser.g:1891:13: (k+= AT k+= MOST L_IntegerLiteral )
                    // xquery/XQueryParser.g:1891:13: (k+= AT k+= MOST L_IntegerLiteral )
                    // xquery/XQueryParser.g:1891:14: k+= AT k+= MOST L_IntegerLiteral
                    k=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTLiteralRange15471); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,MOST,XQueryParser.FOLLOW_MOST_in_p_FTLiteralRange15475); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    L_IntegerLiteral656=this.match(this.input,L_IntegerLiteral,XQueryParser.FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15477); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_IntegerLiteral656_tree = this.adaptor.create(L_IntegerLiteral656);
                    this.adaptor.addChild(root_0, L_IntegerLiteral656_tree);
                    }





                    break;
                case 4 :
                    // xquery/XQueryParser.g:1892:13: (k+= FROM L_IntegerLiteral TO L_IntegerLiteral )
                    // xquery/XQueryParser.g:1892:13: (k+= FROM L_IntegerLiteral TO L_IntegerLiteral )
                    // xquery/XQueryParser.g:1892:14: k+= FROM L_IntegerLiteral TO L_IntegerLiteral
                    k=this.match(this.input,FROM,XQueryParser.FOLLOW_FROM_in_p_FTLiteralRange15495); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    L_IntegerLiteral657=this.match(this.input,L_IntegerLiteral,XQueryParser.FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15497); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_IntegerLiteral657_tree = this.adaptor.create(L_IntegerLiteral657);
                    this.adaptor.addChild(root_0, L_IntegerLiteral657_tree);
                    }
                    TO658=this.match(this.input,TO,XQueryParser.FOLLOW_TO_in_p_FTLiteralRange15499); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    TO658_tree = this.adaptor.create(TO658);
                    this.adaptor.addChild(root_0, TO658_tree);
                    }
                    L_IntegerLiteral659=this.match(this.input,L_IntegerLiteral,XQueryParser.FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15501); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    L_IntegerLiteral659_tree = this.adaptor.create(L_IntegerLiteral659);
                    this.adaptor.addChild(root_0, L_IntegerLiteral659_tree);
                    }





                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTStopWordOption_return: (function() {
        XQueryParser.p_FTStopWordOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTStopWordOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1896:1: p_FTStopWordOption : ( (k+= STOP k+= WORDS p_FTStopWords ( p_FTStopWordsInclExcl )* ) | (k+= STOP k+= WORDS k+= DEFAULT ( p_FTStopWordsInclExcl )* ) | (k+= NO k+= STOP k+= WORDS ) ) ;
    // $ANTLR start "p_FTStopWordOption"
    p_FTStopWordOption: function() {
        var retval = new XQueryParser.p_FTStopWordOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_FTStopWords660 = null;
         var p_FTStopWordsInclExcl661 = null;
         var p_FTStopWordsInclExcl662 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1897:9: ( ( (k+= STOP k+= WORDS p_FTStopWords ( p_FTStopWordsInclExcl )* ) | (k+= STOP k+= WORDS k+= DEFAULT ( p_FTStopWordsInclExcl )* ) | (k+= NO k+= STOP k+= WORDS ) ) )
            // xquery/XQueryParser.g:1897:11: ( (k+= STOP k+= WORDS p_FTStopWords ( p_FTStopWordsInclExcl )* ) | (k+= STOP k+= WORDS k+= DEFAULT ( p_FTStopWordsInclExcl )* ) | (k+= NO k+= STOP k+= WORDS ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1897:11: ( (k+= STOP k+= WORDS p_FTStopWords ( p_FTStopWordsInclExcl )* ) | (k+= STOP k+= WORDS k+= DEFAULT ( p_FTStopWordsInclExcl )* ) | (k+= NO k+= STOP k+= WORDS ) )
            var alt230=3;
            var LA230_0 = this.input.LA(1);

            if ( (LA230_0==STOP) ) {
                var LA230_1 = this.input.LA(2);

                if ( (LA230_1==WORDS) ) {
                    var LA230_3 = this.input.LA(3);

                    if ( (LA230_3==DEFAULT) ) {
                        alt230=2;
                    }
                    else if ( (LA230_3==AT||LA230_3==LPAREN) ) {
                        alt230=1;
                    }
                    else {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 230, 3, this.input);

                        throw nvae;
                    }
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 230, 1, this.input);

                    throw nvae;
                }
            }
            else if ( (LA230_0==NO) ) {
                alt230=3;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 230, 0, this.input);

                throw nvae;
            }
            switch (alt230) {
                case 1 :
                    // xquery/XQueryParser.g:1897:13: (k+= STOP k+= WORDS p_FTStopWords ( p_FTStopWordsInclExcl )* )
                    // xquery/XQueryParser.g:1897:13: (k+= STOP k+= WORDS p_FTStopWords ( p_FTStopWordsInclExcl )* )
                    // xquery/XQueryParser.g:1897:14: k+= STOP k+= WORDS p_FTStopWords ( p_FTStopWordsInclExcl )*
                    k=this.match(this.input,STOP,XQueryParser.FOLLOW_STOP_in_p_FTStopWordOption15537); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,WORDS,XQueryParser.FOLLOW_WORDS_in_p_FTStopWordOption15541); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    this.pushFollow(XQueryParser.FOLLOW_p_FTStopWords_in_p_FTStopWordOption15543);
                    p_FTStopWords660=this.p_FTStopWords();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTStopWords660.getTree());
                    // xquery/XQueryParser.g:1897:45: ( p_FTStopWordsInclExcl )*
                    loop228:
                    do {
                        var alt228=2;
                        var LA228_0 = this.input.LA(1);

                        if ( (LA228_0==EXCEPT||LA228_0==UNION) ) {
                            alt228=1;
                        }


                        switch (alt228) {
                        case 1 :
                            // xquery/XQueryParser.g:1897:45: p_FTStopWordsInclExcl
                            this.pushFollow(XQueryParser.FOLLOW_p_FTStopWordsInclExcl_in_p_FTStopWordOption15545);
                            p_FTStopWordsInclExcl661=this.p_FTStopWordsInclExcl();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTStopWordsInclExcl661.getTree());


                            break;

                        default :
                            break loop228;
                        }
                    } while (true);






                    break;
                case 2 :
                    // xquery/XQueryParser.g:1898:13: (k+= STOP k+= WORDS k+= DEFAULT ( p_FTStopWordsInclExcl )* )
                    // xquery/XQueryParser.g:1898:13: (k+= STOP k+= WORDS k+= DEFAULT ( p_FTStopWordsInclExcl )* )
                    // xquery/XQueryParser.g:1898:14: k+= STOP k+= WORDS k+= DEFAULT ( p_FTStopWordsInclExcl )*
                    k=this.match(this.input,STOP,XQueryParser.FOLLOW_STOP_in_p_FTStopWordOption15564); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,WORDS,XQueryParser.FOLLOW_WORDS_in_p_FTStopWordOption15568); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_FTStopWordOption15572); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    // xquery/XQueryParser.g:1898:42: ( p_FTStopWordsInclExcl )*
                    loop229:
                    do {
                        var alt229=2;
                        var LA229_0 = this.input.LA(1);

                        if ( (LA229_0==EXCEPT||LA229_0==UNION) ) {
                            alt229=1;
                        }


                        switch (alt229) {
                        case 1 :
                            // xquery/XQueryParser.g:1898:42: p_FTStopWordsInclExcl
                            this.pushFollow(XQueryParser.FOLLOW_p_FTStopWordsInclExcl_in_p_FTStopWordOption15574);
                            p_FTStopWordsInclExcl662=this.p_FTStopWordsInclExcl();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTStopWordsInclExcl662.getTree());


                            break;

                        default :
                            break loop229;
                        }
                    } while (true);






                    break;
                case 3 :
                    // xquery/XQueryParser.g:1899:13: (k+= NO k+= STOP k+= WORDS )
                    // xquery/XQueryParser.g:1899:13: (k+= NO k+= STOP k+= WORDS )
                    // xquery/XQueryParser.g:1899:14: k+= NO k+= STOP k+= WORDS
                    k=this.match(this.input,NO,XQueryParser.FOLLOW_NO_in_p_FTStopWordOption15593); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,STOP,XQueryParser.FOLLOW_STOP_in_p_FTStopWordOption15597); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,WORDS,XQueryParser.FOLLOW_WORDS_in_p_FTStopWordOption15601); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTStopWords_return: (function() {
        XQueryParser.p_FTStopWords_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTStopWords_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1903:1: p_FTStopWords : ( (ka= AT p_StringLiteral ) | ( LPAREN p_StringLiteral ( COMMA p_StringLiteral )* RPAREN ) );
    // $ANTLR start "p_FTStopWords"
    p_FTStopWords: function() {
        var retval = new XQueryParser.p_FTStopWords_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ka = null;
        var LPAREN664 = null;
        var COMMA666 = null;
        var RPAREN668 = null;
         var p_StringLiteral663 = null;
         var p_StringLiteral665 = null;
         var p_StringLiteral667 = null;

        var ka_tree=null;
        var LPAREN664_tree=null;
        var COMMA666_tree=null;
        var RPAREN668_tree=null;

        try {
            // xquery/XQueryParser.g:1904:9: ( (ka= AT p_StringLiteral ) | ( LPAREN p_StringLiteral ( COMMA p_StringLiteral )* RPAREN ) )
            var alt232=2;
            var LA232_0 = this.input.LA(1);

            if ( (LA232_0==AT) ) {
                alt232=1;
            }
            else if ( (LA232_0==LPAREN) ) {
                alt232=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 232, 0, this.input);

                throw nvae;
            }
            switch (alt232) {
                case 1 :
                    // xquery/XQueryParser.g:1904:11: (ka= AT p_StringLiteral )
                    root_0 = this.adaptor.nil();

                    // xquery/XQueryParser.g:1904:11: (ka= AT p_StringLiteral )
                    // xquery/XQueryParser.g:1904:12: ka= AT p_StringLiteral
                    ka=this.match(this.input,AT,XQueryParser.FOLLOW_AT_in_p_FTStopWords15635); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    ka_tree = this.adaptor.create(ka);
                    this.adaptor.addChild(root_0, ka_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(ka);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTStopWords15639);
                    p_StringLiteral663=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral663.getTree());





                    break;
                case 2 :
                    // xquery/XQueryParser.g:1905:11: ( LPAREN p_StringLiteral ( COMMA p_StringLiteral )* RPAREN )
                    root_0 = this.adaptor.nil();

                    // xquery/XQueryParser.g:1905:11: ( LPAREN p_StringLiteral ( COMMA p_StringLiteral )* RPAREN )
                    // xquery/XQueryParser.g:1905:12: LPAREN p_StringLiteral ( COMMA p_StringLiteral )* RPAREN
                    LPAREN664=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_FTStopWords15653); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    LPAREN664_tree = this.adaptor.create(LPAREN664);
                    this.adaptor.addChild(root_0, LPAREN664_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTStopWords15655);
                    p_StringLiteral665=this.p_StringLiteral();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral665.getTree());
                    // xquery/XQueryParser.g:1905:35: ( COMMA p_StringLiteral )*
                    loop231:
                    do {
                        var alt231=2;
                        var LA231_0 = this.input.LA(1);

                        if ( (LA231_0==COMMA) ) {
                            alt231=1;
                        }


                        switch (alt231) {
                        case 1 :
                            // xquery/XQueryParser.g:1905:36: COMMA p_StringLiteral
                            COMMA666=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_FTStopWords15658); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            COMMA666_tree = this.adaptor.create(COMMA666);
                            this.adaptor.addChild(root_0, COMMA666_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTStopWords15660);
                            p_StringLiteral667=this.p_StringLiteral();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral667.getTree());


                            break;

                        default :
                            break loop231;
                        }
                    } while (true);

                    RPAREN668=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_FTStopWords15664); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    RPAREN668_tree = this.adaptor.create(RPAREN668);
                    this.adaptor.addChild(root_0, RPAREN668_tree);
                    }





                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTStopWordsInclExcl_return: (function() {
        XQueryParser.p_FTStopWordsInclExcl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTStopWordsInclExcl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1909:1: p_FTStopWordsInclExcl : ( (k+= UNION | k+= EXCEPT ) p_FTStopWords ) ;
    // $ANTLR start "p_FTStopWordsInclExcl"
    p_FTStopWordsInclExcl: function() {
        var retval = new XQueryParser.p_FTStopWordsInclExcl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_FTStopWords669 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1910:9: ( ( (k+= UNION | k+= EXCEPT ) p_FTStopWords ) )
            // xquery/XQueryParser.g:1910:11: ( (k+= UNION | k+= EXCEPT ) p_FTStopWords )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1910:11: ( (k+= UNION | k+= EXCEPT ) p_FTStopWords )
            // xquery/XQueryParser.g:1910:13: (k+= UNION | k+= EXCEPT ) p_FTStopWords
            // xquery/XQueryParser.g:1910:13: (k+= UNION | k+= EXCEPT )
            var alt233=2;
            var LA233_0 = this.input.LA(1);

            if ( (LA233_0==UNION) ) {
                alt233=1;
            }
            else if ( (LA233_0==EXCEPT) ) {
                alt233=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 233, 0, this.input);

                throw nvae;
            }
            switch (alt233) {
                case 1 :
                    // xquery/XQueryParser.g:1910:14: k+= UNION
                    k=this.match(this.input,UNION,XQueryParser.FOLLOW_UNION_in_p_FTStopWordsInclExcl15696); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1910:25: k+= EXCEPT
                    k=this.match(this.input,EXCEPT,XQueryParser.FOLLOW_EXCEPT_in_p_FTStopWordsInclExcl15702); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_FTStopWords_in_p_FTStopWordsInclExcl15705);
            p_FTStopWords669=this.p_FTStopWords();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_FTStopWords669.getTree());



            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTLanguageOption_return: (function() {
        XQueryParser.p_FTLanguageOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTLanguageOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1914:1: p_FTLanguageOption : kl= LANGUAGE p_StringLiteral ;
    // $ANTLR start "p_FTLanguageOption"
    p_FTLanguageOption: function() {
        var retval = new XQueryParser.p_FTLanguageOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var kl = null;
         var p_StringLiteral670 = null;

        var kl_tree=null;

        try {
            // xquery/XQueryParser.g:1915:9: (kl= LANGUAGE p_StringLiteral )
            // xquery/XQueryParser.g:1915:11: kl= LANGUAGE p_StringLiteral
            root_0 = this.adaptor.nil();

            kl=this.match(this.input,LANGUAGE,XQueryParser.FOLLOW_LANGUAGE_in_p_FTLanguageOption15737); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            kl_tree = this.adaptor.create(kl);
            this.adaptor.addChild(root_0, kl_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(kl);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTLanguageOption15741);
            p_StringLiteral670=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral670.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTWildCardOption_return: (function() {
        XQueryParser.p_FTWildCardOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTWildCardOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1919:1: p_FTWildCardOption : (k+= WILDCARDS | (k+= NO k+= WILDCARDS ) ) ;
    // $ANTLR start "p_FTWildCardOption"
    p_FTWildCardOption: function() {
        var retval = new XQueryParser.p_FTWildCardOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1920:9: ( (k+= WILDCARDS | (k+= NO k+= WILDCARDS ) ) )
            // xquery/XQueryParser.g:1920:11: (k+= WILDCARDS | (k+= NO k+= WILDCARDS ) )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1920:11: (k+= WILDCARDS | (k+= NO k+= WILDCARDS ) )
            var alt234=2;
            var LA234_0 = this.input.LA(1);

            if ( (LA234_0==WILDCARDS) ) {
                alt234=1;
            }
            else if ( (LA234_0==NO) ) {
                alt234=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 234, 0, this.input);

                throw nvae;
            }
            switch (alt234) {
                case 1 :
                    // xquery/XQueryParser.g:1920:13: k+= WILDCARDS
                    k=this.match(this.input,WILDCARDS,XQueryParser.FOLLOW_WILDCARDS_in_p_FTWildCardOption15771); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);



                    break;
                case 2 :
                    // xquery/XQueryParser.g:1920:28: (k+= NO k+= WILDCARDS )
                    // xquery/XQueryParser.g:1920:28: (k+= NO k+= WILDCARDS )
                    // xquery/XQueryParser.g:1920:29: k+= NO k+= WILDCARDS
                    k=this.match(this.input,NO,XQueryParser.FOLLOW_NO_in_p_FTWildCardOption15778); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);

                    k=this.match(this.input,WILDCARDS,XQueryParser.FOLLOW_WILDCARDS_in_p_FTWildCardOption15782); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if (org.antlr.lang.isNull(list_k)) list_k = [];
                    list_k.push(k);






                    break;

            }

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTExtensionOption_return: (function() {
        XQueryParser.p_FTExtensionOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTExtensionOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1924:1: p_FTExtensionOption : ko= OPTION p_QName p_StringLiteral ;
    // $ANTLR start "p_FTExtensionOption"
    p_FTExtensionOption: function() {
        var retval = new XQueryParser.p_FTExtensionOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var ko = null;
         var p_QName671 = null;
         var p_StringLiteral672 = null;

        var ko_tree=null;

        try {
            // xquery/XQueryParser.g:1925:9: (ko= OPTION p_QName p_StringLiteral )
            // xquery/XQueryParser.g:1925:11: ko= OPTION p_QName p_StringLiteral
            root_0 = this.adaptor.nil();

            ko=this.match(this.input,OPTION,XQueryParser.FOLLOW_OPTION_in_p_FTExtensionOption15815); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            ko_tree = this.adaptor.create(ko);
            this.adaptor.addChild(root_0, ko_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(ko);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_FTExtensionOption15819);
            p_QName671=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName671.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_FTExtensionOption15821);
            p_StringLiteral672=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral672.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FTIgnoreOption_return: (function() {
        XQueryParser.p_FTIgnoreOption_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FTIgnoreOption_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1929:1: p_FTIgnoreOption : k+= WITHOUT k+= CONTENT p_UnionExpr ;
    // $ANTLR start "p_FTIgnoreOption"
    p_FTIgnoreOption: function() {
        var retval = new XQueryParser.p_FTIgnoreOption_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var list_k=null;
         var p_UnionExpr673 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:1930:9: (k+= WITHOUT k+= CONTENT p_UnionExpr )
            // xquery/XQueryParser.g:1930:11: k+= WITHOUT k+= CONTENT p_UnionExpr
            root_0 = this.adaptor.nil();

            k=this.match(this.input,WITHOUT,XQueryParser.FOLLOW_WITHOUT_in_p_FTIgnoreOption15849); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            k=this.match(this.input,CONTENT,XQueryParser.FOLLOW_CONTENT_in_p_FTIgnoreOption15853); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if (org.antlr.lang.isNull(list_k)) list_k = [];
            list_k.push(k);

            if ( this.state.backtracking===0 ) {
              this.ak(list_k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_UnionExpr_in_p_FTIgnoreOption15857);
            p_UnionExpr673=this.p_UnionExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_UnionExpr673.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Program_return: (function() {
        XQueryParser.p_Program_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Program_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1940:1: p_Program : p_StatementsAndOptionalExpr ;
    // $ANTLR start "p_Program"
    p_Program: function() {
        var retval = new XQueryParser.p_Program_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_StatementsAndOptionalExpr674 = null;


        try {
            // xquery/XQueryParser.g:1941:9: ( p_StatementsAndOptionalExpr )
            // xquery/XQueryParser.g:1941:11: p_StatementsAndOptionalExpr
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndOptionalExpr_in_p_Program15889);
            p_StatementsAndOptionalExpr674=this.p_StatementsAndOptionalExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndOptionalExpr674.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Statements_return: (function() {
        XQueryParser.p_Statements_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Statements_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1945:1: p_Statements[strict] : ( p_Hybrid[$strict,true] )* ;
    // $ANTLR start "p_Statements"
    p_Statements: function(strict) {
        var retval = new XQueryParser.p_Statements_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Hybrid675 = null;


        try {
            // xquery/XQueryParser.g:1946:9: ( ( p_Hybrid[$strict,true] )* )
            // xquery/XQueryParser.g:1946:11: ( p_Hybrid[$strict,true] )*
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:1946:11: ( p_Hybrid[$strict,true] )*
            loop235:
            do {
                var alt235=2;
                var LA235_0 = this.input.LA(1);

                if ( ((LA235_0>=ANCESTOR && LA235_0<=QUOT_ER)||LA235_0==LPAREN||(LA235_0>=DOLLAR && LA235_0<=LBRACKET)||LA235_0==ANN_PERCENT||(LA235_0>=STAR && LA235_0<=SMALLER)||(LA235_0>=SLASH && LA235_0<=DOT_DOT)||LA235_0==ATTR_SIGN||(LA235_0>=APOS && LA235_0<=QUOT)||LA235_0==L_NCName||(LA235_0>=L_Pragma && LA235_0<=L_DoubleLiteral)||LA235_0==EXPLICITLY) ) {
                    alt235=1;
                }


                switch (alt235) {
                case 1 :
                    // xquery/XQueryParser.g:1946:11: p_Hybrid[$strict,true]
                    this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_Statements15916);
                    p_Hybrid675=this.p_Hybrid(strict, true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid675.getTree());


                    break;

                default :
                    break loop235;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_StatementsAndExpr_return: (function() {
        XQueryParser.p_StatementsAndExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_StatementsAndExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1950:1: p_StatementsAndExpr : p_Statements[false] ;
    // $ANTLR start "p_StatementsAndExpr"
    p_StatementsAndExpr: function() {
        var retval = new XQueryParser.p_StatementsAndExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Statements676 = null;


        try {
            // xquery/XQueryParser.g:1951:9: ( p_Statements[false] )
            // xquery/XQueryParser.g:1951:11: p_Statements[false]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_Statements_in_p_StatementsAndExpr15944);
            p_Statements676=this.p_Statements(false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Statements676.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_StatementsAndOptionalExpr_return: (function() {
        XQueryParser.p_StatementsAndOptionalExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_StatementsAndOptionalExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1955:1: p_StatementsAndOptionalExpr : p_Statements[false] ;
    // $ANTLR start "p_StatementsAndOptionalExpr"
    p_StatementsAndOptionalExpr: function() {
        var retval = new XQueryParser.p_StatementsAndOptionalExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_Statements677 = null;


        try {
            // xquery/XQueryParser.g:1956:9: ( p_Statements[false] )
            // xquery/XQueryParser.g:1956:11: p_Statements[false]
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_Statements_in_p_StatementsAndOptionalExpr15971);
            p_Statements677=this.p_Statements(false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Statements677.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Hybrid_return: (function() {
        XQueryParser.p_Hybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Hybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1959:1: p_Hybrid[strict, allowConcat] : ( p_HybridExprSingle[$strict,$allowConcat] | p_Statement );
    // $ANTLR start "p_Hybrid"
    p_Hybrid: function(strict, allowConcat) {
        var retval = new XQueryParser.p_Hybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_HybridExprSingle678 = null;
         var p_Statement679 = null;


        try {
            // xquery/XQueryParser.g:1960:9: ( p_HybridExprSingle[$strict,$allowConcat] | p_Statement )
            var alt236=2;
            alt236 = this.dfa236.predict(this.input);
            switch (alt236) {
                case 1 :
                    // xquery/XQueryParser.g:1960:11: p_HybridExprSingle[$strict,$allowConcat]
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_HybridExprSingle_in_p_Hybrid15998);
                    p_HybridExprSingle678=this.p_HybridExprSingle(strict, allowConcat);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_HybridExprSingle678.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1961:11: p_Statement
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_Statement_in_p_Hybrid16011);
                    p_Statement679=this.p_Statement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Statement679.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {

              if(re instanceof org.antlr.runtime.RecognitionException) {
                console.log("catch3");
                var v = this.p_StepExpr();
                root_0 = this.adaptor.nil();
                this.adaptor.addChild(root_0, v.getTree());
                retval.stop = this.input.LT(-1);
                retval.tree = this.adaptor.rulePostProcessing(root_0);
                this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
              } else {
                throw re;
              }

        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_Statement_return: (function() {
        XQueryParser.p_Statement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_Statement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1977:1: p_Statement : ( p_AssignStatement | p_BreakStatement | p_ContinueStatement | p_ExitStatement | p_VarDeclStatement | p_WhileStatement );
    // $ANTLR start "p_Statement"
    p_Statement: function() {
        var retval = new XQueryParser.p_Statement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_AssignStatement680 = null;
         var p_BreakStatement681 = null;
         var p_ContinueStatement682 = null;
         var p_ExitStatement683 = null;
         var p_VarDeclStatement684 = null;
         var p_WhileStatement685 = null;


        try {
            // xquery/XQueryParser.g:1978:9: ( p_AssignStatement | p_BreakStatement | p_ContinueStatement | p_ExitStatement | p_VarDeclStatement | p_WhileStatement )
            var alt237=6;
            switch ( this.input.LA(1) ) {
            case DOLLAR:
                alt237=1;
                break;
            case BREAK:
                alt237=2;
                break;
            case CONTINUE:
                alt237=3;
                break;
            case EXIT:
                alt237=4;
                break;
            case VARIABLE:
            case ANN_PERCENT:
                alt237=5;
                break;
            case WHILE:
                alt237=6;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 237, 0, this.input);

                throw nvae;
            }

            switch (alt237) {
                case 1 :
                    // xquery/XQueryParser.g:1978:11: p_AssignStatement
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_AssignStatement_in_p_Statement16042);
                    p_AssignStatement680=this.p_AssignStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AssignStatement680.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:1979:11: p_BreakStatement
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_BreakStatement_in_p_Statement16054);
                    p_BreakStatement681=this.p_BreakStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_BreakStatement681.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:1980:11: p_ContinueStatement
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ContinueStatement_in_p_Statement16066);
                    p_ContinueStatement682=this.p_ContinueStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ContinueStatement682.getTree());


                    break;
                case 4 :
                    // xquery/XQueryParser.g:1981:11: p_ExitStatement
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_ExitStatement_in_p_Statement16078);
                    p_ExitStatement683=this.p_ExitStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExitStatement683.getTree());


                    break;
                case 5 :
                    // xquery/XQueryParser.g:1982:11: p_VarDeclStatement
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_VarDeclStatement_in_p_Statement16090);
                    p_VarDeclStatement684=this.p_VarDeclStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_VarDeclStatement684.getTree());


                    break;
                case 6 :
                    // xquery/XQueryParser.g:1983:11: p_WhileStatement
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_WhileStatement_in_p_Statement16102);
                    p_WhileStatement685=this.p_WhileStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_WhileStatement685.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_HybridExprSingle_return: (function() {
        XQueryParser.p_HybridExprSingle_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_HybridExprSingle_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:1985:1: p_HybridExprSingle[strict, allowConcat] : e= p_Expr[$strict,$allowConcat] SEMICOLON ;
    // $ANTLR start "p_HybridExprSingle"
    p_HybridExprSingle: function(strict, allowConcat) {
        var retval = new XQueryParser.p_HybridExprSingle_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SEMICOLON686 = null;
         var e = null;

        var SEMICOLON686_tree=null;

        try {
            // xquery/XQueryParser.g:1986:9: (e= p_Expr[$strict,$allowConcat] SEMICOLON )
            // xquery/XQueryParser.g:1986:11: e= p_Expr[$strict,$allowConcat] SEMICOLON
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_HybridExprSingle16129);
            e=this.p_Expr(strict, allowConcat);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, e.getTree());
            if ( this.state.backtracking===0 ) {
               if (strict || this.input.LT(1).getType() != SEMICOLON) throw new org.antlr.runtime.RecognitionException(this.input); 
            }
            SEMICOLON686=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_HybridExprSingle16144); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON686_tree = this.adaptor.create(SEMICOLON686);
            this.adaptor.addChild(root_0, SEMICOLON686_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {

                if(re instanceof org.antlr.runtime.RecognitionException) {
                  //console.log("catch4");
                  root_0 = this.adaptor.nil();
                  this.adaptor.addChild(root_0, e.getTree());
                  retval.stop = this.input.LT(-1);
                  retval.tree = this.adaptor.rulePostProcessing(root_0);
                  this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
                } else {
                  throw re;
                }

        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ApplyStatement_return: (function() {
        XQueryParser.p_ApplyStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ApplyStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2021:1: p_ApplyStatement : p_ExprSimple SEMICOLON ;
    // $ANTLR start "p_ApplyStatement"
    p_ApplyStatement: function() {
        var retval = new XQueryParser.p_ApplyStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var SEMICOLON688 = null;
         var p_ExprSimple687 = null;

        var SEMICOLON688_tree=null;

        try {
            // xquery/XQueryParser.g:2022:9: ( p_ExprSimple SEMICOLON )
            // xquery/XQueryParser.g:2022:11: p_ExprSimple SEMICOLON
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_ExprSimple_in_p_ApplyStatement16194);
            p_ExprSimple687=this.p_ExprSimple();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSimple687.getTree());
            SEMICOLON688=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_ApplyStatement16196); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON688_tree = this.adaptor.create(SEMICOLON688);
            this.adaptor.addChild(root_0, SEMICOLON688_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AssignStatement_return: (function() {
        XQueryParser.p_AssignStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AssignStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2026:1: p_AssignStatement : d= DOLLAR v= p_VarName BIND p_ExprSingle[true] SEMICOLON ;
    // $ANTLR start "p_AssignStatement"
    p_AssignStatement: function() {
        var retval = new XQueryParser.p_AssignStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
        var BIND689 = null;
        var SEMICOLON691 = null;
         var v = null;
         var p_ExprSingle690 = null;

        var d_tree=null;
        var BIND689_tree=null;
        var SEMICOLON691_tree=null;

        try {
            // xquery/XQueryParser.g:2027:9: (d= DOLLAR v= p_VarName BIND p_ExprSingle[true] SEMICOLON )
            // xquery/XQueryParser.g:2027:11: d= DOLLAR v= p_VarName BIND p_ExprSingle[true] SEMICOLON
            root_0 = this.adaptor.nil();

            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_AssignStatement16224); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_AssignStatement16228);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            BIND689=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_AssignStatement16232); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            BIND689_tree = this.adaptor.create(BIND689);
            this.adaptor.addChild(root_0, BIND689_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_AssignStatement16234);
            p_ExprSingle690=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle690.getTree());
            SEMICOLON691=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_AssignStatement16237); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON691_tree = this.adaptor.create(SEMICOLON691);
            this.adaptor.addChild(root_0, SEMICOLON691_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_BlockStatement_return: (function() {
        XQueryParser.p_BlockStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_BlockStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2031:1: p_BlockStatement : LBRACKET p_Statements[false] RBRACKET ;
    // $ANTLR start "p_BlockStatement"
    p_BlockStatement: function() {
        var retval = new XQueryParser.p_BlockStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LBRACKET692 = null;
        var RBRACKET694 = null;
         var p_Statements693 = null;

        var LBRACKET692_tree=null;
        var RBRACKET694_tree=null;

        try {
            // xquery/XQueryParser.g:2032:9: ( LBRACKET p_Statements[false] RBRACKET )
            // xquery/XQueryParser.g:2032:11: LBRACKET p_Statements[false] RBRACKET
            root_0 = this.adaptor.nil();

            LBRACKET692=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_BlockStatement16263); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET692_tree = this.adaptor.create(LBRACKET692);
            this.adaptor.addChild(root_0, LBRACKET692_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Statements_in_p_BlockStatement16265);
            p_Statements693=this.p_Statements(false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Statements693.getTree());
            RBRACKET694=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_BlockStatement16268); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET694_tree = this.adaptor.create(RBRACKET694);
            this.adaptor.addChild(root_0, RBRACKET694_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_BlockHybrid_return: (function() {
        XQueryParser.p_BlockHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_BlockHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2035:1: p_BlockHybrid[strict] : LBRACKET p_Statements[$strict] RBRACKET ;
    // $ANTLR start "p_BlockHybrid"
    p_BlockHybrid: function(strict) {
        var retval = new XQueryParser.p_BlockHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LBRACKET695 = null;
        var RBRACKET697 = null;
         var p_Statements696 = null;

        var LBRACKET695_tree=null;
        var RBRACKET697_tree=null;

        try {
            // xquery/XQueryParser.g:2036:9: ( LBRACKET p_Statements[$strict] RBRACKET )
            // xquery/XQueryParser.g:2036:11: LBRACKET p_Statements[$strict] RBRACKET
            root_0 = this.adaptor.nil();

            LBRACKET695=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_BlockHybrid16294); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET695_tree = this.adaptor.create(LBRACKET695);
            this.adaptor.addChild(root_0, LBRACKET695_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Statements_in_p_BlockHybrid16296);
            p_Statements696=this.p_Statements(strict);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Statements696.getTree());
            RBRACKET697=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_BlockHybrid16299); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET697_tree = this.adaptor.create(RBRACKET697);
            this.adaptor.addChild(root_0, RBRACKET697_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_BreakStatement_return: (function() {
        XQueryParser.p_BreakStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_BreakStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2040:1: p_BreakStatement : k= BREAK k= LOOP SEMICOLON ;
    // $ANTLR start "p_BreakStatement"
    p_BreakStatement: function() {
        var retval = new XQueryParser.p_BreakStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON698 = null;

        var k_tree=null;
        var SEMICOLON698_tree=null;

        try {
            // xquery/XQueryParser.g:2041:9: (k= BREAK k= LOOP SEMICOLON )
            // xquery/XQueryParser.g:2041:11: k= BREAK k= LOOP SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,BREAK,XQueryParser.FOLLOW_BREAK_in_p_BreakStatement16327); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,LOOP,XQueryParser.FOLLOW_LOOP_in_p_BreakStatement16333); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            SEMICOLON698=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_BreakStatement16337); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON698_tree = this.adaptor.create(SEMICOLON698);
            this.adaptor.addChild(root_0, SEMICOLON698_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ContinueStatement_return: (function() {
        XQueryParser.p_ContinueStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ContinueStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2045:1: p_ContinueStatement : k= CONTINUE k= LOOP SEMICOLON ;
    // $ANTLR start "p_ContinueStatement"
    p_ContinueStatement: function() {
        var retval = new XQueryParser.p_ContinueStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON699 = null;

        var k_tree=null;
        var SEMICOLON699_tree=null;

        try {
            // xquery/XQueryParser.g:2046:9: (k= CONTINUE k= LOOP SEMICOLON )
            // xquery/XQueryParser.g:2046:11: k= CONTINUE k= LOOP SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,CONTINUE,XQueryParser.FOLLOW_CONTINUE_in_p_ContinueStatement16365); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,LOOP,XQueryParser.FOLLOW_LOOP_in_p_ContinueStatement16371); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            SEMICOLON699=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_ContinueStatement16375); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON699_tree = this.adaptor.create(SEMICOLON699);
            this.adaptor.addChild(root_0, SEMICOLON699_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ExitStatement_return: (function() {
        XQueryParser.p_ExitStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ExitStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2050:1: p_ExitStatement : k= EXIT k= RETURNING p_ExprSingle[true] SEMICOLON ;
    // $ANTLR start "p_ExitStatement"
    p_ExitStatement: function() {
        var retval = new XQueryParser.p_ExitStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var SEMICOLON701 = null;
         var p_ExprSingle700 = null;

        var k_tree=null;
        var SEMICOLON701_tree=null;

        try {
            // xquery/XQueryParser.g:2051:9: (k= EXIT k= RETURNING p_ExprSingle[true] SEMICOLON )
            // xquery/XQueryParser.g:2051:11: k= EXIT k= RETURNING p_ExprSingle[true] SEMICOLON
            root_0 = this.adaptor.nil();

            k=this.match(this.input,EXIT,XQueryParser.FOLLOW_EXIT_in_p_ExitStatement16403); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,RETURNING,XQueryParser.FOLLOW_RETURNING_in_p_ExitStatement16409); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_ExitStatement16413);
            p_ExprSingle700=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle700.getTree());
            SEMICOLON701=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_ExitStatement16416); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON701_tree = this.adaptor.create(SEMICOLON701);
            this.adaptor.addChild(root_0, SEMICOLON701_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_FLWORStatement_return: (function() {
        XQueryParser.p_FLWORStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_FLWORStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2055:1: p_FLWORStatement : p_InitialClause ( p_IntermediateClause )* p_ReturnStatement ;
    // $ANTLR start "p_FLWORStatement"
    p_FLWORStatement: function() {
        var retval = new XQueryParser.p_FLWORStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_InitialClause702 = null;
         var p_IntermediateClause703 = null;
         var p_ReturnStatement704 = null;


        try {
            // xquery/XQueryParser.g:2056:9: ( p_InitialClause ( p_IntermediateClause )* p_ReturnStatement )
            // xquery/XQueryParser.g:2056:11: p_InitialClause ( p_IntermediateClause )* p_ReturnStatement
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_InitialClause_in_p_FLWORStatement16442);
            p_InitialClause702=this.p_InitialClause();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_InitialClause702.getTree());
            // xquery/XQueryParser.g:2056:27: ( p_IntermediateClause )*
            loop238:
            do {
                var alt238=2;
                var LA238_0 = this.input.LA(1);

                if ( (LA238_0==FOR||LA238_0==LET||LA238_0==ORDER||LA238_0==STABLE||LA238_0==WHERE||LA238_0==COUNT||LA238_0==GROUP) ) {
                    alt238=1;
                }


                switch (alt238) {
                case 1 :
                    // xquery/XQueryParser.g:2056:27: p_IntermediateClause
                    this.pushFollow(XQueryParser.FOLLOW_p_IntermediateClause_in_p_FLWORStatement16444);
                    p_IntermediateClause703=this.p_IntermediateClause();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IntermediateClause703.getTree());


                    break;

                default :
                    break loop238;
                }
            } while (true);

            this.pushFollow(XQueryParser.FOLLOW_p_ReturnStatement_in_p_FLWORStatement16447);
            p_ReturnStatement704=this.p_ReturnStatement();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ReturnStatement704.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ReturnStatement_return: (function() {
        XQueryParser.p_ReturnStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ReturnStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2060:1: p_ReturnStatement : k= RETURN p_Hybrid[false,false] ;
    // $ANTLR start "p_ReturnStatement"
    p_ReturnStatement: function() {
        var retval = new XQueryParser.p_ReturnStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_Hybrid705 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2061:9: (k= RETURN p_Hybrid[false,false] )
            // xquery/XQueryParser.g:2061:11: k= RETURN p_Hybrid[false,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_ReturnStatement16479); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_ReturnStatement16483);
            p_Hybrid705=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid705.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IfStatement_return: (function() {
        XQueryParser.p_IfStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IfStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2065:1: p_IfStatement : k= IF LPAREN p_Expr[true,true] RPAREN k= THEN p_Hybrid[false,false] k= ELSE p_Hybrid[false,false] ;
    // $ANTLR start "p_IfStatement"
    p_IfStatement: function() {
        var retval = new XQueryParser.p_IfStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LPAREN706 = null;
        var RPAREN708 = null;
         var p_Expr707 = null;
         var p_Hybrid709 = null;
         var p_Hybrid710 = null;

        var k_tree=null;
        var LPAREN706_tree=null;
        var RPAREN708_tree=null;

        try {
            // xquery/XQueryParser.g:2066:9: (k= IF LPAREN p_Expr[true,true] RPAREN k= THEN p_Hybrid[false,false] k= ELSE p_Hybrid[false,false] )
            // xquery/XQueryParser.g:2066:11: k= IF LPAREN p_Expr[true,true] RPAREN k= THEN p_Hybrid[false,false] k= ELSE p_Hybrid[false,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,IF,XQueryParser.FOLLOW_IF_in_p_IfStatement16512); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LPAREN706=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_IfStatement16516); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN706_tree = this.adaptor.create(LPAREN706);
            this.adaptor.addChild(root_0, LPAREN706_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_IfStatement16518);
            p_Expr707=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr707.getTree());
            RPAREN708=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_IfStatement16521); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN708_tree = this.adaptor.create(RPAREN708);
            this.adaptor.addChild(root_0, RPAREN708_tree);
            }
            k=this.match(this.input,THEN,XQueryParser.FOLLOW_THEN_in_p_IfStatement16525); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_IfStatement16529);
            p_Hybrid709=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid709.getTree());
            k=this.match(this.input,ELSE,XQueryParser.FOLLOW_ELSE_in_p_IfStatement16534); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_IfStatement16538);
            p_Hybrid710=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid710.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SwitchStatement_return: (function() {
        XQueryParser.p_SwitchStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SwitchStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2070:1: p_SwitchStatement : k= SWITCH LPAREN p_Expr[true,true] RPAREN ( p_SwitchCaseStatement )+ k= DEFAULT k= RETURN p_Hybrid[false,false] ;
    // $ANTLR start "p_SwitchStatement"
    p_SwitchStatement: function() {
        var retval = new XQueryParser.p_SwitchStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LPAREN711 = null;
        var RPAREN713 = null;
         var p_Expr712 = null;
         var p_SwitchCaseStatement714 = null;
         var p_Hybrid715 = null;

        var k_tree=null;
        var LPAREN711_tree=null;
        var RPAREN713_tree=null;

        try {
            // xquery/XQueryParser.g:2071:9: (k= SWITCH LPAREN p_Expr[true,true] RPAREN ( p_SwitchCaseStatement )+ k= DEFAULT k= RETURN p_Hybrid[false,false] )
            // xquery/XQueryParser.g:2071:11: k= SWITCH LPAREN p_Expr[true,true] RPAREN ( p_SwitchCaseStatement )+ k= DEFAULT k= RETURN p_Hybrid[false,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,SWITCH,XQueryParser.FOLLOW_SWITCH_in_p_SwitchStatement16567); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LPAREN711=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_SwitchStatement16571); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN711_tree = this.adaptor.create(LPAREN711);
            this.adaptor.addChild(root_0, LPAREN711_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_SwitchStatement16573);
            p_Expr712=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr712.getTree());
            RPAREN713=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_SwitchStatement16576); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN713_tree = this.adaptor.create(RPAREN713);
            this.adaptor.addChild(root_0, RPAREN713_tree);
            }
            // xquery/XQueryParser.g:2071:67: ( p_SwitchCaseStatement )+
            var cnt239=0;
            loop239:
            do {
                var alt239=2;
                var LA239_0 = this.input.LA(1);

                if ( (LA239_0==CASE) ) {
                    alt239=1;
                }


                switch (alt239) {
                case 1 :
                    // xquery/XQueryParser.g:2071:67: p_SwitchCaseStatement
                    this.pushFollow(XQueryParser.FOLLOW_p_SwitchCaseStatement_in_p_SwitchStatement16578);
                    p_SwitchCaseStatement714=this.p_SwitchCaseStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SwitchCaseStatement714.getTree());


                    break;

                default :
                    if ( cnt239 >= 1 ) {
                        break loop239;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(239, this.input);
                        throw eee;
                }
                cnt239++;
            } while (true);

            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_SwitchStatement16583); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_SwitchStatement16589); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_SwitchStatement16593);
            p_Hybrid715=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid715.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_SwitchCaseStatement_return: (function() {
        XQueryParser.p_SwitchCaseStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_SwitchCaseStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2075:1: p_SwitchCaseStatement : (k= CASE p_SwitchCaseOperand )+ k= RETURN p_Hybrid[false,false] ;
    // $ANTLR start "p_SwitchCaseStatement"
    p_SwitchCaseStatement: function() {
        var retval = new XQueryParser.p_SwitchCaseStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_SwitchCaseOperand716 = null;
         var p_Hybrid717 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2076:9: ( (k= CASE p_SwitchCaseOperand )+ k= RETURN p_Hybrid[false,false] )
            // xquery/XQueryParser.g:2076:11: (k= CASE p_SwitchCaseOperand )+ k= RETURN p_Hybrid[false,false]
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:2076:11: (k= CASE p_SwitchCaseOperand )+
            var cnt240=0;
            loop240:
            do {
                var alt240=2;
                var LA240_0 = this.input.LA(1);

                if ( (LA240_0==CASE) ) {
                    alt240=1;
                }


                switch (alt240) {
                case 1 :
                    // xquery/XQueryParser.g:2076:12: k= CASE p_SwitchCaseOperand
                    k=this.match(this.input,CASE,XQueryParser.FOLLOW_CASE_in_p_SwitchCaseStatement16623); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_SwitchCaseOperand_in_p_SwitchCaseStatement16627);
                    p_SwitchCaseOperand716=this.p_SwitchCaseOperand();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SwitchCaseOperand716.getTree());


                    break;

                default :
                    if ( cnt240 >= 1 ) {
                        break loop240;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(240, this.input);
                        throw eee;
                }
                cnt240++;
            } while (true);

            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_SwitchCaseStatement16633); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_SwitchCaseStatement16637);
            p_Hybrid717=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid717.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TryCatchStatement_return: (function() {
        XQueryParser.p_TryCatchStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TryCatchStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2080:1: p_TryCatchStatement : k= TRY p_BlockStatement (k= CATCH p_CatchErrorList p_BlockStatement )+ ;
    // $ANTLR start "p_TryCatchStatement"
    p_TryCatchStatement: function() {
        var retval = new XQueryParser.p_TryCatchStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_BlockStatement718 = null;
         var p_CatchErrorList719 = null;
         var p_BlockStatement720 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2081:9: (k= TRY p_BlockStatement (k= CATCH p_CatchErrorList p_BlockStatement )+ )
            // xquery/XQueryParser.g:2081:11: k= TRY p_BlockStatement (k= CATCH p_CatchErrorList p_BlockStatement )+
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TRY,XQueryParser.FOLLOW_TRY_in_p_TryCatchStatement16666); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_BlockStatement_in_p_TryCatchStatement16670);
            p_BlockStatement718=this.p_BlockStatement();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_BlockStatement718.getTree());
            // xquery/XQueryParser.g:2081:49: (k= CATCH p_CatchErrorList p_BlockStatement )+
            var cnt241=0;
            loop241:
            do {
                var alt241=2;
                var LA241_0 = this.input.LA(1);

                if ( (LA241_0==CATCH) ) {
                    alt241=1;
                }


                switch (alt241) {
                case 1 :
                    // xquery/XQueryParser.g:2081:50: k= CATCH p_CatchErrorList p_BlockStatement
                    k=this.match(this.input,CATCH,XQueryParser.FOLLOW_CATCH_in_p_TryCatchStatement16675); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_CatchErrorList_in_p_TryCatchStatement16679);
                    p_CatchErrorList719=this.p_CatchErrorList();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CatchErrorList719.getTree());
                    this.pushFollow(XQueryParser.FOLLOW_p_BlockStatement_in_p_TryCatchStatement16681);
                    p_BlockStatement720=this.p_BlockStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_BlockStatement720.getTree());


                    break;

                default :
                    if ( cnt241 >= 1 ) {
                        break loop241;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(241, this.input);
                        throw eee;
                }
                cnt241++;
            } while (true);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TryCatchHybrid_return: (function() {
        XQueryParser.p_TryCatchHybrid_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TryCatchHybrid_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2084:1: p_TryCatchHybrid[strict] : k= TRY p_BlockHybrid[$strict] (k= CATCH p_CatchErrorList p_BlockHybrid[$strict] )+ ;
    // $ANTLR start "p_TryCatchHybrid"
    p_TryCatchHybrid: function(strict) {
        var retval = new XQueryParser.p_TryCatchHybrid_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_BlockHybrid721 = null;
         var p_CatchErrorList722 = null;
         var p_BlockHybrid723 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2085:9: (k= TRY p_BlockHybrid[$strict] (k= CATCH p_CatchErrorList p_BlockHybrid[$strict] )+ )
            // xquery/XQueryParser.g:2085:11: k= TRY p_BlockHybrid[$strict] (k= CATCH p_CatchErrorList p_BlockHybrid[$strict] )+
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TRY,XQueryParser.FOLLOW_TRY_in_p_TryCatchHybrid16713); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_BlockHybrid_in_p_TryCatchHybrid16717);
            p_BlockHybrid721=this.p_BlockHybrid(strict);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_BlockHybrid721.getTree());
            // xquery/XQueryParser.g:2085:55: (k= CATCH p_CatchErrorList p_BlockHybrid[$strict] )+
            var cnt242=0;
            loop242:
            do {
                var alt242=2;
                var LA242_0 = this.input.LA(1);

                if ( (LA242_0==CATCH) ) {
                    alt242=1;
                }


                switch (alt242) {
                case 1 :
                    // xquery/XQueryParser.g:2085:56: k= CATCH p_CatchErrorList p_BlockHybrid[$strict]
                    k=this.match(this.input,CATCH,XQueryParser.FOLLOW_CATCH_in_p_TryCatchHybrid16723); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    k_tree = this.adaptor.create(k);
                    this.adaptor.addChild(root_0, k_tree);
                    }
                    if ( this.state.backtracking===0 ) {
                      this.ak(k);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_CatchErrorList_in_p_TryCatchHybrid16727);
                    p_CatchErrorList722=this.p_CatchErrorList();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CatchErrorList722.getTree());
                    this.pushFollow(XQueryParser.FOLLOW_p_BlockHybrid_in_p_TryCatchHybrid16729);
                    p_BlockHybrid723=this.p_BlockHybrid(strict);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_BlockHybrid723.getTree());


                    break;

                default :
                    if ( cnt242 >= 1 ) {
                        break loop242;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(242, this.input);
                        throw eee;
                }
                cnt242++;
            } while (true);

            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_TypeswitchStatement_return: (function() {
        XQueryParser.p_TypeswitchStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_TypeswitchStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2089:1: p_TypeswitchStatement : k= TYPESWITCH LPAREN p_Expr[true,true] RPAREN ( p_CaseStatement )+ k= DEFAULT (d= DOLLAR v= p_VarName )? k= RETURN p_Hybrid[false,false] ;
    // $ANTLR start "p_TypeswitchStatement"
    p_TypeswitchStatement: function() {
        var retval = new XQueryParser.p_TypeswitchStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
        var LPAREN724 = null;
        var RPAREN726 = null;
         var v = null;
         var p_Expr725 = null;
         var p_CaseStatement727 = null;
         var p_Hybrid728 = null;

        var k_tree=null;
        var d_tree=null;
        var LPAREN724_tree=null;
        var RPAREN726_tree=null;

        try {
            // xquery/XQueryParser.g:2090:9: (k= TYPESWITCH LPAREN p_Expr[true,true] RPAREN ( p_CaseStatement )+ k= DEFAULT (d= DOLLAR v= p_VarName )? k= RETURN p_Hybrid[false,false] )
            // xquery/XQueryParser.g:2090:11: k= TYPESWITCH LPAREN p_Expr[true,true] RPAREN ( p_CaseStatement )+ k= DEFAULT (d= DOLLAR v= p_VarName )? k= RETURN p_Hybrid[false,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TYPESWITCH,XQueryParser.FOLLOW_TYPESWITCH_in_p_TypeswitchStatement16762); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LPAREN724=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_TypeswitchStatement16766); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN724_tree = this.adaptor.create(LPAREN724);
            this.adaptor.addChild(root_0, LPAREN724_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_TypeswitchStatement16768);
            p_Expr725=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr725.getTree());
            RPAREN726=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_TypeswitchStatement16771); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN726_tree = this.adaptor.create(RPAREN726);
            this.adaptor.addChild(root_0, RPAREN726_tree);
            }
            // xquery/XQueryParser.g:2090:71: ( p_CaseStatement )+
            var cnt243=0;
            loop243:
            do {
                var alt243=2;
                var LA243_0 = this.input.LA(1);

                if ( (LA243_0==CASE) ) {
                    alt243=1;
                }


                switch (alt243) {
                case 1 :
                    // xquery/XQueryParser.g:2090:71: p_CaseStatement
                    this.pushFollow(XQueryParser.FOLLOW_p_CaseStatement_in_p_TypeswitchStatement16773);
                    p_CaseStatement727=this.p_CaseStatement();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CaseStatement727.getTree());


                    break;

                default :
                    if ( cnt243 >= 1 ) {
                        break loop243;
                    }
                    if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        var eee = new org.antlr.runtime.EarlyExitException(243, this.input);
                        throw eee;
                }
                cnt243++;
            } while (true);

            k=this.match(this.input,DEFAULT,XQueryParser.FOLLOW_DEFAULT_in_p_TypeswitchStatement16778); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:2090:113: (d= DOLLAR v= p_VarName )?
            var alt244=2;
            var LA244_0 = this.input.LA(1);

            if ( (LA244_0==DOLLAR) ) {
                alt244=1;
            }
            switch (alt244) {
                case 1 :
                    // xquery/XQueryParser.g:2090:114: d= DOLLAR v= p_VarName
                    d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_TypeswitchStatement16785); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_TypeswitchStatement16789);
                    v=this.p_VarName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
                    if ( this.state.backtracking===0 ) {
                       this.av(d, (v?v.stop:null)); 
                    }


                    break;

            }

            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_TypeswitchStatement16797); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_TypeswitchStatement16801);
            p_Hybrid728=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid728.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CaseStatement_return: (function() {
        XQueryParser.p_CaseStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CaseStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2094:1: p_CaseStatement : k= CASE (d= DOLLAR v= p_VarName AS )? p_SequenceType k= RETURN p_Hybrid[false,false] ;
    // $ANTLR start "p_CaseStatement"
    p_CaseStatement: function() {
        var retval = new XQueryParser.p_CaseStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
        var AS729 = null;
         var v = null;
         var p_SequenceType730 = null;
         var p_Hybrid731 = null;

        var k_tree=null;
        var d_tree=null;
        var AS729_tree=null;

        try {
            // xquery/XQueryParser.g:2095:9: (k= CASE (d= DOLLAR v= p_VarName AS )? p_SequenceType k= RETURN p_Hybrid[false,false] )
            // xquery/XQueryParser.g:2095:11: k= CASE (d= DOLLAR v= p_VarName AS )? p_SequenceType k= RETURN p_Hybrid[false,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,CASE,XQueryParser.FOLLOW_CASE_in_p_CaseStatement16830); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            // xquery/XQueryParser.g:2095:33: (d= DOLLAR v= p_VarName AS )?
            var alt245=2;
            var LA245_0 = this.input.LA(1);

            if ( (LA245_0==DOLLAR) ) {
                alt245=1;
            }
            switch (alt245) {
                case 1 :
                    // xquery/XQueryParser.g:2095:34: d= DOLLAR v= p_VarName AS
                    d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_CaseStatement16837); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    d_tree = this.adaptor.create(d);
                    this.adaptor.addChild(root_0, d_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_CaseStatement16841);
                    v=this.p_VarName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
                    if ( this.state.backtracking===0 ) {
                       this.av(d, (v?v.stop:null)); 
                    }
                    AS729=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_CaseStatement16845); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    AS729_tree = this.adaptor.create(AS729);
                    this.adaptor.addChild(root_0, AS729_tree);
                    }


                    break;

            }

            this.pushFollow(XQueryParser.FOLLOW_p_SequenceType_in_p_CaseStatement16849);
            p_SequenceType730=this.p_SequenceType();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_SequenceType730.getTree());
            k=this.match(this.input,RETURN,XQueryParser.FOLLOW_RETURN_in_p_CaseStatement16853); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_CaseStatement16857);
            p_Hybrid731=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid731.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_VarDeclStatement_return: (function() {
        XQueryParser.p_VarDeclStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_VarDeclStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2099:1: p_VarDeclStatement : ( p_Annotation )* k= VARIABLE d= DOLLAR v= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )? ( COMMA e= DOLLAR w= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )? )* SEMICOLON ;
    // $ANTLR start "p_VarDeclStatement"
    p_VarDeclStatement: function() {
        var retval = new XQueryParser.p_VarDeclStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
        var e = null;
        var BIND734 = null;
        var COMMA736 = null;
        var BIND738 = null;
        var SEMICOLON740 = null;
         var v = null;
         var w = null;
         var p_Annotation732 = null;
         var p_TypeDeclaration733 = null;
         var p_ExprSingle735 = null;
         var p_TypeDeclaration737 = null;
         var p_ExprSingle739 = null;

        var k_tree=null;
        var d_tree=null;
        var e_tree=null;
        var BIND734_tree=null;
        var COMMA736_tree=null;
        var BIND738_tree=null;
        var SEMICOLON740_tree=null;

        try {
            // xquery/XQueryParser.g:2100:9: ( ( p_Annotation )* k= VARIABLE d= DOLLAR v= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )? ( COMMA e= DOLLAR w= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )? )* SEMICOLON )
            // xquery/XQueryParser.g:2100:11: ( p_Annotation )* k= VARIABLE d= DOLLAR v= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )? ( COMMA e= DOLLAR w= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )? )* SEMICOLON
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:2100:11: ( p_Annotation )*
            loop246:
            do {
                var alt246=2;
                var LA246_0 = this.input.LA(1);

                if ( (LA246_0==ANN_PERCENT) ) {
                    alt246=1;
                }


                switch (alt246) {
                case 1 :
                    // xquery/XQueryParser.g:2100:11: p_Annotation
                    this.pushFollow(XQueryParser.FOLLOW_p_Annotation_in_p_VarDeclStatement16884);
                    p_Annotation732=this.p_Annotation();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Annotation732.getTree());


                    break;

                default :
                    break loop246;
                }
            } while (true);

            k=this.match(this.input,VARIABLE,XQueryParser.FOLLOW_VARIABLE_in_p_VarDeclStatement16889); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_VarDeclStatement16895); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_VarDeclStatement16899);
            v=this.p_VarName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            // xquery/XQueryParser.g:2100:98: ( p_TypeDeclaration )?
            var alt247=2;
            var LA247_0 = this.input.LA(1);

            if ( (LA247_0==AS) ) {
                alt247=1;
            }
            switch (alt247) {
                case 1 :
                    // xquery/XQueryParser.g:2100:98: p_TypeDeclaration
                    this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_VarDeclStatement16903);
                    p_TypeDeclaration733=this.p_TypeDeclaration();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration733.getTree());


                    break;

            }

            // xquery/XQueryParser.g:2100:117: ( BIND p_ExprSingle[true] )?
            var alt248=2;
            var LA248_0 = this.input.LA(1);

            if ( (LA248_0==BIND) ) {
                alt248=1;
            }
            switch (alt248) {
                case 1 :
                    // xquery/XQueryParser.g:2100:118: BIND p_ExprSingle[true]
                    BIND734=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_VarDeclStatement16907); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    BIND734_tree = this.adaptor.create(BIND734);
                    this.adaptor.addChild(root_0, BIND734_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_VarDeclStatement16909);
                    p_ExprSingle735=this.p_ExprSingle(true);

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle735.getTree());


                    break;

            }

            // xquery/XQueryParser.g:2101:11: ( COMMA e= DOLLAR w= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )? )*
            loop251:
            do {
                var alt251=2;
                var LA251_0 = this.input.LA(1);

                if ( (LA251_0==COMMA) ) {
                    alt251=1;
                }


                switch (alt251) {
                case 1 :
                    // xquery/XQueryParser.g:2101:12: COMMA e= DOLLAR w= p_VarName ( p_TypeDeclaration )? ( BIND p_ExprSingle[true] )?
                    COMMA736=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_VarDeclStatement16925); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA736_tree = this.adaptor.create(COMMA736);
                    this.adaptor.addChild(root_0, COMMA736_tree);
                    }
                    e=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_VarDeclStatement16929); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    e_tree = this.adaptor.create(e);
                    this.adaptor.addChild(root_0, e_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_VarName_in_p_VarDeclStatement16933);
                    w=this.p_VarName();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, w.getTree());
                    if ( this.state.backtracking===0 ) {
                       this.av(e, (w?w.stop:null)); 
                    }
                    // xquery/XQueryParser.g:2101:65: ( p_TypeDeclaration )?
                    var alt249=2;
                    var LA249_0 = this.input.LA(1);

                    if ( (LA249_0==AS) ) {
                        alt249=1;
                    }
                    switch (alt249) {
                        case 1 :
                            // xquery/XQueryParser.g:2101:65: p_TypeDeclaration
                            this.pushFollow(XQueryParser.FOLLOW_p_TypeDeclaration_in_p_VarDeclStatement16937);
                            p_TypeDeclaration737=this.p_TypeDeclaration();

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_TypeDeclaration737.getTree());


                            break;

                    }

                    // xquery/XQueryParser.g:2101:84: ( BIND p_ExprSingle[true] )?
                    var alt250=2;
                    var LA250_0 = this.input.LA(1);

                    if ( (LA250_0==BIND) ) {
                        alt250=1;
                    }
                    switch (alt250) {
                        case 1 :
                            // xquery/XQueryParser.g:2101:85: BIND p_ExprSingle[true]
                            BIND738=this.match(this.input,BIND,XQueryParser.FOLLOW_BIND_in_p_VarDeclStatement16941); if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) {
                            BIND738_tree = this.adaptor.create(BIND738);
                            this.adaptor.addChild(root_0, BIND738_tree);
                            }
                            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_VarDeclStatement16943);
                            p_ExprSingle739=this.p_ExprSingle(true);

                            this.state._fsp--;
                            if (this.state.failed) return retval;
                            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle739.getTree());


                            break;

                    }



                    break;

                default :
                    break loop251;
                }
            } while (true);

            SEMICOLON740=this.match(this.input,SEMICOLON,XQueryParser.FOLLOW_SEMICOLON_in_p_VarDeclStatement16960); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            SEMICOLON740_tree = this.adaptor.create(SEMICOLON740);
            this.adaptor.addChild(root_0, SEMICOLON740_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_WhileStatement_return: (function() {
        XQueryParser.p_WhileStatement_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_WhileStatement_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2106:1: p_WhileStatement : k= WHILE LPAREN p_Expr[true,true] RPAREN p_Hybrid[false,false] ;
    // $ANTLR start "p_WhileStatement"
    p_WhileStatement: function() {
        var retval = new XQueryParser.p_WhileStatement_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var LPAREN741 = null;
        var RPAREN743 = null;
         var p_Expr742 = null;
         var p_Hybrid744 = null;

        var k_tree=null;
        var LPAREN741_tree=null;
        var RPAREN743_tree=null;

        try {
            // xquery/XQueryParser.g:2107:9: (k= WHILE LPAREN p_Expr[true,true] RPAREN p_Hybrid[false,false] )
            // xquery/XQueryParser.g:2107:11: k= WHILE LPAREN p_Expr[true,true] RPAREN p_Hybrid[false,false]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,WHILE,XQueryParser.FOLLOW_WHILE_in_p_WhileStatement16988); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            LPAREN741=this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_p_WhileStatement16992); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LPAREN741_tree = this.adaptor.create(LPAREN741);
            this.adaptor.addChild(root_0, LPAREN741_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Expr_in_p_WhileStatement16994);
            p_Expr742=this.p_Expr(true, true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Expr742.getTree());
            RPAREN743=this.match(this.input,RPAREN,XQueryParser.FOLLOW_RPAREN_in_p_WhileStatement16997); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RPAREN743_tree = this.adaptor.create(RPAREN743);
            this.adaptor.addChild(root_0, RPAREN743_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_Hybrid_in_p_WhileStatement16999);
            p_Hybrid744=this.p_Hybrid(false, false);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_Hybrid744.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ExprSimple_return: (function() {
        XQueryParser.p_ExprSimple_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ExprSimple_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2111:1: p_ExprSimple : ( p_QuantifiedExpr | p_OrExpr | {...}? => pg_UpdateExpr );
    // $ANTLR start "p_ExprSimple"
    p_ExprSimple: function() {
        var retval = new XQueryParser.p_ExprSimple_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QuantifiedExpr745 = null;
         var p_OrExpr746 = null;
         var pg_UpdateExpr747 = null;


        try {
            // xquery/XQueryParser.g:2112:9: ( p_QuantifiedExpr | p_OrExpr | {...}? => pg_UpdateExpr )
            var alt252=3;
            alt252 = this.dfa252.predict(this.input);
            switch (alt252) {
                case 1 :
                    // xquery/XQueryParser.g:2112:11: p_QuantifiedExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_QuantifiedExpr_in_p_ExprSimple17026);
                    p_QuantifiedExpr745=this.p_QuantifiedExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QuantifiedExpr745.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:2113:11: p_OrExpr
                    root_0 = this.adaptor.nil();

                    this.pushFollow(XQueryParser.FOLLOW_p_OrExpr_in_p_ExprSimple17038);
                    p_OrExpr746=this.p_OrExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OrExpr746.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:2114:11: {...}? => pg_UpdateExpr
                    root_0 = this.adaptor.nil();

                    if ( !((this.lc(XQU))) ) {
                        if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "p_ExprSimple", "this.lc(XQU)");
                    }
                    this.pushFollow(XQueryParser.FOLLOW_pg_UpdateExpr_in_p_ExprSimple17053);
                    pg_UpdateExpr747=this.pg_UpdateExpr();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, pg_UpdateExpr747.getTree());


                    break;

            }
            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_BlockExpr_return: (function() {
        XQueryParser.p_BlockExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_BlockExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2118:1: p_BlockExpr : LBRACKET p_StatementsAndExpr RBRACKET ;
    // $ANTLR start "p_BlockExpr"
    p_BlockExpr: function() {
        var retval = new XQueryParser.p_BlockExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var LBRACKET748 = null;
        var RBRACKET750 = null;
         var p_StatementsAndExpr749 = null;

        var LBRACKET748_tree=null;
        var RBRACKET750_tree=null;

        try {
            // xquery/XQueryParser.g:2119:9: ( LBRACKET p_StatementsAndExpr RBRACKET )
            // xquery/XQueryParser.g:2119:11: LBRACKET p_StatementsAndExpr RBRACKET
            root_0 = this.adaptor.nil();

            LBRACKET748=this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_p_BlockExpr17079); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            LBRACKET748_tree = this.adaptor.create(LBRACKET748);
            this.adaptor.addChild(root_0, LBRACKET748_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StatementsAndExpr_in_p_BlockExpr17081);
            p_StatementsAndExpr749=this.p_StatementsAndExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StatementsAndExpr749.getTree());
            RBRACKET750=this.match(this.input,RBRACKET,XQueryParser.FOLLOW_RBRACKET_in_p_BlockExpr17083); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            RBRACKET750_tree = this.adaptor.create(RBRACKET750);
            this.adaptor.addChild(root_0, RBRACKET750_tree);
            }



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CollectionDecl_return: (function() {
        XQueryParser.p_CollectionDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CollectionDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2126:1: p_CollectionDecl : k= COLLECTION p_QName ( p_CollectionTypeDecl )? ;
    // $ANTLR start "p_CollectionDecl"
    p_CollectionDecl: function() {
        var retval = new XQueryParser.p_CollectionDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_QName751 = null;
         var p_CollectionTypeDecl752 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2127:9: (k= COLLECTION p_QName ( p_CollectionTypeDecl )? )
            // xquery/XQueryParser.g:2127:11: k= COLLECTION p_QName ( p_CollectionTypeDecl )?
            root_0 = this.adaptor.nil();

            k=this.match(this.input,COLLECTION,XQueryParser.FOLLOW_COLLECTION_in_p_CollectionDecl17114); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_CollectionDecl17118);
            p_QName751=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName751.getTree());
            // xquery/XQueryParser.g:2127:47: ( p_CollectionTypeDecl )?
            var alt253=2;
            var LA253_0 = this.input.LA(1);

            if ( (LA253_0==AS) ) {
                alt253=1;
            }
            switch (alt253) {
                case 1 :
                    // xquery/XQueryParser.g:2127:47: p_CollectionTypeDecl
                    this.pushFollow(XQueryParser.FOLLOW_p_CollectionTypeDecl_in_p_CollectionDecl17120);
                    p_CollectionTypeDecl752=this.p_CollectionTypeDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_CollectionTypeDecl752.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_CollectionTypeDecl_return: (function() {
        XQueryParser.p_CollectionTypeDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_CollectionTypeDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2130:1: p_CollectionTypeDecl : (k= AS p_KindTest ( ( p_OccurrenceIndicator )=> p_OccurrenceIndicator )? ) ;
    // $ANTLR start "p_CollectionTypeDecl"
    p_CollectionTypeDecl: function() {
        var retval = new XQueryParser.p_CollectionTypeDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_KindTest753 = null;
         var p_OccurrenceIndicator754 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2131:9: ( (k= AS p_KindTest ( ( p_OccurrenceIndicator )=> p_OccurrenceIndicator )? ) )
            // xquery/XQueryParser.g:2131:11: (k= AS p_KindTest ( ( p_OccurrenceIndicator )=> p_OccurrenceIndicator )? )
            root_0 = this.adaptor.nil();

            // xquery/XQueryParser.g:2131:11: (k= AS p_KindTest ( ( p_OccurrenceIndicator )=> p_OccurrenceIndicator )? )
            // xquery/XQueryParser.g:2131:12: k= AS p_KindTest ( ( p_OccurrenceIndicator )=> p_OccurrenceIndicator )?
            k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_CollectionTypeDecl17149); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_KindTest_in_p_CollectionTypeDecl17153);
            p_KindTest753=this.p_KindTest();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_KindTest753.getTree());
            // xquery/XQueryParser.g:2131:43: ( ( p_OccurrenceIndicator )=> p_OccurrenceIndicator )?
            var alt254=2;
            var LA254_0 = this.input.LA(1);

            if ( ((LA254_0>=QUESTION && LA254_0<=PLUS)) && (this.synpred18_XQueryParser())) {
                alt254=1;
            }
            switch (alt254) {
                case 1 :
                    // xquery/XQueryParser.g:2131:44: ( p_OccurrenceIndicator )=> p_OccurrenceIndicator
                    this.pushFollow(XQueryParser.FOLLOW_p_OccurrenceIndicator_in_p_CollectionTypeDecl17162);
                    p_OccurrenceIndicator754=this.p_OccurrenceIndicator();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OccurrenceIndicator754.getTree());


                    break;

            }







            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IndexDecl_return: (function() {
        XQueryParser.p_IndexDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IndexDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2134:1: p_IndexDecl : k= INDEX p_IndexName k= ON k= NODES p_IndexDomainExpr k= BY p_IndexKeySpec ( COMMA p_IndexKeySpec )* ;
    // $ANTLR start "p_IndexDecl"
    p_IndexDecl: function() {
        var retval = new XQueryParser.p_IndexDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var COMMA758 = null;
         var p_IndexName755 = null;
         var p_IndexDomainExpr756 = null;
         var p_IndexKeySpec757 = null;
         var p_IndexKeySpec759 = null;

        var k_tree=null;
        var COMMA758_tree=null;

        try {
            // xquery/XQueryParser.g:2135:9: (k= INDEX p_IndexName k= ON k= NODES p_IndexDomainExpr k= BY p_IndexKeySpec ( COMMA p_IndexKeySpec )* )
            // xquery/XQueryParser.g:2135:11: k= INDEX p_IndexName k= ON k= NODES p_IndexDomainExpr k= BY p_IndexKeySpec ( COMMA p_IndexKeySpec )*
            root_0 = this.adaptor.nil();

            k=this.match(this.input,INDEX,XQueryParser.FOLLOW_INDEX_in_p_IndexDecl17192); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_IndexName_in_p_IndexDecl17196);
            p_IndexName755=this.p_IndexName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexName755.getTree());
            k=this.match(this.input,ON,XQueryParser.FOLLOW_ON_in_p_IndexDecl17200); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,NODES,XQueryParser.FOLLOW_NODES_in_p_IndexDecl17206); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_IndexDomainExpr_in_p_IndexDecl17210);
            p_IndexDomainExpr756=this.p_IndexDomainExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexDomainExpr756.getTree());
            k=this.match(this.input,BY,XQueryParser.FOLLOW_BY_in_p_IndexDecl17214); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_IndexKeySpec_in_p_IndexDecl17218);
            p_IndexKeySpec757=this.p_IndexKeySpec();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexKeySpec757.getTree());
            // xquery/XQueryParser.g:2135:142: ( COMMA p_IndexKeySpec )*
            loop255:
            do {
                var alt255=2;
                var LA255_0 = this.input.LA(1);

                if ( (LA255_0==COMMA) ) {
                    alt255=1;
                }


                switch (alt255) {
                case 1 :
                    // xquery/XQueryParser.g:2135:143: COMMA p_IndexKeySpec
                    COMMA758=this.match(this.input,COMMA,XQueryParser.FOLLOW_COMMA_in_p_IndexDecl17221); if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) {
                    COMMA758_tree = this.adaptor.create(COMMA758);
                    this.adaptor.addChild(root_0, COMMA758_tree);
                    }
                    this.pushFollow(XQueryParser.FOLLOW_p_IndexKeySpec_in_p_IndexDecl17223);
                    p_IndexKeySpec759=this.p_IndexKeySpec();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexKeySpec759.getTree());


                    break;

                default :
                    break loop255;
                }
            } while (true);




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IndexName_return: (function() {
        XQueryParser.p_IndexName_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IndexName_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2138:1: p_IndexName : p_QName ;
    // $ANTLR start "p_IndexName"
    p_IndexName: function() {
        var retval = new XQueryParser.p_IndexName_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName760 = null;


        try {
            // xquery/XQueryParser.g:2139:9: ( p_QName )
            // xquery/XQueryParser.g:2139:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_IndexName17250);
            p_QName760=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName760.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IndexDomainExpr_return: (function() {
        XQueryParser.p_IndexDomainExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IndexDomainExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2142:1: p_IndexDomainExpr : p_PathExpr ;
    // $ANTLR start "p_IndexDomainExpr"
    p_IndexDomainExpr: function() {
        var retval = new XQueryParser.p_IndexDomainExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_PathExpr761 = null;


        try {
            // xquery/XQueryParser.g:2143:9: ( p_PathExpr )
            // xquery/XQueryParser.g:2143:11: p_PathExpr
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_PathExpr_in_p_IndexDomainExpr17275);
            p_PathExpr761=this.p_PathExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PathExpr761.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IndexKeySpec_return: (function() {
        XQueryParser.p_IndexKeySpec_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IndexKeySpec_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2146:1: p_IndexKeySpec : p_IndexKeyExpr ( p_IndexKeyTypeDecl )? ( p_IndexKeyCollation )? ;
    // $ANTLR start "p_IndexKeySpec"
    p_IndexKeySpec: function() {
        var retval = new XQueryParser.p_IndexKeySpec_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_IndexKeyExpr762 = null;
         var p_IndexKeyTypeDecl763 = null;
         var p_IndexKeyCollation764 = null;


        try {
            // xquery/XQueryParser.g:2147:9: ( p_IndexKeyExpr ( p_IndexKeyTypeDecl )? ( p_IndexKeyCollation )? )
            // xquery/XQueryParser.g:2147:11: p_IndexKeyExpr ( p_IndexKeyTypeDecl )? ( p_IndexKeyCollation )?
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_IndexKeyExpr_in_p_IndexKeySpec17300);
            p_IndexKeyExpr762=this.p_IndexKeyExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexKeyExpr762.getTree());
            // xquery/XQueryParser.g:2147:26: ( p_IndexKeyTypeDecl )?
            var alt256=2;
            var LA256_0 = this.input.LA(1);

            if ( (LA256_0==AS) ) {
                alt256=1;
            }
            switch (alt256) {
                case 1 :
                    // xquery/XQueryParser.g:2147:26: p_IndexKeyTypeDecl
                    this.pushFollow(XQueryParser.FOLLOW_p_IndexKeyTypeDecl_in_p_IndexKeySpec17302);
                    p_IndexKeyTypeDecl763=this.p_IndexKeyTypeDecl();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexKeyTypeDecl763.getTree());


                    break;

            }

            // xquery/XQueryParser.g:2147:46: ( p_IndexKeyCollation )?
            var alt257=2;
            var LA257_0 = this.input.LA(1);

            if ( (LA257_0==COLLATION) ) {
                alt257=1;
            }
            switch (alt257) {
                case 1 :
                    // xquery/XQueryParser.g:2147:46: p_IndexKeyCollation
                    this.pushFollow(XQueryParser.FOLLOW_p_IndexKeyCollation_in_p_IndexKeySpec17305);
                    p_IndexKeyCollation764=this.p_IndexKeyCollation();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_IndexKeyCollation764.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IndexKeyExpr_return: (function() {
        XQueryParser.p_IndexKeyExpr_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IndexKeyExpr_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2150:1: p_IndexKeyExpr : p_PathExpr ;
    // $ANTLR start "p_IndexKeyExpr"
    p_IndexKeyExpr: function() {
        var retval = new XQueryParser.p_IndexKeyExpr_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_PathExpr765 = null;


        try {
            // xquery/XQueryParser.g:2151:9: ( p_PathExpr )
            // xquery/XQueryParser.g:2151:11: p_PathExpr
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_PathExpr_in_p_IndexKeyExpr17331);
            p_PathExpr765=this.p_PathExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PathExpr765.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IndexKeyTypeDecl_return: (function() {
        XQueryParser.p_IndexKeyTypeDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IndexKeyTypeDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2154:1: p_IndexKeyTypeDecl : k= AS p_AtomicType ( p_OccurrenceIndicator )? ;
    // $ANTLR start "p_IndexKeyTypeDecl"
    p_IndexKeyTypeDecl: function() {
        var retval = new XQueryParser.p_IndexKeyTypeDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_AtomicType766 = null;
         var p_OccurrenceIndicator767 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2155:9: (k= AS p_AtomicType ( p_OccurrenceIndicator )? )
            // xquery/XQueryParser.g:2155:11: k= AS p_AtomicType ( p_OccurrenceIndicator )?
            root_0 = this.adaptor.nil();

            k=this.match(this.input,AS,XQueryParser.FOLLOW_AS_in_p_IndexKeyTypeDecl17358); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_AtomicType_in_p_IndexKeyTypeDecl17362);
            p_AtomicType766=this.p_AtomicType();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_AtomicType766.getTree());
            // xquery/XQueryParser.g:2155:44: ( p_OccurrenceIndicator )?
            var alt258=2;
            var LA258_0 = this.input.LA(1);

            if ( ((LA258_0>=QUESTION && LA258_0<=PLUS)) ) {
                alt258=1;
            }
            switch (alt258) {
                case 1 :
                    // xquery/XQueryParser.g:2155:44: p_OccurrenceIndicator
                    this.pushFollow(XQueryParser.FOLLOW_p_OccurrenceIndicator_in_p_IndexKeyTypeDecl17364);
                    p_OccurrenceIndicator767=this.p_OccurrenceIndicator();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_OccurrenceIndicator767.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_AtomicType_return: (function() {
        XQueryParser.p_AtomicType_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_AtomicType_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2158:1: p_AtomicType : p_QName ;
    // $ANTLR start "p_AtomicType"
    p_AtomicType: function() {
        var retval = new XQueryParser.p_AtomicType_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

         var p_QName768 = null;


        try {
            // xquery/XQueryParser.g:2159:9: ( p_QName )
            // xquery/XQueryParser.g:2159:11: p_QName
            root_0 = this.adaptor.nil();

            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_AtomicType17390);
            p_QName768=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName768.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_IndexKeyCollation_return: (function() {
        XQueryParser.p_IndexKeyCollation_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_IndexKeyCollation_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2162:1: p_IndexKeyCollation : k= COLLATION p_StringLiteral ;
    // $ANTLR start "p_IndexKeyCollation"
    p_IndexKeyCollation: function() {
        var retval = new XQueryParser.p_IndexKeyCollation_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_StringLiteral769 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2163:9: (k= COLLATION p_StringLiteral )
            // xquery/XQueryParser.g:2163:11: k= COLLATION p_StringLiteral
            root_0 = this.adaptor.nil();

            k=this.match(this.input,COLLATION,XQueryParser.FOLLOW_COLLATION_in_p_IndexKeyCollation17417); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_StringLiteral_in_p_IndexKeyCollation17421);
            p_StringLiteral769=this.p_StringLiteral();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_StringLiteral769.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICDecl_return: (function() {
        XQueryParser.p_ICDecl_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICDecl_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2166:1: p_ICDecl : k= INTEGRITY k= CONSTRAINT p_QName ( p_ICCollection | p_ICForeignKey ) ;
    // $ANTLR start "p_ICDecl"
    p_ICDecl: function() {
        var retval = new XQueryParser.p_ICDecl_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_QName770 = null;
         var p_ICCollection771 = null;
         var p_ICForeignKey772 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2167:9: (k= INTEGRITY k= CONSTRAINT p_QName ( p_ICCollection | p_ICForeignKey ) )
            // xquery/XQueryParser.g:2167:11: k= INTEGRITY k= CONSTRAINT p_QName ( p_ICCollection | p_ICForeignKey )
            root_0 = this.adaptor.nil();

            k=this.match(this.input,INTEGRITY,XQueryParser.FOLLOW_INTEGRITY_in_p_ICDecl17448); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,CONSTRAINT,XQueryParser.FOLLOW_CONSTRAINT_in_p_ICDecl17454); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ICDecl17458);
            p_QName770=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName770.getTree());
            // xquery/XQueryParser.g:2167:74: ( p_ICCollection | p_ICForeignKey )
            var alt259=2;
            var LA259_0 = this.input.LA(1);

            if ( (LA259_0==ON) ) {
                alt259=1;
            }
            else if ( (LA259_0==FOREIGN) ) {
                alt259=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 259, 0, this.input);

                throw nvae;
            }
            switch (alt259) {
                case 1 :
                    // xquery/XQueryParser.g:2167:75: p_ICCollection
                    this.pushFollow(XQueryParser.FOLLOW_p_ICCollection_in_p_ICDecl17461);
                    p_ICCollection771=this.p_ICCollection();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICCollection771.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:2167:92: p_ICForeignKey
                    this.pushFollow(XQueryParser.FOLLOW_p_ICForeignKey_in_p_ICDecl17465);
                    p_ICForeignKey772=this.p_ICForeignKey();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICForeignKey772.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICCollection_return: (function() {
        XQueryParser.p_ICCollection_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICCollection_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2170:1: p_ICCollection : k= ON k= COLLECTION p_QName ( p_ICCollSequence | p_ICCollSequenceUnique | p_ICCollNode ) ;
    // $ANTLR start "p_ICCollection"
    p_ICCollection: function() {
        var retval = new XQueryParser.p_ICCollection_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_QName773 = null;
         var p_ICCollSequence774 = null;
         var p_ICCollSequenceUnique775 = null;
         var p_ICCollNode776 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2171:9: (k= ON k= COLLECTION p_QName ( p_ICCollSequence | p_ICCollSequenceUnique | p_ICCollNode ) )
            // xquery/XQueryParser.g:2171:11: k= ON k= COLLECTION p_QName ( p_ICCollSequence | p_ICCollSequenceUnique | p_ICCollNode )
            root_0 = this.adaptor.nil();

            k=this.match(this.input,ON,XQueryParser.FOLLOW_ON_in_p_ICCollection17493); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,COLLECTION,XQueryParser.FOLLOW_COLLECTION_in_p_ICCollection17499); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ICCollection17503);
            p_QName773=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName773.getTree());
            // xquery/XQueryParser.g:2171:67: ( p_ICCollSequence | p_ICCollSequenceUnique | p_ICCollNode )
            var alt260=3;
            switch ( this.input.LA(1) ) {
            case DOLLAR:
                alt260=1;
                break;
            case NODE:
                alt260=2;
                break;
            case FOREACH:
                alt260=3;
                break;
            default:
                if (this.state.backtracking>0) {this.state.failed=true; return retval;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 260, 0, this.input);

                throw nvae;
            }

            switch (alt260) {
                case 1 :
                    // xquery/XQueryParser.g:2171:68: p_ICCollSequence
                    this.pushFollow(XQueryParser.FOLLOW_p_ICCollSequence_in_p_ICCollection17506);
                    p_ICCollSequence774=this.p_ICCollSequence();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICCollSequence774.getTree());


                    break;
                case 2 :
                    // xquery/XQueryParser.g:2171:87: p_ICCollSequenceUnique
                    this.pushFollow(XQueryParser.FOLLOW_p_ICCollSequenceUnique_in_p_ICCollection17510);
                    p_ICCollSequenceUnique775=this.p_ICCollSequenceUnique();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICCollSequenceUnique775.getTree());


                    break;
                case 3 :
                    // xquery/XQueryParser.g:2171:112: p_ICCollNode
                    this.pushFollow(XQueryParser.FOLLOW_p_ICCollNode_in_p_ICCollection17514);
                    p_ICCollNode776=this.p_ICCollNode();

                    this.state._fsp--;
                    if (this.state.failed) return retval;
                    if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICCollNode776.getTree());


                    break;

            }




            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICCollSequence_return: (function() {
        XQueryParser.p_ICCollSequence_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICCollSequence_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2174:1: p_ICCollSequence : d= DOLLAR v= p_QName k= CHECK p_ExprSingle[true] ;
    // $ANTLR start "p_ICCollSequence"
    p_ICCollSequence: function() {
        var retval = new XQueryParser.p_ICCollSequence_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var d = null;
        var k = null;
         var v = null;
         var p_ExprSingle777 = null;

        var d_tree=null;
        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2175:9: (d= DOLLAR v= p_QName k= CHECK p_ExprSingle[true] )
            // xquery/XQueryParser.g:2175:11: d= DOLLAR v= p_QName k= CHECK p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_ICCollSequence17542); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ICCollSequence17546);
            v=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            k=this.match(this.input,CHECK,XQueryParser.FOLLOW_CHECK_in_p_ICCollSequence17552); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_ICCollSequence17556);
            p_ExprSingle777=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle777.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICCollSequenceUnique_return: (function() {
        XQueryParser.p_ICCollSequenceUnique_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICCollSequenceUnique_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2178:1: p_ICCollSequenceUnique : k= NODE d= DOLLAR v= p_QName k= CHECK k= UNIQUE k= KEY p_PathExpr ;
    // $ANTLR start "p_ICCollSequenceUnique"
    p_ICCollSequenceUnique: function() {
        var retval = new XQueryParser.p_ICCollSequenceUnique_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;
         var p_PathExpr778 = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:2179:9: (k= NODE d= DOLLAR v= p_QName k= CHECK k= UNIQUE k= KEY p_PathExpr )
            // xquery/XQueryParser.g:2179:11: k= NODE d= DOLLAR v= p_QName k= CHECK k= UNIQUE k= KEY p_PathExpr
            root_0 = this.adaptor.nil();

            k=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_ICCollSequenceUnique17584); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_ICCollSequenceUnique17590); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ICCollSequenceUnique17594);
            v=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            k=this.match(this.input,CHECK,XQueryParser.FOLLOW_CHECK_in_p_ICCollSequenceUnique17600); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,UNIQUE,XQueryParser.FOLLOW_UNIQUE_in_p_ICCollSequenceUnique17606); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,KEY,XQueryParser.FOLLOW_KEY_in_p_ICCollSequenceUnique17612); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_PathExpr_in_p_ICCollSequenceUnique17616);
            p_PathExpr778=this.p_PathExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PathExpr778.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICCollNode_return: (function() {
        XQueryParser.p_ICCollNode_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICCollNode_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2182:1: p_ICCollNode : k= FOREACH k= NODE d= DOLLAR v= p_QName k= CHECK p_ExprSingle[true] ;
    // $ANTLR start "p_ICCollNode"
    p_ICCollNode: function() {
        var retval = new XQueryParser.p_ICCollNode_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;
         var p_ExprSingle779 = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:2183:9: (k= FOREACH k= NODE d= DOLLAR v= p_QName k= CHECK p_ExprSingle[true] )
            // xquery/XQueryParser.g:2183:11: k= FOREACH k= NODE d= DOLLAR v= p_QName k= CHECK p_ExprSingle[true]
            root_0 = this.adaptor.nil();

            k=this.match(this.input,FOREACH,XQueryParser.FOLLOW_FOREACH_in_p_ICCollNode17643); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_ICCollNode17649); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_ICCollNode17655); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ICCollNode17659);
            v=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            k=this.match(this.input,CHECK,XQueryParser.FOLLOW_CHECK_in_p_ICCollNode17665); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ExprSingle_in_p_ICCollNode17669);
            p_ExprSingle779=this.p_ExprSingle(true);

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ExprSingle779.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICForeignKey_return: (function() {
        XQueryParser.p_ICForeignKey_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICForeignKey_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2186:1: p_ICForeignKey : k= FOREIGN k= KEY p_ICForeignKeySource p_ICForeignKeyTarget ;
    // $ANTLR start "p_ICForeignKey"
    p_ICForeignKey: function() {
        var retval = new XQueryParser.p_ICForeignKey_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_ICForeignKeySource780 = null;
         var p_ICForeignKeyTarget781 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2187:9: (k= FOREIGN k= KEY p_ICForeignKeySource p_ICForeignKeyTarget )
            // xquery/XQueryParser.g:2187:11: k= FOREIGN k= KEY p_ICForeignKeySource p_ICForeignKeyTarget
            root_0 = this.adaptor.nil();

            k=this.match(this.input,FOREIGN,XQueryParser.FOLLOW_FOREIGN_in_p_ICForeignKey17697); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            k=this.match(this.input,KEY,XQueryParser.FOLLOW_KEY_in_p_ICForeignKey17703); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ICForeignKeySource_in_p_ICForeignKey17707);
            p_ICForeignKeySource780=this.p_ICForeignKeySource();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICForeignKeySource780.getTree());
            this.pushFollow(XQueryParser.FOLLOW_p_ICForeignKeyTarget_in_p_ICForeignKey17709);
            p_ICForeignKeyTarget781=this.p_ICForeignKeyTarget();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICForeignKeyTarget781.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICForeignKeySource_return: (function() {
        XQueryParser.p_ICForeignKeySource_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICForeignKeySource_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2190:1: p_ICForeignKeySource : k= FROM p_ICForeignKeyValues ;
    // $ANTLR start "p_ICForeignKeySource"
    p_ICForeignKeySource: function() {
        var retval = new XQueryParser.p_ICForeignKeySource_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_ICForeignKeyValues782 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2191:9: (k= FROM p_ICForeignKeyValues )
            // xquery/XQueryParser.g:2191:11: k= FROM p_ICForeignKeyValues
            root_0 = this.adaptor.nil();

            k=this.match(this.input,FROM,XQueryParser.FOLLOW_FROM_in_p_ICForeignKeySource17736); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ICForeignKeyValues_in_p_ICForeignKeySource17740);
            p_ICForeignKeyValues782=this.p_ICForeignKeyValues();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICForeignKeyValues782.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICForeignKeyTarget_return: (function() {
        XQueryParser.p_ICForeignKeyTarget_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICForeignKeyTarget_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2194:1: p_ICForeignKeyTarget : k= TO p_ICForeignKeyValues ;
    // $ANTLR start "p_ICForeignKeyTarget"
    p_ICForeignKeyTarget: function() {
        var retval = new XQueryParser.p_ICForeignKeyTarget_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
         var p_ICForeignKeyValues783 = null;

        var k_tree=null;

        try {
            // xquery/XQueryParser.g:2195:9: (k= TO p_ICForeignKeyValues )
            // xquery/XQueryParser.g:2195:11: k= TO p_ICForeignKeyValues
            root_0 = this.adaptor.nil();

            k=this.match(this.input,TO,XQueryParser.FOLLOW_TO_in_p_ICForeignKeyTarget17767); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_ICForeignKeyValues_in_p_ICForeignKeyTarget17771);
            p_ICForeignKeyValues783=this.p_ICForeignKeyValues();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_ICForeignKeyValues783.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // inline static return class
    p_ICForeignKeyValues_return: (function() {
        XQueryParser.p_ICForeignKeyValues_return = function(){};
        org.antlr.lang.extend(XQueryParser.p_ICForeignKeyValues_return,
                          org.antlr.runtime.ParserRuleReturnScope,
        {
            getTree: function() { return this.tree; }
        });
        return;
    })(),

    // xquery/XQueryParser.g:2198:1: p_ICForeignKeyValues : k= COLLECTION p_QName k= NODE d= DOLLAR v= p_QName k= KEY p_PathExpr ;
    // $ANTLR start "p_ICForeignKeyValues"
    p_ICForeignKeyValues: function() {
        var retval = new XQueryParser.p_ICForeignKeyValues_return();
        retval.start = this.input.LT(1);

        var root_0 = null;

        var k = null;
        var d = null;
         var v = null;
         var p_QName784 = null;
         var p_PathExpr785 = null;

        var k_tree=null;
        var d_tree=null;

        try {
            // xquery/XQueryParser.g:2199:9: (k= COLLECTION p_QName k= NODE d= DOLLAR v= p_QName k= KEY p_PathExpr )
            // xquery/XQueryParser.g:2199:11: k= COLLECTION p_QName k= NODE d= DOLLAR v= p_QName k= KEY p_PathExpr
            root_0 = this.adaptor.nil();

            k=this.match(this.input,COLLECTION,XQueryParser.FOLLOW_COLLECTION_in_p_ICForeignKeyValues17798); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ICForeignKeyValues17802);
            p_QName784=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_QName784.getTree());
            k=this.match(this.input,NODE,XQueryParser.FOLLOW_NODE_in_p_ICForeignKeyValues17806); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            d=this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_p_ICForeignKeyValues17812); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            d_tree = this.adaptor.create(d);
            this.adaptor.addChild(root_0, d_tree);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_QName_in_p_ICForeignKeyValues17816);
            v=this.p_QName();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, v.getTree());
            if ( this.state.backtracking===0 ) {
               this.av(d, (v?v.stop:null)); 
            }
            k=this.match(this.input,KEY,XQueryParser.FOLLOW_KEY_in_p_ICForeignKeyValues17822); if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) {
            k_tree = this.adaptor.create(k);
            this.adaptor.addChild(root_0, k_tree);
            }
            if ( this.state.backtracking===0 ) {
              this.ak(k);
            }
            this.pushFollow(XQueryParser.FOLLOW_p_PathExpr_in_p_ICForeignKeyValues17826);
            p_PathExpr785=this.p_PathExpr();

            this.state._fsp--;
            if (this.state.failed) return retval;
            if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, p_PathExpr785.getTree());



            retval.stop = this.input.LT(-1);

            if ( this.state.backtracking===0 ) {

            retval.tree = this.adaptor.rulePostProcessing(root_0);
            this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        }
        catch (re) {
            if (re instanceof org.antlr.runtime.RecognitionException) {
                this.reportError(re);
                this.recover(this.input,re);
                retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
            } else {
                throw re;
            }
        }
        finally {
        }
        return retval;
    },

    // $ANTLR start "synpred1_XQueryParser"
    synpred1_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:567:11: ( ( ( FOR | LET ) DOLLAR ) | ( FOR ( TUMBLING | SLIDING ) ) )
        var alt261=2;
        var LA261_0 = this.input.LA(1);

        if ( (LA261_0==FOR) ) {
            var LA261_1 = this.input.LA(2);

            if ( (LA261_1==DOLLAR) ) {
                alt261=1;
            }
            else if ( (LA261_1==SLIDING||LA261_1==TUMBLING) ) {
                alt261=2;
            }
            else {
                if (this.state.backtracking>0) {this.state.failed=true; return ;}
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 261, 1, this.input);

                throw nvae;
            }
        }
        else if ( (LA261_0==LET) ) {
            alt261=1;
        }
        else {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var nvae =
                new org.antlr.runtime.NoViableAltException("", 261, 0, this.input);

            throw nvae;
        }
        switch (alt261) {
            case 1 :
                // xquery/XQueryParser.g:567:12: ( ( FOR | LET ) DOLLAR )
                // xquery/XQueryParser.g:567:12: ( ( FOR | LET ) DOLLAR )
                // xquery/XQueryParser.g:567:13: ( FOR | LET ) DOLLAR
                if ( this.input.LA(1)==FOR||this.input.LA(1)==LET ) {
                    this.input.consume();
                    this.state.errorRecovery=false;this.state.failed=false;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return ;}
                    var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                    throw mse;
                }

                this.match(this.input,DOLLAR,XQueryParser.FOLLOW_DOLLAR_in_synpred1_XQueryParser3543); if (this.state.failed) return ;





                break;
            case 2 :
                // xquery/XQueryParser.g:567:35: ( FOR ( TUMBLING | SLIDING ) )
                // xquery/XQueryParser.g:567:35: ( FOR ( TUMBLING | SLIDING ) )
                // xquery/XQueryParser.g:567:36: FOR ( TUMBLING | SLIDING )
                this.match(this.input,FOR,XQueryParser.FOLLOW_FOR_in_synpred1_XQueryParser3549); if (this.state.failed) return ;
                if ( this.input.LA(1)==SLIDING||this.input.LA(1)==TUMBLING ) {
                    this.input.consume();
                    this.state.errorRecovery=false;this.state.failed=false;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return ;}
                    var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                    throw mse;
                }






                break;

        }},
    // $ANTLR end "synpred1_XQueryParser",

    // $ANTLR start "synpred2_XQueryParser"
    synpred2_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:568:11: ( IF LPAREN )
        // xquery/XQueryParser.g:568:12: IF LPAREN
        this.match(this.input,IF,XQueryParser.FOLLOW_IF_in_synpred2_XQueryParser3577); if (this.state.failed) return ;
        this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_synpred2_XQueryParser3579); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred2_XQueryParser",

    // $ANTLR start "synpred3_XQueryParser"
    synpred3_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:569:11: ( SWITCH LPAREN )
        // xquery/XQueryParser.g:569:12: SWITCH LPAREN
        this.match(this.input,SWITCH,XQueryParser.FOLLOW_SWITCH_in_synpred3_XQueryParser3607); if (this.state.failed) return ;
        this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_synpred3_XQueryParser3609); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred3_XQueryParser",

    // $ANTLR start "synpred4_XQueryParser"
    synpred4_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:570:11: ( TYPESWITCH LPAREN )
        // xquery/XQueryParser.g:570:12: TYPESWITCH LPAREN
        this.match(this.input,TYPESWITCH,XQueryParser.FOLLOW_TYPESWITCH_in_synpred4_XQueryParser3633); if (this.state.failed) return ;
        this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_synpred4_XQueryParser3635); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred4_XQueryParser",

    // $ANTLR start "synpred5_XQueryParser"
    synpred5_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:571:11: ( TRY LBRACKET )
        // xquery/XQueryParser.g:571:12: TRY LBRACKET
        this.match(this.input,TRY,XQueryParser.FOLLOW_TRY_in_synpred5_XQueryParser3655); if (this.state.failed) return ;
        this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_synpred5_XQueryParser3657); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred5_XQueryParser",

    // $ANTLR start "synpred6_XQueryParser"
    synpred6_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:857:11: ( VALIDATE ( p_ValidationMode | TYPE )? )
        // xquery/XQueryParser.g:857:12: VALIDATE ( p_ValidationMode | TYPE )?
        this.match(this.input,VALIDATE,XQueryParser.FOLLOW_VALIDATE_in_synpred6_XQueryParser6185); if (this.state.failed) return ;
        // xquery/XQueryParser.g:857:21: ( p_ValidationMode | TYPE )?
        var alt262=3;
        var LA262_0 = this.input.LA(1);

        if ( (LA262_0==LAX||LA262_0==STRICT) ) {
            alt262=1;
        }
        else if ( (LA262_0==TYPE) ) {
            alt262=2;
        }
        switch (alt262) {
            case 1 :
                // xquery/XQueryParser.g:857:23: p_ValidationMode
                this.pushFollow(XQueryParser.FOLLOW_p_ValidationMode_in_synpred6_XQueryParser6189);
                this.p_ValidationMode();

                this.state._fsp--;
                if (this.state.failed) return ;


                break;
            case 2 :
                // xquery/XQueryParser.g:857:42: TYPE
                this.match(this.input,TYPE,XQueryParser.FOLLOW_TYPE_in_synpred6_XQueryParser6193); if (this.state.failed) return ;


                break;

        }



    },
    // $ANTLR end "synpred6_XQueryParser",

    // $ANTLR start "synpred7_XQueryParser"
    synpred7_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:902:11: ( SLASH p_RelativePathExpr )
        // xquery/XQueryParser.g:902:12: SLASH p_RelativePathExpr
        this.match(this.input,SLASH,XQueryParser.FOLLOW_SLASH_in_synpred7_XQueryParser6533); if (this.state.failed) return ;
        this.pushFollow(XQueryParser.FOLLOW_p_RelativePathExpr_in_synpred7_XQueryParser6535);
        this.p_RelativePathExpr();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred7_XQueryParser",

    // $ANTLR start "synpred8_XQueryParser"
    synpred8_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:915:11: ( LBRACKET | LPAREN | SMALLER | QUOT | APOS | DOLLAR )
        // xquery/XQueryParser.g:
        if ( this.input.LA(1)==LPAREN||(this.input.LA(1)>=DOLLAR && this.input.LA(1)<=LBRACKET)||this.input.LA(1)==SMALLER||(this.input.LA(1)>=APOS && this.input.LA(1)<=QUOT) ) {
            this.input.consume();
            this.state.errorRecovery=false;this.state.failed=false;
        }
        else {
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
            throw mse;
        }



    },
    // $ANTLR end "synpred8_XQueryParser",

    // $ANTLR start "synpred9_XQueryParser"
    synpred9_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:916:11: ( ( ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET ) | ( ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET ) | ( ( DOCUMENT | TEXT | COMMENT ) LBRACKET ) )
        var alt265=3;
        switch ( this.input.LA(1) ) {
        case ATTRIBUTE:
        case ELEMENT:
            alt265=1;
            break;
        case NAMESPACE:
        case PROCESSING_INSTRUCTION:
            alt265=2;
            break;
        case COMMENT:
        case DOCUMENT:
        case TEXT:
            alt265=3;
            break;
        default:
            if (this.state.backtracking>0) {this.state.failed=true; return ;}
            var nvae =
                new org.antlr.runtime.NoViableAltException("", 265, 0, this.input);

            throw nvae;
        }

        switch (alt265) {
            case 1 :
                // xquery/XQueryParser.g:917:13: ( ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET )
                // xquery/XQueryParser.g:917:13: ( ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET )
                // xquery/XQueryParser.g:917:14: ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET
                if ( this.input.LA(1)==ATTRIBUTE||this.input.LA(1)==ELEMENT ) {
                    this.input.consume();
                    this.state.errorRecovery=false;this.state.failed=false;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return ;}
                    var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                    throw mse;
                }

                // xquery/XQueryParser.g:917:36: ( p_QName )?
                var alt263=2;
                var LA263_0 = this.input.LA(1);

                if ( ((LA263_0>=ANCESTOR && LA263_0<=SKIP)||(LA263_0>=VALUE && LA263_0<=QUOT_ER)||LA263_0==L_NCName||LA263_0==EXPLICITLY) ) {
                    alt263=1;
                }
                switch (alt263) {
                    case 1 :
                        // xquery/XQueryParser.g:917:36: p_QName
                        this.pushFollow(XQueryParser.FOLLOW_p_QName_in_synpred9_XQueryParser6710);
                        this.p_QName();

                        this.state._fsp--;
                        if (this.state.failed) return ;


                        break;

                }

                this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_synpred9_XQueryParser6713); if (this.state.failed) return ;





                break;
            case 2 :
                // xquery/XQueryParser.g:918:13: ( ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET )
                // xquery/XQueryParser.g:918:13: ( ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET )
                // xquery/XQueryParser.g:918:14: ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET
                if ( this.input.LA(1)==NAMESPACE||this.input.LA(1)==PROCESSING_INSTRUCTION ) {
                    this.input.consume();
                    this.state.errorRecovery=false;this.state.failed=false;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return ;}
                    var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                    throw mse;
                }

                // xquery/XQueryParser.g:918:51: ( p_NCName )?
                var alt264=2;
                var LA264_0 = this.input.LA(1);

                if ( ((LA264_0>=ANCESTOR && LA264_0<=SKIP)||(LA264_0>=VALUE && LA264_0<=QUOT_ER)||LA264_0==L_NCName||LA264_0==EXPLICITLY) ) {
                    alt264=1;
                }
                switch (alt264) {
                    case 1 :
                        // xquery/XQueryParser.g:918:51: p_NCName
                        this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_synpred9_XQueryParser6739);
                        this.p_NCName();

                        this.state._fsp--;
                        if (this.state.failed) return ;


                        break;

                }

                this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_synpred9_XQueryParser6742); if (this.state.failed) return ;





                break;
            case 3 :
                // xquery/XQueryParser.g:919:13: ( ( DOCUMENT | TEXT | COMMENT ) LBRACKET )
                // xquery/XQueryParser.g:919:13: ( ( DOCUMENT | TEXT | COMMENT ) LBRACKET )
                // xquery/XQueryParser.g:919:14: ( DOCUMENT | TEXT | COMMENT ) LBRACKET
                if ( this.input.LA(1)==COMMENT||this.input.LA(1)==DOCUMENT||this.input.LA(1)==TEXT ) {
                    this.input.consume();
                    this.state.errorRecovery=false;this.state.failed=false;
                }
                else {
                    if (this.state.backtracking>0) {this.state.failed=true; return ;}
                    var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                    throw mse;
                }

                this.match(this.input,LBRACKET,XQueryParser.FOLLOW_LBRACKET_in_synpred9_XQueryParser6772); if (this.state.failed) return ;





                break;

        }},
    // $ANTLR end "synpred9_XQueryParser",

    // $ANTLR start "synpred10_XQueryParser"
    synpred10_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:921:11: ( p_KindTest )
        // xquery/XQueryParser.g:921:12: p_KindTest
        this.pushFollow(XQueryParser.FOLLOW_p_KindTest_in_synpred10_XQueryParser6802);
        this.p_KindTest();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred10_XQueryParser",

    // $ANTLR start "synpred11_XQueryParser"
    synpred11_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:922:11: ( p_QName LPAREN )
        // xquery/XQueryParser.g:922:12: p_QName LPAREN
        this.pushFollow(XQueryParser.FOLLOW_p_QName_in_synpred11_XQueryParser6821);
        this.p_QName();

        this.state._fsp--;
        if (this.state.failed) return ;
        this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_synpred11_XQueryParser6823); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred11_XQueryParser",

    // $ANTLR start "synpred12_XQueryParser"
    synpred12_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:923:11: ( p_PrimaryExpr )
        // xquery/XQueryParser.g:923:12: p_PrimaryExpr
        this.pushFollow(XQueryParser.FOLLOW_p_PrimaryExpr_in_synpred12_XQueryParser6841);
        this.p_PrimaryExpr();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred12_XQueryParser",

    // $ANTLR start "synpred13_XQueryParser"
    synpred13_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:981:11: ( p_Wildcard )
        // xquery/XQueryParser.g:981:12: p_Wildcard
        this.pushFollow(XQueryParser.FOLLOW_p_Wildcard_in_synpred13_XQueryParser7280);
        this.p_Wildcard();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred13_XQueryParser",

    // $ANTLR start "synpred14_XQueryParser"
    synpred14_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:982:11: ( p_NCName COLON )
        // xquery/XQueryParser.g:982:12: p_NCName COLON
        this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_synpred14_XQueryParser7299);
        this.p_NCName();

        this.state._fsp--;
        if (this.state.failed) return ;
        this.match(this.input,COLON,XQueryParser.FOLLOW_COLON_in_synpred14_XQueryParser7301); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred14_XQueryParser",

    // $ANTLR start "synpred15_XQueryParser"
    synpred15_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:983:11: ( p_NCName )
        // xquery/XQueryParser.g:983:12: p_NCName
        this.pushFollow(XQueryParser.FOLLOW_p_NCName_in_synpred15_XQueryParser7319);
        this.p_NCName();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred15_XQueryParser",

    // $ANTLR start "synpred16_XQueryParser"
    synpred16_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:1020:11: ( LPAREN )
        // xquery/XQueryParser.g:1020:12: LPAREN
        this.match(this.input,LPAREN,XQueryParser.FOLLOW_LPAREN_in_synpred16_XQueryParser7575); if (this.state.failed) return ;


    },
    // $ANTLR end "synpred16_XQueryParser",

    // $ANTLR start "synpred17_XQueryParser"
    synpred17_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:1299:26: ( p_OccurrenceIndicator )
        // xquery/XQueryParser.g:1299:27: p_OccurrenceIndicator
        this.pushFollow(XQueryParser.FOLLOW_p_OccurrenceIndicator_in_synpred17_XQueryParser9583);
        this.p_OccurrenceIndicator();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred17_XQueryParser",

    // $ANTLR start "synpred18_XQueryParser"
    synpred18_XQueryParser_fragment: function() {
        // xquery/XQueryParser.g:2131:44: ( p_OccurrenceIndicator )
        // xquery/XQueryParser.g:2131:45: p_OccurrenceIndicator
        this.pushFollow(XQueryParser.FOLLOW_p_OccurrenceIndicator_in_synpred18_XQueryParser17157);
        this.p_OccurrenceIndicator();

        this.state._fsp--;
        if (this.state.failed) return ;


    },
    // $ANTLR end "synpred18_XQueryParser"

    // Delegated rules



    synpred3_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred3_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred15_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred15_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred7_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred7_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred9_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred9_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred10_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred10_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred17_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred17_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred5_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred5_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred12_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred12_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred16_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred16_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred14_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred14_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred6_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred6_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred18_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred18_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred8_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred8_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred13_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred13_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred4_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred4_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred11_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred11_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred1_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred1_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    },
    synpred2_XQueryParser: function() {
        this.state.backtracking++;
        var start = this.input.mark();
        try {
            this.synpred2_XQueryParser_fragment(); // can never throw exception
        } catch (re) {
            alert("impossible: "+re.toString());
        }
        var success = !this.state.failed;
        this.input.rewind(start);
        this.state.backtracking--;
        this.state.failed=false;
        return success;
    }

}, true); // important to pass true to overwrite default implementations

org.antlr.lang.augmentObject(XQueryParser, {
    DFA1_eotS:
        "\u000a\uffff",
    DFA1_eofS:
        "\u0001\u0005\u0001\u0009\u0008\uffff",
    DFA1_minS:
        "\u0001\u0010\u0001\u0012\u0008\uffff",
    DFA1_maxS:
        "\u0001\u0154\u0001\u00fe\u0008\uffff",
    DFA1_acceptS:
        "\u0002\uffff\u0004\u0002\u0001\u0001\u0003\u0002",
    DFA1_specialS:
        "\u0001\u0001\u0001\u0000\u0008\uffff}>",
    DFA1_transitionS: [
            "\u0002\u0002\u0004\u0004\u0001\u0002\u0006\u0004\u0001\u0002"+
            "\u0001\u0004\u0001\u0002\u0002\u0004\u0001\u0002\u0001\u0004"+
            "\u0002\u0002\u0002\u0004\u0003\u0002\u0005\u0004\u0001\u0002"+
            "\u0002\u0004\u0003\u0002\u0005\u0004\u0002\u0002\u0009\u0004"+
            "\u0001\u0002\u0002\u0004\u0002\u0002\u0003\u0004\u0001\u0002"+
            "\u0004\u0004\u0001\u0002\u0001\u0004\u0003\u0002\u0001\u0004"+
            "\u0001\u0002\u0003\u0004\u0004\u0002\u0003\u0004\u0001\u0002"+
            "\u0003\u0004\u0001\u0002\u0001\u0004\u0003\u0002\u0002\u0004"+
            "\u0001\u0001\u000c\u0004\u0001\u0002\u0009\u0004\u0002\u0002"+
            "\u0007\u0004\u0002\u0002\u0001\u0004\u0001\u0002\u0004\u0004"+
            "\u0002\u0002\u0002\u0004\u0001\u0002\u002c\u0004\u0003\u0002"+
            "\u0002\u0004\u0001\u0002\u000a\u0004\u0001\u0002\u0003\u0004"+
            "\u0001\uffff\u0001\u0002\u0001\uffff\u0002\u0002\u0006\uffff"+
            "\u0001\u0003\u0004\uffff\u0004\u0002\u0005\uffff\u0004\u0002"+
            "\u000c\uffff\u0001\u0002\u0002\uffff\u0002\u0002\u0002\uffff"+
            "\u0001\u0004\u0006\uffff\u0006\u0002\u003b\uffff\u0001\u0004",
            "\u0001\u0007\u0008\uffff\u0002\u0007\u000a\uffff\u0001\u0007"+
            "\u0006\uffff\u0001\u0006\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0005\uffff\u0001\u0007\u0001\uffff\u0002\u0007\u0004\uffff"+
            "\u0003\u0007\u0002\uffff\u0001\u0007\u0002\uffff\u0002\u0007"+
            "\u0002\uffff\u0001\u0007\u0005\uffff\u0001\u0007\u0014\uffff"+
            "\u0002\u0007\u0001\uffff\u0001\u0007\u0003\uffff\u0001\u0006"+
            "\u0032\uffff\u0001\u0007\u003b\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0001\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0003\uffff\u0001\u0007\u0001\uffff\u000b\u0007\u0002\uffff"+
            "\u0001\u0007\u0003\uffff\u0001\u0008\u0001\u0007",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA1_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA1_eotS),
    DFA1_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA1_eofS),
    DFA1_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA1_minS),
    DFA1_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA1_maxS),
    DFA1_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA1_acceptS),
    DFA1_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA1_specialS),
    DFA1_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA1_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA1_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA1 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 1;
    this.eot = XQueryParser.DFA1_eot;
    this.eof = XQueryParser.DFA1_eof;
    this.min = XQueryParser.DFA1_min;
    this.max = XQueryParser.DFA1_max;
    this.accept = XQueryParser.DFA1_accept;
    this.special = XQueryParser.DFA1_special;
    this.transition = XQueryParser.DFA1_transition;
};

org.antlr.lang.extend(XQueryParser.DFA1, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "289:13: (vd= p_VersionDecl )?";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA1_1 = input.LA(1);

                             
                            var index1_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA1_1==ENCODING||LA1_1==VERSION) ) {s = 6;}

                            else if ( (LA1_1==AND||(LA1_1>=CAST && LA1_1<=CASTABLE)||LA1_1==DIV||LA1_1==EQ||LA1_1==EXCEPT||LA1_1==GE||(LA1_1>=GT && LA1_1<=IDIV)||(LA1_1>=INSTANCE && LA1_1<=IS)||LA1_1==LE||(LA1_1>=LT && LA1_1<=MOD)||LA1_1==NE||LA1_1==OR||(LA1_1>=TO && LA1_1<=TREAT)||LA1_1==UNION||LA1_1==CONTAINS||(LA1_1>=CONCAT && LA1_1<=LPAREN)||LA1_1==LSQUARE||LA1_1==EQUAL||LA1_1==NOTEQUAL||LA1_1==COMMA||(LA1_1>=STAR && LA1_1<=SLASH_SLASH)||LA1_1==COLON||LA1_1==VBAR) ) {s = 7;}

                            else if ( (LA1_1==SEMICOLON) && ((this.lc(XQS)))) {s = 8;}

                            else if ( (LA1_1==EOF) ) {s = 9;}

                             
                            input.seek(index1_1);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA1_0 = input.LA(1);

                             
                            var index1_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA1_0==XQUERY) ) {s = 1;}

                            else if ( ((LA1_0>=ANCESTOR && LA1_0<=ANCESTOR_OR_SELF)||LA1_0==ATTRIBUTE||LA1_0==CHILD||LA1_0==COMMENT||LA1_0==DECLARE||(LA1_0>=DESCENDANT && LA1_0<=DESCENDANT_OR_SELF)||(LA1_0>=DOCUMENT && LA1_0<=ELEMENT)||LA1_0==EVERY||(LA1_0>=FOLLOWING && LA1_0<=FOR)||(LA1_0>=IF && LA1_0<=IMPORT)||LA1_0==LET||(LA1_0>=MODULE && LA1_0<=NAMESPACE)||LA1_0==NODE||LA1_0==ORDERED||(LA1_0>=PARENT && LA1_0<=PRECEDING_SIBLING)||LA1_0==PROCESSING_INSTRUCTION||(LA1_0>=SCHEMA_ATTRIBUTE && LA1_0<=SOME)||LA1_0==TEXT||LA1_0==TYPESWITCH||(LA1_0>=UNORDERED && LA1_0<=VARIABLE)||LA1_0==NAMESPACE_NODE||(LA1_0>=SWITCH && LA1_0<=TRY)||(LA1_0>=COPY && LA1_0<=DELETE)||LA1_0==INSERT||(LA1_0>=RENAME && LA1_0<=REPLACE)||LA1_0==UPDATING||(LA1_0>=BREAK && LA1_0<=EXIT)||LA1_0==WHILE||LA1_0==BINARY||LA1_0==LPAREN||(LA1_0>=DOLLAR && LA1_0<=LBRACKET)||(LA1_0>=STAR && LA1_0<=SMALLER)||(LA1_0>=SLASH && LA1_0<=DOT_DOT)||LA1_0==ATTR_SIGN||(LA1_0>=APOS && LA1_0<=QUOT)||(LA1_0>=L_Pragma && LA1_0<=L_DoubleLiteral)) ) {s = 2;}

                            else if ( (LA1_0==ANN_PERCENT) && ((this.lc(XQS)))) {s = 3;}

                            else if ( ((LA1_0>=AND && LA1_0<=AT)||(LA1_0>=BASE_URI && LA1_0<=CASTABLE)||LA1_0==COLLATION||(LA1_0>=CONSTRUCTION && LA1_0<=COPY_NAMESPACES)||LA1_0==DEFAULT||(LA1_0>=DESCENDING && LA1_0<=DIV)||(LA1_0>=ELSE && LA1_0<=EQ)||(LA1_0>=EXCEPT && LA1_0<=EXTERNAL)||(LA1_0>=FUNCTION && LA1_0<=IDIV)||(LA1_0>=IN && LA1_0<=LEAST)||(LA1_0>=LT && LA1_0<=MOD)||(LA1_0>=NE && LA1_0<=NO_PRESERVE)||(LA1_0>=OF && LA1_0<=ORDER)||LA1_0==ORDERING||LA1_0==PRESERVE||(LA1_0>=RETURN && LA1_0<=SCHEMA)||(LA1_0>=STABLE && LA1_0<=STRIP)||(LA1_0>=THEN && LA1_0<=TREAT)||LA1_0==UNION||(LA1_0>=VERSION && LA1_0<=WHERE)||(LA1_0>=ALLOWING && LA1_0<=MINUS_SIGN)||(LA1_0>=NAN && LA1_0<=START)||(LA1_0>=TUMBLING && LA1_0<=BEFORE)||LA1_0==FIRST||(LA1_0>=INTO && LA1_0<=NODES)||(LA1_0>=REVALIDATION && LA1_0<=SKIP)||(LA1_0>=VALUE && LA1_0<=WORDS)||(LA1_0>=LOOP && LA1_0<=RETURNING)||(LA1_0>=CHECK && LA1_0<=UNIQUE)||(LA1_0>=AMP_ER && LA1_0<=QUOT_ER)||LA1_0==L_NCName||LA1_0==EXPLICITLY) ) {s = 4;}

                            else if ( (LA1_0==EOF) && ((this.lc(XQS)))) {s = 5;}

                             
                            input.seek(index1_0);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 1, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA2_eotS:
        "\u000a\uffff",
    DFA2_eofS:
        "\u0001\u0005\u0001\u0009\u0008\uffff",
    DFA2_minS:
        "\u0001\u0010\u0001\u0012\u0008\uffff",
    DFA2_maxS:
        "\u0001\u0154\u0001\u00fe\u0008\uffff",
    DFA2_acceptS:
        "\u0002\uffff\u0004\u0002\u0001\u0001\u0003\u0002",
    DFA2_specialS:
        "\u0001\u0000\u0001\u0001\u0008\uffff}>",
    DFA2_transitionS: [
            "\u0002\u0002\u0004\u0004\u0001\u0002\u0006\u0004\u0001\u0002"+
            "\u0001\u0004\u0001\u0002\u0002\u0004\u0001\u0002\u0001\u0004"+
            "\u0002\u0002\u0002\u0004\u0003\u0002\u0005\u0004\u0001\u0002"+
            "\u0002\u0004\u0003\u0002\u0005\u0004\u0002\u0002\u0009\u0004"+
            "\u0001\u0002\u0002\u0004\u0001\u0001\u0001\u0002\u0003\u0004"+
            "\u0001\u0002\u0004\u0004\u0001\u0002\u0001\u0004\u0003\u0002"+
            "\u0001\u0004\u0001\u0002\u0003\u0004\u0004\u0002\u0003\u0004"+
            "\u0001\u0002\u0003\u0004\u0001\u0002\u0001\u0004\u0003\u0002"+
            "\u000f\u0004\u0001\u0002\u0009\u0004\u0002\u0002\u0007\u0004"+
            "\u0002\u0002\u0001\u0004\u0001\u0002\u0004\u0004\u0002\u0002"+
            "\u0002\u0004\u0001\u0002\u002c\u0004\u0003\u0002\u0002\u0004"+
            "\u0001\u0002\u000a\u0004\u0001\u0002\u0003\u0004\u0001\uffff"+
            "\u0001\u0002\u0001\uffff\u0002\u0002\u0006\uffff\u0001\u0003"+
            "\u0004\uffff\u0004\u0002\u0005\uffff\u0004\u0002\u000c\uffff"+
            "\u0001\u0002\u0002\uffff\u0002\u0002\u0002\uffff\u0001\u0004"+
            "\u0006\uffff\u0006\u0002\u003b\uffff\u0001\u0004",
            "\u0001\u0007\u0008\uffff\u0002\u0007\u000a\uffff\u0001\u0007"+
            "\u0007\uffff\u0001\u0007\u0001\uffff\u0001\u0007\u0005\uffff"+
            "\u0001\u0007\u0001\uffff\u0002\u0007\u0004\uffff\u0003\u0007"+
            "\u0002\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0001\uffff"+
            "\u0001\u0006\u0001\u0007\u0005\uffff\u0001\u0007\u0014\uffff"+
            "\u0002\u0007\u0001\uffff\u0001\u0007\u0036\uffff\u0001\u0007"+
            "\u003b\uffff\u0002\u0007\u0004\uffff\u0001\u0007\u0001\uffff"+
            "\u0001\u0007\u0001\uffff\u0001\u0007\u0003\uffff\u0001\u0007"+
            "\u0001\uffff\u000b\u0007\u0002\uffff\u0001\u0007\u0003\uffff"+
            "\u0001\u0008\u0001\u0007",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA2_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA2_eotS),
    DFA2_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA2_eofS),
    DFA2_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA2_minS),
    DFA2_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA2_maxS),
    DFA2_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA2_acceptS),
    DFA2_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA2_specialS),
    DFA2_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA2_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA2_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA2 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 2;
    this.eot = XQueryParser.DFA2_eot;
    this.eof = XQueryParser.DFA2_eof;
    this.min = XQueryParser.DFA2_min;
    this.max = XQueryParser.DFA2_max;
    this.accept = XQueryParser.DFA2_accept;
    this.special = XQueryParser.DFA2_special;
    this.transition = XQueryParser.DFA2_transition;
};

org.antlr.lang.extend(XQueryParser.DFA2, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "290:13: (lm= p_LibraryModule[$vd.tree] -> | mm= p_MainModule[$vd.tree] ->)";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA2_0 = input.LA(1);

                             
                            var index2_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA2_0==MODULE) ) {s = 1;}

                            else if ( ((LA2_0>=ANCESTOR && LA2_0<=ANCESTOR_OR_SELF)||LA2_0==ATTRIBUTE||LA2_0==CHILD||LA2_0==COMMENT||LA2_0==DECLARE||(LA2_0>=DESCENDANT && LA2_0<=DESCENDANT_OR_SELF)||(LA2_0>=DOCUMENT && LA2_0<=ELEMENT)||LA2_0==EVERY||(LA2_0>=FOLLOWING && LA2_0<=FOR)||(LA2_0>=IF && LA2_0<=IMPORT)||LA2_0==LET||LA2_0==NAMESPACE||LA2_0==NODE||LA2_0==ORDERED||(LA2_0>=PARENT && LA2_0<=PRECEDING_SIBLING)||LA2_0==PROCESSING_INSTRUCTION||(LA2_0>=SCHEMA_ATTRIBUTE && LA2_0<=SOME)||LA2_0==TEXT||LA2_0==TYPESWITCH||(LA2_0>=UNORDERED && LA2_0<=VARIABLE)||LA2_0==NAMESPACE_NODE||(LA2_0>=SWITCH && LA2_0<=TRY)||(LA2_0>=COPY && LA2_0<=DELETE)||LA2_0==INSERT||(LA2_0>=RENAME && LA2_0<=REPLACE)||LA2_0==UPDATING||(LA2_0>=BREAK && LA2_0<=EXIT)||LA2_0==WHILE||LA2_0==BINARY||LA2_0==LPAREN||(LA2_0>=DOLLAR && LA2_0<=LBRACKET)||(LA2_0>=STAR && LA2_0<=SMALLER)||(LA2_0>=SLASH && LA2_0<=DOT_DOT)||LA2_0==ATTR_SIGN||(LA2_0>=APOS && LA2_0<=QUOT)||(LA2_0>=L_Pragma && LA2_0<=L_DoubleLiteral)) ) {s = 2;}

                            else if ( (LA2_0==ANN_PERCENT) && ((this.lc(XQS)))) {s = 3;}

                            else if ( ((LA2_0>=AND && LA2_0<=AT)||(LA2_0>=BASE_URI && LA2_0<=CASTABLE)||LA2_0==COLLATION||(LA2_0>=CONSTRUCTION && LA2_0<=COPY_NAMESPACES)||LA2_0==DEFAULT||(LA2_0>=DESCENDING && LA2_0<=DIV)||(LA2_0>=ELSE && LA2_0<=EQ)||(LA2_0>=EXCEPT && LA2_0<=EXTERNAL)||(LA2_0>=FUNCTION && LA2_0<=IDIV)||(LA2_0>=IN && LA2_0<=LEAST)||(LA2_0>=LT && LA2_0<=MOD)||(LA2_0>=NE && LA2_0<=NO_PRESERVE)||(LA2_0>=OF && LA2_0<=ORDER)||LA2_0==ORDERING||LA2_0==PRESERVE||(LA2_0>=RETURN && LA2_0<=SCHEMA)||(LA2_0>=STABLE && LA2_0<=STRIP)||(LA2_0>=THEN && LA2_0<=TREAT)||LA2_0==UNION||(LA2_0>=VERSION && LA2_0<=MINUS_SIGN)||(LA2_0>=NAN && LA2_0<=START)||(LA2_0>=TUMBLING && LA2_0<=BEFORE)||LA2_0==FIRST||(LA2_0>=INTO && LA2_0<=NODES)||(LA2_0>=REVALIDATION && LA2_0<=SKIP)||(LA2_0>=VALUE && LA2_0<=WORDS)||(LA2_0>=LOOP && LA2_0<=RETURNING)||(LA2_0>=CHECK && LA2_0<=UNIQUE)||(LA2_0>=AMP_ER && LA2_0<=QUOT_ER)||LA2_0==L_NCName||LA2_0==EXPLICITLY) ) {s = 4;}

                            else if ( (LA2_0==EOF) && ((this.lc(XQS)))) {s = 5;}

                             
                            input.seek(index2_0);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA2_1 = input.LA(1);

                             
                            var index2_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA2_1==NAMESPACE) ) {s = 6;}

                            else if ( (LA2_1==AND||(LA2_1>=CAST && LA2_1<=CASTABLE)||LA2_1==DIV||LA2_1==EQ||LA2_1==EXCEPT||LA2_1==GE||(LA2_1>=GT && LA2_1<=IDIV)||(LA2_1>=INSTANCE && LA2_1<=IS)||LA2_1==LE||(LA2_1>=LT && LA2_1<=MOD)||LA2_1==NE||LA2_1==OR||(LA2_1>=TO && LA2_1<=TREAT)||LA2_1==UNION||LA2_1==CONTAINS||(LA2_1>=CONCAT && LA2_1<=LPAREN)||LA2_1==LSQUARE||LA2_1==EQUAL||LA2_1==NOTEQUAL||LA2_1==COMMA||(LA2_1>=STAR && LA2_1<=SLASH_SLASH)||LA2_1==COLON||LA2_1==VBAR) ) {s = 7;}

                            else if ( (LA2_1==SEMICOLON) && ((this.lc(XQS)))) {s = 8;}

                            else if ( (LA2_1==EOF) ) {s = 9;}

                             
                            input.seek(index2_1);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 2, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA6_eotS:
        "\u000a\uffff",
    DFA6_eofS:
        "\u0001\u0005\u0001\u0009\u0002\uffff\u0001\u0009\u0005\uffff",
    DFA6_minS:
        "\u0001\u0010\u0001\u0012\u0002\uffff\u0001\u0012\u0005\uffff",
    DFA6_maxS:
        "\u0001\u0154\u0001\u00fe\u0002\uffff\u0001\u00fe\u0005\uffff",
    DFA6_acceptS:
        "\u0002\uffff\u0002\u0002\u0001\uffff\u0001\u0002\u0002\u0001\u0002"+
    "\u0002",
    DFA6_specialS:
        "\u0001\u0002\u0001\u0000\u0002\uffff\u0001\u0001\u0005\uffff}>",
    DFA6_transitionS: [
            "\u0002\u0002\u0004\u0005\u0001\u0002\u0006\u0005\u0001\u0002"+
            "\u0001\u0005\u0001\u0002\u0002\u0005\u0001\u0001\u0001\u0005"+
            "\u0002\u0002\u0002\u0005\u0003\u0002\u0005\u0005\u0001\u0002"+
            "\u0002\u0005\u0003\u0002\u0005\u0005\u0001\u0002\u0001\u0004"+
            "\u0009\u0005\u0001\u0002\u0003\u0005\u0001\u0002\u0003\u0005"+
            "\u0001\u0002\u0004\u0005\u0001\u0002\u0001\u0005\u0003\u0002"+
            "\u0001\u0005\u0001\u0002\u0003\u0005\u0004\u0002\u0003\u0005"+
            "\u0001\u0002\u0003\u0005\u0001\u0002\u0001\u0005\u0003\u0002"+
            "\u000f\u0005\u0001\u0002\u0009\u0005\u0002\u0002\u0007\u0005"+
            "\u0002\u0002\u0001\u0005\u0001\u0002\u0004\u0005\u0002\u0002"+
            "\u0002\u0005\u0001\u0002\u002c\u0005\u0003\u0002\u0002\u0005"+
            "\u0001\u0002\u000a\u0005\u0001\u0002\u0003\u0005\u0001\uffff"+
            "\u0001\u0002\u0001\uffff\u0002\u0002\u0006\uffff\u0001\u0003"+
            "\u0004\uffff\u0004\u0002\u0005\uffff\u0004\u0002\u000c\uffff"+
            "\u0001\u0002\u0002\uffff\u0002\u0002\u0002\uffff\u0001\u0005"+
            "\u0006\uffff\u0006\u0002\u003b\uffff\u0001\u0005",
            "\u0001\u0005\u0004\uffff\u0002\u0007\u0002\uffff\u0002\u0005"+
            "\u0003\uffff\u0002\u0007\u0001\uffff\u0001\u0007\u0003\uffff"+
            "\u0001\u0005\u0007\uffff\u0001\u0005\u0001\uffff\u0001\u0005"+
            "\u0004\uffff\u0002\u0005\u0001\uffff\u0002\u0005\u0004\uffff"+
            "\u0003\u0005\u0002\uffff\u0001\u0005\u0002\uffff\u0002\u0005"+
            "\u0001\uffff\u0001\u0007\u0001\u0005\u0004\uffff\u0002\u0005"+
            "\u0002\uffff\u0001\u0007\u0011\uffff\u0002\u0005\u0001\uffff"+
            "\u0001\u0005\u0002\uffff\u0001\u0005\u0005\uffff\u0001\u0005"+
            "\u0001\uffff\u0001\u0007\u0024\uffff\u0001\u0006\u0001\uffff"+
            "\u0001\u0005\u0004\uffff\u0001\u0005\u0007\uffff\u0001\u0007"+
            "\u0026\uffff\u0001\u0005\u0003\uffff\u0002\u0005\u0007\uffff"+
            "\u0002\u0005\u0004\uffff\u0001\u0005\u0001\uffff\u0001\u0005"+
            "\u0001\uffff\u0002\u0005\u0002\uffff\u0001\u0005\u0001\uffff"+
            "\u000b\u0005\u0002\uffff\u0001\u0005\u0003\uffff\u0001\u0008"+
            "\u0001\u0005",
            "",
            "",
            "\u0001\u0009\u0008\uffff\u0002\u0009\u000a\uffff\u0001\u0009"+
            "\u0007\uffff\u0001\u0009\u0001\uffff\u0001\u0009\u0005\uffff"+
            "\u0001\u0009\u0001\uffff\u0002\u0009\u0004\uffff\u0003\u0009"+
            "\u0002\uffff\u0001\u0009\u0002\uffff\u0002\u0009\u0001\u0007"+
            "\u0001\uffff\u0001\u0009\u0005\uffff\u0001\u0009\u000a\uffff"+
            "\u0001\u0007\u0009\uffff\u0002\u0009\u0001\uffff\u0001\u0009"+
            "\u0036\uffff\u0001\u0009\u003b\uffff\u0002\u0009\u0004\uffff"+
            "\u0001\u0009\u0001\uffff\u0001\u0009\u0001\uffff\u0001\u0009"+
            "\u0003\uffff\u0001\u0009\u0001\uffff\u000b\u0009\u0002\uffff"+
            "\u0001\u0009\u0003\uffff\u0001\u0008\u0001\u0009",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA6_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA6_eotS),
    DFA6_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA6_eofS),
    DFA6_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA6_minS),
    DFA6_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA6_maxS),
    DFA6_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA6_acceptS),
    DFA6_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA6_specialS),
    DFA6_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA6_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA6_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA6 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 6;
    this.eot = XQueryParser.DFA6_eot;
    this.eof = XQueryParser.DFA6_eof;
    this.min = XQueryParser.DFA6_min;
    this.max = XQueryParser.DFA6_max;
    this.accept = XQueryParser.DFA6_accept;
    this.special = XQueryParser.DFA6_special;
    this.transition = XQueryParser.DFA6_transition;
};

org.antlr.lang.extend(XQueryParser.DFA6, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "()* loopback of 325:11: ( (dnd+= pm_DefaultNamespaceDecl | s+= p_Setter | nd+= pm_NamespaceDecl | i+= p_Import | fto+= pm_FTOptionDecl ) )*";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA6_1 = input.LA(1);

                             
                            var index6_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA6_1==REVALIDATION) && ((this.lc(XQU)))) {s = 6;}

                            else if ( ((LA6_1>=BASE_URI && LA6_1<=BOUNDARY_SPACE)||(LA6_1>=CONSTRUCTION && LA6_1<=COPY_NAMESPACES)||LA6_1==DEFAULT||LA6_1==NAMESPACE||LA6_1==ORDERING||LA6_1==DECIMAL_FORMAT||LA6_1==FT_OPTION) ) {s = 7;}

                            else if ( (LA6_1==AND||(LA6_1>=CAST && LA6_1<=CASTABLE)||LA6_1==DIV||LA6_1==EQ||LA6_1==EXCEPT||(LA6_1>=FUNCTION && LA6_1<=GE)||(LA6_1>=GT && LA6_1<=IDIV)||(LA6_1>=INSTANCE && LA6_1<=IS)||LA6_1==LE||(LA6_1>=LT && LA6_1<=MOD)||LA6_1==NE||(LA6_1>=OPTION && LA6_1<=OR)||(LA6_1>=TO && LA6_1<=TREAT)||LA6_1==UNION||LA6_1==VARIABLE||LA6_1==CONTEXT||LA6_1==UPDATING||LA6_1==CONTAINS||LA6_1==COLLECTION||(LA6_1>=INDEX && LA6_1<=INTEGRITY)||(LA6_1>=CONCAT && LA6_1<=LPAREN)||LA6_1==LSQUARE||LA6_1==EQUAL||(LA6_1>=NOTEQUAL && LA6_1<=ANN_PERCENT)||LA6_1==COMMA||(LA6_1>=STAR && LA6_1<=SLASH_SLASH)||LA6_1==COLON||LA6_1==VBAR) ) {s = 5;}

                            else if ( (LA6_1==SEMICOLON) && ((this.lc(XQS)))) {s = 8;}

                            else if ( (LA6_1==EOF) ) {s = 9;}

                             
                            input.seek(index6_1);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA6_4 = input.LA(1);

                             
                            var index6_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA6_4==EOF||LA6_4==AND||(LA6_4>=CAST && LA6_4<=CASTABLE)||LA6_4==DIV||LA6_4==EQ||LA6_4==EXCEPT||LA6_4==GE||(LA6_4>=GT && LA6_4<=IDIV)||(LA6_4>=INSTANCE && LA6_4<=IS)||LA6_4==LE||(LA6_4>=LT && LA6_4<=MOD)||LA6_4==NE||LA6_4==OR||(LA6_4>=TO && LA6_4<=TREAT)||LA6_4==UNION||LA6_4==CONTAINS||(LA6_4>=CONCAT && LA6_4<=LPAREN)||LA6_4==LSQUARE||LA6_4==EQUAL||LA6_4==NOTEQUAL||LA6_4==COMMA||(LA6_4>=STAR && LA6_4<=SLASH_SLASH)||LA6_4==COLON||LA6_4==VBAR) ) {s = 9;}

                            else if ( (LA6_4==SEMICOLON) && ((this.lc(XQS)))) {s = 8;}

                            else if ( (LA6_4==MODULE||LA6_4==SCHEMA) ) {s = 7;}

                             
                            input.seek(index6_4);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA6_0 = input.LA(1);

                             
                            var index6_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA6_0==DECLARE) ) {s = 1;}

                            else if ( ((LA6_0>=ANCESTOR && LA6_0<=ANCESTOR_OR_SELF)||LA6_0==ATTRIBUTE||LA6_0==CHILD||LA6_0==COMMENT||(LA6_0>=DESCENDANT && LA6_0<=DESCENDANT_OR_SELF)||(LA6_0>=DOCUMENT && LA6_0<=ELEMENT)||LA6_0==EVERY||(LA6_0>=FOLLOWING && LA6_0<=FOR)||LA6_0==IF||LA6_0==LET||LA6_0==NAMESPACE||LA6_0==NODE||LA6_0==ORDERED||(LA6_0>=PARENT && LA6_0<=PRECEDING_SIBLING)||LA6_0==PROCESSING_INSTRUCTION||(LA6_0>=SCHEMA_ATTRIBUTE && LA6_0<=SOME)||LA6_0==TEXT||LA6_0==TYPESWITCH||(LA6_0>=UNORDERED && LA6_0<=VARIABLE)||LA6_0==NAMESPACE_NODE||(LA6_0>=SWITCH && LA6_0<=TRY)||(LA6_0>=COPY && LA6_0<=DELETE)||LA6_0==INSERT||(LA6_0>=RENAME && LA6_0<=REPLACE)||LA6_0==UPDATING||(LA6_0>=BREAK && LA6_0<=EXIT)||LA6_0==WHILE||LA6_0==BINARY||LA6_0==LPAREN||(LA6_0>=DOLLAR && LA6_0<=LBRACKET)||(LA6_0>=STAR && LA6_0<=SMALLER)||(LA6_0>=SLASH && LA6_0<=DOT_DOT)||LA6_0==ATTR_SIGN||(LA6_0>=APOS && LA6_0<=QUOT)||(LA6_0>=L_Pragma && LA6_0<=L_DoubleLiteral)) ) {s = 2;}

                            else if ( (LA6_0==ANN_PERCENT) && ((this.lc(XQS)))) {s = 3;}

                            else if ( (LA6_0==IMPORT) ) {s = 4;}

                            else if ( (LA6_0==EOF||(LA6_0>=AND && LA6_0<=AT)||(LA6_0>=BASE_URI && LA6_0<=CASTABLE)||LA6_0==COLLATION||(LA6_0>=CONSTRUCTION && LA6_0<=COPY_NAMESPACES)||LA6_0==DEFAULT||(LA6_0>=DESCENDING && LA6_0<=DIV)||(LA6_0>=ELSE && LA6_0<=EQ)||(LA6_0>=EXCEPT && LA6_0<=EXTERNAL)||(LA6_0>=FUNCTION && LA6_0<=IDIV)||(LA6_0>=IN && LA6_0<=LEAST)||(LA6_0>=LT && LA6_0<=MODULE)||(LA6_0>=NE && LA6_0<=NO_PRESERVE)||(LA6_0>=OF && LA6_0<=ORDER)||LA6_0==ORDERING||LA6_0==PRESERVE||(LA6_0>=RETURN && LA6_0<=SCHEMA)||(LA6_0>=STABLE && LA6_0<=STRIP)||(LA6_0>=THEN && LA6_0<=TREAT)||LA6_0==UNION||(LA6_0>=VERSION && LA6_0<=MINUS_SIGN)||(LA6_0>=NAN && LA6_0<=START)||(LA6_0>=TUMBLING && LA6_0<=BEFORE)||LA6_0==FIRST||(LA6_0>=INTO && LA6_0<=NODES)||(LA6_0>=REVALIDATION && LA6_0<=SKIP)||(LA6_0>=VALUE && LA6_0<=WORDS)||(LA6_0>=LOOP && LA6_0<=RETURNING)||(LA6_0>=CHECK && LA6_0<=UNIQUE)||(LA6_0>=AMP_ER && LA6_0<=QUOT_ER)||LA6_0==L_NCName||LA6_0==EXPLICITLY) ) {s = 5;}

                             
                            input.seek(index6_0);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 6, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA9_eotS:
        "\u000c\uffff",
    DFA9_eofS:
        "\u000c\uffff",
    DFA9_minS:
        "\u0001\u0022\u0001\u0017\u0002\uffff\u0001\u001e\u0007\uffff",
    DFA9_maxS:
        "\u0001\u0022\u0001\u0099\u0002\uffff\u0001\u0074\u0007\uffff",
    DFA9_acceptS:
        "\u0002\uffff\u0001\u0007\u0001\u0001\u0001\uffff\u0001\u0003\u0001"+
    "\u0004\u0001\u0005\u0001\u0008\u0001\u0009\u0001\u0002\u0001\u0006",
    DFA9_specialS:
        "\u0001\uffff\u0001\u0000\u000a\uffff}>",
    DFA9_transitionS: [
            "\u0001\u0001",
            "\u0001\u0005\u0001\u0003\u0007\uffff\u0001\u0006\u0001\u0008"+
            "\u0001\uffff\u0001\u0004\u0030\uffff\u0001\u0007\u001f\uffff"+
            "\u0001\u0009\u0024\uffff\u0001\u0002",
            "",
            "",
            "\u0001\u000a\u0033\uffff\u0001\u000b\u0021\uffff\u0001\u0009",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA9_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA9_eotS),
    DFA9_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA9_eofS),
    DFA9_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA9_minS),
    DFA9_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA9_maxS),
    DFA9_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA9_acceptS),
    DFA9_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA9_specialS),
    DFA9_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA9_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA9_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA9 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 9;
    this.eot = XQueryParser.DFA9_eot;
    this.eof = XQueryParser.DFA9_eof;
    this.min = XQueryParser.DFA9_min;
    this.max = XQueryParser.DFA9_max;
    this.accept = XQueryParser.DFA9_accept;
    this.special = XQueryParser.DFA9_special;
    this.transition = XQueryParser.DFA9_transition;
};

org.antlr.lang.extend(XQueryParser.DFA9, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "351:1: p_Setter : ( pm_BoundarySpaceDecl | pm_DefaultCollationDecl | pm_BaseURIDecl | pm_ConstructionDecl | pm_OrderingModeDecl | pm_EmptyOrderDecl | {...}? => pm_RevalidationDecl | pm_CopyNamespacesDecl | pm_DecimalFormatDecl );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA9_1 = input.LA(1);

                             
                            var index9_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA9_1==REVALIDATION) && ((this.lc(XQU)))) {s = 2;}

                            else if ( (LA9_1==BOUNDARY_SPACE) ) {s = 3;}

                            else if ( (LA9_1==DEFAULT) ) {s = 4;}

                            else if ( (LA9_1==BASE_URI) ) {s = 5;}

                            else if ( (LA9_1==CONSTRUCTION) ) {s = 6;}

                            else if ( (LA9_1==ORDERING) ) {s = 7;}

                            else if ( (LA9_1==COPY_NAMESPACES) ) {s = 8;}

                            else if ( (LA9_1==DECIMAL_FORMAT) ) {s = 9;}

                             
                            input.seek(index9_1);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 9, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA44_eotS:
        "\u0048\uffff",
    DFA44_eofS:
        "\u0001\u0043\u0047\uffff",
    DFA44_minS:
        "\u0001\u0010\u0042\u0000\u0001\uffff\u0002\u0000\u0002\uffff",
    DFA44_maxS:
        "\u0001\u0154\u0042\u0000\u0001\uffff\u0002\u0000\u0002\uffff",
    DFA44_acceptS:
        "\u0043\uffff\u0001\u0001\u0003\uffff\u0001\u0002",
    DFA44_specialS:
        "\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001"+
    "\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001"+
    "\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001"+
    "\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0001"+
    "\u0017\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u001b\u0001\u001c\u0001"+
    "\u001d\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021\u0001\u0022\u0001"+
    "\u0023\u0001\u0024\u0001\u0025\u0001\u0026\u0001\u0027\u0001\u0028\u0001"+
    "\u0029\u0001\u002a\u0001\u002b\u0001\u002c\u0001\u002d\u0001\u002e\u0001"+
    "\u002f\u0001\u0030\u0001\u0031\u0001\u0032\u0001\u0033\u0001\u0034\u0001"+
    "\u0035\u0001\u0036\u0001\u0037\u0001\u0038\u0001\u0039\u0001\u003a\u0001"+
    "\u003b\u0001\u003c\u0001\u003d\u0001\u003e\u0001\u003f\u0001\u0040\u0001"+
    "\u0041\u0001\u0042\u0001\uffff\u0001\u0043\u0001\u0044\u0002\uffff}>",
    DFA44_transitionS: [
            "\u0001\u0027\u0001\u002a\u0004\u0044\u0001\u001f\u0006\u0044"+
            "\u0001\u002b\u0001\u0044\u0001\u0022\u0004\u0044\u0001\u002d"+
            "\u0001\u002f\u0002\u0044\u0001\u001a\u0001\u0024\u0001\u0017"+
            "\u0002\u0044\u0001\u0045\u0002\u0044\u0001\u0008\u0002\u0044"+
            "\u0001\u0031\u0001\u0030\u0001\u0001\u0005\u0044\u0001\u0003"+
            "\u0006\u0044\u0001\u0045\u0003\u0044\u0001\u0002\u0003\u0044"+
            "\u0001\u001e\u0003\u0044\u0001\u0037\u0004\u0044\u0001\u0016"+
            "\u0001\u0044\u0001\u0025\u0001\u0029\u0001\u0028\u0001\u0044"+
            "\u0001\u0023\u0003\u0044\u0001\u0035\u0001\u0034\u0001\u002e"+
            "\u0001\u0007\u0003\u0044\u0001\u0020\u0003\u0044\u0001\u0005"+
            "\u0001\u0044\u0001\u0019\u0001\u000b\u0001\u0042\u000f\u0044"+
            "\u0001\u0036\u0009\u0044\u0001\u0004\u0001\u0006\u0007\u0044"+
            "\u0001\u003e\u0001\u003b\u0001\u0044\u0001\u0032\u0004\u0044"+
            "\u0001\u003c\u0001\u003d\u0002\u0044\u0001\u0018\u002c\u0044"+
            "\u0001\u003f\u0001\u0040\u0001\u0041\u0002\u0044\u0001\u0038"+
            "\u000a\u0044\u0001\u0021\u0003\u0044\u0001\uffff\u0001\u000e"+
            "\u0001\uffff\u0001\u0014\u0001\u0026\u0006\uffff\u0001\u0043"+
            "\u0004\uffff\u0001\u0039\u0001\u0009\u0001\u000a\u0001\u001b"+
            "\u0005\uffff\u0001\u000c\u0001\u000d\u0001\u0015\u0001\u002c"+
            "\u000c\uffff\u0001\u0033\u0002\uffff\u0001\u0013\u0001\u0012"+
            "\u0002\uffff\u0001\u0044\u0006\uffff\u0001\u003a\u0001\u001c"+
            "\u0001\u001d\u0001\u000f\u0001\u0010\u0001\u0011\u003b\uffff"+
            "\u0001\u0044",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "",
            "\u0001\uffff",
            "\u0001\uffff",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA44_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA44_eotS),
    DFA44_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA44_eofS),
    DFA44_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA44_minS),
    DFA44_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA44_maxS),
    DFA44_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA44_acceptS),
    DFA44_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA44_specialS),
    DFA44_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA44_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA44_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA44 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 44;
    this.eot = XQueryParser.DFA44_eot;
    this.eof = XQueryParser.DFA44_eof;
    this.min = XQueryParser.DFA44_min;
    this.max = XQueryParser.DFA44_max;
    this.accept = XQueryParser.DFA44_accept;
    this.special = XQueryParser.DFA44_special;
    this.transition = XQueryParser.DFA44_transition;
};

org.antlr.lang.extend(XQueryParser.DFA44, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "530:1: pm_QueryBody : ({...}? => p_Program | p_Expr[true,true] );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA44_0 = input.LA(1);

                             
                            var index44_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA44_0==FOR) ) {s = 1;}

                            else if ( (LA44_0==LET) ) {s = 2;}

                            else if ( (LA44_0==IF) ) {s = 3;}

                            else if ( (LA44_0==SWITCH) ) {s = 4;}

                            else if ( (LA44_0==TYPESWITCH) ) {s = 5;}

                            else if ( (LA44_0==TRY) ) {s = 6;}

                            else if ( (LA44_0==SOME) ) {s = 7;}

                            else if ( (LA44_0==EVERY) ) {s = 8;}

                            else if ( (LA44_0==PLUS) ) {s = 9;}

                            else if ( (LA44_0==MINUS) ) {s = 10;}

                            else if ( (LA44_0==VALIDATE) ) {s = 11;}

                            else if ( (LA44_0==SLASH) ) {s = 12;}

                            else if ( (LA44_0==SLASH_SLASH) ) {s = 13;}

                            else if ( (LA44_0==LPAREN) ) {s = 14;}

                            else if ( (LA44_0==L_IntegerLiteral) ) {s = 15;}

                            else if ( (LA44_0==L_DecimalLiteral) ) {s = 16;}

                            else if ( (LA44_0==L_DoubleLiteral) ) {s = 17;}

                            else if ( (LA44_0==QUOT) ) {s = 18;}

                            else if ( (LA44_0==APOS) ) {s = 19;}

                            else if ( (LA44_0==DOLLAR) ) {s = 20;}

                            else if ( (LA44_0==DOT) ) {s = 21;}

                            else if ( (LA44_0==ORDERED) ) {s = 22;}

                            else if ( (LA44_0==ELEMENT) ) {s = 23;}

                            else if ( (LA44_0==UPDATING) ) {s = 24;}

                            else if ( (LA44_0==UNORDERED) ) {s = 25;}

                            else if ( (LA44_0==DOCUMENT) ) {s = 26;}

                            else if ( (LA44_0==SMALLER) ) {s = 27;}

                            else if ( (LA44_0==L_DirCommentConstructor) ) {s = 28;}

                            else if ( (LA44_0==L_DirPIConstructor) ) {s = 29;}

                            else if ( (LA44_0==NAMESPACE) ) {s = 30;}

                            else if ( (LA44_0==ATTRIBUTE) ) {s = 31;}

                            else if ( (LA44_0==TEXT) ) {s = 32;}

                            else if ( (LA44_0==BINARY) ) {s = 33;}

                            else if ( (LA44_0==COMMENT) ) {s = 34;}

                            else if ( (LA44_0==PROCESSING_INSTRUCTION) ) {s = 35;}

                            else if ( (LA44_0==DOCUMENT_NODE) ) {s = 36;}

                            else if ( (LA44_0==PARENT) ) {s = 37;}

                            else if ( (LA44_0==LBRACKET) ) {s = 38;}

                            else if ( (LA44_0==ANCESTOR) ) {s = 39;}

                            else if ( (LA44_0==PRECEDING_SIBLING) ) {s = 40;}

                            else if ( (LA44_0==PRECEDING) ) {s = 41;}

                            else if ( (LA44_0==ANCESTOR_OR_SELF) ) {s = 42;}

                            else if ( (LA44_0==CHILD) ) {s = 43;}

                            else if ( (LA44_0==DOT_DOT) ) {s = 44;}

                            else if ( (LA44_0==DESCENDANT) ) {s = 45;}

                            else if ( (LA44_0==SELF) ) {s = 46;}

                            else if ( (LA44_0==DESCENDANT_OR_SELF) ) {s = 47;}

                            else if ( (LA44_0==FOLLOWING_SIBLING) ) {s = 48;}

                            else if ( (LA44_0==FOLLOWING) ) {s = 49;}

                            else if ( (LA44_0==INSERT) ) {s = 50;}

                            else if ( (LA44_0==ATTR_SIGN) ) {s = 51;}

                            else if ( (LA44_0==SCHEMA_ELEMENT) ) {s = 52;}

                            else if ( (LA44_0==SCHEMA_ATTRIBUTE) ) {s = 53;}

                            else if ( (LA44_0==NAMESPACE_NODE) ) {s = 54;}

                            else if ( (LA44_0==NODE) ) {s = 55;}

                            else if ( (LA44_0==WHILE) ) {s = 56;}

                            else if ( (LA44_0==STAR) ) {s = 57;}

                            else if ( (LA44_0==L_Pragma) ) {s = 58;}

                            else if ( (LA44_0==DELETE) ) {s = 59;}

                            else if ( (LA44_0==RENAME) ) {s = 60;}

                            else if ( (LA44_0==REPLACE) ) {s = 61;}

                            else if ( (LA44_0==COPY) ) {s = 62;}

                            else if ( (LA44_0==BREAK) ) {s = 63;}

                            else if ( (LA44_0==CONTINUE) ) {s = 64;}

                            else if ( (LA44_0==EXIT) ) {s = 65;}

                            else if ( (LA44_0==VARIABLE) ) {s = 66;}

                            else if ( (LA44_0==EOF||LA44_0==ANN_PERCENT) && ((this.lc(XQS)))) {s = 67;}

                            else if ( ((LA44_0>=AND && LA44_0<=AT)||(LA44_0>=BASE_URI && LA44_0<=CASTABLE)||LA44_0==COLLATION||(LA44_0>=CONSTRUCTION && LA44_0<=DEFAULT)||(LA44_0>=DESCENDING && LA44_0<=DIV)||(LA44_0>=ELSE && LA44_0<=EMPTY)||(LA44_0>=ENCODING && LA44_0<=EQ)||(LA44_0>=EXCEPT && LA44_0<=EXTERNAL)||(LA44_0>=FUNCTION && LA44_0<=IDIV)||(LA44_0>=IMPORT && LA44_0<=IS)||(LA44_0>=LAX && LA44_0<=LEAST)||(LA44_0>=LT && LA44_0<=MODULE)||(LA44_0>=NE && LA44_0<=NO_PRESERVE)||(LA44_0>=OF && LA44_0<=ORDER)||LA44_0==ORDERING||LA44_0==PRESERVE||(LA44_0>=RETURN && LA44_0<=SCHEMA)||(LA44_0>=STABLE && LA44_0<=STRIP)||(LA44_0>=THEN && LA44_0<=TREAT)||LA44_0==UNION||(LA44_0>=VERSION && LA44_0<=MINUS_SIGN)||(LA44_0>=NAN && LA44_0<=START)||(LA44_0>=TUMBLING && LA44_0<=BEFORE)||LA44_0==FIRST||(LA44_0>=INTO && LA44_0<=NODES)||(LA44_0>=REVALIDATION && LA44_0<=SKIP)||(LA44_0>=VALUE && LA44_0<=WORDS)||(LA44_0>=LOOP && LA44_0<=RETURNING)||(LA44_0>=CHECK && LA44_0<=UNIQUE)||(LA44_0>=AMP_ER && LA44_0<=QUOT_ER)||LA44_0==L_NCName||LA44_0==EXPLICITLY) ) {s = 68;}

                            else if ( (LA44_0==EMPTY_SEQUENCE||LA44_0==ITEM) ) {s = 69;}

                             
                            input.seek(index44_0);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA44_1 = input.LA(1);

                             
                            var index44_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_1);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA44_2 = input.LA(1);

                             
                            var index44_2 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_2);
                            if ( s>=0 ) return s;
                            break;
                        case 3 : 
                            var LA44_3 = input.LA(1);

                             
                            var index44_3 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_3);
                            if ( s>=0 ) return s;
                            break;
                        case 4 : 
                            var LA44_4 = input.LA(1);

                             
                            var index44_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_4);
                            if ( s>=0 ) return s;
                            break;
                        case 5 : 
                            var LA44_5 = input.LA(1);

                             
                            var index44_5 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_5);
                            if ( s>=0 ) return s;
                            break;
                        case 6 : 
                            var LA44_6 = input.LA(1);

                             
                            var index44_6 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_6);
                            if ( s>=0 ) return s;
                            break;
                        case 7 : 
                            var LA44_7 = input.LA(1);

                             
                            var index44_7 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_7);
                            if ( s>=0 ) return s;
                            break;
                        case 8 : 
                            var LA44_8 = input.LA(1);

                             
                            var index44_8 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_8);
                            if ( s>=0 ) return s;
                            break;
                        case 9 : 
                            var LA44_9 = input.LA(1);

                             
                            var index44_9 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_9);
                            if ( s>=0 ) return s;
                            break;
                        case 10 : 
                            var LA44_10 = input.LA(1);

                             
                            var index44_10 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_10);
                            if ( s>=0 ) return s;
                            break;
                        case 11 : 
                            var LA44_11 = input.LA(1);

                             
                            var index44_11 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_11);
                            if ( s>=0 ) return s;
                            break;
                        case 12 : 
                            var LA44_12 = input.LA(1);

                             
                            var index44_12 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_12);
                            if ( s>=0 ) return s;
                            break;
                        case 13 : 
                            var LA44_13 = input.LA(1);

                             
                            var index44_13 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_13);
                            if ( s>=0 ) return s;
                            break;
                        case 14 : 
                            var LA44_14 = input.LA(1);

                             
                            var index44_14 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_14);
                            if ( s>=0 ) return s;
                            break;
                        case 15 : 
                            var LA44_15 = input.LA(1);

                             
                            var index44_15 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_15);
                            if ( s>=0 ) return s;
                            break;
                        case 16 : 
                            var LA44_16 = input.LA(1);

                             
                            var index44_16 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_16);
                            if ( s>=0 ) return s;
                            break;
                        case 17 : 
                            var LA44_17 = input.LA(1);

                             
                            var index44_17 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_17);
                            if ( s>=0 ) return s;
                            break;
                        case 18 : 
                            var LA44_18 = input.LA(1);

                             
                            var index44_18 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_18);
                            if ( s>=0 ) return s;
                            break;
                        case 19 : 
                            var LA44_19 = input.LA(1);

                             
                            var index44_19 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_19);
                            if ( s>=0 ) return s;
                            break;
                        case 20 : 
                            var LA44_20 = input.LA(1);

                             
                            var index44_20 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_20);
                            if ( s>=0 ) return s;
                            break;
                        case 21 : 
                            var LA44_21 = input.LA(1);

                             
                            var index44_21 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_21);
                            if ( s>=0 ) return s;
                            break;
                        case 22 : 
                            var LA44_22 = input.LA(1);

                             
                            var index44_22 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_22);
                            if ( s>=0 ) return s;
                            break;
                        case 23 : 
                            var LA44_23 = input.LA(1);

                             
                            var index44_23 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_23);
                            if ( s>=0 ) return s;
                            break;
                        case 24 : 
                            var LA44_24 = input.LA(1);

                             
                            var index44_24 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_24);
                            if ( s>=0 ) return s;
                            break;
                        case 25 : 
                            var LA44_25 = input.LA(1);

                             
                            var index44_25 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_25);
                            if ( s>=0 ) return s;
                            break;
                        case 26 : 
                            var LA44_26 = input.LA(1);

                             
                            var index44_26 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_26);
                            if ( s>=0 ) return s;
                            break;
                        case 27 : 
                            var LA44_27 = input.LA(1);

                             
                            var index44_27 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_27);
                            if ( s>=0 ) return s;
                            break;
                        case 28 : 
                            var LA44_28 = input.LA(1);

                             
                            var index44_28 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_28);
                            if ( s>=0 ) return s;
                            break;
                        case 29 : 
                            var LA44_29 = input.LA(1);

                             
                            var index44_29 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_29);
                            if ( s>=0 ) return s;
                            break;
                        case 30 : 
                            var LA44_30 = input.LA(1);

                             
                            var index44_30 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_30);
                            if ( s>=0 ) return s;
                            break;
                        case 31 : 
                            var LA44_31 = input.LA(1);

                             
                            var index44_31 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_31);
                            if ( s>=0 ) return s;
                            break;
                        case 32 : 
                            var LA44_32 = input.LA(1);

                             
                            var index44_32 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_32);
                            if ( s>=0 ) return s;
                            break;
                        case 33 : 
                            var LA44_33 = input.LA(1);

                             
                            var index44_33 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((((this.lc(XQS))&&(this.lc(MLS)))||((this.lc(XQS))&&(this.lc(MLS)))||(this.lc(XQS))||((this.lc(XQS))&&(this.lc(MLS)))||((this.lc(XQS))&&(this.lc(MLS))))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_33);
                            if ( s>=0 ) return s;
                            break;
                        case 34 : 
                            var LA44_34 = input.LA(1);

                             
                            var index44_34 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_34);
                            if ( s>=0 ) return s;
                            break;
                        case 35 : 
                            var LA44_35 = input.LA(1);

                             
                            var index44_35 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_35);
                            if ( s>=0 ) return s;
                            break;
                        case 36 : 
                            var LA44_36 = input.LA(1);

                             
                            var index44_36 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_36);
                            if ( s>=0 ) return s;
                            break;
                        case 37 : 
                            var LA44_37 = input.LA(1);

                             
                            var index44_37 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_37);
                            if ( s>=0 ) return s;
                            break;
                        case 38 : 
                            var LA44_38 = input.LA(1);

                             
                            var index44_38 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_38);
                            if ( s>=0 ) return s;
                            break;
                        case 39 : 
                            var LA44_39 = input.LA(1);

                             
                            var index44_39 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_39);
                            if ( s>=0 ) return s;
                            break;
                        case 40 : 
                            var LA44_40 = input.LA(1);

                             
                            var index44_40 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_40);
                            if ( s>=0 ) return s;
                            break;
                        case 41 : 
                            var LA44_41 = input.LA(1);

                             
                            var index44_41 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_41);
                            if ( s>=0 ) return s;
                            break;
                        case 42 : 
                            var LA44_42 = input.LA(1);

                             
                            var index44_42 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_42);
                            if ( s>=0 ) return s;
                            break;
                        case 43 : 
                            var LA44_43 = input.LA(1);

                             
                            var index44_43 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_43);
                            if ( s>=0 ) return s;
                            break;
                        case 44 : 
                            var LA44_44 = input.LA(1);

                             
                            var index44_44 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_44);
                            if ( s>=0 ) return s;
                            break;
                        case 45 : 
                            var LA44_45 = input.LA(1);

                             
                            var index44_45 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_45);
                            if ( s>=0 ) return s;
                            break;
                        case 46 : 
                            var LA44_46 = input.LA(1);

                             
                            var index44_46 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_46);
                            if ( s>=0 ) return s;
                            break;
                        case 47 : 
                            var LA44_47 = input.LA(1);

                             
                            var index44_47 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_47);
                            if ( s>=0 ) return s;
                            break;
                        case 48 : 
                            var LA44_48 = input.LA(1);

                             
                            var index44_48 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_48);
                            if ( s>=0 ) return s;
                            break;
                        case 49 : 
                            var LA44_49 = input.LA(1);

                             
                            var index44_49 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_49);
                            if ( s>=0 ) return s;
                            break;
                        case 50 : 
                            var LA44_50 = input.LA(1);

                             
                            var index44_50 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((((this.lc(XQS))&&(this.lc(XQU)))||(this.lc(XQS)))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_50);
                            if ( s>=0 ) return s;
                            break;
                        case 51 : 
                            var LA44_51 = input.LA(1);

                             
                            var index44_51 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_51);
                            if ( s>=0 ) return s;
                            break;
                        case 52 : 
                            var LA44_52 = input.LA(1);

                             
                            var index44_52 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_52);
                            if ( s>=0 ) return s;
                            break;
                        case 53 : 
                            var LA44_53 = input.LA(1);

                             
                            var index44_53 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_53);
                            if ( s>=0 ) return s;
                            break;
                        case 54 : 
                            var LA44_54 = input.LA(1);

                             
                            var index44_54 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_54);
                            if ( s>=0 ) return s;
                            break;
                        case 55 : 
                            var LA44_55 = input.LA(1);

                             
                            var index44_55 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_55);
                            if ( s>=0 ) return s;
                            break;
                        case 56 : 
                            var LA44_56 = input.LA(1);

                             
                            var index44_56 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_56);
                            if ( s>=0 ) return s;
                            break;
                        case 57 : 
                            var LA44_57 = input.LA(1);

                             
                            var index44_57 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_57);
                            if ( s>=0 ) return s;
                            break;
                        case 58 : 
                            var LA44_58 = input.LA(1);

                             
                            var index44_58 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_58);
                            if ( s>=0 ) return s;
                            break;
                        case 59 : 
                            var LA44_59 = input.LA(1);

                             
                            var index44_59 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((((this.lc(XQS))&&(this.lc(XQU)))||(this.lc(XQS)))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_59);
                            if ( s>=0 ) return s;
                            break;
                        case 60 : 
                            var LA44_60 = input.LA(1);

                             
                            var index44_60 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((((this.lc(XQS))&&(this.lc(XQU)))||(this.lc(XQS)))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_60);
                            if ( s>=0 ) return s;
                            break;
                        case 61 : 
                            var LA44_61 = input.LA(1);

                             
                            var index44_61 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((((this.lc(XQS))&&(this.lc(XQU)))||(this.lc(XQS)))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_61);
                            if ( s>=0 ) return s;
                            break;
                        case 62 : 
                            var LA44_62 = input.LA(1);

                             
                            var index44_62 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((((this.lc(XQS))&&(this.lc(XQU)))||(this.lc(XQS)))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_62);
                            if ( s>=0 ) return s;
                            break;
                        case 63 : 
                            var LA44_63 = input.LA(1);

                             
                            var index44_63 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_63);
                            if ( s>=0 ) return s;
                            break;
                        case 64 : 
                            var LA44_64 = input.LA(1);

                             
                            var index44_64 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_64);
                            if ( s>=0 ) return s;
                            break;
                        case 65 : 
                            var LA44_65 = input.LA(1);

                             
                            var index44_65 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_65);
                            if ( s>=0 ) return s;
                            break;
                        case 66 : 
                            var LA44_66 = input.LA(1);

                             
                            var index44_66 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_66);
                            if ( s>=0 ) return s;
                            break;
                        case 67 : 
                            var LA44_68 = input.LA(1);

                             
                            var index44_68 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_68);
                            if ( s>=0 ) return s;
                            break;
                        case 68 : 
                            var LA44_69 = input.LA(1);

                             
                            var index44_69 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.lc(XQS))) ) {s = 67;}

                            else if ( (true) ) {s = 71;}

                             
                            input.seek(index44_69);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 44, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA46_eotS:
        "\u0011\uffff",
    DFA46_eofS:
        "\u0001\uffff\u0006\u0007\u000a\uffff",
    DFA46_minS:
        "\u0001\u0010\u0006\u0012\u000a\uffff",
    DFA46_maxS:
        "\u0001\u0154\u0006\u00fe\u000a\uffff",
    DFA46_acceptS:
        "\u0007\uffff\u0001\u0006\u0005\u0001\u0001\u0002\u0001\u0003\u0001"+
    "\u0004\u0001\u0005",
    DFA46_specialS:
        "\u0001\uffff\u0001\u0002\u0001\u0004\u0001\u0001\u0001\u0003\u0001"+
    "\u0000\u0001\u0005\u000a\uffff}>",
    DFA46_transitionS: [
            "\u0025\u0007\u0001\u0001\u0005\u0007\u0001\u0003\u000a\u0007"+
            "\u0001\u0002\u0021\u0007\u0001\u0005\u001d\u0007\u0001\u0004"+
            "\u0001\u0006\u0054\u0007\u0001\uffff\u0001\u0007\u0001\uffff"+
            "\u0002\u0007\u000b\uffff\u0004\u0007\u0005\uffff\u0004\u0007"+
            "\u000c\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0002\uffff"+
            "\u0001\u0007\u0006\uffff\u0006\u0007\u003b\uffff\u0001\u0007",
            "\u0003\u0007\u0005\uffff\u0003\u0007\u0001\uffff\u0001\u0007"+
            "\u0004\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0002\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0003\uffff\u0001\u0007\u0001\uffff\u0001\u0007\u0001\uffff"+
            "\u0002\u0007\u0004\uffff\u0003\u0007\u0002\uffff\u0001\u0007"+
            "\u0001\uffff\u0003\u0007\u0002\uffff\u0001\u0007\u0005\uffff"+
            "\u0002\u0007\u0007\uffff\u0002\u0007\u0005\uffff\u0001\u0007"+
            "\u0004\uffff\u0002\u0007\u0001\uffff\u0001\u0007\u0004\uffff"+
            "\u0001\u0007\u0004\uffff\u0001\u0007\u0003\uffff\u0002\u0007"+
            "\u0006\uffff\u0001\u0007\u0004\uffff\u0001\u000a\u0001\u0007"+
            "\u0002\uffff\u0001\u0009\u0004\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0001\uffff\u0001\u0007\u0007\uffff\u0001\u0007"+
            "\u0002\uffff\u0001\u0007\u003b\uffff\u0003\u0007\u0001\u0008"+
            "\u0001\uffff\u0004\u0007\u0001\uffff\u0001\u0007\u0003\uffff"+
            "\u0001\u0007\u0001\uffff\u000b\u0007\u0002\uffff\u0001\u0007"+
            "\u0003\uffff\u0002\u0007",
            "\u0003\u0007\u0005\uffff\u0003\u0007\u0001\uffff\u0001\u0007"+
            "\u0004\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0002\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0003\uffff\u0001\u0007\u0001\uffff\u0001\u0007\u0001\uffff"+
            "\u0002\u0007\u0004\uffff\u0003\u0007\u0002\uffff\u0001\u0007"+
            "\u0001\uffff\u0003\u0007\u0002\uffff\u0001\u0007\u0005\uffff"+
            "\u0002\u0007\u0007\uffff\u0002\u0007\u0005\uffff\u0001\u0007"+
            "\u0004\uffff\u0002\u0007\u0001\uffff\u0001\u0007\u0004\uffff"+
            "\u0001\u0007\u0004\uffff\u0001\u0007\u0003\uffff\u0002\u0007"+
            "\u0006\uffff\u0001\u0007\u0005\uffff\u0001\u0007\u0007\uffff"+
            "\u0002\u0007\u0004\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0007\uffff\u0001\u0007\u0002\uffff\u0001\u0007\u0018\uffff"+
            "\u0001\u000c\u0022\uffff\u0003\u0007\u0001\u000b\u0001\uffff"+
            "\u0004\u0007\u0001\uffff\u0001\u0007\u0003\uffff\u0001\u0007"+
            "\u0001\uffff\u000b\u0007\u0002\uffff\u0001\u0007\u0003\uffff"+
            "\u0002\u0007",
            "\u0003\u0007\u0005\uffff\u0003\u0007\u0001\uffff\u0001\u0007"+
            "\u0004\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0002\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0003\uffff\u0001\u0007\u0001\uffff\u0001\u0007\u0001\uffff"+
            "\u0002\u0007\u0004\uffff\u0003\u0007\u0002\uffff\u0001\u0007"+
            "\u0001\uffff\u0003\u0007\u0002\uffff\u0001\u0007\u0005\uffff"+
            "\u0002\u0007\u0007\uffff\u0002\u0007\u0005\uffff\u0001\u0007"+
            "\u0004\uffff\u0002\u0007\u0001\uffff\u0001\u0007\u0004\uffff"+
            "\u0001\u0007\u0004\uffff\u0001\u0007\u0003\uffff\u0002\u0007"+
            "\u0006\uffff\u0001\u0007\u0005\uffff\u0001\u0007\u0007\uffff"+
            "\u0002\u0007\u0004\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0007\uffff\u0001\u0007\u0002\uffff\u0001\u0007\u003b\uffff"+
            "\u0001\u0007\u0001\u000d\u0001\u0007\u0002\uffff\u0004\u0007"+
            "\u0001\uffff\u0001\u0007\u0003\uffff\u0001\u0007\u0001\uffff"+
            "\u000b\u0007\u0002\uffff\u0001\u0007\u0003\uffff\u0002\u0007",
            "\u0003\u0007\u0005\uffff\u0003\u0007\u0001\uffff\u0001\u0007"+
            "\u0004\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0002\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0003\uffff\u0001\u0007\u0001\uffff\u0001\u0007\u0001\uffff"+
            "\u0002\u0007\u0004\uffff\u0003\u0007\u0002\uffff\u0001\u0007"+
            "\u0001\uffff\u0003\u0007\u0002\uffff\u0001\u0007\u0005\uffff"+
            "\u0002\u0007\u0007\uffff\u0002\u0007\u0005\uffff\u0001\u0007"+
            "\u0004\uffff\u0002\u0007\u0001\uffff\u0001\u0007\u0004\uffff"+
            "\u0001\u0007\u0004\uffff\u0001\u0007\u0003\uffff\u0002\u0007"+
            "\u0006\uffff\u0001\u0007\u0005\uffff\u0001\u0007\u0007\uffff"+
            "\u0002\u0007\u0004\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0007\uffff\u0001\u0007\u0002\uffff\u0001\u0007\u003b\uffff"+
            "\u0001\u0007\u0001\u000e\u0001\u0007\u0002\uffff\u0004\u0007"+
            "\u0001\uffff\u0001\u0007\u0003\uffff\u0001\u0007\u0001\uffff"+
            "\u000b\u0007\u0002\uffff\u0001\u0007\u0003\uffff\u0002\u0007",
            "\u0003\u0007\u0005\uffff\u0003\u0007\u0001\uffff\u0001\u0007"+
            "\u0004\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0002\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0003\uffff\u0001\u0007\u0001\uffff\u0001\u0007\u0001\uffff"+
            "\u0002\u0007\u0004\uffff\u0003\u0007\u0002\uffff\u0001\u0007"+
            "\u0001\uffff\u0003\u0007\u0002\uffff\u0001\u0007\u0005\uffff"+
            "\u0002\u0007\u0007\uffff\u0002\u0007\u0005\uffff\u0001\u0007"+
            "\u0004\uffff\u0002\u0007\u0001\uffff\u0001\u0007\u0004\uffff"+
            "\u0001\u0007\u0004\uffff\u0001\u0007\u0003\uffff\u0002\u0007"+
            "\u0006\uffff\u0001\u0007\u0005\uffff\u0001\u0007\u0007\uffff"+
            "\u0002\u0007\u0004\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0007\uffff\u0001\u0007\u0002\uffff\u0001\u0007\u003b\uffff"+
            "\u0001\u0007\u0001\u000f\u0001\u0007\u0002\uffff\u0004\u0007"+
            "\u0001\uffff\u0001\u0007\u0003\uffff\u0001\u0007\u0001\uffff"+
            "\u000b\u0007\u0002\uffff\u0001\u0007\u0003\uffff\u0002\u0007",
            "\u0003\u0007\u0005\uffff\u0003\u0007\u0001\uffff\u0001\u0007"+
            "\u0004\uffff\u0001\u0007\u0002\uffff\u0002\u0007\u0004\uffff"+
            "\u0001\u0007\u0002\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0003\uffff\u0001\u0007\u0001\uffff\u0001\u0007\u0001\uffff"+
            "\u0002\u0007\u0004\uffff\u0003\u0007\u0002\uffff\u0001\u0007"+
            "\u0001\uffff\u0003\u0007\u0002\uffff\u0001\u0007\u0005\uffff"+
            "\u0002\u0007\u0007\uffff\u0002\u0007\u0005\uffff\u0001\u0007"+
            "\u0004\uffff\u0002\u0007\u0001\uffff\u0001\u0007\u0004\uffff"+
            "\u0001\u0007\u0004\uffff\u0001\u0007\u0003\uffff\u0002\u0007"+
            "\u0006\uffff\u0001\u0007\u0005\uffff\u0001\u0007\u0007\uffff"+
            "\u0002\u0007\u0004\uffff\u0001\u0007\u0001\uffff\u0001\u0007"+
            "\u0007\uffff\u0001\u0007\u0002\uffff\u0001\u0007\u003b\uffff"+
            "\u0003\u0007\u0001\uffff\u0001\u0010\u0004\u0007\u0001\uffff"+
            "\u0001\u0007\u0003\uffff\u0001\u0007\u0001\uffff\u000b\u0007"+
            "\u0002\uffff\u0001\u0007\u0003\uffff\u0002\u0007",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA46_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA46_eotS),
    DFA46_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA46_eofS),
    DFA46_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA46_minS),
    DFA46_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA46_maxS),
    DFA46_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA46_acceptS),
    DFA46_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA46_specialS),
    DFA46_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA46_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA46_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA46 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 46;
    this.eot = XQueryParser.DFA46_eot;
    this.eof = XQueryParser.DFA46_eof;
    this.min = XQueryParser.DFA46_min;
    this.max = XQueryParser.DFA46_max;
    this.accept = XQueryParser.DFA46_accept;
    this.special = XQueryParser.DFA46_special;
    this.transition = XQueryParser.DFA46_transition;
};

org.antlr.lang.extend(XQueryParser.DFA46, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "566:1: p_ExprSingle[strict] : ( ( ( ( FOR | LET ) DOLLAR ) | ( FOR ( TUMBLING | SLIDING ) ) )=> p_FLWORHybrid[$strict] | ( IF LPAREN )=> p_IfHybrid[$strict] | ( SWITCH LPAREN )=> p_SwitchHybrid[$strict] | ( TYPESWITCH LPAREN )=> p_TypeswitchHybrid[$strict] | ( TRY LBRACKET )=> p_TryCatchHybrid[$strict] | p_ExprSimple );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA46_5 = input.LA(1);

                             
                            var index46_5 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA46_5==LPAREN) && (this.synpred4_XQueryParser())) {s = 15;}

                            else if ( (LA46_5==EOF||(LA46_5>=AND && LA46_5<=ASCENDING)||(LA46_5>=CASE && LA46_5<=CASTABLE)||LA46_5==COLLATION||LA46_5==DEFAULT||(LA46_5>=DESCENDING && LA46_5<=DIV)||LA46_5==EMPTY||LA46_5==EQ||LA46_5==EXCEPT||LA46_5==FOR||LA46_5==GE||(LA46_5>=GT && LA46_5<=IDIV)||(LA46_5>=INSTANCE && LA46_5<=IS)||LA46_5==LE||(LA46_5>=LET && LA46_5<=MOD)||LA46_5==NE||(LA46_5>=OR && LA46_5<=ORDER)||(LA46_5>=RETURN && LA46_5<=SATISFIES)||LA46_5==STABLE||(LA46_5>=TO && LA46_5<=TREAT)||LA46_5==UNION||LA46_5==WHERE||LA46_5==COUNT||(LA46_5>=END && LA46_5<=GROUP)||LA46_5==ONLY||LA46_5==START||(LA46_5>=AFTER && LA46_5<=BEFORE)||LA46_5==INTO||LA46_5==MODIFY||LA46_5==WITH||LA46_5==CONTAINS||LA46_5==CONCAT||LA46_5==RPAREN||(LA46_5>=RBRACKET && LA46_5<=EQUAL)||LA46_5==NOTEQUAL||LA46_5==COMMA||(LA46_5>=STAR && LA46_5<=SLASH_SLASH)||LA46_5==COLON||(LA46_5>=SEMICOLON && LA46_5<=VBAR)) ) {s = 7;}

                             
                            input.seek(index46_5);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA46_3 = input.LA(1);

                             
                            var index46_3 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA46_3==LPAREN) && (this.synpred2_XQueryParser())) {s = 13;}

                            else if ( (LA46_3==EOF||(LA46_3>=AND && LA46_3<=ASCENDING)||(LA46_3>=CASE && LA46_3<=CASTABLE)||LA46_3==COLLATION||LA46_3==DEFAULT||(LA46_3>=DESCENDING && LA46_3<=DIV)||LA46_3==EMPTY||LA46_3==EQ||LA46_3==EXCEPT||LA46_3==FOR||LA46_3==GE||(LA46_3>=GT && LA46_3<=IDIV)||(LA46_3>=INSTANCE && LA46_3<=IS)||LA46_3==LE||(LA46_3>=LET && LA46_3<=MOD)||LA46_3==NE||(LA46_3>=OR && LA46_3<=ORDER)||(LA46_3>=RETURN && LA46_3<=SATISFIES)||LA46_3==STABLE||(LA46_3>=TO && LA46_3<=TREAT)||LA46_3==UNION||LA46_3==WHERE||LA46_3==COUNT||(LA46_3>=END && LA46_3<=GROUP)||LA46_3==ONLY||LA46_3==START||(LA46_3>=AFTER && LA46_3<=BEFORE)||LA46_3==INTO||LA46_3==MODIFY||LA46_3==WITH||LA46_3==CONTAINS||LA46_3==CONCAT||LA46_3==RPAREN||(LA46_3>=RBRACKET && LA46_3<=EQUAL)||LA46_3==NOTEQUAL||LA46_3==COMMA||(LA46_3>=STAR && LA46_3<=SLASH_SLASH)||LA46_3==COLON||(LA46_3>=SEMICOLON && LA46_3<=VBAR)) ) {s = 7;}

                             
                            input.seek(index46_3);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA46_1 = input.LA(1);

                             
                            var index46_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA46_1==DOLLAR) && (this.synpred1_XQueryParser())) {s = 8;}

                            else if ( (LA46_1==TUMBLING) && (this.synpred1_XQueryParser())) {s = 9;}

                            else if ( (LA46_1==SLIDING) && (this.synpred1_XQueryParser())) {s = 10;}

                            else if ( (LA46_1==EOF||(LA46_1>=AND && LA46_1<=ASCENDING)||(LA46_1>=CASE && LA46_1<=CASTABLE)||LA46_1==COLLATION||LA46_1==DEFAULT||(LA46_1>=DESCENDING && LA46_1<=DIV)||LA46_1==EMPTY||LA46_1==EQ||LA46_1==EXCEPT||LA46_1==FOR||LA46_1==GE||(LA46_1>=GT && LA46_1<=IDIV)||(LA46_1>=INSTANCE && LA46_1<=IS)||LA46_1==LE||(LA46_1>=LET && LA46_1<=MOD)||LA46_1==NE||(LA46_1>=OR && LA46_1<=ORDER)||(LA46_1>=RETURN && LA46_1<=SATISFIES)||LA46_1==STABLE||(LA46_1>=TO && LA46_1<=TREAT)||LA46_1==UNION||LA46_1==WHERE||LA46_1==COUNT||(LA46_1>=END && LA46_1<=GROUP)||LA46_1==ONLY||LA46_1==START||(LA46_1>=AFTER && LA46_1<=BEFORE)||LA46_1==INTO||LA46_1==MODIFY||LA46_1==WITH||LA46_1==CONTAINS||(LA46_1>=CONCAT && LA46_1<=RPAREN)||(LA46_1>=RBRACKET && LA46_1<=EQUAL)||LA46_1==NOTEQUAL||LA46_1==COMMA||(LA46_1>=STAR && LA46_1<=SLASH_SLASH)||LA46_1==COLON||(LA46_1>=SEMICOLON && LA46_1<=VBAR)) ) {s = 7;}

                             
                            input.seek(index46_1);
                            if ( s>=0 ) return s;
                            break;
                        case 3 : 
                            var LA46_4 = input.LA(1);

                             
                            var index46_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA46_4==LPAREN) && (this.synpred3_XQueryParser())) {s = 14;}

                            else if ( (LA46_4==EOF||(LA46_4>=AND && LA46_4<=ASCENDING)||(LA46_4>=CASE && LA46_4<=CASTABLE)||LA46_4==COLLATION||LA46_4==DEFAULT||(LA46_4>=DESCENDING && LA46_4<=DIV)||LA46_4==EMPTY||LA46_4==EQ||LA46_4==EXCEPT||LA46_4==FOR||LA46_4==GE||(LA46_4>=GT && LA46_4<=IDIV)||(LA46_4>=INSTANCE && LA46_4<=IS)||LA46_4==LE||(LA46_4>=LET && LA46_4<=MOD)||LA46_4==NE||(LA46_4>=OR && LA46_4<=ORDER)||(LA46_4>=RETURN && LA46_4<=SATISFIES)||LA46_4==STABLE||(LA46_4>=TO && LA46_4<=TREAT)||LA46_4==UNION||LA46_4==WHERE||LA46_4==COUNT||(LA46_4>=END && LA46_4<=GROUP)||LA46_4==ONLY||LA46_4==START||(LA46_4>=AFTER && LA46_4<=BEFORE)||LA46_4==INTO||LA46_4==MODIFY||LA46_4==WITH||LA46_4==CONTAINS||LA46_4==CONCAT||LA46_4==RPAREN||(LA46_4>=RBRACKET && LA46_4<=EQUAL)||LA46_4==NOTEQUAL||LA46_4==COMMA||(LA46_4>=STAR && LA46_4<=SLASH_SLASH)||LA46_4==COLON||(LA46_4>=SEMICOLON && LA46_4<=VBAR)) ) {s = 7;}

                             
                            input.seek(index46_4);
                            if ( s>=0 ) return s;
                            break;
                        case 4 : 
                            var LA46_2 = input.LA(1);

                             
                            var index46_2 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA46_2==DOLLAR) && (this.synpred1_XQueryParser())) {s = 11;}

                            else if ( (LA46_2==SCORE) && (this.synpred1_XQueryParser())) {s = 12;}

                            else if ( (LA46_2==EOF||(LA46_2>=AND && LA46_2<=ASCENDING)||(LA46_2>=CASE && LA46_2<=CASTABLE)||LA46_2==COLLATION||LA46_2==DEFAULT||(LA46_2>=DESCENDING && LA46_2<=DIV)||LA46_2==EMPTY||LA46_2==EQ||LA46_2==EXCEPT||LA46_2==FOR||LA46_2==GE||(LA46_2>=GT && LA46_2<=IDIV)||(LA46_2>=INSTANCE && LA46_2<=IS)||LA46_2==LE||(LA46_2>=LET && LA46_2<=MOD)||LA46_2==NE||(LA46_2>=OR && LA46_2<=ORDER)||(LA46_2>=RETURN && LA46_2<=SATISFIES)||LA46_2==STABLE||(LA46_2>=TO && LA46_2<=TREAT)||LA46_2==UNION||LA46_2==WHERE||LA46_2==COUNT||(LA46_2>=END && LA46_2<=GROUP)||LA46_2==ONLY||LA46_2==START||(LA46_2>=AFTER && LA46_2<=BEFORE)||LA46_2==INTO||LA46_2==MODIFY||LA46_2==WITH||LA46_2==CONTAINS||(LA46_2>=CONCAT && LA46_2<=RPAREN)||(LA46_2>=RBRACKET && LA46_2<=EQUAL)||LA46_2==NOTEQUAL||LA46_2==COMMA||(LA46_2>=STAR && LA46_2<=SLASH_SLASH)||LA46_2==COLON||(LA46_2>=SEMICOLON && LA46_2<=VBAR)) ) {s = 7;}

                             
                            input.seek(index46_2);
                            if ( s>=0 ) return s;
                            break;
                        case 5 : 
                            var LA46_6 = input.LA(1);

                             
                            var index46_6 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA46_6==LBRACKET) && (this.synpred5_XQueryParser())) {s = 16;}

                            else if ( (LA46_6==EOF||(LA46_6>=AND && LA46_6<=ASCENDING)||(LA46_6>=CASE && LA46_6<=CASTABLE)||LA46_6==COLLATION||LA46_6==DEFAULT||(LA46_6>=DESCENDING && LA46_6<=DIV)||LA46_6==EMPTY||LA46_6==EQ||LA46_6==EXCEPT||LA46_6==FOR||LA46_6==GE||(LA46_6>=GT && LA46_6<=IDIV)||(LA46_6>=INSTANCE && LA46_6<=IS)||LA46_6==LE||(LA46_6>=LET && LA46_6<=MOD)||LA46_6==NE||(LA46_6>=OR && LA46_6<=ORDER)||(LA46_6>=RETURN && LA46_6<=SATISFIES)||LA46_6==STABLE||(LA46_6>=TO && LA46_6<=TREAT)||LA46_6==UNION||LA46_6==WHERE||LA46_6==COUNT||(LA46_6>=END && LA46_6<=GROUP)||LA46_6==ONLY||LA46_6==START||(LA46_6>=AFTER && LA46_6<=BEFORE)||LA46_6==INTO||LA46_6==MODIFY||LA46_6==WITH||LA46_6==CONTAINS||(LA46_6>=CONCAT && LA46_6<=RPAREN)||(LA46_6>=RBRACKET && LA46_6<=EQUAL)||LA46_6==NOTEQUAL||LA46_6==COMMA||(LA46_6>=STAR && LA46_6<=SLASH_SLASH)||LA46_6==COLON||(LA46_6>=SEMICOLON && LA46_6<=VBAR)) ) {s = 7;}

                             
                            input.seek(index46_6);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 46, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA116_eotS:
        "\u0031\uffff",
    DFA116_eofS:
        "\u0031\uffff",
    DFA116_minS:
        "\u0001\u0010\u0001\u0000\u002f\uffff",
    DFA116_maxS:
        "\u0001\u0154\u0001\u0000\u002f\uffff",
    DFA116_acceptS:
        "\u0002\uffff\u0001\u0003\u0001\u0004\u002b\uffff\u0001\u0001\u0001"+
    "\u0002",
    DFA116_specialS:
        "\u0001\uffff\u0001\u0000\u002f\uffff}>",
    DFA116_transitionS: [
            "\u00cc\u0003\u0001\uffff\u0001\u0003\u0001\uffff\u0002\u0003"+
            "\u000b\uffff\u0001\u0003\u0002\uffff\u0001\u0003\u0005\uffff"+
            "\u0001\u0001\u0001\u0002\u0002\u0003\u000c\uffff\u0001\u0003"+
            "\u0002\uffff\u0002\u0003\u0002\uffff\u0001\u0003\u0007\uffff"+
            "\u0005\u0003\u003b\uffff\u0001\u0003",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA116_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA116_eotS),
    DFA116_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA116_eofS),
    DFA116_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA116_minS),
    DFA116_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA116_maxS),
    DFA116_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA116_acceptS),
    DFA116_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA116_specialS),
    DFA116_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA116_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA116_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA116 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 116;
    this.eot = XQueryParser.DFA116_eot;
    this.eof = XQueryParser.DFA116_eof;
    this.min = XQueryParser.DFA116_min;
    this.max = XQueryParser.DFA116_max;
    this.accept = XQueryParser.DFA116_accept;
    this.special = XQueryParser.DFA116_special;
    this.transition = XQueryParser.DFA116_transition;
};

org.antlr.lang.extend(XQueryParser.DFA116, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "901:1: p_PathExpr : ( ( SLASH p_RelativePathExpr )=> ( SLASH p_RelativePathExpr ) | SLASH | SLASH_SLASH p_RelativePathExpr | p_RelativePathExpr );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA116_1 = input.LA(1);

                             
                            var index116_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred7_XQueryParser()) ) {s = 47;}

                            else if ( (true) ) {s = 48;}

                             
                            input.seek(index116_1);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 116, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA118_eotS:
        "\u0033\uffff",
    DFA118_eofS:
        "\u0033\uffff",
    DFA118_minS:
        "\u0001\u0010\u002c\u0000\u0006\uffff",
    DFA118_maxS:
        "\u0001\u0154\u002c\u0000\u0006\uffff",
    DFA118_acceptS:
        "\u002d\uffff\u0001\u0001\u0001\u0002\u0001\u0004\u0001\u0005\u0001"+
    "\u0003\u0001\u0006",
    DFA118_specialS:
        "\u0001\uffff\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001"+
    "\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001"+
    "\u000a\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001"+
    "\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001"+
    "\u0016\u0001\u0017\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u001b\u0001"+
    "\u001c\u0001\u001d\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021\u0001"+
    "\u0022\u0001\u0023\u0001\u0024\u0001\u0025\u0001\u0026\u0001\u0027\u0001"+
    "\u0028\u0001\u0029\u0001\u002a\u0001\u002b\u0006\uffff}>",
    DFA118_transitionS: [
            "\u0001\u001a\u0001\u001d\u0004\u0025\u0001\u0012\u0006\u0025"+
            "\u0001\u001e\u0001\u0025\u0001\u0015\u0004\u0025\u0001\u0020"+
            "\u0001\u0022\u0002\u0025\u0001\u000d\u0001\u0017\u0001\u000a"+
            "\u0002\u0025\u0001\u002b\u0005\u0025\u0001\u0024\u0001\u0023"+
            "\u0006\u0025\u0001\u002b\u0006\u0025\u0001\u002b\u0007\u0025"+
            "\u0001\u0011\u0003\u0025\u0001\u002a\u0004\u0025\u0001\u0009"+
            "\u0001\u0025\u0001\u0018\u0001\u001c\u0001\u001b\u0001\u0025"+
            "\u0001\u0016\u0003\u0025\u0001\u0028\u0001\u0027\u0001\u0021"+
            "\u0004\u0025\u0001\u0013\u0003\u0025\u0001\u002b\u0001\u0025"+
            "\u0001\u000c\u0011\u0025\u0001\u0029\u0009\u0025\u0001\u002b"+
            "\u0014\u0025\u0001\u000b\u0031\u0025\u0001\u002b\u000a\u0025"+
            "\u0001\u0014\u0003\u0025\u0001\uffff\u0001\u0001\u0001\uffff"+
            "\u0001\u0007\u0001\u0019\u000b\uffff\u0001\u002c\u0002\uffff"+
            "\u0001\u000e\u0007\uffff\u0001\u0008\u0001\u001f\u000c\uffff"+
            "\u0001\u0026\u0002\uffff\u0001\u0006\u0001\u0005\u0002\uffff"+
            "\u0001\u0025\u0007\uffff\u0001\u000f\u0001\u0010\u0001\u0002"+
            "\u0001\u0003\u0001\u0004\u003b\uffff\u0001\u0025",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA118_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA118_eotS),
    DFA118_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA118_eofS),
    DFA118_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA118_minS),
    DFA118_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA118_maxS),
    DFA118_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA118_acceptS),
    DFA118_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA118_specialS),
    DFA118_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA118_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA118_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA118 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 118;
    this.eot = XQueryParser.DFA118_eot;
    this.eof = XQueryParser.DFA118_eof;
    this.min = XQueryParser.DFA118_min;
    this.max = XQueryParser.DFA118_max;
    this.accept = XQueryParser.DFA118_accept;
    this.special = XQueryParser.DFA118_special;
    this.transition = XQueryParser.DFA118_transition;
};

org.antlr.lang.extend(XQueryParser.DFA118, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "914:1: p_StepExpr : ( ( LBRACKET | LPAREN | SMALLER | QUOT | APOS | DOLLAR )=> p_PostfixExpr | ( ( ( ELEMENT | ATTRIBUTE ) ( p_QName )? LBRACKET ) | ( ( NAMESPACE | PROCESSING_INSTRUCTION ) ( p_NCName )? LBRACKET ) | ( ( DOCUMENT | TEXT | COMMENT ) LBRACKET ) )=> p_PostfixExpr | ( p_KindTest )=> p_AxisStep | ( p_QName LPAREN )=> p_PostfixExpr | ( p_PrimaryExpr )=> p_PostfixExpr | p_AxisStep );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA118_1 = input.LA(1);

                             
                            var index118_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_1);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA118_2 = input.LA(1);

                             
                            var index118_2 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_2);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA118_3 = input.LA(1);

                             
                            var index118_3 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_3);
                            if ( s>=0 ) return s;
                            break;
                        case 3 : 
                            var LA118_4 = input.LA(1);

                             
                            var index118_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_4);
                            if ( s>=0 ) return s;
                            break;
                        case 4 : 
                            var LA118_5 = input.LA(1);

                             
                            var index118_5 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_5);
                            if ( s>=0 ) return s;
                            break;
                        case 5 : 
                            var LA118_6 = input.LA(1);

                             
                            var index118_6 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_6);
                            if ( s>=0 ) return s;
                            break;
                        case 6 : 
                            var LA118_7 = input.LA(1);

                             
                            var index118_7 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_7);
                            if ( s>=0 ) return s;
                            break;
                        case 7 : 
                            var LA118_8 = input.LA(1);

                             
                            var index118_8 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_8);
                            if ( s>=0 ) return s;
                            break;
                        case 8 : 
                            var LA118_9 = input.LA(1);

                             
                            var index118_9 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_9);
                            if ( s>=0 ) return s;
                            break;
                        case 9 : 
                            var LA118_10 = input.LA(1);

                             
                            var index118_10 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_10);
                            if ( s>=0 ) return s;
                            break;
                        case 10 : 
                            var LA118_11 = input.LA(1);

                             
                            var index118_11 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_11);
                            if ( s>=0 ) return s;
                            break;
                        case 11 : 
                            var LA118_12 = input.LA(1);

                             
                            var index118_12 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_12);
                            if ( s>=0 ) return s;
                            break;
                        case 12 : 
                            var LA118_13 = input.LA(1);

                             
                            var index118_13 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_13);
                            if ( s>=0 ) return s;
                            break;
                        case 13 : 
                            var LA118_14 = input.LA(1);

                             
                            var index118_14 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_14);
                            if ( s>=0 ) return s;
                            break;
                        case 14 : 
                            var LA118_15 = input.LA(1);

                             
                            var index118_15 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_15);
                            if ( s>=0 ) return s;
                            break;
                        case 15 : 
                            var LA118_16 = input.LA(1);

                             
                            var index118_16 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_16);
                            if ( s>=0 ) return s;
                            break;
                        case 16 : 
                            var LA118_17 = input.LA(1);

                             
                            var index118_17 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_17);
                            if ( s>=0 ) return s;
                            break;
                        case 17 : 
                            var LA118_18 = input.LA(1);

                             
                            var index118_18 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_18);
                            if ( s>=0 ) return s;
                            break;
                        case 18 : 
                            var LA118_19 = input.LA(1);

                             
                            var index118_19 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_19);
                            if ( s>=0 ) return s;
                            break;
                        case 19 : 
                            var LA118_20 = input.LA(1);

                             
                            var index118_20 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((this.synpred8_XQueryParser()||(this.synpred8_XQueryParser()&&(this.lc(MLS))))) ) {s = 45;}

                            else if ( ((this.synpred9_XQueryParser()||(this.synpred9_XQueryParser()&&(this.lc(MLS))))) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( ((this.synpred11_XQueryParser()||(this.synpred11_XQueryParser()&&(this.lc(MLS))))) ) {s = 47;}

                            else if ( (((this.synpred12_XQueryParser()&&(this.lc(MLS)))||this.synpred12_XQueryParser())) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_20);
                            if ( s>=0 ) return s;
                            break;
                        case 20 : 
                            var LA118_21 = input.LA(1);

                             
                            var index118_21 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_21);
                            if ( s>=0 ) return s;
                            break;
                        case 21 : 
                            var LA118_22 = input.LA(1);

                             
                            var index118_22 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_22);
                            if ( s>=0 ) return s;
                            break;
                        case 22 : 
                            var LA118_23 = input.LA(1);

                             
                            var index118_23 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_23);
                            if ( s>=0 ) return s;
                            break;
                        case 23 : 
                            var LA118_24 = input.LA(1);

                             
                            var index118_24 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_24);
                            if ( s>=0 ) return s;
                            break;
                        case 24 : 
                            var LA118_25 = input.LA(1);

                             
                            var index118_25 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                             
                            input.seek(index118_25);
                            if ( s>=0 ) return s;
                            break;
                        case 25 : 
                            var LA118_26 = input.LA(1);

                             
                            var index118_26 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_26);
                            if ( s>=0 ) return s;
                            break;
                        case 26 : 
                            var LA118_27 = input.LA(1);

                             
                            var index118_27 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_27);
                            if ( s>=0 ) return s;
                            break;
                        case 27 : 
                            var LA118_28 = input.LA(1);

                             
                            var index118_28 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_28);
                            if ( s>=0 ) return s;
                            break;
                        case 28 : 
                            var LA118_29 = input.LA(1);

                             
                            var index118_29 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_29);
                            if ( s>=0 ) return s;
                            break;
                        case 29 : 
                            var LA118_30 = input.LA(1);

                             
                            var index118_30 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_30);
                            if ( s>=0 ) return s;
                            break;
                        case 30 : 
                            var LA118_31 = input.LA(1);

                             
                            var index118_31 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_31);
                            if ( s>=0 ) return s;
                            break;
                        case 31 : 
                            var LA118_32 = input.LA(1);

                             
                            var index118_32 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_32);
                            if ( s>=0 ) return s;
                            break;
                        case 32 : 
                            var LA118_33 = input.LA(1);

                             
                            var index118_33 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_33);
                            if ( s>=0 ) return s;
                            break;
                        case 33 : 
                            var LA118_34 = input.LA(1);

                             
                            var index118_34 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_34);
                            if ( s>=0 ) return s;
                            break;
                        case 34 : 
                            var LA118_35 = input.LA(1);

                             
                            var index118_35 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_35);
                            if ( s>=0 ) return s;
                            break;
                        case 35 : 
                            var LA118_36 = input.LA(1);

                             
                            var index118_36 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_36);
                            if ( s>=0 ) return s;
                            break;
                        case 36 : 
                            var LA118_37 = input.LA(1);

                             
                            var index118_37 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_37);
                            if ( s>=0 ) return s;
                            break;
                        case 37 : 
                            var LA118_38 = input.LA(1);

                             
                            var index118_38 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_38);
                            if ( s>=0 ) return s;
                            break;
                        case 38 : 
                            var LA118_39 = input.LA(1);

                             
                            var index118_39 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_39);
                            if ( s>=0 ) return s;
                            break;
                        case 39 : 
                            var LA118_40 = input.LA(1);

                             
                            var index118_40 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_40);
                            if ( s>=0 ) return s;
                            break;
                        case 40 : 
                            var LA118_41 = input.LA(1);

                             
                            var index118_41 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_41);
                            if ( s>=0 ) return s;
                            break;
                        case 41 : 
                            var LA118_42 = input.LA(1);

                             
                            var index118_42 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_42);
                            if ( s>=0 ) return s;
                            break;
                        case 42 : 
                            var LA118_43 = input.LA(1);

                             
                            var index118_43 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred8_XQueryParser()) ) {s = 45;}

                            else if ( (this.synpred9_XQueryParser()) ) {s = 46;}

                            else if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (this.synpred11_XQueryParser()) ) {s = 47;}

                            else if ( (this.synpred12_XQueryParser()) ) {s = 48;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_43);
                            if ( s>=0 ) return s;
                            break;
                        case 43 : 
                            var LA118_44 = input.LA(1);

                             
                            var index118_44 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred10_XQueryParser()) ) {s = 49;}

                            else if ( (true) ) {s = 50;}

                             
                            input.seek(index118_44);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 118, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA120_eotS:
        "\u000a\uffff",
    DFA120_eofS:
        "\u0001\uffff\u0007\u0008\u0002\uffff",
    DFA120_minS:
        "\u0001\u0010\u0007\u0012\u0002\uffff",
    DFA120_maxS:
        "\u0001\u0154\u0007\u00fe\u0002\uffff",
    DFA120_acceptS:
        "\u0008\uffff\u0001\u0002\u0001\u0001",
    DFA120_specialS:
        "\u000a\uffff}>",
    DFA120_transitionS: [
            "\u0006\u0008\u0001\u0003\u0006\u0008\u0001\u0001\u0006\u0008"+
            "\u0001\u0002\u0001\u0005\u000d\u0008\u0001\u0007\u0001\u0006"+
            "\u002a\u0008\u0001\u0004\u003b\u0008\u0001\uffff\u0040\u0008"+
            "\u0010\uffff\u0001\u0008\u0018\uffff\u0001\u0008\u0002\uffff"+
            "\u0002\u0008\u0002\uffff\u0001\u0008\u0047\uffff\u0001\u0008",
            "\u0003\u0008\u0004\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0004\uffff\u0001\u0008\u0002\uffff\u0002\u0008\u0004\uffff"+
            "\u0001\u0008\u0002\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u0001\u0008\u0001\uffff"+
            "\u0002\u0008\u0004\uffff\u0003\u0008\u0002\uffff\u0001\u0008"+
            "\u0001\uffff\u0003\u0008\u0002\uffff\u0001\u0008\u0005\uffff"+
            "\u0002\u0008\u0007\uffff\u0002\u0008\u0005\uffff\u0001\u0008"+
            "\u0004\uffff\u0002\u0008\u0001\uffff\u0001\u0008\u0004\uffff"+
            "\u0001\u0008\u0004\uffff\u0001\u0008\u0003\uffff\u0002\u0008"+
            "\u0006\uffff\u0001\u0008\u0005\uffff\u0001\u0008\u0007\uffff"+
            "\u0002\u0008\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0007\uffff\u0001\u0008\u0002\uffff\u0001\u0008\u0014\uffff"+
            "\u0001\u0008\u0006\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0006\uffff\u0001\u0008\u0014\uffff\u0001\u0008\u0001\uffff"+
            "\u0001\u0008\u0002\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u000b\u0008\u0002\uffff"+
            "\u0001\u0008\u0001\u0009\u0002\uffff\u0002\u0008",
            "\u0003\u0008\u0004\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0004\uffff\u0001\u0008\u0002\uffff\u0002\u0008\u0004\uffff"+
            "\u0001\u0008\u0002\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u0001\u0008\u0001\uffff"+
            "\u0002\u0008\u0004\uffff\u0003\u0008\u0002\uffff\u0001\u0008"+
            "\u0001\uffff\u0003\u0008\u0002\uffff\u0001\u0008\u0005\uffff"+
            "\u0002\u0008\u0007\uffff\u0002\u0008\u0005\uffff\u0001\u0008"+
            "\u0004\uffff\u0002\u0008\u0001\uffff\u0001\u0008\u0004\uffff"+
            "\u0001\u0008\u0004\uffff\u0001\u0008\u0003\uffff\u0002\u0008"+
            "\u0006\uffff\u0001\u0008\u0005\uffff\u0001\u0008\u0007\uffff"+
            "\u0002\u0008\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0007\uffff\u0001\u0008\u0002\uffff\u0001\u0008\u0014\uffff"+
            "\u0001\u0008\u0006\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0006\uffff\u0001\u0008\u0014\uffff\u0001\u0008\u0001\uffff"+
            "\u0001\u0008\u0002\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u000b\u0008\u0002\uffff"+
            "\u0001\u0008\u0001\u0009\u0002\uffff\u0002\u0008",
            "\u0003\u0008\u0004\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0004\uffff\u0001\u0008\u0002\uffff\u0002\u0008\u0004\uffff"+
            "\u0001\u0008\u0002\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u0001\u0008\u0001\uffff"+
            "\u0002\u0008\u0004\uffff\u0003\u0008\u0002\uffff\u0001\u0008"+
            "\u0001\uffff\u0003\u0008\u0002\uffff\u0001\u0008\u0005\uffff"+
            "\u0002\u0008\u0007\uffff\u0002\u0008\u0005\uffff\u0001\u0008"+
            "\u0004\uffff\u0002\u0008\u0001\uffff\u0001\u0008\u0004\uffff"+
            "\u0001\u0008\u0004\uffff\u0001\u0008\u0003\uffff\u0002\u0008"+
            "\u0006\uffff\u0001\u0008\u0005\uffff\u0001\u0008\u0007\uffff"+
            "\u0002\u0008\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0007\uffff\u0001\u0008\u0002\uffff\u0001\u0008\u0014\uffff"+
            "\u0001\u0008\u0006\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0006\uffff\u0001\u0008\u0014\uffff\u0003\u0008\u0002\uffff"+
            "\u0004\u0008\u0001\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0001\uffff\u000b\u0008\u0002\uffff\u0001\u0008\u0001\u0009"+
            "\u0002\uffff\u0002\u0008",
            "\u0003\u0008\u0004\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0004\uffff\u0001\u0008\u0002\uffff\u0002\u0008\u0004\uffff"+
            "\u0001\u0008\u0002\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u0001\u0008\u0001\uffff"+
            "\u0002\u0008\u0004\uffff\u0003\u0008\u0002\uffff\u0001\u0008"+
            "\u0001\uffff\u0003\u0008\u0002\uffff\u0001\u0008\u0005\uffff"+
            "\u0002\u0008\u0007\uffff\u0002\u0008\u0005\uffff\u0001\u0008"+
            "\u0004\uffff\u0002\u0008\u0001\uffff\u0001\u0008\u0004\uffff"+
            "\u0001\u0008\u0004\uffff\u0001\u0008\u0003\uffff\u0002\u0008"+
            "\u0006\uffff\u0001\u0008\u0005\uffff\u0001\u0008\u0007\uffff"+
            "\u0002\u0008\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0007\uffff\u0001\u0008\u0002\uffff\u0001\u0008\u0014\uffff"+
            "\u0001\u0008\u0006\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0006\uffff\u0001\u0008\u0014\uffff\u0001\u0008\u0001\uffff"+
            "\u0001\u0008\u0002\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u000b\u0008\u0002\uffff"+
            "\u0001\u0008\u0001\u0009\u0002\uffff\u0002\u0008",
            "\u0003\u0008\u0004\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0004\uffff\u0001\u0008\u0002\uffff\u0002\u0008\u0004\uffff"+
            "\u0001\u0008\u0002\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u0001\u0008\u0001\uffff"+
            "\u0002\u0008\u0004\uffff\u0003\u0008\u0002\uffff\u0001\u0008"+
            "\u0001\uffff\u0003\u0008\u0002\uffff\u0001\u0008\u0005\uffff"+
            "\u0002\u0008\u0007\uffff\u0002\u0008\u0005\uffff\u0001\u0008"+
            "\u0004\uffff\u0002\u0008\u0001\uffff\u0001\u0008\u0004\uffff"+
            "\u0001\u0008\u0004\uffff\u0001\u0008\u0003\uffff\u0002\u0008"+
            "\u0006\uffff\u0001\u0008\u0005\uffff\u0001\u0008\u0007\uffff"+
            "\u0002\u0008\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0007\uffff\u0001\u0008\u0002\uffff\u0001\u0008\u0014\uffff"+
            "\u0001\u0008\u0006\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0006\uffff\u0001\u0008\u0014\uffff\u0001\u0008\u0001\uffff"+
            "\u0001\u0008\u0002\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u000b\u0008\u0002\uffff"+
            "\u0001\u0008\u0001\u0009\u0002\uffff\u0002\u0008",
            "\u0003\u0008\u0004\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0004\uffff\u0001\u0008\u0002\uffff\u0002\u0008\u0004\uffff"+
            "\u0001\u0008\u0002\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u0001\u0008\u0001\uffff"+
            "\u0002\u0008\u0004\uffff\u0003\u0008\u0002\uffff\u0001\u0008"+
            "\u0001\uffff\u0003\u0008\u0002\uffff\u0001\u0008\u0005\uffff"+
            "\u0002\u0008\u0007\uffff\u0002\u0008\u0005\uffff\u0001\u0008"+
            "\u0004\uffff\u0002\u0008\u0001\uffff\u0001\u0008\u0004\uffff"+
            "\u0001\u0008\u0004\uffff\u0001\u0008\u0003\uffff\u0002\u0008"+
            "\u0006\uffff\u0001\u0008\u0005\uffff\u0001\u0008\u0007\uffff"+
            "\u0002\u0008\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0007\uffff\u0001\u0008\u0002\uffff\u0001\u0008\u0014\uffff"+
            "\u0001\u0008\u0006\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0006\uffff\u0001\u0008\u0014\uffff\u0001\u0008\u0001\uffff"+
            "\u0001\u0008\u0002\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u000b\u0008\u0002\uffff"+
            "\u0001\u0008\u0001\u0009\u0002\uffff\u0002\u0008",
            "\u0003\u0008\u0004\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0004\uffff\u0001\u0008\u0002\uffff\u0002\u0008\u0004\uffff"+
            "\u0001\u0008\u0002\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u0001\u0008\u0001\uffff"+
            "\u0002\u0008\u0004\uffff\u0003\u0008\u0002\uffff\u0001\u0008"+
            "\u0001\uffff\u0003\u0008\u0002\uffff\u0001\u0008\u0005\uffff"+
            "\u0002\u0008\u0007\uffff\u0002\u0008\u0005\uffff\u0001\u0008"+
            "\u0004\uffff\u0002\u0008\u0001\uffff\u0001\u0008\u0004\uffff"+
            "\u0001\u0008\u0004\uffff\u0001\u0008\u0003\uffff\u0002\u0008"+
            "\u0006\uffff\u0001\u0008\u0005\uffff\u0001\u0008\u0007\uffff"+
            "\u0002\u0008\u0004\uffff\u0001\u0008\u0001\uffff\u0001\u0008"+
            "\u0007\uffff\u0001\u0008\u0002\uffff\u0001\u0008\u0014\uffff"+
            "\u0001\u0008\u0006\uffff\u0001\u0008\u0003\uffff\u0001\u0008"+
            "\u0006\uffff\u0001\u0008\u0014\uffff\u0001\u0008\u0001\uffff"+
            "\u0001\u0008\u0002\uffff\u0004\u0008\u0001\uffff\u0001\u0008"+
            "\u0003\uffff\u0001\u0008\u0001\uffff\u000b\u0008\u0002\uffff"+
            "\u0001\u0008\u0001\u0009\u0002\uffff\u0002\u0008",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA120_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA120_eotS),
    DFA120_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA120_eofS),
    DFA120_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA120_minS),
    DFA120_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA120_maxS),
    DFA120_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA120_acceptS),
    DFA120_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA120_specialS),
    DFA120_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA120_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA120_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA120 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 120;
    this.eot = XQueryParser.DFA120_eot;
    this.eof = XQueryParser.DFA120_eof;
    this.min = XQueryParser.DFA120_min;
    this.max = XQueryParser.DFA120_max;
    this.accept = XQueryParser.DFA120_accept;
    this.special = XQueryParser.DFA120_special;
    this.transition = XQueryParser.DFA120_transition;
};

org.antlr.lang.extend(XQueryParser.DFA120, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "933:1: p_ForwardStep : ( p_ForwardAxis p_NodeTest | p_AbbrevForwardStep );";
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA125_eotS:
        "\u000d\uffff",
    DFA125_eofS:
        "\u0001\uffff\u000a\u000b\u0002\uffff",
    DFA125_minS:
        "\u0001\u0010\u000a\u0012\u0002\uffff",
    DFA125_maxS:
        "\u0001\u0154\u000a\u00fe\u0002\uffff",
    DFA125_acceptS:
        "\u000b\uffff\u0001\u0002\u0001\u0001",
    DFA125_specialS:
        "\u000d\uffff}>",
    DFA125_transitionS: [
            "\u0006\u000b\u0001\u0003\u0008\u000b\u0001\u0007\u0009\u000b"+
            "\u0001\u0001\u0001\u0002\u0023\u000b\u0001\u000a\u000a\u000b"+
            "\u0001\u0006\u0003\u000b\u0001\u0005\u0001\u0004\u0005\u000b"+
            "\u0001\u0008\u0017\u000b\u0001\u0009\u001e\u000b\u0001\uffff"+
            "\u0040\u000b\u0010\uffff\u0001\u000b\u001b\uffff\u0002\u000b"+
            "\u0002\uffff\u0001\u000b\u0047\uffff\u0001\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "\u0003\u000b\u0004\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0004\uffff\u0001\u000b\u0002\uffff\u0002\u000b\u0004\uffff"+
            "\u0001\u000b\u0002\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u0001\u000b\u0001\uffff"+
            "\u0002\u000b\u0004\uffff\u0003\u000b\u0002\uffff\u0001\u000b"+
            "\u0001\uffff\u0003\u000b\u0002\uffff\u0001\u000b\u0005\uffff"+
            "\u0002\u000b\u0007\uffff\u0002\u000b\u0005\uffff\u0001\u000b"+
            "\u0004\uffff\u0002\u000b\u0001\uffff\u0001\u000b\u0004\uffff"+
            "\u0001\u000b\u0004\uffff\u0001\u000b\u0003\uffff\u0002\u000b"+
            "\u0006\uffff\u0001\u000b\u0005\uffff\u0001\u000b\u0007\uffff"+
            "\u0002\u000b\u0004\uffff\u0001\u000b\u0001\uffff\u0001\u000b"+
            "\u0007\uffff\u0001\u000b\u0002\uffff\u0001\u000b\u0014\uffff"+
            "\u0001\u000b\u0006\uffff\u0001\u000b\u0003\uffff\u0001\u000b"+
            "\u0006\uffff\u0001\u000b\u0014\uffff\u0001\u000b\u0001\u000c"+
            "\u0001\u000b\u0002\uffff\u0004\u000b\u0001\uffff\u0001\u000b"+
            "\u0003\uffff\u0001\u000b\u0001\uffff\u000b\u000b\u0002\uffff"+
            "\u0001\u000b\u0003\uffff\u0002\u000b",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA125_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA125_eotS),
    DFA125_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA125_eofS),
    DFA125_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA125_minS),
    DFA125_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA125_maxS),
    DFA125_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA125_acceptS),
    DFA125_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA125_specialS),
    DFA125_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA125_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA125_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA125 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 125;
    this.eot = XQueryParser.DFA125_eot;
    this.eof = XQueryParser.DFA125_eof;
    this.min = XQueryParser.DFA125_min;
    this.max = XQueryParser.DFA125_max;
    this.accept = XQueryParser.DFA125_accept;
    this.special = XQueryParser.DFA125_special;
    this.transition = XQueryParser.DFA125_transition;
};

org.antlr.lang.extend(XQueryParser.DFA125, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "975:1: p_NodeTest : ( p_KindTest | p_NameTest );";
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA133_eotS:
        "\u0016\uffff",
    DFA133_eofS:
        "\u0016\uffff",
    DFA133_minS:
        "\u0001\u0010\u0004\uffff\u0001\u00dd\u0001\u0010\u0001\uffff\u0002"+
    "\u00dd\u0001\uffff\u0002\u0010\u0001\u00e0\u0001\u00dd\u0001\u00e0\u0001"+
    "\u0010\u0005\uffff",
    DFA133_maxS:
        "\u0001\u0154\u0004\uffff\u0001\u00f9\u0001\u0154\u0001\uffff\u0002"+
    "\u00f9\u0001\uffff\u0002\u0154\u0003\u00f9\u0001\u0154\u0005\uffff",
    DFA133_acceptS:
        "\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0002"+
    "\uffff\u0001\u0005\u0002\uffff\u0001\u0008\u0006\uffff\u0001\u0009\u0001"+
    "\u0006\u0001\u0007\u0002\u0008",
    DFA133_specialS:
        "\u0001\u0001\u000d\uffff\u0001\u0000\u0007\uffff}>",
    DFA133_transitionS: [
            "\u0006\u0007\u0001\u000c\u0008\u0007\u0001\u000f\u0008\u0007"+
            "\u0001\u0009\u0001\u0007\u0001\u0006\u001f\u0007\u0001\u000b"+
            "\u0008\u0007\u0001\u0005\u0005\u0007\u0001\u0010\u000a\u0007"+
            "\u0001\u000d\u0005\u0007\u0001\u0008\u006d\u0007\u0001\u000e"+
            "\u0003\u0007\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0003"+
            "\u0001\u0011\u000e\uffff\u0001\u000a\u0007\uffff\u0001\u0004"+
            "\u0010\uffff\u0002\u0002\u0002\uffff\u0001\u0007\u0007\uffff"+
            "\u0002\u000a\u0003\u0002\u003b\uffff\u0001\u0007",
            "",
            "",
            "",
            "",
            "\u0001\u0007\u0002\uffff\u0001\u0012\u0018\uffff\u0001\u0007",
            "\u008b\u000a\u0001\uffff\u0040\u000a\u0004\uffff\u0001\u000a"+
            "\u0018\uffff\u0001\u0007\u0012\uffff\u0001\u000a\u0047\uffff"+
            "\u0001\u000a",
            "",
            "\u0001\u0007\u0002\uffff\u0001\u0013\u0018\uffff\u0001\u0007",
            "\u0001\u0007\u0002\uffff\u0001\u000a\u0018\uffff\u0001\u0007",
            "",
            "\u008b\u000a\u0001\uffff\u0040\u000a\u0001\uffff\u0001\u0007"+
            "\u0002\uffff\u0001\u000a\u0018\uffff\u0001\u0007\u0012\uffff"+
            "\u0001\u000a\u0047\uffff\u0001\u000a",
            "\u008b\u000a\u0001\uffff\u0040\u000a\u0004\uffff\u0001\u000a"+
            "\u0018\uffff\u0001\u0007\u0012\uffff\u0001\u000a\u0047\uffff"+
            "\u0001\u000a",
            "\u0001\u000a\u0018\uffff\u0001\u0007",
            "\u0001\u0007\u0002\uffff\u0001\u0014\u0018\uffff\u0001\u0007",
            "\u0001\u0015\u0018\uffff\u0001\u0007",
            "\u008b\u0015\u0001\uffff\u0040\u0015\u0004\uffff\u0001\u0015"+
            "\u0018\uffff\u0001\u0007\u0012\uffff\u0001\u0015\u0047\uffff"+
            "\u0001\u0015",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA133_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA133_eotS),
    DFA133_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA133_eofS),
    DFA133_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA133_minS),
    DFA133_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA133_maxS),
    DFA133_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA133_acceptS),
    DFA133_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA133_specialS),
    DFA133_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA133_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA133_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA133 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 133;
    this.eot = XQueryParser.DFA133_eot;
    this.eof = XQueryParser.DFA133_eof;
    this.min = XQueryParser.DFA133_min;
    this.max = XQueryParser.DFA133_max;
    this.accept = XQueryParser.DFA133_accept;
    this.special = XQueryParser.DFA133_special;
    this.transition = XQueryParser.DFA133_transition;
};

org.antlr.lang.extend(XQueryParser.DFA133, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1019:1: p_PrimaryExpr : ( ( LPAREN )=> p_ParenthesizedExpr | p_Literal | p_VarRef | p_ContextItemExpr | p_FunctionCall | p_OrderedExpr | p_UnorderedExpr | p_Constructor | p_BlockExpr );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA133_14 = input.LA(1);

                             
                            var index133_14 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA133_14==LPAREN||LA133_14==COLON) ) {s = 7;}

                            else if ( (LA133_14==LBRACKET) && ((this.lc(MLS)))) {s = 20;}

                             
                            input.seek(index133_14);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA133_0 = input.LA(1);

                             
                            var index133_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA133_0==LPAREN) && (this.synpred16_XQueryParser())) {s = 1;}

                            else if ( ((LA133_0>=APOS && LA133_0<=QUOT)||(LA133_0>=L_IntegerLiteral && LA133_0<=L_DoubleLiteral)) ) {s = 2;}

                            else if ( (LA133_0==DOLLAR) ) {s = 3;}

                            else if ( (LA133_0==DOT) ) {s = 4;}

                            else if ( (LA133_0==ORDERED) ) {s = 5;}

                            else if ( (LA133_0==ELEMENT) ) {s = 6;}

                            else if ( ((LA133_0>=ANCESTOR && LA133_0<=AT)||(LA133_0>=BASE_URI && LA133_0<=COLLATION)||(LA133_0>=CONSTRUCTION && LA133_0<=DIV)||LA133_0==DOCUMENT_NODE||(LA133_0>=ELSE && LA133_0<=MODULE)||(LA133_0>=NE && LA133_0<=ORDER)||(LA133_0>=ORDERING && LA133_0<=PRESERVE)||(LA133_0>=RETURN && LA133_0<=STRIP)||(LA133_0>=THEN && LA133_0<=UNION)||(LA133_0>=VALIDATE && LA133_0<=UNIQUE)||(LA133_0>=AMP_ER && LA133_0<=QUOT_ER)||LA133_0==L_NCName||LA133_0==EXPLICITLY) ) {s = 7;}

                            else if ( (LA133_0==UNORDERED) ) {s = 8;}

                            else if ( (LA133_0==DOCUMENT) ) {s = 9;}

                            else if ( (LA133_0==SMALLER||(LA133_0>=L_DirCommentConstructor && LA133_0<=L_DirPIConstructor)) ) {s = 10;}

                            else if ( (LA133_0==NAMESPACE) ) {s = 11;}

                            else if ( (LA133_0==ATTRIBUTE) ) {s = 12;}

                            else if ( (LA133_0==TEXT) ) {s = 13;}

                            else if ( (LA133_0==BINARY) ) {s = 14;}

                            else if ( (LA133_0==COMMENT) ) {s = 15;}

                            else if ( (LA133_0==PROCESSING_INSTRUCTION) ) {s = 16;}

                            else if ( (LA133_0==LBRACKET) ) {s = 17;}

                             
                            input.seek(index133_0);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 133, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA161_eotS:
        "\u0045\uffff",
    DFA161_eofS:
        "\u0001\u0002\u0044\uffff",
    DFA161_minS:
        "\u0001\u0012\u0001\u0000\u0007\uffff\u0001\u0000\u003b\uffff",
    DFA161_maxS:
        "\u0001\u00fe\u0001\u0000\u0007\uffff\u0001\u0000\u003b\uffff",
    DFA161_acceptS:
        "\u0002\uffff\u0001\u0002\u000a\uffff\u0001\u0001\u0037\uffff",
    DFA161_specialS:
        "\u0001\u0000\u0001\u0001\u0007\uffff\u0001\u0002\u003b\uffff}>",
    DFA161_transitionS: [
            "\u0004\u0002\u0004\uffff\u0001\u0002\u0003\uffff\u0001\u0002"+
            "\u0004\uffff\u0001\u0002\u0002\uffff\u0002\u0002\u0004\uffff"+
            "\u0001\u0002\u0002\uffff\u0001\u0002\u0001\uffff\u0002\u0002"+
            "\u0002\uffff\u0001\u0002\u0001\uffff\u0001\u0002\u0001\uffff"+
            "\u0002\u0002\u0002\uffff\u0001\u0002\u0001\uffff\u0003\u0002"+
            "\u0002\uffff\u0001\u0002\u0001\uffff\u0003\u0002\u0002\uffff"+
            "\u0001\u0002\u0005\uffff\u0002\u0002\u0007\uffff\u0002\u0002"+
            "\u0005\uffff\u0001\u0002\u0004\uffff\u0001\u0002\u0002\uffff"+
            "\u0001\u0002\u0004\uffff\u0001\u0002\u0001\uffff\u0001\u0002"+
            "\u0002\uffff\u0001\u0002\u0003\uffff\u0002\u0002\u0006\uffff"+
            "\u0001\u0002\u0005\uffff\u0001\u0002\u0007\uffff\u0002\u0002"+
            "\u0004\uffff\u0001\u0002\u0001\uffff\u0001\u0002\u0007\uffff"+
            "\u0001\u0002\u0002\uffff\u0001\u0002\u0014\uffff\u0001\u0002"+
            "\u0003\uffff\u0001\u0002\u0002\uffff\u0001\u0002\u0003\uffff"+
            "\u0001\u0002\u0006\uffff\u0001\u0002\u0014\uffff\u0001\u0002"+
            "\u0001\uffff\u0001\u0002\u0001\uffff\u0002\u0002\u0001\uffff"+
            "\u0004\u0002\u0003\uffff\u0001\u0002\u0001\u000d\u0001\u0001"+
            "\u0001\u0009\u0007\u0002\u0008\uffff\u0002\u0002",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA161_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA161_eotS),
    DFA161_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA161_eofS),
    DFA161_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA161_minS),
    DFA161_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA161_maxS),
    DFA161_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA161_acceptS),
    DFA161_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA161_specialS),
    DFA161_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA161_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA161_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA161 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 161;
    this.eot = XQueryParser.DFA161_eot;
    this.eof = XQueryParser.DFA161_eof;
    this.min = XQueryParser.DFA161_min;
    this.max = XQueryParser.DFA161_max;
    this.accept = XQueryParser.DFA161_accept;
    this.special = XQueryParser.DFA161_special;
    this.transition = XQueryParser.DFA161_transition;
};

org.antlr.lang.extend(XQueryParser.DFA161, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1299:25: ( ( p_OccurrenceIndicator )=>oi= p_OccurrenceIndicator )?";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA161_0 = input.LA(1);

                             
                            var index161_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA161_0==STAR) ) {s = 1;}

                            else if ( (LA161_0==EOF||(LA161_0>=AND && LA161_0<=AT)||LA161_0==CASE||LA161_0==COLLATION||LA161_0==DEFAULT||(LA161_0>=DESCENDING && LA161_0<=DIV)||LA161_0==EMPTY||LA161_0==EQ||(LA161_0>=EXCEPT && LA161_0<=EXTERNAL)||LA161_0==FOR||LA161_0==GE||(LA161_0>=GT && LA161_0<=IDIV)||LA161_0==IN||(LA161_0>=INSTANCE && LA161_0<=IS)||LA161_0==LE||(LA161_0>=LET && LA161_0<=MOD)||LA161_0==NE||(LA161_0>=OR && LA161_0<=ORDER)||(LA161_0>=RETURN && LA161_0<=SATISFIES)||LA161_0==STABLE||LA161_0==TO||LA161_0==UNION||LA161_0==WHERE||LA161_0==ALLOWING||LA161_0==COUNT||(LA161_0>=END && LA161_0<=GROUP)||LA161_0==ONLY||LA161_0==START||(LA161_0>=AFTER && LA161_0<=BEFORE)||LA161_0==INTO||LA161_0==MODIFY||LA161_0==WITH||LA161_0==CONTAINS||LA161_0==PARAGRAPHS||LA161_0==SCORE||LA161_0==SENTENCES||LA161_0==TIMES||LA161_0==WORDS||LA161_0==CONCAT||LA161_0==RPAREN||(LA161_0>=LBRACKET && LA161_0<=RBRACKET)||(LA161_0>=RSQUARE && LA161_0<=NOTEQUAL)||LA161_0==COMMA||(LA161_0>=MINUS && LA161_0<=GREATER_GREATER)||(LA161_0>=SEMICOLON && LA161_0<=VBAR)) ) {s = 2;}

                            else if ( (LA161_0==PLUS) ) {s = 9;}

                            else if ( (LA161_0==QUESTION) && (this.synpred17_XQueryParser())) {s = 13;}

                             
                            input.seek(index161_0);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA161_1 = input.LA(1);

                             
                            var index161_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred17_XQueryParser()) ) {s = 13;}

                            else if ( (true) ) {s = 2;}

                             
                            input.seek(index161_1);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA161_9 = input.LA(1);

                             
                            var index161_9 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (this.synpred17_XQueryParser()) ) {s = 13;}

                            else if ( (true) ) {s = 2;}

                             
                            input.seek(index161_9);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 161, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA163_eotS:
        "\u0012\uffff",
    DFA163_eofS:
        "\u0001\uffff\u000c\u000d\u0005\uffff",
    DFA163_minS:
        "\u0001\u0010\u000c\u0012\u0005\uffff",
    DFA163_maxS:
        "\u0001\u0154\u000c\u00fe\u0005\uffff",
    DFA163_acceptS:
        "\u000d\uffff\u0001\u0004\u0001\u0005\u0001\u0001\u0001\u0002\u0001"+
    "\u0003",
    DFA163_specialS:
        "\u000b\uffff\u0001\u0000\u0006\uffff}>",
    DFA163_transitionS: [
            "\u0006\u000d\u0001\u0003\u0008\u000d\u0001\u0007\u0009\u000d"+
            "\u0001\u0001\u0001\u0002\u0017\u000d\u0001\u000c\u000b\u000d"+
            "\u0001\u000a\u000a\u000d\u0001\u0006\u0003\u000d\u0001\u0005"+
            "\u0001\u0004\u0005\u000d\u0001\u0008\u0017\u000d\u0001\u0009"+
            "\u001e\u000d\u0001\uffff\u003c\u000d\u0001\u000b\u0003\u000d"+
            "\u0001\uffff\u0001\u000e\u002e\uffff\u0001\u000d\u0047\uffff"+
            "\u0001\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u000f\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u0010\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "\u0004\u000d\u0004\uffff\u0001\u000d\u0003\uffff\u0001\u000d"+
            "\u0004\uffff\u0001\u000d\u0002\uffff\u0002\u000d\u0004\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0002\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0001\uffff"+
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d"+
            "\u0002\uffff\u0001\u000d\u0001\uffff\u0003\u000d\u0002\uffff"+
            "\u0001\u000d\u0005\uffff\u0002\u000d\u0007\uffff\u0002\u000d"+
            "\u0005\uffff\u0001\u000d\u0004\uffff\u0001\u000d\u0002\uffff"+
            "\u0001\u000d\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d"+
            "\u0002\uffff\u0001\u000d\u0003\uffff\u0002\u000d\u0006\uffff"+
            "\u0001\u000d\u0005\uffff\u0001\u000d\u0007\uffff\u0002\u000d"+
            "\u0004\uffff\u0001\u000d\u0001\uffff\u0001\u000d\u0007\uffff"+
            "\u0001\u000d\u0002\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0003\uffff\u0001\u000d\u0002\uffff\u0001\u000d\u0003\uffff"+
            "\u0001\u000d\u0006\uffff\u0001\u000d\u0014\uffff\u0001\u000d"+
            "\u0001\u0011\u0001\u000d\u0001\uffff\u0002\u000d\u0001\uffff"+
            "\u0004\u000d\u0003\uffff\u000b\u000d\u0004\uffff\u0001\u000d"+
            "\u0003\uffff\u0002\u000d",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA163_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA163_eotS),
    DFA163_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA163_eofS),
    DFA163_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA163_minS),
    DFA163_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA163_maxS),
    DFA163_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA163_acceptS),
    DFA163_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA163_specialS),
    DFA163_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA163_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA163_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA163 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 163;
    this.eot = XQueryParser.DFA163_eot;
    this.eof = XQueryParser.DFA163_eof;
    this.min = XQueryParser.DFA163_min;
    this.max = XQueryParser.DFA163_max;
    this.accept = XQueryParser.DFA163_accept;
    this.special = XQueryParser.DFA163_special;
    this.transition = XQueryParser.DFA163_transition;
};

org.antlr.lang.extend(XQueryParser.DFA163, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1309:1: p_ItemType : ( p_KindTest -> ^( KindTest p_KindTest ) | {...}? => ( BINARY LPAREN RPAREN ) -> ^( BinaryTest BINARY LPAREN RPAREN ) | ( ITEM LPAREN RPAREN ) -> ^( ItemTest ITEM LPAREN RPAREN ) | p_AtomicOrUnionType | p_ParenthesizedItemType );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA163_11 = input.LA(1);

                             
                            var index163_11 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA163_11==LPAREN) && ((this.lc(MLS)))) {s = 16;}

                            else if ( (LA163_11==EOF||(LA163_11>=AND && LA163_11<=AT)||LA163_11==CASE||LA163_11==COLLATION||LA163_11==DEFAULT||(LA163_11>=DESCENDING && LA163_11<=DIV)||LA163_11==EMPTY||LA163_11==EQ||(LA163_11>=EXCEPT && LA163_11<=EXTERNAL)||LA163_11==FOR||LA163_11==GE||(LA163_11>=GT && LA163_11<=IDIV)||LA163_11==IN||(LA163_11>=INSTANCE && LA163_11<=IS)||LA163_11==LE||(LA163_11>=LET && LA163_11<=MOD)||LA163_11==NE||(LA163_11>=OR && LA163_11<=ORDER)||(LA163_11>=RETURN && LA163_11<=SATISFIES)||LA163_11==STABLE||LA163_11==TO||LA163_11==UNION||LA163_11==WHERE||LA163_11==ALLOWING||LA163_11==COUNT||(LA163_11>=END && LA163_11<=GROUP)||LA163_11==ONLY||LA163_11==START||(LA163_11>=AFTER && LA163_11<=BEFORE)||LA163_11==INTO||LA163_11==MODIFY||LA163_11==WITH||LA163_11==CONTAINS||LA163_11==PARAGRAPHS||LA163_11==SCORE||LA163_11==SENTENCES||LA163_11==TIMES||LA163_11==WORDS||LA163_11==CONCAT||LA163_11==RPAREN||(LA163_11>=LBRACKET && LA163_11<=RBRACKET)||(LA163_11>=RSQUARE && LA163_11<=NOTEQUAL)||(LA163_11>=COMMA && LA163_11<=GREATER_GREATER)||LA163_11==COLON||(LA163_11>=SEMICOLON && LA163_11<=VBAR)) ) {s = 13;}

                             
                            input.seek(index163_11);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 163, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA217_eotS:
        "\u000a\uffff",
    DFA217_eofS:
        "\u000a\uffff",
    DFA217_minS:
        "\u0001\u001a\u0002\uffff\u0001\u00bd\u0006\uffff",
    DFA217_maxS:
        "\u0001\u00c4\u0002\uffff\u0001\u00c4\u0006\uffff",
    DFA217_acceptS:
        "\u0001\uffff\u0001\u0001\u0001\u0002\u0001\uffff\u0001\u0003\u0001"+
    "\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008",
    DFA217_specialS:
        "\u000a\uffff}>",
    DFA217_transitionS: [
            "\u0001\u0006\u0035\uffff\u0001\u0009\u0051\uffff\u0001\u0007"+
            "\u000a\uffff\u0001\u0001\u0001\uffff\u0001\u0006\u0001\uffff"+
            "\u0001\u0003\u000b\uffff\u0001\u0005\u0001\u0008\u0001\u0004"+
            "\u0001\uffff\u0001\u0006\u0002\uffff\u0001\u0002",
            "",
            "",
            "\u0001\u0005\u0001\u0008\u0001\u0004\u0004\uffff\u0001\u0002",
            "",
            "",
            "",
            "",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA217_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA217_eotS),
    DFA217_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA217_eofS),
    DFA217_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA217_minS),
    DFA217_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA217_maxS),
    DFA217_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA217_acceptS),
    DFA217_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA217_specialS),
    DFA217_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA217_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA217_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA217 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 217;
    this.eot = XQueryParser.DFA217_eot;
    this.eof = XQueryParser.DFA217_eof;
    this.min = XQueryParser.DFA217_min;
    this.max = XQueryParser.DFA217_max;
    this.accept = XQueryParser.DFA217_accept;
    this.special = XQueryParser.DFA217_special;
    this.transition = XQueryParser.DFA217_transition;
};

org.antlr.lang.extend(XQueryParser.DFA217, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1845:1: p_FTMatchOption : ( p_FTLanguageOption | p_FTWildCardOption | p_FTThesaurusOption | p_FTStemOption | p_FTCaseOption | p_FTDiacriticsOption | p_FTStopWordOption | p_FTExtensionOption );";
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA236_eotS:
        "\u000c\uffff",
    DFA236_eofS:
        "\u000c\uffff",
    DFA236_minS:
        "\u0001\u0010\u0001\uffff\u0001\u0010\u0005\u0012\u0001\uffff\u0001"+
    "\u0012\u0001\u0010\u0001\u0012",
    DFA236_maxS:
        "\u0001\u0154\u0001\uffff\u0001\u0154\u0005\u00fe\u0001\uffff\u0001"+
    "\u00fe\u0001\u0154\u0001\u00fe",
    DFA236_acceptS:
        "\u0001\uffff\u0001\u0001\u0006\uffff\u0001\u0002\u0003\uffff",
    DFA236_specialS:
        "\u000c\uffff}>",
    DFA236_transitionS: [
            "\u005c\u0001\u0001\u0007\u005b\u0001\u0001\u0004\u0001\u0005"+
            "\u0001\u0006\u0002\u0001\u0001\u0003\u000e\u0001\u0001\uffff"+
            "\u0001\u0001\u0001\uffff\u0001\u0002\u0001\u0001\u0006\uffff"+
            "\u0001\u0008\u0004\uffff\u0004\u0001\u0005\uffff\u0004\u0001"+
            "\u000c\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0006\uffff\u0006\u0001\u003b\uffff\u0001\u0001",
            "",
            "\u008b\u0009\u0001\uffff\u0040\u0009\u0030\uffff\u0001\u0009"+
            "\u0047\uffff\u0001\u0009",
            "\u0001\u0001\u0008\uffff\u0002\u0001\u000a\uffff\u0001\u0001"+
            "\u0007\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0005\uffff"+
            "\u0001\u0001\u0001\uffff\u0002\u0001\u0004\uffff\u0003\u0001"+
            "\u0002\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0014\uffff\u0002\u0001"+
            "\u0001\uffff\u0001\u0001\u0036\uffff\u0001\u0001\u003b\uffff"+
            "\u0001\u0001\u0001\u0008\u0004\uffff\u0001\u0001\u0001\uffff"+
            "\u0001\u0001\u0001\uffff\u0001\u0001\u0003\uffff\u0001\u0001"+
            "\u0001\uffff\u000b\u0001\u0002\uffff\u0001\u0001\u0003\uffff"+
            "\u0002\u0001",
            "\u0001\u0001\u0008\uffff\u0002\u0001\u000a\uffff\u0001\u0001"+
            "\u0007\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0005\uffff"+
            "\u0001\u0001\u0001\uffff\u0002\u0001\u0004\uffff\u0003\u0001"+
            "\u0002\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0014\uffff\u0002\u0001"+
            "\u0001\uffff\u0001\u0001\u0036\uffff\u0001\u0001\u002a\uffff"+
            "\u0001\u0008\u0010\uffff\u0002\u0001\u0004\uffff\u0001\u0001"+
            "\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0003\uffff"+
            "\u0001\u0001\u0001\uffff\u000b\u0001\u0002\uffff\u0001\u0001"+
            "\u0003\uffff\u0002\u0001",
            "\u0001\u0001\u0008\uffff\u0002\u0001\u000a\uffff\u0001\u0001"+
            "\u0007\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0005\uffff"+
            "\u0001\u0001\u0001\uffff\u0002\u0001\u0004\uffff\u0003\u0001"+
            "\u0002\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0014\uffff\u0002\u0001"+
            "\u0001\uffff\u0001\u0001\u0036\uffff\u0001\u0001\u002a\uffff"+
            "\u0001\u0008\u0010\uffff\u0002\u0001\u0004\uffff\u0001\u0001"+
            "\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0003\uffff"+
            "\u0001\u0001\u0001\uffff\u000b\u0001\u0002\uffff\u0001\u0001"+
            "\u0003\uffff\u0002\u0001",
            "\u0001\u0001\u0008\uffff\u0002\u0001\u000a\uffff\u0001\u0001"+
            "\u0007\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0005\uffff"+
            "\u0001\u0001\u0001\uffff\u0002\u0001\u0004\uffff\u0003\u0001"+
            "\u0002\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0014\uffff\u0002\u0001"+
            "\u0001\uffff\u0001\u0001\u0036\uffff\u0001\u0001\u002b\uffff"+
            "\u0001\u0008\u000f\uffff\u0002\u0001\u0004\uffff\u0001\u0001"+
            "\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0003\uffff"+
            "\u0001\u0001\u0001\uffff\u000b\u0001\u0002\uffff\u0001\u0001"+
            "\u0003\uffff\u0002\u0001",
            "\u0001\u0001\u0008\uffff\u0002\u0001\u000a\uffff\u0001\u0001"+
            "\u0007\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0005\uffff"+
            "\u0001\u0001\u0001\uffff\u0002\u0001\u0004\uffff\u0003\u0001"+
            "\u0002\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0014\uffff\u0002\u0001"+
            "\u0001\uffff\u0001\u0001\u0036\uffff\u0001\u0001\u003b\uffff"+
            "\u0002\u0001\u0001\uffff\u0001\u0008\u0002\uffff\u0001\u0001"+
            "\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0003\uffff"+
            "\u0001\u0001\u0001\uffff\u000b\u0001\u0002\uffff\u0001\u0001"+
            "\u0003\uffff\u0002\u0001",
            "",
            "\u0001\u0001\u0008\uffff\u0002\u0001\u000a\uffff\u0001\u0001"+
            "\u0007\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0005\uffff"+
            "\u0001\u0001\u0001\uffff\u0002\u0001\u0004\uffff\u0003\u0001"+
            "\u0002\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0014\uffff\u0002\u0001"+
            "\u0001\uffff\u0001\u0001\u0036\uffff\u0001\u0001\u003b\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0001\uffff\u0001\u0001"+
            "\u0001\u0008\u0001\u0001\u0003\uffff\u0001\u0001\u0001\uffff"+
            "\u000b\u0001\u0002\uffff\u0001\u000a\u0003\uffff\u0002\u0001",
            "\u008b\u000b\u0001\uffff\u0040\u000b\u0030\uffff\u0001\u000b"+
            "\u0047\uffff\u0001\u000b",
            "\u0001\u0001\u0008\uffff\u0002\u0001\u000a\uffff\u0001\u0001"+
            "\u0007\uffff\u0001\u0001\u0001\uffff\u0001\u0001\u0005\uffff"+
            "\u0001\u0001\u0001\uffff\u0002\u0001\u0004\uffff\u0003\u0001"+
            "\u0002\uffff\u0001\u0001\u0002\uffff\u0002\u0001\u0002\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0014\uffff\u0002\u0001"+
            "\u0001\uffff\u0001\u0001\u0036\uffff\u0001\u0001\u003b\uffff"+
            "\u0001\u0001\u0005\uffff\u0001\u0001\u0001\uffff\u0001\u0001"+
            "\u0001\u0008\u0001\u0001\u0003\uffff\u0001\u0001\u0001\uffff"+
            "\u000b\u0001\u0006\uffff\u0002\u0001"
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA236_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA236_eotS),
    DFA236_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA236_eofS),
    DFA236_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA236_minS),
    DFA236_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA236_maxS),
    DFA236_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA236_acceptS),
    DFA236_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA236_specialS),
    DFA236_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA236_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA236_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA236 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 236;
    this.eot = XQueryParser.DFA236_eot;
    this.eof = XQueryParser.DFA236_eof;
    this.min = XQueryParser.DFA236_min;
    this.max = XQueryParser.DFA236_max;
    this.accept = XQueryParser.DFA236_accept;
    this.special = XQueryParser.DFA236_special;
    this.transition = XQueryParser.DFA236_transition;
};

org.antlr.lang.extend(XQueryParser.DFA236, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1959:1: p_Hybrid[strict, allowConcat] : ( p_HybridExprSingle[$strict,$allowConcat] | p_Statement );";
    },
    dummy: null
});
org.antlr.lang.augmentObject(XQueryParser, {
    DFA252_eotS:
        "\u000b\uffff",
    DFA252_eofS:
        "\u0001\uffff\u0002\u0003\u0001\uffff\u0005\u0003\u0002\uffff",
    DFA252_minS:
        "\u0001\u0010\u0002\u0012\u0001\uffff\u0005\u0012\u0002\uffff",
    DFA252_maxS:
        "\u0001\u0154\u0002\u00fe\u0001\uffff\u0005\u00fe\u0002\uffff",
    DFA252_acceptS:
        "\u0003\uffff\u0001\u0002\u0005\uffff\u0001\u0001\u0001\u0003",
    DFA252_specialS:
        "\u0004\uffff\u0001\u0004\u0001\u0000\u0001\u0003\u0001\u0002\u0001"+
    "\u0001\u0002\uffff}>",
    DFA252_transitionS: [
            "\u0020\u0003\u0001\u0002\u002f\u0003\u0001\u0001\u002e\u0003"+
            "\u0001\u0008\u0001\u0005\u0001\u0003\u0001\u0004\u0004\u0003"+
            "\u0001\u0006\u0001\u0007\u0043\u0003\u0001\uffff\u0001\u0003"+
            "\u0001\uffff\u0002\u0003\u000b\uffff\u0004\u0003\u0005\uffff"+
            "\u0004\u0003\u000c\uffff\u0001\u0003\u0002\uffff\u0002\u0003"+
            "\u0002\uffff\u0001\u0003\u0006\uffff\u0006\u0003\u003b\uffff"+
            "\u0001\u0003",
            "\u0003\u0003\u0005\uffff\u0003\u0003\u0001\uffff\u0001\u0003"+
            "\u0004\uffff\u0001\u0003\u0002\uffff\u0002\u0003\u0004\uffff"+
            "\u0001\u0003\u0002\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0003\uffff\u0001\u0003\u0001\uffff\u0001\u0003\u0001\uffff"+
            "\u0002\u0003\u0004\uffff\u0003\u0003\u0002\uffff\u0001\u0003"+
            "\u0001\uffff\u0003\u0003\u0002\uffff\u0001\u0003\u0005\uffff"+
            "\u0002\u0003\u0007\uffff\u0002\u0003\u0005\uffff\u0001\u0003"+
            "\u0004\uffff\u0002\u0003\u0001\uffff\u0001\u0003\u0004\uffff"+
            "\u0001\u0003\u0004\uffff\u0001\u0003\u0003\uffff\u0002\u0003"+
            "\u0006\uffff\u0001\u0003\u0005\uffff\u0001\u0003\u0007\uffff"+
            "\u0002\u0003\u0004\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0007\uffff\u0001\u0003\u0002\uffff\u0001\u0003\u003b\uffff"+
            "\u0003\u0003\u0001\u0009\u0001\uffff\u0004\u0003\u0001\uffff"+
            "\u0001\u0003\u0003\uffff\u0001\u0003\u0001\uffff\u000b\u0003"+
            "\u0002\uffff\u0001\u0003\u0003\uffff\u0002\u0003",
            "\u0003\u0003\u0005\uffff\u0003\u0003\u0001\uffff\u0001\u0003"+
            "\u0004\uffff\u0001\u0003\u0002\uffff\u0002\u0003\u0004\uffff"+
            "\u0001\u0003\u0002\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0003\uffff\u0001\u0003\u0001\uffff\u0001\u0003\u0001\uffff"+
            "\u0002\u0003\u0004\uffff\u0003\u0003\u0002\uffff\u0001\u0003"+
            "\u0001\uffff\u0003\u0003\u0002\uffff\u0001\u0003\u0005\uffff"+
            "\u0002\u0003\u0007\uffff\u0002\u0003\u0005\uffff\u0001\u0003"+
            "\u0004\uffff\u0002\u0003\u0001\uffff\u0001\u0003\u0004\uffff"+
            "\u0001\u0003\u0004\uffff\u0001\u0003\u0003\uffff\u0002\u0003"+
            "\u0006\uffff\u0001\u0003\u0005\uffff\u0001\u0003\u0007\uffff"+
            "\u0002\u0003\u0004\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0007\uffff\u0001\u0003\u0002\uffff\u0001\u0003\u003b\uffff"+
            "\u0003\u0003\u0001\u0009\u0001\uffff\u0004\u0003\u0001\uffff"+
            "\u0001\u0003\u0003\uffff\u0001\u0003\u0001\uffff\u000b\u0003"+
            "\u0002\uffff\u0001\u0003\u0003\uffff\u0002\u0003",
            "",
            "\u0003\u0003\u0005\uffff\u0003\u0003\u0001\uffff\u0001\u0003"+
            "\u0004\uffff\u0001\u0003\u0002\uffff\u0002\u0003\u0004\uffff"+
            "\u0001\u0003\u0002\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0003\uffff\u0001\u0003\u0001\uffff\u0001\u0003\u0001\uffff"+
            "\u0002\u0003\u0004\uffff\u0003\u0003\u0002\uffff\u0001\u0003"+
            "\u0001\uffff\u0003\u0003\u0002\uffff\u0001\u0003\u0002\uffff"+
            "\u0001\u000a\u0002\uffff\u0002\u0003\u0007\uffff\u0002\u0003"+
            "\u0005\uffff\u0001\u0003\u0004\uffff\u0002\u0003\u0001\uffff"+
            "\u0001\u0003\u0004\uffff\u0001\u0003\u0004\uffff\u0001\u0003"+
            "\u0003\uffff\u0002\u0003\u0006\uffff\u0001\u0003\u0005\uffff"+
            "\u0001\u0003\u0007\uffff\u0002\u0003\u0004\uffff\u0001\u0003"+
            "\u0001\uffff\u0001\u0003\u0001\u000a\u0006\uffff\u0001\u0003"+
            "\u0002\uffff\u0001\u0003\u003b\uffff\u0003\u0003\u0002\uffff"+
            "\u0004\u0003\u0001\uffff\u0001\u0003\u0003\uffff\u0001\u0003"+
            "\u0001\uffff\u000b\u0003\u0002\uffff\u0001\u0003\u0003\uffff"+
            "\u0002\u0003",
            "\u0003\u0003\u0005\uffff\u0003\u0003\u0001\uffff\u0001\u0003"+
            "\u0004\uffff\u0001\u0003\u0002\uffff\u0002\u0003\u0004\uffff"+
            "\u0001\u0003\u0002\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0003\uffff\u0001\u0003\u0001\uffff\u0001\u0003\u0001\uffff"+
            "\u0002\u0003\u0004\uffff\u0003\u0003\u0002\uffff\u0001\u0003"+
            "\u0001\uffff\u0003\u0003\u0002\uffff\u0001\u0003\u0002\uffff"+
            "\u0001\u000a\u0002\uffff\u0002\u0003\u0007\uffff\u0002\u0003"+
            "\u0005\uffff\u0001\u0003\u0004\uffff\u0002\u0003\u0001\uffff"+
            "\u0001\u0003\u0004\uffff\u0001\u0003\u0004\uffff\u0001\u0003"+
            "\u0003\uffff\u0002\u0003\u0006\uffff\u0001\u0003\u0005\uffff"+
            "\u0001\u0003\u0007\uffff\u0002\u0003\u0004\uffff\u0001\u0003"+
            "\u0001\uffff\u0001\u0003\u0001\u000a\u0006\uffff\u0001\u0003"+
            "\u0002\uffff\u0001\u0003\u003b\uffff\u0003\u0003\u0002\uffff"+
            "\u0004\u0003\u0001\uffff\u0001\u0003\u0003\uffff\u0001\u0003"+
            "\u0001\uffff\u000b\u0003\u0002\uffff\u0001\u0003\u0003\uffff"+
            "\u0002\u0003",
            "\u0003\u0003\u0005\uffff\u0003\u0003\u0001\uffff\u0001\u0003"+
            "\u0004\uffff\u0001\u0003\u0002\uffff\u0002\u0003\u0004\uffff"+
            "\u0001\u0003\u0002\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0003\uffff\u0001\u0003\u0001\uffff\u0001\u0003\u0001\uffff"+
            "\u0002\u0003\u0004\uffff\u0003\u0003\u0002\uffff\u0001\u0003"+
            "\u0001\uffff\u0003\u0003\u0002\uffff\u0001\u0003\u0002\uffff"+
            "\u0001\u000a\u0002\uffff\u0002\u0003\u0007\uffff\u0002\u0003"+
            "\u0005\uffff\u0001\u0003\u0004\uffff\u0002\u0003\u0001\uffff"+
            "\u0001\u0003\u0004\uffff\u0001\u0003\u0004\uffff\u0001\u0003"+
            "\u0003\uffff\u0002\u0003\u0006\uffff\u0001\u0003\u0005\uffff"+
            "\u0001\u0003\u0007\uffff\u0002\u0003\u0004\uffff\u0001\u0003"+
            "\u0001\uffff\u0001\u0003\u0007\uffff\u0001\u0003\u0002\uffff"+
            "\u0001\u0003\u003b\uffff\u0003\u0003\u0002\uffff\u0004\u0003"+
            "\u0001\uffff\u0001\u0003\u0003\uffff\u0001\u0003\u0001\uffff"+
            "\u000b\u0003\u0002\uffff\u0001\u0003\u0003\uffff\u0002\u0003",
            "\u0003\u0003\u0005\uffff\u0003\u0003\u0001\uffff\u0001\u0003"+
            "\u0004\uffff\u0001\u0003\u0002\uffff\u0002\u0003\u0004\uffff"+
            "\u0001\u0003\u0002\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0003\uffff\u0001\u0003\u0001\uffff\u0001\u0003\u0001\uffff"+
            "\u0002\u0003\u0004\uffff\u0003\u0003\u0002\uffff\u0001\u0003"+
            "\u0001\uffff\u0003\u0003\u0002\uffff\u0001\u0003\u0002\uffff"+
            "\u0001\u000a\u0002\uffff\u0002\u0003\u0007\uffff\u0002\u0003"+
            "\u0005\uffff\u0001\u0003\u0004\uffff\u0002\u0003\u0001\uffff"+
            "\u0001\u0003\u0004\uffff\u0001\u0003\u0004\uffff\u0001\u0003"+
            "\u0003\uffff\u0002\u0003\u0006\uffff\u0001\u0003\u0005\uffff"+
            "\u0001\u0003\u0007\uffff\u0002\u0003\u0004\uffff\u0001\u0003"+
            "\u0001\uffff\u0001\u0003\u0006\uffff\u0001\u000a\u0001\u0003"+
            "\u0002\uffff\u0001\u0003\u003b\uffff\u0003\u0003\u0002\uffff"+
            "\u0004\u0003\u0001\uffff\u0001\u0003\u0003\uffff\u0001\u0003"+
            "\u0001\uffff\u000b\u0003\u0002\uffff\u0001\u0003\u0003\uffff"+
            "\u0002\u0003",
            "\u0003\u0003\u0005\uffff\u0003\u0003\u0001\uffff\u0001\u0003"+
            "\u0004\uffff\u0001\u0003\u0002\uffff\u0002\u0003\u0004\uffff"+
            "\u0001\u0003\u0002\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0003\uffff\u0001\u0003\u0001\uffff\u0001\u0003\u0001\uffff"+
            "\u0002\u0003\u0004\uffff\u0003\u0003\u0002\uffff\u0001\u0003"+
            "\u0001\uffff\u0003\u0003\u0002\uffff\u0001\u0003\u0005\uffff"+
            "\u0002\u0003\u0007\uffff\u0002\u0003\u0005\uffff\u0001\u0003"+
            "\u0004\uffff\u0002\u0003\u0001\uffff\u0001\u0003\u0004\uffff"+
            "\u0001\u0003\u0004\uffff\u0001\u0003\u0003\uffff\u0002\u0003"+
            "\u0006\uffff\u0001\u0003\u0005\uffff\u0001\u0003\u0007\uffff"+
            "\u0002\u0003\u0004\uffff\u0001\u0003\u0001\uffff\u0001\u0003"+
            "\u0007\uffff\u0001\u0003\u0002\uffff\u0001\u0003\u003b\uffff"+
            "\u0003\u0003\u0001\u000a\u0001\uffff\u0004\u0003\u0001\uffff"+
            "\u0001\u0003\u0003\uffff\u0001\u0003\u0001\uffff\u000b\u0003"+
            "\u0002\uffff\u0001\u0003\u0003\uffff\u0002\u0003",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XQueryParser, {
    DFA252_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA252_eotS),
    DFA252_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA252_eofS),
    DFA252_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA252_minS),
    DFA252_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XQueryParser.DFA252_maxS),
    DFA252_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA252_acceptS),
    DFA252_special:
        org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA252_specialS),
    DFA252_transition: (function() {
        var a = [],
            i,
            numStates = XQueryParser.DFA252_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XQueryParser.DFA252_transitionS[i]));
        }
        return a;
    })()
});

XQueryParser.DFA252 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 252;
    this.eot = XQueryParser.DFA252_eot;
    this.eof = XQueryParser.DFA252_eof;
    this.min = XQueryParser.DFA252_min;
    this.max = XQueryParser.DFA252_max;
    this.accept = XQueryParser.DFA252_accept;
    this.special = XQueryParser.DFA252_special;
    this.transition = XQueryParser.DFA252_transition;
};

org.antlr.lang.extend(XQueryParser.DFA252, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "2111:1: p_ExprSimple : ( p_QuantifiedExpr | p_OrExpr | {...}? => pg_UpdateExpr );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA252_5 = input.LA(1);

                             
                            var index252_5 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA252_5==EOF||(LA252_5>=AND && LA252_5<=ASCENDING)||(LA252_5>=CASE && LA252_5<=CASTABLE)||LA252_5==COLLATION||LA252_5==DEFAULT||(LA252_5>=DESCENDING && LA252_5<=DIV)||LA252_5==EMPTY||LA252_5==EQ||LA252_5==EXCEPT||LA252_5==FOR||LA252_5==GE||(LA252_5>=GT && LA252_5<=IDIV)||(LA252_5>=INSTANCE && LA252_5<=IS)||LA252_5==LE||(LA252_5>=LET && LA252_5<=MOD)||LA252_5==NE||(LA252_5>=OR && LA252_5<=ORDER)||(LA252_5>=RETURN && LA252_5<=SATISFIES)||LA252_5==STABLE||(LA252_5>=TO && LA252_5<=TREAT)||LA252_5==UNION||LA252_5==WHERE||LA252_5==COUNT||(LA252_5>=END && LA252_5<=GROUP)||LA252_5==ONLY||LA252_5==START||(LA252_5>=AFTER && LA252_5<=BEFORE)||LA252_5==INTO||LA252_5==MODIFY||LA252_5==WITH||LA252_5==CONTAINS||(LA252_5>=CONCAT && LA252_5<=RPAREN)||(LA252_5>=RBRACKET && LA252_5<=EQUAL)||LA252_5==NOTEQUAL||LA252_5==COMMA||(LA252_5>=STAR && LA252_5<=SLASH_SLASH)||LA252_5==COLON||(LA252_5>=SEMICOLON && LA252_5<=VBAR)) ) {s = 3;}

                            else if ( (LA252_5==NODE||LA252_5==NODES) && ((this.lc(XQU)))) {s = 10;}

                             
                            input.seek(index252_5);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA252_8 = input.LA(1);

                             
                            var index252_8 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA252_8==DOLLAR) && ((this.lc(XQU)))) {s = 10;}

                            else if ( (LA252_8==EOF||(LA252_8>=AND && LA252_8<=ASCENDING)||(LA252_8>=CASE && LA252_8<=CASTABLE)||LA252_8==COLLATION||LA252_8==DEFAULT||(LA252_8>=DESCENDING && LA252_8<=DIV)||LA252_8==EMPTY||LA252_8==EQ||LA252_8==EXCEPT||LA252_8==FOR||LA252_8==GE||(LA252_8>=GT && LA252_8<=IDIV)||(LA252_8>=INSTANCE && LA252_8<=IS)||LA252_8==LE||(LA252_8>=LET && LA252_8<=MOD)||LA252_8==NE||(LA252_8>=OR && LA252_8<=ORDER)||(LA252_8>=RETURN && LA252_8<=SATISFIES)||LA252_8==STABLE||(LA252_8>=TO && LA252_8<=TREAT)||LA252_8==UNION||LA252_8==WHERE||LA252_8==COUNT||(LA252_8>=END && LA252_8<=GROUP)||LA252_8==ONLY||LA252_8==START||(LA252_8>=AFTER && LA252_8<=BEFORE)||LA252_8==INTO||LA252_8==MODIFY||LA252_8==WITH||LA252_8==CONTAINS||(LA252_8>=CONCAT && LA252_8<=RPAREN)||(LA252_8>=RBRACKET && LA252_8<=EQUAL)||LA252_8==NOTEQUAL||LA252_8==COMMA||(LA252_8>=STAR && LA252_8<=SLASH_SLASH)||LA252_8==COLON||(LA252_8>=SEMICOLON && LA252_8<=VBAR)) ) {s = 3;}

                             
                            input.seek(index252_8);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA252_7 = input.LA(1);

                             
                            var index252_7 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA252_7==EOF||(LA252_7>=AND && LA252_7<=ASCENDING)||(LA252_7>=CASE && LA252_7<=CASTABLE)||LA252_7==COLLATION||LA252_7==DEFAULT||(LA252_7>=DESCENDING && LA252_7<=DIV)||LA252_7==EMPTY||LA252_7==EQ||LA252_7==EXCEPT||LA252_7==FOR||LA252_7==GE||(LA252_7>=GT && LA252_7<=IDIV)||(LA252_7>=INSTANCE && LA252_7<=IS)||LA252_7==LE||(LA252_7>=LET && LA252_7<=MOD)||LA252_7==NE||(LA252_7>=OR && LA252_7<=ORDER)||(LA252_7>=RETURN && LA252_7<=SATISFIES)||LA252_7==STABLE||(LA252_7>=TO && LA252_7<=TREAT)||LA252_7==UNION||LA252_7==WHERE||LA252_7==COUNT||(LA252_7>=END && LA252_7<=GROUP)||LA252_7==ONLY||LA252_7==START||(LA252_7>=AFTER && LA252_7<=BEFORE)||LA252_7==INTO||LA252_7==MODIFY||LA252_7==WITH||LA252_7==CONTAINS||(LA252_7>=CONCAT && LA252_7<=RPAREN)||(LA252_7>=RBRACKET && LA252_7<=EQUAL)||LA252_7==NOTEQUAL||LA252_7==COMMA||(LA252_7>=STAR && LA252_7<=SLASH_SLASH)||LA252_7==COLON||(LA252_7>=SEMICOLON && LA252_7<=VBAR)) ) {s = 3;}

                            else if ( (LA252_7==NODE||LA252_7==VALUE) && ((this.lc(XQU)))) {s = 10;}

                             
                            input.seek(index252_7);
                            if ( s>=0 ) return s;
                            break;
                        case 3 : 
                            var LA252_6 = input.LA(1);

                             
                            var index252_6 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA252_6==NODE) && ((this.lc(XQU)))) {s = 10;}

                            else if ( (LA252_6==EOF||(LA252_6>=AND && LA252_6<=ASCENDING)||(LA252_6>=CASE && LA252_6<=CASTABLE)||LA252_6==COLLATION||LA252_6==DEFAULT||(LA252_6>=DESCENDING && LA252_6<=DIV)||LA252_6==EMPTY||LA252_6==EQ||LA252_6==EXCEPT||LA252_6==FOR||LA252_6==GE||(LA252_6>=GT && LA252_6<=IDIV)||(LA252_6>=INSTANCE && LA252_6<=IS)||LA252_6==LE||(LA252_6>=LET && LA252_6<=MOD)||LA252_6==NE||(LA252_6>=OR && LA252_6<=ORDER)||(LA252_6>=RETURN && LA252_6<=SATISFIES)||LA252_6==STABLE||(LA252_6>=TO && LA252_6<=TREAT)||LA252_6==UNION||LA252_6==WHERE||LA252_6==COUNT||(LA252_6>=END && LA252_6<=GROUP)||LA252_6==ONLY||LA252_6==START||(LA252_6>=AFTER && LA252_6<=BEFORE)||LA252_6==INTO||LA252_6==MODIFY||LA252_6==WITH||LA252_6==CONTAINS||(LA252_6>=CONCAT && LA252_6<=RPAREN)||(LA252_6>=RBRACKET && LA252_6<=EQUAL)||LA252_6==NOTEQUAL||LA252_6==COMMA||(LA252_6>=STAR && LA252_6<=SLASH_SLASH)||LA252_6==COLON||(LA252_6>=SEMICOLON && LA252_6<=VBAR)) ) {s = 3;}

                             
                            input.seek(index252_6);
                            if ( s>=0 ) return s;
                            break;
                        case 4 : 
                            var LA252_4 = input.LA(1);

                             
                            var index252_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA252_4==EOF||(LA252_4>=AND && LA252_4<=ASCENDING)||(LA252_4>=CASE && LA252_4<=CASTABLE)||LA252_4==COLLATION||LA252_4==DEFAULT||(LA252_4>=DESCENDING && LA252_4<=DIV)||LA252_4==EMPTY||LA252_4==EQ||LA252_4==EXCEPT||LA252_4==FOR||LA252_4==GE||(LA252_4>=GT && LA252_4<=IDIV)||(LA252_4>=INSTANCE && LA252_4<=IS)||LA252_4==LE||(LA252_4>=LET && LA252_4<=MOD)||LA252_4==NE||(LA252_4>=OR && LA252_4<=ORDER)||(LA252_4>=RETURN && LA252_4<=SATISFIES)||LA252_4==STABLE||(LA252_4>=TO && LA252_4<=TREAT)||LA252_4==UNION||LA252_4==WHERE||LA252_4==COUNT||(LA252_4>=END && LA252_4<=GROUP)||LA252_4==ONLY||LA252_4==START||(LA252_4>=AFTER && LA252_4<=BEFORE)||LA252_4==INTO||LA252_4==MODIFY||LA252_4==WITH||LA252_4==CONTAINS||(LA252_4>=CONCAT && LA252_4<=RPAREN)||(LA252_4>=RBRACKET && LA252_4<=EQUAL)||LA252_4==NOTEQUAL||LA252_4==COMMA||(LA252_4>=STAR && LA252_4<=SLASH_SLASH)||LA252_4==COLON||(LA252_4>=SEMICOLON && LA252_4<=VBAR)) ) {s = 3;}

                            else if ( (LA252_4==NODE||LA252_4==NODES) && ((this.lc(XQU)))) {s = 10;}

                             
                            input.seek(index252_4);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 252, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
 

// public class variables
org.antlr.lang.augmentObject(XQueryParser, {
    tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "L_QuotAttrContentChar", "L_AposAttrContentChar", "L_ElementContentChar", "L_CDataSection", "L_PredefinedEntityRef", "L_CharRef", "ESCAPE_LBRACKET", "ESCAPE_RBRACKET", "ESCAPE_APOS", "ESCAPE_QUOT", "CDATA_START", "CDATA_END", "ANCESTOR", "ANCESTOR_OR_SELF", "AND", "AS", "ASCENDING", "AT", "ATTRIBUTE", "BASE_URI", "BOUNDARY_SPACE", "BY", "CASE", "CAST", "CASTABLE", "CHILD", "COLLATION", "COMMENT", "CONSTRUCTION", "COPY_NAMESPACES", "DECLARE", "DEFAULT", "DESCENDANT", "DESCENDANT_OR_SELF", "DESCENDING", "DIV", "DOCUMENT", "DOCUMENT_NODE", "ELEMENT", "ELSE", "EMPTY", "EMPTY_SEQUENCE", "ENCODING", "EQ", "EVERY", "EXCEPT", "EXTERNAL", "FOLLOWING", "FOLLOWING_SIBLING", "FOR", "FUNCTION", "GE", "GREATEST", "GT", "IDIV", "IF", "IMPORT", "IN", "INHERIT", "INSTANCE", "INTERSECT", "IS", "ITEM", "LAX", "LE", "LEAST", "LET", "LT", "MOD", "MODULE", "NAMESPACE", "NE", "NO_INHERIT", "NO_PRESERVE", "NODE", "OF", "OPTION", "OR", "ORDER", "ORDERED", "ORDERING", "PARENT", "PRECEDING", "PRECEDING_SIBLING", "PRESERVE", "PROCESSING_INSTRUCTION", "RETURN", "SATISFIES", "SCHEMA", "SCHEMA_ATTRIBUTE", "SCHEMA_ELEMENT", "SELF", "SOME", "STABLE", "STRICT", "STRIP", "TEXT", "THEN", "TO", "TREAT", "TYPESWITCH", "UNION", "UNORDERED", "VALIDATE", "VARIABLE", "VERSION", "WHERE", "XQUERY", "ALLOWING", "CATCH", "CONTEXT", "COUNT", "DECIMAL_FORMAT", "DECIMAL_SEPARATOR", "DIGIT", "END", "GROUP", "GROUPING_SEPARATOR", "INFINITY", "MINUS_SIGN", "NAMESPACE_NODE", "NAN", "NEXT", "ONLY", "PATTERN_SEPARATOR", "PERCENT", "PER_MILLE", "PREVIOUS", "SLIDING", "START", "SWITCH", "TRY", "TUMBLING", "TYPE", "WHEN", "WINDOW", "ZERO_DIGIT", "AFTER", "BEFORE", "COPY", "DELETE", "FIRST", "INSERT", "INTO", "LAST", "MODIFY", "NODES", "RENAME", "REPLACE", "REVALIDATION", "SKIP", "UPDATING", "VALUE", "WITH", "ALL", "ANY", "CONTAINS", "CONTENT", "DIACRITICS", "DIFFERENT", "DISTANCE", "ENTIRE", "EXACTLY", "FROM", "FT_OPTION", "FTAND", "FTNOT", "FTOR", "INSENSITIVE", "LANGUAGE", "LEVELS", "LOWERCASE", "MOST", "NO", "NOT", "OCCURS", "PARAGRAPH", "PARAGRAPHS", "PHRASE", "RELATIONSHIP", "SAME", "SCORE", "SENSITIVE", "SENTENCE", "SENTENCES", "STEMMING", "STOP", "THESAURUS", "TIMES", "UPPERCASE", "USING", "WEIGHT", "WILDCARDS", "WITHOUT", "WORD", "WORDS", "BREAK", "CONTINUE", "EXIT", "LOOP", "RETURNING", "WHILE", "CHECK", "COLLECTION", "CONSTRAINT", "FOREACH", "FOREIGN", "INDEX", "INTEGRITY", "KEY", "ON", "UNIQUE", "BINARY", "AMP_ER", "APOS_ER", "QUOT_ER", "CONCAT", "LPAREN", "RPAREN", "DOLLAR", "LBRACKET", "RBRACKET", "LSQUARE", "RSQUARE", "EQUAL", "BIND", "NOTEQUAL", "ANN_PERCENT", "HASH", "AMP", "COMMA", "QUESTION", "STAR", "PLUS", "MINUS", "SMALLER", "GREATER", "SMALLEREQ", "GREATEREQ", "SMALLER_SMALLER", "GREATER_GREATER", "SLASH", "SLASH_SLASH", "DOT", "DOT_DOT", "COLON", "COLON_COLON", "EMPTY_CLOSE_TAG", "CLOSE_TAG", "SEMICOLON", "VBAR", "PRAGMA_START", "PRAGMA_END", "XML_COMMENT_START", "XML_COMMENT_END", "PI_START", "PI_END", "ATTR_SIGN", "CHARREF_DEC", "CHARREF_HEX", "APOS", "QUOT", "NCNameStartChar", "NCNameChar", "L_NCName", "Letter", "HexLetter", "Digit", "Digits", "S", "SU", "L_Pragma", "L_DirCommentConstructor", "L_DirPIConstructor", "L_IntegerLiteral", "L_DecimalLiteral", "L_DoubleLiteral", "L_Comment", "L_AnyChar", "L_QuotStringLiteralChar", "L_AposStringLiteralChar", "LibraryModule", "MainModule", "VersionDecl", "VersionDeclEncoding", "VersionDeclVersion", "ModuleDecl", "Prolog", "DefaultNamespaceDecls", "DefaultNamespaceDecl", "Setters", "Setter", "NamespaceDecls", "NamespaceDecl", "Imports", "FTOptionDecls", "SchemaImport", "SchemaPrefix", "NamespaceName", "DefaultElementNamespace", "AtHints", "ModuleImport", "BaseURIDecl", "OrderedDecls", "VarDecl", "VarType", "VarValue", "VarDefaultValue", "VarVariableDecl", "FunctionDecl", "ParamList", "ReturnType", "OptionDecl", "TypeDeclaration", "Param", "EnclosedExpr", "QueryBody", "UnaryExpr", "DirElemConstructor", "DirAttributeList", "DirAttributeValue", "DirElemContent", "CommonContent", "SequenceType", "EmptySequenceTest", "KindTest", "ItemTest", "FunctionTest", "AtomicType", "AtomicOrUnionType", "StringLiteral", "ElementContentChar", "AttributeValueChar", "QName", "BlockExpr", "BinaryTest", "EXPLICITLY"],
    FOLLOW_p_VersionDecl_in_p_Module507: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_LibraryModule_in_p_Module540: new org.antlr.runtime.BitSet([0x00000000, 0x00000000]),
    FOLLOW_p_MainModule_in_p_Module563: new org.antlr.runtime.BitSet([0x00000000, 0x00000000]),
    FOLLOW_EOF_in_p_Module587: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_XQUERY_in_p_VersionDecl615: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00002000]),
    FOLLOW_ENCODING_in_p_VersionDecl623: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_VersionDecl629: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_VERSION_in_p_VersionDecl650: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_VersionDecl656: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_ENCODING_in_p_VersionDecl661: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_VersionDecl667: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_VersionDecl673: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_Prolog_in_p_MainModule739: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_pm_QueryBody_in_p_MainModule741: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ModuleDecl_in_p_LibraryModule797: new org.antlr.runtime.BitSet([0x00000000, 0x10000004]),
    FOLLOW_pm_Prolog_in_p_LibraryModule799: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_MODULE_in_p_ModuleDecl855: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000400, 0x00000000]),
    FOLLOW_NAMESPACE_in_p_ModuleDecl859: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_p_ModuleDecl863: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
    FOLLOW_EQUAL_in_p_ModuleDecl865: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_ModuleDecl867: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_ModuleDecl869: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_DefaultNamespaceDecl_in_pm_Prolog928: new org.antlr.runtime.BitSet([0x00000002, 0x10000004]),
    FOLLOW_p_Setter_in_pm_Prolog934: new org.antlr.runtime.BitSet([0x00000002, 0x10000004]),
    FOLLOW_pm_NamespaceDecl_in_pm_Prolog940: new org.antlr.runtime.BitSet([0x00000002, 0x10000004]),
    FOLLOW_p_Import_in_pm_Prolog946: new org.antlr.runtime.BitSet([0x00000002, 0x10000004]),
    FOLLOW_pm_FTOptionDecl_in_pm_Prolog952: new org.antlr.runtime.BitSet([0x00000002, 0x10000004]),
    FOLLOW_pg_OrderedDecl_in_pm_Prolog959: new org.antlr.runtime.BitSet([0x00000002, 0x00000004]),
    FOLLOW_pm_ContextItemDecl_in_pg_OrderedDecl1274: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_AnnotatedDecl_in_pg_OrderedDecl1286: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_OptionDecl_in_pg_OrderedDecl1298: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_BoundarySpaceDecl_in_p_Setter1328: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_DefaultCollationDecl_in_p_Setter1340: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_BaseURIDecl_in_p_Setter1352: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_ConstructionDecl_in_p_Setter1364: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_OrderingModeDecl_in_p_Setter1376: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_EmptyOrderDecl_in_p_Setter1388: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_RevalidationDecl_in_p_Setter1403: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CopyNamespacesDecl_in_p_Setter1415: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_DecimalFormatDecl_in_p_Setter1427: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_BoundarySpaceDecl1459: new org.antlr.runtime.BitSet([0x01000000, 0x00000000]),
    FOLLOW_BOUNDARY_SPACE_in_pm_BoundarySpaceDecl1465: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x01000000, 0x00000008]),
    FOLLOW_PRESERVE_in_pm_BoundarySpaceDecl1474: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_STRIP_in_pm_BoundarySpaceDecl1484: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_BoundarySpaceDecl1491: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_DefaultCollationDecl1519: new org.antlr.runtime.BitSet([0x00000000, 0x00000008]),
    FOLLOW_DEFAULT_in_pm_DefaultCollationDecl1525: new org.antlr.runtime.BitSet([0x40000000, 0x00000000]),
    FOLLOW_COLLATION_in_pm_DefaultCollationDecl1531: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_DefaultCollationDecl1535: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_DefaultCollationDecl1537: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_BaseURIDecl1573: new org.antlr.runtime.BitSet([0x00800000, 0x00000000]),
    FOLLOW_BASE_URI_in_pm_BaseURIDecl1579: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_BaseURIDecl1585: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_BaseURIDecl1587: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_ConstructionDecl1640: new org.antlr.runtime.BitSet([0x00000000, 0x00000001]),
    FOLLOW_CONSTRUCTION_in_pm_ConstructionDecl1646: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x01000000, 0x00000008]),
    FOLLOW_STRIP_in_pm_ConstructionDecl1655: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_PRESERVE_in_pm_ConstructionDecl1661: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_ConstructionDecl1668: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_OrderingModeDecl1696: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_ORDERING_in_pm_OrderingModeDecl1702: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00080000, 0x00000400]),
    FOLLOW_ORDERED_in_pm_OrderingModeDecl1711: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_UNORDERED_in_pm_OrderingModeDecl1717: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_OrderingModeDecl1724: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_EmptyOrderDecl1752: new org.antlr.runtime.BitSet([0x00000000, 0x00000008]),
    FOLLOW_DEFAULT_in_pm_EmptyOrderDecl1758: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00040000, 0x00000000]),
    FOLLOW_ORDER_in_pm_EmptyOrderDecl1764: new org.antlr.runtime.BitSet([0x00000000, 0x00001000]),
    FOLLOW_EMPTY_in_pm_EmptyOrderDecl1770: new org.antlr.runtime.BitSet([0x00000000, 0x01000000,0x00000020, 0x00000000]),
    FOLLOW_GREATEST_in_pm_EmptyOrderDecl1779: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_LEAST_in_pm_EmptyOrderDecl1785: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_EmptyOrderDecl1792: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_CopyNamespacesDecl1820: new org.antlr.runtime.BitSet([0x00000000, 0x00000002]),
    FOLLOW_COPY_NAMESPACES_in_pm_CopyNamespacesDecl1826: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x01002000, 0x00000000]),
    FOLLOW_p_PreserveMode_in_pm_CopyNamespacesDecl1830: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_pm_CopyNamespacesDecl1832: new org.antlr.runtime.BitSet([0x00000000, 0x40000000,0x00001000, 0x00000000]),
    FOLLOW_p_InheritMode_in_pm_CopyNamespacesDecl1834: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_CopyNamespacesDecl1836: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PRESERVE_in_p_PreserveMode1865: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NO_PRESERVE_in_p_PreserveMode1871: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_INHERIT_in_p_InheritMode1903: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NO_INHERIT_in_p_InheritMode1909: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_DecimalFormatDecl1948: new org.antlr.runtime.BitSet([0x00000000, 0x00000008,0x00000000, 0x00100000]),
    FOLLOW_DECIMAL_FORMAT_in_pm_DecimalFormatDecl1956: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_pm_DecimalFormatDecl1960: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x2E600000,0x00001007, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_DEFAULT_in_pm_DecimalFormatDecl1968: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00100000]),
    FOLLOW_DECIMAL_FORMAT_in_pm_DecimalFormatDecl1974: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x2E600000,0x00001007, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_p_DFPropertyName_in_pm_DecimalFormatDecl1981: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
    FOLLOW_EQUAL_in_pm_DecimalFormatDecl1983: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_DecimalFormatDecl1985: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x2E600000,0x00001007, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_DecimalFormatDecl1989: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECIMAL_SEPARATOR_in_p_DFPropertyName2018: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_GROUPING_SEPARATOR_in_p_DFPropertyName2024: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_INFINITY_in_p_DFPropertyName2030: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_MINUS_SIGN_in_p_DFPropertyName2036: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NAN_in_p_DFPropertyName2042: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PERCENT_in_p_DFPropertyName2048: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PER_MILLE_in_p_DFPropertyName2054: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ZERO_DIGIT_in_p_DFPropertyName2060: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DIGIT_in_p_DFPropertyName2066: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PATTERN_SEPARATOR_in_p_DFPropertyName2072: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_SchemaImport_in_p_Import2101: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_ModuleImport_in_p_Import2105: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IMPORT_in_pm_SchemaImport2141: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x10000000, 0x00000000]),
    FOLLOW_SCHEMA_in_pm_SchemaImport2147: new org.antlr.runtime.BitSet([0x00000000, 0x00000008,0x00000400, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_SchemaPrefix_in_pm_SchemaImport2153: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_SchemaImport2158: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_AT_in_pm_SchemaImport2163: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_SchemaImport2169: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000400]),
    FOLLOW_COMMA_in_pm_SchemaImport2172: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_SchemaImport2176: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000400]),
    FOLLOW_SEMICOLON_in_pm_SchemaImport2182: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NAMESPACE_in_p_SchemaPrefix2252: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_p_SchemaPrefix2258: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
    FOLLOW_EQUAL_in_p_SchemaPrefix2260: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DEFAULT_in_p_SchemaPrefix2299: new org.antlr.runtime.BitSet([0x00000000, 0x00000400]),
    FOLLOW_ELEMENT_in_p_SchemaPrefix2305: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000400, 0x00000000]),
    FOLLOW_NAMESPACE_in_p_SchemaPrefix2311: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IMPORT_in_pm_ModuleImport2361: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000200, 0x00000000]),
    FOLLOW_MODULE_in_pm_ModuleImport2367: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000400, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_NAMESPACE_in_pm_ModuleImport2374: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_pm_ModuleImport2380: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
    FOLLOW_EQUAL_in_pm_ModuleImport2382: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_ModuleImport2388: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_AT_in_pm_ModuleImport2393: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_ModuleImport2399: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000400]),
    FOLLOW_COMMA_in_pm_ModuleImport2402: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_ModuleImport2406: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000400]),
    FOLLOW_SEMICOLON_in_pm_ModuleImport2412: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_NamespaceDecl2481: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000400, 0x00000000]),
    FOLLOW_NAMESPACE_in_pm_NamespaceDecl2487: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_pm_NamespaceDecl2493: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
    FOLLOW_EQUAL_in_pm_NamespaceDecl2495: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_NamespaceDecl2499: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_NamespaceDecl2501: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_DefaultNamespaceDecl2558: new org.antlr.runtime.BitSet([0x00000000, 0x00000008]),
    FOLLOW_DEFAULT_in_pm_DefaultNamespaceDecl2564: new org.antlr.runtime.BitSet([0x00000000, 0x00400400]),
    FOLLOW_ELEMENT_in_pm_DefaultNamespaceDecl2571: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000400, 0x00000000]),
    FOLLOW_FUNCTION_in_pm_DefaultNamespaceDecl2577: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000400, 0x00000000]),
    FOLLOW_NAMESPACE_in_pm_DefaultNamespaceDecl2584: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_DefaultNamespaceDecl2588: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_DefaultNamespaceDecl2590: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_AnnotatedDecl2618: new org.antlr.runtime.BitSet([0x00000000, 0x00400000,0x00000000, 0x00001000,0x08000000, 0x00000000,0x00188000, 0x00000080]),
    FOLLOW_p_Annotation_in_pm_AnnotatedDecl2622: new org.antlr.runtime.BitSet([0x00000000, 0x00400000,0x00000000, 0x00001000,0x08000000, 0x00000000,0x00188000, 0x00000080]),
    FOLLOW_pg_AnnotatedDecl_in_pm_AnnotatedDecl2625: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_AnnotatedDecl2627: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_VarDecl_in_pg_AnnotatedDecl2651: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_FunctionDecl_in_pg_AnnotatedDecl2663: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CollectionDecl_in_pg_AnnotatedDecl2678: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_IndexDecl_in_pg_AnnotatedDecl2693: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ICDecl_in_pg_AnnotatedDecl2708: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ANN_PERCENT_in_p_Annotation2734: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_Annotation2736: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_Annotation2739: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_Literal_in_p_Annotation2741: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_COMMA_in_p_Annotation2744: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_Literal_in_p_Annotation2746: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_RPAREN_in_p_Annotation2750: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_VARIABLE_in_p_VarDecl2780: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_VarDecl2786: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_VarDecl2790: new org.antlr.runtime.BitSet([0x00080000, 0x00040000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_p_TypeDeclaration_in_p_VarDecl2796: new org.antlr.runtime.BitSet([0x00000000, 0x00040000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_BIND_in_p_VarDecl2801: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarValue_in_p_VarDecl2805: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_EXTERNAL_in_p_VarDecl2813: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_BIND_in_p_VarDecl2818: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarDefaultValue_in_p_VarDecl2822: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_VarValue2901: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_VarDefaultValue2928: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_ContextItemDecl2957: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00040000]),
    FOLLOW_CONTEXT_in_pm_ContextItemDecl2963: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000004, 0x00000000]),
    FOLLOW_ITEM_in_pm_ContextItemDecl2969: new org.antlr.runtime.BitSet([0x00080000, 0x00040000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_AS_in_pm_ContextItemDecl2976: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ItemType_in_pm_ContextItemDecl2980: new org.antlr.runtime.BitSet([0x00000000, 0x00040000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_BIND_in_pm_ContextItemDecl2986: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarValue_in_pm_ContextItemDecl2988: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_EXTERNAL_in_pm_ContextItemDecl2996: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000020]),
    FOLLOW_BIND_in_pm_ContextItemDecl3001: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarDefaultValue_in_pm_ContextItemDecl3003: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_ContextItemDecl3009: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_UPDATING_in_pm_FunctionDecl3042: new org.antlr.runtime.BitSet([0x00000000, 0x00400000]),
    FOLLOW_FUNCTION_in_pm_FunctionDecl3050: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_pg_FQName_in_pm_FunctionDecl3056: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_pm_FunctionDecl3058: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0xC0000000, 0x00000000]),
    FOLLOW_p_ParamList_in_pm_FunctionDecl3062: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_pm_FunctionDecl3065: new org.antlr.runtime.BitSet([0x00080000, 0x00040000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_AS_in_pm_FunctionDecl3070: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_pm_FunctionDecl3076: new org.antlr.runtime.BitSet([0x00000000, 0x00040000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_FunctionDecl3081: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_pm_FunctionDecl3085: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_FunctionDecl3087: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_EXTERNAL_in_pm_FunctionDecl3093: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Param_in_p_ParamList3170: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_ParamList3173: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_p_Param_in_p_ParamList3177: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_DOLLAR_in_p_Param3237: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_Param3241: new org.antlr.runtime.BitSet([0x00080002, 0x00000000]),
    FOLLOW_p_TypeDeclaration_in_p_Param3247: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_EnclosedExpr_in_pm_FunctionBody3303: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LBRACKET_in_p_EnclosedExpr3330: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_EnclosedExpr3332: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_EnclosedExpr3335: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_OptionDecl3387: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00010000, 0x00000000]),
    FOLLOW_OPTION_in_pm_OptionDecl3393: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_pm_OptionDecl3397: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_pm_OptionDecl3399: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_OptionDecl3401: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Program_in_pm_QueryBody3430: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Expr_in_pm_QueryBody3442: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_Expr3478: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_Expr3494: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_Expr3496: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_p_FLWORHybrid_in_p_ExprSingle3563: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_IfHybrid_in_p_ExprSingle3593: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_SwitchHybrid_in_p_ExprSingle3619: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_TypeswitchHybrid_in_p_ExprSingle3641: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_TryCatchHybrid_in_p_ExprSingle3668: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSimple_in_p_ExprSingle3681: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_InitialClause_in_p_FLWORHybrid3708: new org.antlr.runtime.BitSet([0x00000000, 0x00200000,0x04040040, 0x01084002]),
    FOLLOW_p_IntermediateClause_in_p_FLWORHybrid3710: new org.antlr.runtime.BitSet([0x00000000, 0x00200000,0x04040040, 0x01084002]),
    FOLLOW_p_ReturnHybrid_in_p_FLWORHybrid3713: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ForClause_in_p_InitialClause3740: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_LetClause_in_p_InitialClause3744: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_WindowClause_in_p_InitialClause3748: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_InitialClause_in_p_IntermediateClause3774: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_WhereClause_in_p_IntermediateClause3778: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_GroupByClause_in_p_IntermediateClause3782: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_OrderByClause_in_p_IntermediateClause3786: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CountClause_in_p_IntermediateClause3790: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_RangeExpr_in_p_StringConcatExpr3811: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x10000000, 0x00000000]),
    FOLLOW_CONCAT_in_p_StringConcatExpr3815: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_RangeExpr_in_p_StringConcatExpr3817: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x10000000, 0x00000000]),
    FOLLOW_FOR_in_p_ForClause3844: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_p_ForBinding_in_p_ForClause3848: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_ForClause3851: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_p_ForBinding_in_p_ForClause3853: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_DOLLAR_in_p_ForBinding3883: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_ForBinding3887: new org.antlr.runtime.BitSet([0x00280000, 0x20000000,0x00000000, 0x00010000,0x00000000, 0x02000000]),
    FOLLOW_p_TypeDeclaration_in_p_ForBinding3891: new org.antlr.runtime.BitSet([0x00200000, 0x20000000,0x00000000, 0x00010000,0x00000000, 0x02000000]),
    FOLLOW_p_AllowingEmpty_in_p_ForBinding3894: new org.antlr.runtime.BitSet([0x00200000, 0x20000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
    FOLLOW_p_PositionalVar_in_p_ForBinding3897: new org.antlr.runtime.BitSet([0x00000000, 0x20000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
    FOLLOW_p_FTScoreVar_in_p_ForBinding3900: new org.antlr.runtime.BitSet([0x00000000, 0x20000000]),
    FOLLOW_IN_in_p_ForBinding3905: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_ForBinding3909: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ALLOWING_in_p_AllowingEmpty3938: new org.antlr.runtime.BitSet([0x00000000, 0x00001000]),
    FOLLOW_EMPTY_in_p_AllowingEmpty3944: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_PositionalVar3974: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_PositionalVar3980: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_PositionalVar3984: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LET_in_p_LetClause4014: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000,0x80000000, 0x00000000]),
    FOLLOW_p_LetBinding_in_p_LetClause4018: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_LetClause4021: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000,0x80000000, 0x00000000]),
    FOLLOW_p_LetBinding_in_p_LetClause4023: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_DOLLAR_in_p_LetBinding4057: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_LetBinding4061: new org.antlr.runtime.BitSet([0x00080000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_p_TypeDeclaration_in_p_LetBinding4065: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_p_FTScoreVar_in_p_LetBinding4071: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_BIND_in_p_LetBinding4075: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_LetBinding4077: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FOR_in_p_WindowClause4106: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000110, 0x00000000]),
    FOLLOW_p_TumblingWindowClause_in_p_WindowClause4111: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_SlidingWindowClause_in_p_WindowClause4115: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TUMBLING_in_p_TumblingWindowClause4152: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
    FOLLOW_WINDOW_in_p_TumblingWindowClause4158: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_TumblingWindowClause4164: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_TumblingWindowClause4168: new org.antlr.runtime.BitSet([0x00080000, 0x20000000]),
    FOLLOW_p_TypeDeclaration_in_p_TumblingWindowClause4172: new org.antlr.runtime.BitSet([0x00000000, 0x20000000]),
    FOLLOW_IN_in_p_TumblingWindowClause4177: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_TumblingWindowClause4181: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_p_WindowStartCondition_in_p_TumblingWindowClause4184: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x80800000]),
    FOLLOW_p_WindowEndCondition_in_p_TumblingWindowClause4186: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SLIDING_in_p_SlidingWindowClause4215: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
    FOLLOW_WINDOW_in_p_SlidingWindowClause4221: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_SlidingWindowClause4227: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_SlidingWindowClause4231: new org.antlr.runtime.BitSet([0x00080000, 0x20000000]),
    FOLLOW_p_TypeDeclaration_in_p_SlidingWindowClause4235: new org.antlr.runtime.BitSet([0x00000000, 0x20000000]),
    FOLLOW_IN_in_p_SlidingWindowClause4240: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_SlidingWindowClause4244: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_p_WindowStartCondition_in_p_SlidingWindowClause4247: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x80800000]),
    FOLLOW_p_WindowEndCondition_in_p_SlidingWindowClause4249: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_START_in_p_WindowStartCondition4278: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x40000000,0x00000408, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_p_WindowVars_in_p_WindowStartCondition4282: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
    FOLLOW_WHEN_in_p_WindowStartCondition4286: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_WindowStartCondition4290: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ONLY_in_p_WindowEndCondition4320: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00800000]),
    FOLLOW_END_in_p_WindowEndCondition4328: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x40000000,0x00000408, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_p_WindowVars_in_p_WindowEndCondition4332: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
    FOLLOW_WHEN_in_p_WindowEndCondition4336: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_WindowEndCondition4340: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOLLAR_in_p_WindowVars4370: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_CurrentItem_in_p_WindowVars4374: new org.antlr.runtime.BitSet([0x00200002, 0x00000000,0x00000000, 0x40000000,0x00000008, 0x00000000]),
    FOLLOW_p_PositionalVar_in_p_WindowVars4380: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x40000000,0x00000008, 0x00000000]),
    FOLLOW_PREVIOUS_in_p_WindowVars4386: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_WindowVars4390: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_PreviousItem_in_p_WindowVars4392: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_NEXT_in_p_WindowVars4399: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_WindowVars4403: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NextItem_in_p_WindowVars4405: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_CurrentItem4433: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_PreviousItem4459: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_NextItem4485: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COUNT_in_p_CountClause4513: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_CountClause4519: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_CountClause4523: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_WHERE_in_p_WhereClause4561: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_WhereClause4565: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_GROUP_in_p_GroupByClause4594: new org.antlr.runtime.BitSet([0x02000000, 0x00000000]),
    FOLLOW_BY_in_p_GroupByClause4600: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_p_GroupingSpecList_in_p_GroupByClause4604: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_GroupingSpec_in_p_GroupingSpecList4630: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_GroupingSpecList4633: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_p_GroupingSpec_in_p_GroupingSpecList4635: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_DOLLAR_in_p_GroupingSpec4665: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_GroupingSpec4669: new org.antlr.runtime.BitSet([0x40000002, 0x00000000]),
    FOLLOW_COLLATION_in_p_GroupingSpec4676: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_GroupingSpec4680: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ORDER_in_p_OrderByClause4712: new org.antlr.runtime.BitSet([0x02000000, 0x00000000]),
    FOLLOW_BY_in_p_OrderByClause4716: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_STABLE_in_p_OrderByClause4724: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00040000, 0x00000000]),
    FOLLOW_ORDER_in_p_OrderByClause4728: new org.antlr.runtime.BitSet([0x02000000, 0x00000000]),
    FOLLOW_BY_in_p_OrderByClause4732: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_OrderSpecList_in_p_OrderByClause4738: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_OrderSpec_in_p_OrderSpecList4764: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_OrderSpecList4767: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_OrderSpec_in_p_OrderSpecList4769: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_p_ExprSingle_in_p_OrderSpec4797: new org.antlr.runtime.BitSet([0x40100000, 0x00001040]),
    FOLLOW_p_OrderModifier_in_p_OrderSpec4800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ASCENDING_in_p_OrderModifier4829: new org.antlr.runtime.BitSet([0x40000002, 0x00001000]),
    FOLLOW_DESCENDING_in_p_OrderModifier4835: new org.antlr.runtime.BitSet([0x40000002, 0x00001000]),
    FOLLOW_EMPTY_in_p_OrderModifier4842: new org.antlr.runtime.BitSet([0x00000000, 0x01000000,0x00000020, 0x00000000]),
    FOLLOW_GREATEST_in_p_OrderModifier4847: new org.antlr.runtime.BitSet([0x40000002, 0x00000000]),
    FOLLOW_LEAST_in_p_OrderModifier4853: new org.antlr.runtime.BitSet([0x40000002, 0x00000000]),
    FOLLOW_COLLATION_in_p_OrderModifier4861: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_OrderModifier4863: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_RETURN_in_p_ReturnHybrid4896: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_ReturnHybrid4900: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SOME_in_p_QuantifiedExpr4930: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_EVERY_in_p_QuantifiedExpr4936: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_QuantifiedExpr4943: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_QuantifiedExpr4947: new org.antlr.runtime.BitSet([0x00080000, 0x20000000]),
    FOLLOW_p_TypeDeclaration_in_p_QuantifiedExpr4951: new org.antlr.runtime.BitSet([0x00000000, 0x20000000]),
    FOLLOW_IN_in_p_QuantifiedExpr4956: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_QuantifiedExpr4960: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x08000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_QuantifiedExpr4964: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_QuantifiedExpr4968: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_QuantifiedExpr4972: new org.antlr.runtime.BitSet([0x00080000, 0x20000000]),
    FOLLOW_p_TypeDeclaration_in_p_QuantifiedExpr4976: new org.antlr.runtime.BitSet([0x00000000, 0x20000000]),
    FOLLOW_IN_in_p_QuantifiedExpr4981: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_QuantifiedExpr4985: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x08000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_SATISFIES_in_p_QuantifiedExpr4992: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_QuantifiedExpr4996: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SWITCH_in_p_SwitchHybrid5026: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_SwitchHybrid5030: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_SwitchHybrid5032: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_SwitchHybrid5035: new org.antlr.runtime.BitSet([0x04000000, 0x00000000]),
    FOLLOW_p_SwitchCaseHybrid_in_p_SwitchHybrid5037: new org.antlr.runtime.BitSet([0x04000000, 0x00000008]),
    FOLLOW_DEFAULT_in_p_SwitchHybrid5043: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_SwitchHybrid5049: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_SwitchHybrid5053: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CASE_in_p_SwitchCaseHybrid5084: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SwitchCaseOperand_in_p_SwitchCaseHybrid5088: new org.antlr.runtime.BitSet([0x04000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_SwitchCaseHybrid5094: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_SwitchCaseHybrid5098: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_SwitchCaseOperand5125: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TYPESWITCH_in_p_TypeswitchHybrid5155: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_TypeswitchHybrid5159: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_TypeswitchHybrid5161: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_TypeswitchHybrid5164: new org.antlr.runtime.BitSet([0x04000000, 0x00000000]),
    FOLLOW_p_CaseHybrid_in_p_TypeswitchHybrid5166: new org.antlr.runtime.BitSet([0x04000000, 0x00000008]),
    FOLLOW_DEFAULT_in_p_TypeswitchHybrid5172: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_TypeswitchHybrid5179: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_TypeswitchHybrid5183: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_TypeswitchHybrid5191: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_TypeswitchHybrid5195: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CASE_in_p_CaseHybrid5225: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_CaseHybrid5232: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_CaseHybrid5236: new org.antlr.runtime.BitSet([0x00080000, 0x00000000]),
    FOLLOW_AS_in_p_CaseHybrid5242: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceTypeUnion_in_p_CaseHybrid5248: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_CaseHybrid5252: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_CaseHybrid5256: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_SequenceTypeUnion5283: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_VBAR_in_p_SequenceTypeUnion5286: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_SequenceTypeUnion5288: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_IF_in_p_IfHybrid5319: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_IfHybrid5323: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_IfHybrid5325: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_IfHybrid5328: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_THEN_in_p_IfHybrid5332: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_IfHybrid5336: new org.antlr.runtime.BitSet([0x00000000, 0x00000800]),
    FOLLOW_ELSE_in_p_IfHybrid5341: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_IfHybrid5345: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_TryClause_in_p_TryCatchExpr5372: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_p_CatchClause_in_p_TryCatchExpr5374: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_TRY_in_p_TryClause5403: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_TryClause5407: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_TryTargetExpr_in_p_TryClause5409: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_TryClause5411: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Expr_in_p_TryTargetExpr5437: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CATCH_in_p_CatchClause5466: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x01001001,0x01C01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_CatchErrorList_in_p_CatchClause5470: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_CatchClause5472: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_CatchClause5474: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_CatchClause5477: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NameTest_in_p_CatchErrorList5503: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_VBAR_in_p_CatchErrorList5506: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x01001000,0x01C01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NameTest_in_p_CatchErrorList5508: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_p_AndExpr_in_p_OrExpr5553: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
    FOLLOW_OR_in_p_OrExpr5559: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AndExpr_in_p_OrExpr5563: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
    FOLLOW_p_ComparisonExpr_in_p_AndExpr5592: new org.antlr.runtime.BitSet([0x00040002, 0x00000000]),
    FOLLOW_AND_in_p_AndExpr5598: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ComparisonExpr_in_p_AndExpr5602: new org.antlr.runtime.BitSet([0x00040002, 0x00000000]),
    FOLLOW_p_FTContainsExpr_in_p_ComparisonExpr5632: new org.antlr.runtime.BitSet([0x00000002, 0x02808000,0x00000892, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x001F8050]),
    FOLLOW_p_ValueComp_in_p_ComparisonExpr5637: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_GeneralComp_in_p_ComparisonExpr5641: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NodeComp_in_p_ComparisonExpr5645: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_FTContainsExpr_in_p_ComparisonExpr5648: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_RangeExpr5677: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000040]),
    FOLLOW_TO_in_p_RangeExpr5683: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_RangeExpr5687: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_MultiplicativeExpr_in_p_AdditiveExpr5716: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
    FOLLOW_PLUS_in_p_AdditiveExpr5723: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_MINUS_in_p_AdditiveExpr5731: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_MultiplicativeExpr_in_p_AdditiveExpr5736: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
    FOLLOW_p_UnionExpr_in_p_MultiplicativeExpr5765: new org.antlr.runtime.BitSet([0x00000002, 0x04000080,0x00000100, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001000]),
    FOLLOW_STAR_in_p_MultiplicativeExpr5772: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_DIV_in_p_MultiplicativeExpr5781: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_IDIV_in_p_MultiplicativeExpr5787: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_MOD_in_p_MultiplicativeExpr5793: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_UnionExpr_in_p_MultiplicativeExpr5799: new org.antlr.runtime.BitSet([0x00000002, 0x04000080,0x00000100, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001000]),
    FOLLOW_p_IntersectExceptExpr_in_p_UnionExpr5828: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000200,0x00000000, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_UNION_in_p_UnionExpr5835: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_VBAR_in_p_UnionExpr5841: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_IntersectExceptExpr_in_p_UnionExpr5844: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000200,0x00000000, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_p_InstanceofExpr_in_p_IntersectExceptExpr5873: new org.antlr.runtime.BitSet([0x00000002, 0x00020000,0x00000001, 0x00000000]),
    FOLLOW_INTERSECT_in_p_IntersectExceptExpr5880: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_EXCEPT_in_p_IntersectExceptExpr5886: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_InstanceofExpr_in_p_IntersectExceptExpr5891: new org.antlr.runtime.BitSet([0x00000002, 0x00020000,0x00000001, 0x00000000]),
    FOLLOW_p_TreatExpr_in_p_InstanceofExpr5920: new org.antlr.runtime.BitSet([0x00000002, 0x80000000]),
    FOLLOW_INSTANCE_in_p_InstanceofExpr5926: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00008000, 0x00000000]),
    FOLLOW_OF_in_p_InstanceofExpr5932: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_InstanceofExpr5936: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CastableExpr_in_p_TreatExpr5964: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000080]),
    FOLLOW_TREAT_in_p_TreatExpr5970: new org.antlr.runtime.BitSet([0x00080000, 0x00000000]),
    FOLLOW_AS_in_p_TreatExpr5976: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_TreatExpr5980: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CastExpr_in_p_CastableExpr6017: new org.antlr.runtime.BitSet([0x10000002, 0x00000000]),
    FOLLOW_CASTABLE_in_p_CastableExpr6023: new org.antlr.runtime.BitSet([0x00080000, 0x00000000]),
    FOLLOW_AS_in_p_CastableExpr6029: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SingleType_in_p_CastableExpr6033: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_UnaryExpr_in_p_CastExpr6070: new org.antlr.runtime.BitSet([0x08000002, 0x00000000]),
    FOLLOW_CAST_in_p_CastExpr6076: new org.antlr.runtime.BitSet([0x00080000, 0x00000000]),
    FOLLOW_AS_in_p_CastExpr6082: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SingleType_in_p_CastExpr6086: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PLUS_in_p_UnaryExpr6118: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_MINUS_in_p_UnaryExpr6126: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ValueExpr_in_p_UnaryExpr6131: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ValidateExpr_in_p_ValueExpr6201: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PathExpr_in_p_ValueExpr6213: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExtensionExpr_in_p_ValueExpr6225: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_p_GeneralComp0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_EQ_in_p_ValueComp6300: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NE_in_p_ValueComp6306: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LT_in_p_ValueComp6312: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LE_in_p_ValueComp6318: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_GT_in_p_ValueComp6324: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_GE_in_p_ValueComp6330: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IS_in_p_NodeComp6361: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SMALLER_SMALLER_in_p_NodeComp6367: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_GREATER_GREATER_in_p_NodeComp6371: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_VALIDATE_in_p_ValidateExpr6399: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000008, 0x00000004,0x00000200, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_p_ValidationMode_in_p_ValidateExpr6405: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_TYPE_in_p_ValidateExpr6411: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_TypeName_in_p_ValidateExpr6415: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_ValidateExpr6420: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_ValidateExpr6422: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_ValidateExpr6425: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LAX_in_p_ValidationMode6454: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_STRICT_in_p_ValidationMode6460: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_Pragma_in_p_ExtensionExpr6489: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00080000, 0x00000000]),
    FOLLOW_LBRACKET_in_p_ExtensionExpr6492: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F003,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_ExtensionExpr6494: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_ExtensionExpr6498: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SLASH_in_p_PathExpr6541: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_RelativePathExpr_in_p_PathExpr6543: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SLASH_in_p_PathExpr6556: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SLASH_SLASH_in_p_PathExpr6568: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_RelativePathExpr_in_p_PathExpr6570: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_RelativePathExpr_in_p_PathExpr6582: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_StepExpr_in_p_RelativePathExpr6610: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00600000]),
    FOLLOW_set_in_p_RelativePathExpr6613: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StepExpr_in_p_RelativePathExpr6621: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00600000]),
    FOLLOW_p_PostfixExpr_in_p_StepExpr6675: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PostfixExpr_in_p_StepExpr6789: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AxisStep_in_p_StepExpr6807: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PostfixExpr_in_p_StepExpr6828: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PostfixExpr_in_p_StepExpr6846: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AxisStep_in_p_StepExpr6858: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ReverseStep_in_p_AxisStep6885: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
    FOLLOW_p_ForwardStep_in_p_AxisStep6889: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
    FOLLOW_p_PredicateList_in_p_AxisStep6892: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ForwardAxis_in_p_ForwardStep6918: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x01001000,0x01C01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NodeTest_in_p_ForwardStep6920: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AbbrevForwardStep_in_p_ForwardStep6932: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CHILD_in_p_ForwardAxis6958: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ForwardAxis6960: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DESCENDANT_in_p_ForwardAxis6972: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ForwardAxis6974: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ATTRIBUTE_in_p_ForwardAxis6986: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ForwardAxis6988: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SELF_in_p_ForwardAxis7000: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ForwardAxis7002: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DESCENDANT_OR_SELF_in_p_ForwardAxis7014: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ForwardAxis7016: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FOLLOWING_SIBLING_in_p_ForwardAxis7028: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ForwardAxis7030: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FOLLOWING_in_p_ForwardAxis7042: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ForwardAxis7044: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ATTR_SIGN_in_p_AbbrevForwardStep7070: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x01001000,0x01C01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NodeTest_in_p_AbbrevForwardStep7073: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ReverseAxis_in_p_ReverseStep7099: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x01001000,0x01C01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NodeTest_in_p_ReverseStep7101: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AbbrevReverseStep_in_p_ReverseStep7113: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PARENT_in_p_ReverseAxis7139: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ReverseAxis7141: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ANCESTOR_in_p_ReverseAxis7153: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ReverseAxis7155: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PRECEDING_SIBLING_in_p_ReverseAxis7167: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ReverseAxis7169: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PRECEDING_in_p_ReverseAxis7181: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ReverseAxis7183: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ANCESTOR_OR_SELF_in_p_ReverseAxis7195: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_COLON_COLON_in_p_ReverseAxis7197: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOT_DOT_in_p_AbbrevReverseStep7223: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_KindTest_in_p_NodeTest7249: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NameTest_in_p_NodeTest7253: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Wildcard_in_p_NameTest7285: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_NameTest7306: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_NameTest7324: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_STAR_in_p_Wildcard7354: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
    FOLLOW_COLON_in_p_Wildcard7357: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_p_Wildcard7359: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NCName_in_p_Wildcard7373: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
    FOLLOW_COLON_in_p_Wildcard7375: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001000]),
    FOLLOW_STAR_in_p_Wildcard7377: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_Wildcard7389: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
    FOLLOW_COLON_in_p_Wildcard7391: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001000]),
    FOLLOW_STAR_in_p_Wildcard7393: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PrimaryExpr_in_p_PostfixExpr7431: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
    FOLLOW_p_Predicate_in_p_PostfixExpr7434: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
    FOLLOW_LPAREN_in_p_ArgumentList7475: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xEFFFFFFF, 0x01E0F801,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Argument_in_p_ArgumentList7478: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_COMMA_in_p_ArgumentList7481: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F801,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Argument_in_p_ArgumentList7483: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_RPAREN_in_p_ArgumentList7489: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Predicate_in_p_PredicateList7515: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
    FOLLOW_LSQUARE_in_p_Predicate7542: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_Predicate7544: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000008]),
    FOLLOW_RSQUARE_in_p_Predicate7547: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ParenthesizedExpr_in_p_PrimaryExpr7580: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Literal_in_p_PrimaryExpr7592: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_VarRef_in_p_PrimaryExpr7604: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ContextItemExpr_in_p_PrimaryExpr7616: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FunctionCall_in_p_PrimaryExpr7628: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_OrderedExpr_in_p_PrimaryExpr7640: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_UnorderedExpr_in_p_PrimaryExpr7652: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Constructor_in_p_PrimaryExpr7664: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_BlockExpr_in_p_PrimaryExpr7678: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NumericLiteral_in_p_Literal7704: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_Literal7708: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_IntegerLiteral_in_p_NumericLiteral7736: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_DecimalLiteral_in_p_NumericLiteral7744: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_DoubleLiteral_in_p_NumericLiteral7752: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOLLAR_in_p_VarRef7790: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_VarRef7794: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_VarName7822: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LPAREN_in_p_ParenthesizedExpr7848: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xEFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_ParenthesizedExpr7850: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_ParenthesizedExpr7854: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOT_in_p_ContextItemExpr7880: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ORDERED_in_p_OrderedExpr7908: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_OrderedExpr7912: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_OrderedExpr7914: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_OrderedExpr7917: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_UNORDERED_in_p_UnorderedExpr7945: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_UnorderedExpr7949: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_UnorderedExpr7951: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_UnorderedExpr7954: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pg_FQName_in_p_FunctionCall7983: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_p_ArgumentList_in_p_FunctionCall7988: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_Argument8014: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ArgumentPlaceholder_in_p_Argument8019: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_QUESTION_in_p_ArgumentPlaceholder8045: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_DirectConstructor_in_p_Constructor8071: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ComputedConstructor_in_p_Constructor8083: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_DirElemConstructor_in_p_DirectConstructor8109: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_DirCommentConstructor_in_p_DirectConstructor8121: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_DirPIConstructor_in_p_DirectConstructor8133: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SMALLER_in_p_DirElemConstructor8160: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_DirElemConstructor8176: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08010000,0x00020000, 0x00000000]),
    FOLLOW_p_DirAttributeList_in_p_DirElemConstructor8181: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08010000]),
    FOLLOW_EMPTY_CLOSE_TAG_in_p_DirElemConstructor8195: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_GREATER_in_p_DirElemConstructor8200: new org.antlr.runtime.BitSet([0x00000FC0, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10008001,0x00300000, 0x00000000]),
    FOLLOW_pm_DirElemContent_in_p_DirElemConstructor8202: new org.antlr.runtime.BitSet([0x00000FC0, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10008001,0x00300000, 0x00000000]),
    FOLLOW_CLOSE_TAG_in_p_DirElemConstructor8205: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_DirElemConstructor8209: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00010000,0x00020000, 0x00000000]),
    FOLLOW_S_in_p_DirElemConstructor8213: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00010000]),
    FOLLOW_GREATER_in_p_DirElemConstructor8216: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_S_in_p_DirAttributeList8293: new org.antlr.runtime.BitSet([0xFFFF0002, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00021000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_DirAttributeList8298: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010,0x00020000, 0x00000000]),
    FOLLOW_S_in_p_DirAttributeList8302: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
    FOLLOW_EQUAL_in_p_DirAttributeList8305: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00020300, 0x00000000]),
    FOLLOW_S_in_p_DirAttributeList8307: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00020300, 0x00000000]),
    FOLLOW_p_DirAttributeValue_in_p_DirAttributeList8312: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00020000, 0x00000000]),
    FOLLOW_QUOT_in_p_DirAttributeValue8345: new org.antlr.runtime.BitSet([0x00002F10, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_ESCAPE_QUOT_in_p_DirAttributeValue8348: new org.antlr.runtime.BitSet([0x00002F10, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_APOS_in_p_DirAttributeValue8352: new org.antlr.runtime.BitSet([0x00002F10, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_p_QuotAttrValueContent_in_p_DirAttributeValue8356: new org.antlr.runtime.BitSet([0x00002F10, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_QUOT_in_p_DirAttributeValue8360: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_APOS_in_p_DirAttributeValue8399: new org.antlr.runtime.BitSet([0x00001F20, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_ESCAPE_APOS_in_p_DirAttributeValue8402: new org.antlr.runtime.BitSet([0x00001F20, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_QUOT_in_p_DirAttributeValue8406: new org.antlr.runtime.BitSet([0x00001F20, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_p_AposAttrValueContent_in_p_DirAttributeValue8410: new org.antlr.runtime.BitSet([0x00001F20, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00000300, 0x00000000]),
    FOLLOW_APOS_in_p_DirAttributeValue8414: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QuotAttrContentChar_in_p_QuotAttrValueContent8466: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CommonContent_in_p_QuotAttrValueContent8470: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AposAttrContentChar_in_p_AposAttrValueContent8496: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CommonContent_in_p_AposAttrValueContent8500: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_DirectConstructor_in_pm_DirElemContent8526: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CDataSection_in_pm_DirElemContent8538: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CommonContent_in_pm_DirElemContent8550: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ElementContentChar_in_pm_DirElemContent8562: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_PredefinedEntityRef_in_pm_CommonContent8590: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_CharRef_in_pm_CommonContent8602: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ESCAPE_LBRACKET_in_pm_CommonContent8614: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ESCAPE_RBRACKET_in_pm_CommonContent8626: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pg_EnclosedExprXml_in_pm_CommonContent8638: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LBRACKET_in_pg_EnclosedExprXml8670: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_pg_EnclosedExprXml8686: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pg_EnclosedExprXml8700: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_DirCommentConstructor_in_p_DirCommentConstructor8731: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_DirPIConstructor_in_p_DirPIConstructor8765: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_CDataSection_in_p_CDataSection8798: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CompDocConstructor_in_p_ComputedConstructor8830: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CompElemConstructor_in_p_ComputedConstructor8842: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CompAttrConstructor_in_p_ComputedConstructor8854: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CompNamespaceConstructor_in_p_ComputedConstructor8866: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CompTextConstructor_in_p_ComputedConstructor8878: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CompCommentConstructor_in_p_ComputedConstructor8890: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pm_CompPIConstructor_in_p_ComputedConstructor8902: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CompBinaryConstructor_in_p_ComputedConstructor8917: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOCUMENT_in_pm_CompDocConstructor8946: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompDocConstructor8950: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompDocConstructor8952: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompDocConstructor8954: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ELEMENT_in_pm_CompElemConstructor8990: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000001,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_pm_CompElemConstructor8995: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompElemConstructor9000: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_pm_CompElemConstructor9002: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompElemConstructor9005: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompElemConstructor9009: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_pm_ContentExpr_in_pm_CompElemConstructor9011: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompElemConstructor9013: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_pm_ContentExpr9040: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ATTRIBUTE_in_pm_CompAttrConstructor9069: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000001,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_pm_CompAttrConstructor9074: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompAttrConstructor9079: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_pm_CompAttrConstructor9081: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompAttrConstructor9084: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompAttrConstructor9088: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompAttrConstructor9090: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompAttrConstructor9092: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NAMESPACE_in_p_CompNamespaceConstructor9120: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000001,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Prefix_in_p_CompNamespaceConstructor9125: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_CompNamespaceConstructor9130: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_PrefixExpr_in_p_CompNamespaceConstructor9132: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_CompNamespaceConstructor9134: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_CompNamespaceConstructor9138: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F003,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_URIExpr_in_p_CompNamespaceConstructor9140: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_CompNamespaceConstructor9143: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NCName_in_p_Prefix9169: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Expr_in_p_PrefixExpr9195: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Expr_in_p_URIExpr9222: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TEXT_in_p_CompTextConstructor9251: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_CompTextConstructor9255: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_CompTextConstructor9257: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_CompTextConstructor9260: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_BINARY_in_p_CompBinaryConstructor9288: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_CompBinaryConstructor9292: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_CompBinaryConstructor9294: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_CompBinaryConstructor9297: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COMMENT_in_pm_CompCommentConstructor9326: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompCommentConstructor9330: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompCommentConstructor9332: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompCommentConstructor9334: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PROCESSING_INSTRUCTION_in_pm_CompPIConstructor9363: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000001,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_pm_CompPIConstructor9368: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompPIConstructor9373: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_pm_CompPIConstructor9375: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompPIConstructor9378: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_pm_CompPIConstructor9382: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_pm_CompPIConstructor9384: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_pm_CompPIConstructor9386: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AtomicOrUnionType_in_p_SingleType9430: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000800]),
    FOLLOW_QUESTION_in_p_SingleType9432: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AS_in_p_TypeDeclaration9461: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_TypeDeclaration9467: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_EMPTY_SEQUENCE_in_p_SequenceType9520: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_SequenceType9526: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_SequenceType9530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ItemType_in_p_SequenceType9579: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00003800]),
    FOLLOW_p_OccurrenceIndicator_in_p_SequenceType9590: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_p_OccurrenceIndicator0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_KindTest_in_p_ItemType9692: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_BINARY_in_p_ItemType9732: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_ItemType9734: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_ItemType9736: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ITEM_in_p_ItemType9778: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_ItemType9780: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_ItemType9782: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AtomicOrUnionType_in_p_ItemType9826: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ParenthesizedItemType_in_p_ItemType9838: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_AtomicOrUnionType9864: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_DocumentTest_in_p_KindTest9914: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ElementTest_in_p_KindTest9926: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AttributeTest_in_p_KindTest9938: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_SchemaElementTest_in_p_KindTest9950: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_SchemaAttributeTest_in_p_KindTest9962: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PITest_in_p_KindTest9974: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_CommentTest_in_p_KindTest9986: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_TextTest_in_p_KindTest9998: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NamespaceNodeTest_in_p_KindTest10010: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AnyKindTest_in_p_KindTest10022: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NODE_in_p_AnyKindTest10048: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_AnyKindTest10050: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_AnyKindTest10052: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOCUMENT_NODE_in_p_DocumentTest10078: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_DocumentTest10080: new org.antlr.runtime.BitSet([0x00000000, 0x00000400,0x40000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_p_ElementTest_in_p_DocumentTest10083: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_p_SchemaElementTest_in_p_DocumentTest10087: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_DocumentTest10091: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TEXT_in_p_TextTest10117: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_TextTest10119: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_TextTest10121: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COMMENT_in_p_CommentTest10147: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_CommentTest10149: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_CommentTest10151: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NAMESPACE_NODE_in_p_NamespaceNodeTest10177: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_NamespaceNodeTest10179: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_NamespaceNodeTest10181: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PROCESSING_INSTRUCTION_in_p_PITest10207: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_PITest10209: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x4FFFFFFF, 0x00000000,0x01C01300, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_p_PITest10212: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_PITest10216: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_PITest10220: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ATTRIBUTE_in_p_AttributeTest10246: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_AttributeTest10248: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x4FFFFFFF, 0x00001000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AttribNameOrWildcard_in_p_AttributeTest10251: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_COMMA_in_p_AttributeTest10254: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_TypeName_in_p_AttributeTest10256: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_AttributeTest10262: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AttributeName_in_p_AttribNameOrWildcard10290: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_STAR_in_p_AttribNameOrWildcard10294: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SCHEMA_ATTRIBUTE_in_p_SchemaAttributeTest10320: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_SchemaAttributeTest10322: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AttributeDeclaration_in_p_SchemaAttributeTest10324: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_SchemaAttributeTest10326: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AttributeName_in_p_AttributeDeclaration10352: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ELEMENT_in_p_ElementTest10378: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_ElementTest10380: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x4FFFFFFF, 0x00001000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ElementNameOrWildcard_in_p_ElementTest10383: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_COMMA_in_p_ElementTest10386: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_TypeName_in_p_ElementTest10388: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000800]),
    FOLLOW_QUESTION_in_p_ElementTest10390: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_ElementTest10397: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_ElementNameOrWildcard10423: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_STAR_in_p_ElementNameOrWildcard10427: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SCHEMA_ELEMENT_in_p_SchemaElementTest10445: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_SchemaElementTest10447: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ElementDeclaration_in_p_SchemaElementTest10449: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_SchemaElementTest10451: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ElementName_in_p_ElementDeclaration10477: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_AttributeName10503: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_ElementName10529: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_TypeName10555: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Annotation_in_p_FunctionTest10581: new org.antlr.runtime.BitSet([0x00000000, 0x00400000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000080]),
    FOLLOW_p_AnyFunctionTest_in_p_FunctionTest10585: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_TypedFunctionTest_in_p_FunctionTest10589: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FUNCTION_in_p_AnyFunctionTest10616: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_AnyFunctionTest10618: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001000]),
    FOLLOW_STAR_in_p_AnyFunctionTest10620: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_AnyFunctionTest10622: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FUNCTION_in_p_TypedFunctionTest10648: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_TypedFunctionTest10650: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x6FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_TypedFunctionTest10653: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_COMMA_in_p_TypedFunctionTest10656: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_TypedFunctionTest10658: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_RPAREN_in_p_TypedFunctionTest10664: new org.antlr.runtime.BitSet([0x00080000, 0x00000000]),
    FOLLOW_AS_in_p_TypedFunctionTest10666: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_TypedFunctionTest10668: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LPAREN_in_p_ParenthesizedItemType10694: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ItemType_in_p_ParenthesizedItemType10696: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_ParenthesizedItemType10698: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_QUOT_in_p_StringLiteral10749: new org.antlr.runtime.BitSet([0xFFFFFFF0, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFDFF,0xFFFFFFFF, 0xFFFFFFFF,0x001FFFFF, 0x00000000]),
    FOLLOW_pg_QuotStringLiteralContent_in_p_StringLiteral10753: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000200, 0x00000000]),
    FOLLOW_QUOT_in_p_StringLiteral10755: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_APOS_in_p_StringLiteral10794: new org.antlr.runtime.BitSet([0xFFFFFFF0, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFDFF,0xFFFFFFFF, 0xFFFFFFFF,0x001FFFFF, 0x00000000]),
    FOLLOW_pg_AposStringLiteralContent_in_p_StringLiteral10798: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
    FOLLOW_APOS_in_p_StringLiteral10800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_pg_QuotStringLiteralContent10866: new org.antlr.runtime.BitSet([0xFFFFFFF2, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFDFF,0xFFFFFDFF, 0xFFFFFFFF,0x001FFFFF, 0x00000000]),
    FOLLOW_set_in_pg_AposStringLiteralContent10917: new org.antlr.runtime.BitSet([0xFFFFFFF2, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFDFF,0xFFFFFEFF, 0xFFFFFFFF,0x001FFFFF, 0x00000000]),
    FOLLOW_L_ElementContentChar_in_p_ElementContentChar10975: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_QuotAttrContentChar_in_p_QuotAttrContentChar11001: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_AposAttrContentChar_in_p_AposAttrContentChar11051: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pg_QName_in_p_QName11137: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NCName_in_p_QName11149: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pg_QName_in_pg_FQName11210: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FNCName_in_pg_FQName11222: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NCName_in_pg_QName11266: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
    FOLLOW_COLON_in_pg_QName11268: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_pg_QName11272: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_p_NCName0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_p_FNCName0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_InsertExpr_in_pg_UpdateExpr13263: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_DeleteExpr_in_pg_UpdateExpr13275: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_RenameExpr_in_pg_UpdateExpr13287: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ReplaceExpr_in_pg_UpdateExpr13299: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_TransformExpr_in_pg_UpdateExpr13311: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_RevalidationDecl13339: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x02000000, 0x00000000]),
    FOLLOW_REVALIDATION_in_pm_RevalidationDecl13343: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000008, 0x00000004,0x04000000, 0x00000000]),
    FOLLOW_STRICT_in_pm_RevalidationDecl13348: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_LAX_in_pm_RevalidationDecl13354: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SKIP_in_pm_RevalidationDecl13360: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_RevalidationDecl13365: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AS_in_p_InsertExprTargetChoice13395: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00120000, 0x00000000]),
    FOLLOW_FIRST_in_p_InsertExprTargetChoice13400: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00080000, 0x00000000]),
    FOLLOW_LAST_in_p_InsertExprTargetChoice13406: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00080000, 0x00000000]),
    FOLLOW_INTO_in_p_InsertExprTargetChoice13413: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AFTER_in_p_InsertExprTargetChoice13430: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_BEFORE_in_p_InsertExprTargetChoice13446: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_INSERT_in_p_InsertExpr13476: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_NODE_in_p_InsertExpr13481: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_NODES_in_p_InsertExpr13487: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SourceExpr_in_p_InsertExpr13490: new org.antlr.runtime.BitSet([0x00080000, 0x00000000,0x00000000, 0x00000000,0x00086000, 0x00000000]),
    FOLLOW_p_InsertExprTargetChoice_in_p_InsertExpr13492: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_TargetExpr_in_p_InsertExpr13494: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DELETE_in_p_DeleteExpr13524: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_NODE_in_p_DeleteExpr13529: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_NODES_in_p_DeleteExpr13535: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_TargetExpr_in_p_DeleteExpr13538: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_REPLACE_in_p_ReplaceExpr13568: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x10000000, 0x00000000]),
    FOLLOW_VALUE_in_p_ReplaceExpr13573: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00008000, 0x00000000]),
    FOLLOW_OF_in_p_ReplaceExpr13577: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000]),
    FOLLOW_NODE_in_p_ReplaceExpr13583: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_ReplaceExpr13585: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_WITH_in_p_ReplaceExpr13590: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_ReplaceExpr13592: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_RENAME_in_p_RenameExpr13623: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000]),
    FOLLOW_NODE_in_p_RenameExpr13627: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_TargetExpr_in_p_RenameExpr13629: new org.antlr.runtime.BitSet([0x00080000, 0x00000000]),
    FOLLOW_AS_in_p_RenameExpr13633: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NewNameExpr_in_p_RenameExpr13635: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_SourceExpr13663: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_TargetExpr13690: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_NewNameExpr13717: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COPY_in_p_TransformExpr13746: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_TransformExpr13750: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_TransformExpr13754: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_BIND_in_p_TransformExpr13758: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_TransformExpr13760: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00200000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_TransformExpr13764: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_TransformExpr13768: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_TransformExpr13772: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_BIND_in_p_TransformExpr13776: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_TransformExpr13778: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00200000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_MODIFY_in_p_TransformExpr13785: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_TransformExpr13787: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_TransformExpr13792: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_TransformExpr13794: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DECLARE_in_pm_FTOptionDecl13832: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000100]),
    FOLLOW_FT_OPTION_in_pm_FTOptionDecl13836: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000004, 0x00000000]),
    FOLLOW_p_FTMatchOptions_in_pm_FTOptionDecl13838: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_pm_FTOptionDecl13840: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SCORE_in_p_FTScoreVar13870: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_FTScoreVar13876: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_FTScoreVar13880: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_StringConcatExpr_in_p_FTContainsExpr13908: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_CONTAINS_in_p_FTContainsExpr13914: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000010]),
    FOLLOW_TEXT_in_p_FTContainsExpr13918: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400,0x20000000, 0x00000001,0x01C80300, 0x00000000]),
    FOLLOW_p_FTSelection_in_p_FTContainsExpr13922: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_p_FTIgnoreOption_in_p_FTContainsExpr13924: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTOr_in_p_FTSelection13954: new org.antlr.runtime.BitSet([0x00200002, 0x00000000,0x00080000, 0x00000000,0x00000800, 0x01000038]),
    FOLLOW_p_FTPosFilter_in_p_FTSelection13956: new org.antlr.runtime.BitSet([0x00200002, 0x00000000,0x00080000, 0x00000000,0x00000800, 0x01000038]),
    FOLLOW_WEIGHT_in_p_FTWeight13985: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_p_FTWeight13989: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_FTWeight13991: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_FTWeight13994: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTAnd_in_p_FTOr14020: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000800]),
    FOLLOW_FTOR_in_p_FTOr14026: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400,0x20000000, 0x00000001,0x01C80300, 0x00000000]),
    FOLLOW_p_FTAnd_in_p_FTOr14030: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000800]),
    FOLLOW_p_FTMildNot_in_p_FTAnd14059: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000200]),
    FOLLOW_FTAND_in_p_FTAnd14065: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400,0x20000000, 0x00000001,0x01C80300, 0x00000000]),
    FOLLOW_p_FTMildNot_in_p_FTAnd14069: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000200]),
    FOLLOW_p_FTUnaryNot_in_p_FTMildNot14098: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00040000]),
    FOLLOW_NOT_in_p_FTMildNot14104: new org.antlr.runtime.BitSet([0x00000000, 0x20000000]),
    FOLLOW_IN_in_p_FTMildNot14108: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400,0x20000000, 0x00000001,0x01C80300, 0x00000000]),
    FOLLOW_p_FTUnaryNot_in_p_FTMildNot14112: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00040000]),
    FOLLOW_FTNOT_in_p_FTUnaryNot14145: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400,0x20000000, 0x00000001,0x01C80300, 0x00000000]),
    FOLLOW_p_FTPrimaryWithOptions_in_p_FTUnaryNot14152: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTPrimary_in_p_FTPrimaryWithOptions14178: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x0000000C, 0x00000000]),
    FOLLOW_p_FTMatchOptions_in_p_FTPrimaryWithOptions14180: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000008, 0x00000000]),
    FOLLOW_p_FTWeight_in_p_FTPrimaryWithOptions14183: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTWords_in_p_FTPrimary14214: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00080000]),
    FOLLOW_p_FTTimes_in_p_FTPrimary14216: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LPAREN_in_p_FTPrimary14231: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400,0x20000000, 0x00000001,0x01C80300, 0x00000000]),
    FOLLOW_p_FTSelection_in_p_FTPrimary14233: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_FTPrimary14235: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTExtensionSelection_in_p_FTPrimary14248: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTWordsValue_in_p_FTWords14274: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xC0000000, 0x00400000]),
    FOLLOW_p_FTAnyallOption_in_p_FTWords14276: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTWordsValue14303: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LBRACKET_in_p_FTWordsValue14316: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_FTWordsValue14318: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_FTWordsValue14321: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_L_Pragma_in_p_FTExtensionSelection14348: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001,0x00080000, 0x00000000]),
    FOLLOW_LBRACKET_in_p_FTExtensionSelection14351: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400,0x20000000, 0x00000003,0x01C80300, 0x00000000]),
    FOLLOW_p_FTSelection_in_p_FTExtensionSelection14353: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_FTExtensionSelection14356: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ANY_in_p_FTAnyallOption14387: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000040, 0x00000000]),
    FOLLOW_WORD_in_p_FTAnyallOption14391: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ALL_in_p_FTAnyallOption14400: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000080, 0x00000000]),
    FOLLOW_WORDS_in_p_FTAnyallOption14402: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PHRASE_in_p_FTAnyallOption14410: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_OCCURS_in_p_FTTimes14442: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000000C0]),
    FOLLOW_p_FTRange_in_p_FTTimes14444: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000001, 0x00000000]),
    FOLLOW_TIMES_in_p_FTTimes14448: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_EXACTLY_in_p_FTRange14481: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_FTRange14483: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTRange14501: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_LEAST_in_p_FTRange14505: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_FTRange14507: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTRange14525: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00010000]),
    FOLLOW_MOST_in_p_FTRange14529: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_FTRange14531: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FROM_in_p_FTRange14549: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_FTRange14551: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000040]),
    FOLLOW_TO_in_p_FTRange14555: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_FTRange14557: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTOrder_in_p_FTPosFilter14588: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTWindow_in_p_FTPosFilter14592: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTDistance_in_p_FTPosFilter14596: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTScope_in_p_FTPosFilter14600: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTContent_in_p_FTPosFilter14604: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ORDERED_in_p_FTOrder14632: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_WINDOW_in_p_FTWindow14662: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AdditiveExpr_in_p_FTWindow14666: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10200000,0x00000080, 0x00000000]),
    FOLLOW_p_FTUnit_in_p_FTWindow14668: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DISTANCE_in_p_FTDistance14696: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000000C0]),
    FOLLOW_p_FTRange_in_p_FTDistance14700: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10200000,0x00000080, 0x00000000]),
    FOLLOW_p_FTUnit_in_p_FTDistance14702: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_WORDS_in_p_FTUnit14732: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SENTENCES_in_p_FTUnit14738: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PARAGRAPHS_in_p_FTUnit14744: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SAME_in_p_FTScope14777: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08100000]),
    FOLLOW_DIFFERENT_in_p_FTScope14783: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08100000]),
    FOLLOW_p_FTBigUnit_in_p_FTScope14788: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SENTENCE_in_p_FTBigUnit14818: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_PARAGRAPH_in_p_FTBigUnit14824: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTContent14859: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_START_in_p_FTContent14863: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTContent14871: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00800000]),
    FOLLOW_END_in_p_FTContent14875: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ENTIRE_in_p_FTContent14883: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_CONTENT_in_p_FTContent14887: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_USING_in_p_FTMatchOptions14921: new org.antlr.runtime.BitSet([0x04000000, 0x00000000,0x00010000, 0x00000000,0x00000000, 0xE002A004,0x00000012, 0x00000000]),
    FOLLOW_p_FTMatchOption_in_p_FTMatchOptions14925: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000004, 0x00000000]),
    FOLLOW_p_FTLanguageOption_in_p_FTMatchOption14953: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTWildCardOption_in_p_FTMatchOption14965: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTThesaurusOption_in_p_FTMatchOption14977: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTStemOption_in_p_FTMatchOption14989: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTCaseOption_in_p_FTMatchOption15001: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTDiacriticsOption_in_p_FTMatchOption15013: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTStopWordOption_in_p_FTMatchOption15025: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_FTExtensionOption_in_p_FTMatchOption15037: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CASE_in_p_FTCaseOption15068: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001000]),
    FOLLOW_INSENSITIVE_in_p_FTCaseOption15072: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CASE_in_p_FTCaseOption15090: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_SENSITIVE_in_p_FTCaseOption15094: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LOWERCASE_in_p_FTCaseOption15111: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_UPPERCASE_in_p_FTCaseOption15127: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DIACRITICS_in_p_FTDiacriticsOption15162: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001000]),
    FOLLOW_INSENSITIVE_in_p_FTDiacriticsOption15166: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DIACRITICS_in_p_FTDiacriticsOption15184: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
    FOLLOW_SENSITIVE_in_p_FTDiacriticsOption15188: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_STEMMING_in_p_FTStemOption15223: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NO_in_p_FTStemOption15230: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_STEMMING_in_p_FTStemOption15234: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_THESAURUS_in_p_FTThesaurusOption15270: new org.antlr.runtime.BitSet([0x00200000, 0x00000008]),
    FOLLOW_p_FTThesaurusID_in_p_FTThesaurusOption15273: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DEFAULT_in_p_FTThesaurusOption15279: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_THESAURUS_in_p_FTThesaurusOption15298: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_FTThesaurusOption15300: new org.antlr.runtime.BitSet([0x00200000, 0x00000008]),
    FOLLOW_p_FTThesaurusID_in_p_FTThesaurusOption15303: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_DEFAULT_in_p_FTThesaurusOption15309: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_COMMA_in_p_FTThesaurusOption15313: new org.antlr.runtime.BitSet([0x00200000, 0x00000000]),
    FOLLOW_p_FTThesaurusID_in_p_FTThesaurusOption15315: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_RPAREN_in_p_FTThesaurusOption15319: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NO_in_p_FTThesaurusOption15337: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x80000000]),
    FOLLOW_THESAURUS_in_p_FTThesaurusOption15341: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTThesaurusID15374: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTThesaurusID15376: new org.antlr.runtime.BitSet([0x00200002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x008000C0]),
    FOLLOW_RELATIONSHIP_in_p_FTThesaurusID15381: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTThesaurusID15383: new org.antlr.runtime.BitSet([0x00200002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000000C0]),
    FOLLOW_p_FTLiteralRange_in_p_FTThesaurusID15388: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00004000]),
    FOLLOW_LEVELS_in_p_FTThesaurusID15392: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_EXACTLY_in_p_FTLiteralRange15427: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15429: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTLiteralRange15447: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000020, 0x00000000]),
    FOLLOW_LEAST_in_p_FTLiteralRange15451: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15453: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTLiteralRange15471: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00010000]),
    FOLLOW_MOST_in_p_FTLiteralRange15475: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15477: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FROM_in_p_FTLiteralRange15495: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15497: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000040]),
    FOLLOW_TO_in_p_FTLiteralRange15499: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_L_IntegerLiteral_in_p_FTLiteralRange15501: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_STOP_in_p_FTStopWordOption15537: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000080, 0x00000000]),
    FOLLOW_WORDS_in_p_FTStopWordOption15541: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_p_FTStopWords_in_p_FTStopWordOption15543: new org.antlr.runtime.BitSet([0x00000002, 0x00020000,0x00000000, 0x00000200]),
    FOLLOW_p_FTStopWordsInclExcl_in_p_FTStopWordOption15545: new org.antlr.runtime.BitSet([0x00000002, 0x00020000,0x00000000, 0x00000200]),
    FOLLOW_STOP_in_p_FTStopWordOption15564: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000080, 0x00000000]),
    FOLLOW_WORDS_in_p_FTStopWordOption15568: new org.antlr.runtime.BitSet([0x00000000, 0x00000008]),
    FOLLOW_DEFAULT_in_p_FTStopWordOption15572: new org.antlr.runtime.BitSet([0x00000002, 0x00020000,0x00000000, 0x00000200]),
    FOLLOW_p_FTStopWordsInclExcl_in_p_FTStopWordOption15574: new org.antlr.runtime.BitSet([0x00000002, 0x00020000,0x00000000, 0x00000200]),
    FOLLOW_NO_in_p_FTStopWordOption15593: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
    FOLLOW_STOP_in_p_FTStopWordOption15597: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000080, 0x00000000]),
    FOLLOW_WORDS_in_p_FTStopWordOption15601: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AT_in_p_FTStopWords15635: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTStopWords15639: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LPAREN_in_p_FTStopWords15653: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTStopWords15655: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_COMMA_in_p_FTStopWords15658: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTStopWords15660: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000400]),
    FOLLOW_RPAREN_in_p_FTStopWords15664: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_UNION_in_p_FTStopWordsInclExcl15696: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_EXCEPT_in_p_FTStopWordsInclExcl15702: new org.antlr.runtime.BitSet([0x00200000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_p_FTStopWords_in_p_FTStopWordsInclExcl15705: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LANGUAGE_in_p_FTLanguageOption15737: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTLanguageOption15741: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_WILDCARDS_in_p_FTWildCardOption15771: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NO_in_p_FTWildCardOption15778: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
    FOLLOW_WILDCARDS_in_p_FTWildCardOption15782: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_OPTION_in_p_FTExtensionOption15815: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_FTExtensionOption15819: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_FTExtensionOption15821: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_WITHOUT_in_p_FTIgnoreOption15849: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_CONTENT_in_p_FTIgnoreOption15853: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_UnionExpr_in_p_FTIgnoreOption15857: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_StatementsAndOptionalExpr_in_p_Program15889: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_Statements15916: new org.antlr.runtime.BitSet([0xFFFF0002, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Statements_in_p_StatementsAndExpr15944: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Statements_in_p_StatementsAndOptionalExpr15971: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_HybridExprSingle_in_p_Hybrid15998: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Statement_in_p_Hybrid16011: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_AssignStatement_in_p_Statement16042: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_BreakStatement_in_p_Statement16054: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ContinueStatement_in_p_Statement16066: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExitStatement_in_p_Statement16078: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_VarDeclStatement_in_p_Statement16090: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_WhileStatement_in_p_Statement16102: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Expr_in_p_HybridExprSingle16129: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_HybridExprSingle16144: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ExprSimple_in_p_ApplyStatement16194: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_ApplyStatement16196: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOLLAR_in_p_AssignStatement16224: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_AssignStatement16228: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_BIND_in_p_AssignStatement16232: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_AssignStatement16234: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_AssignStatement16237: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LBRACKET_in_p_BlockStatement16263: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F083,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Statements_in_p_BlockStatement16265: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_BlockStatement16268: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LBRACKET_in_p_BlockHybrid16294: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F083,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Statements_in_p_BlockHybrid16296: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_BlockHybrid16299: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_BREAK_in_p_BreakStatement16327: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
    FOLLOW_LOOP_in_p_BreakStatement16333: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_BreakStatement16337: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CONTINUE_in_p_ContinueStatement16365: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
    FOLLOW_LOOP_in_p_ContinueStatement16371: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_ContinueStatement16375: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_EXIT_in_p_ExitStatement16403: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00001000, 0x00000000]),
    FOLLOW_RETURNING_in_p_ExitStatement16409: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_ExitStatement16413: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
    FOLLOW_SEMICOLON_in_p_ExitStatement16416: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_InitialClause_in_p_FLWORStatement16442: new org.antlr.runtime.BitSet([0x00000000, 0x00200000,0x04040040, 0x01084002]),
    FOLLOW_p_IntermediateClause_in_p_FLWORStatement16444: new org.antlr.runtime.BitSet([0x00000000, 0x00200000,0x04040040, 0x01084002]),
    FOLLOW_p_ReturnStatement_in_p_FLWORStatement16447: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_RETURN_in_p_ReturnStatement16479: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_ReturnStatement16483: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IF_in_p_IfStatement16512: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_IfStatement16516: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_IfStatement16518: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_IfStatement16521: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000020]),
    FOLLOW_THEN_in_p_IfStatement16525: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_IfStatement16529: new org.antlr.runtime.BitSet([0x00000000, 0x00000800]),
    FOLLOW_ELSE_in_p_IfStatement16534: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_IfStatement16538: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SWITCH_in_p_SwitchStatement16567: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_SwitchStatement16571: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_SwitchStatement16573: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_SwitchStatement16576: new org.antlr.runtime.BitSet([0x04000000, 0x00000000]),
    FOLLOW_p_SwitchCaseStatement_in_p_SwitchStatement16578: new org.antlr.runtime.BitSet([0x04000000, 0x00000008]),
    FOLLOW_DEFAULT_in_p_SwitchStatement16583: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_SwitchStatement16589: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_SwitchStatement16593: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CASE_in_p_SwitchCaseStatement16623: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SwitchCaseOperand_in_p_SwitchCaseStatement16627: new org.antlr.runtime.BitSet([0x04000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_SwitchCaseStatement16633: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_SwitchCaseStatement16637: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TRY_in_p_TryCatchStatement16666: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_p_BlockStatement_in_p_TryCatchStatement16670: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_CATCH_in_p_TryCatchStatement16675: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x01001001,0x01C01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_CatchErrorList_in_p_TryCatchStatement16679: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_p_BlockStatement_in_p_TryCatchStatement16681: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_TRY_in_p_TryCatchHybrid16713: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_p_BlockHybrid_in_p_TryCatchHybrid16717: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_CATCH_in_p_TryCatchHybrid16723: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x01001001,0x01C01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_CatchErrorList_in_p_TryCatchHybrid16727: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_p_BlockHybrid_in_p_TryCatchHybrid16729: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00020000]),
    FOLLOW_TYPESWITCH_in_p_TypeswitchStatement16762: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_TypeswitchStatement16766: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_TypeswitchStatement16768: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_TypeswitchStatement16771: new org.antlr.runtime.BitSet([0x04000000, 0x00000000]),
    FOLLOW_p_CaseStatement_in_p_TypeswitchStatement16773: new org.antlr.runtime.BitSet([0x04000000, 0x00000008]),
    FOLLOW_DEFAULT_in_p_TypeswitchStatement16778: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_TypeswitchStatement16785: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_TypeswitchStatement16789: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_TypeswitchStatement16797: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_TypeswitchStatement16801: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_CASE_in_p_CaseStatement16830: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_CaseStatement16837: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_CaseStatement16841: new org.antlr.runtime.BitSet([0x00080000, 0x00000000]),
    FOLLOW_AS_in_p_CaseStatement16845: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x2FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_SequenceType_in_p_CaseStatement16849: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x04000000, 0x00000000]),
    FOLLOW_RETURN_in_p_CaseStatement16853: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_CaseStatement16857: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Annotation_in_p_VarDeclStatement16884: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00001000,0x00000000, 0x00000000,0x00000000, 0x00000080]),
    FOLLOW_VARIABLE_in_p_VarDeclStatement16889: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_VarDeclStatement16895: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_VarDeclStatement16899: new org.antlr.runtime.BitSet([0x00080000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000420]),
    FOLLOW_p_TypeDeclaration_in_p_VarDeclStatement16903: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000420]),
    FOLLOW_BIND_in_p_VarDeclStatement16907: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_VarDeclStatement16909: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000400]),
    FOLLOW_COMMA_in_p_VarDeclStatement16925: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_VarDeclStatement16929: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_VarName_in_p_VarDeclStatement16933: new org.antlr.runtime.BitSet([0x00080000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000420]),
    FOLLOW_p_TypeDeclaration_in_p_VarDeclStatement16937: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000420]),
    FOLLOW_BIND_in_p_VarDeclStatement16941: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_VarDeclStatement16943: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000400]),
    FOLLOW_SEMICOLON_in_p_VarDeclStatement16960: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_WHILE_in_p_WhileStatement16988: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_p_WhileStatement16992: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Expr_in_p_WhileStatement16994: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
    FOLLOW_RPAREN_in_p_WhileStatement16997: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_Hybrid_in_p_WhileStatement16999: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QuantifiedExpr_in_p_ExprSimple17026: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_OrExpr_in_p_ExprSimple17038: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_pg_UpdateExpr_in_p_ExprSimple17053: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LBRACKET_in_p_BlockExpr17079: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F081,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_StatementsAndExpr_in_p_BlockExpr17081: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
    FOLLOW_RBRACKET_in_p_BlockExpr17083: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COLLECTION_in_p_CollectionDecl17114: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_CollectionDecl17118: new org.antlr.runtime.BitSet([0x00080002, 0x00000000]),
    FOLLOW_p_CollectionTypeDecl_in_p_CollectionDecl17120: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AS_in_p_CollectionTypeDecl17149: new org.antlr.runtime.BitSet([0x80400000, 0x00000600,0x62004000, 0x10000010]),
    FOLLOW_p_KindTest_in_p_CollectionTypeDecl17153: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00003800]),
    FOLLOW_p_OccurrenceIndicator_in_p_CollectionTypeDecl17162: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_INDEX_in_p_IndexDecl17192: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_IndexName_in_p_IndexDecl17196: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_ON_in_p_IndexDecl17200: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
    FOLLOW_NODES_in_p_IndexDecl17206: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_IndexDomainExpr_in_p_IndexDecl17210: new org.antlr.runtime.BitSet([0x02000000, 0x00000000]),
    FOLLOW_BY_in_p_IndexDecl17214: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_IndexKeySpec_in_p_IndexDecl17218: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_COMMA_in_p_IndexDecl17221: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_IndexKeySpec_in_p_IndexDecl17223: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000400]),
    FOLLOW_p_QName_in_p_IndexName17250: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PathExpr_in_p_IndexDomainExpr17275: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_IndexKeyExpr_in_p_IndexKeySpec17300: new org.antlr.runtime.BitSet([0x40080002, 0x00000000]),
    FOLLOW_p_IndexKeyTypeDecl_in_p_IndexKeySpec17302: new org.antlr.runtime.BitSet([0x40000002, 0x00000000]),
    FOLLOW_p_IndexKeyCollation_in_p_IndexKeySpec17305: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PathExpr_in_p_IndexKeyExpr17331: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_AS_in_p_IndexKeyTypeDecl17358: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_AtomicType_in_p_IndexKeyTypeDecl17362: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00003800]),
    FOLLOW_p_OccurrenceIndicator_in_p_IndexKeyTypeDecl17364: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_p_AtomicType17390: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COLLATION_in_p_IndexKeyCollation17417: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x01C00300, 0x00000000]),
    FOLLOW_p_StringLiteral_in_p_IndexKeyCollation17421: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_INTEGRITY_in_p_ICDecl17448: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00010000, 0x00000000]),
    FOLLOW_CONSTRAINT_in_p_ICDecl17454: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_ICDecl17458: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00440000, 0x00000000]),
    FOLLOW_p_ICCollection_in_p_ICDecl17461: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ICForeignKey_in_p_ICDecl17465: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_ON_in_p_ICCollection17493: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00008000, 0x00000000]),
    FOLLOW_COLLECTION_in_p_ICCollection17499: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_ICCollection17503: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x00000000, 0x00000000,0x80020000, 0x00000000]),
    FOLLOW_p_ICCollSequence_in_p_ICCollection17506: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ICCollSequenceUnique_in_p_ICCollection17510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_ICCollNode_in_p_ICCollection17514: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_DOLLAR_in_p_ICCollSequence17542: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_ICCollSequence17546: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00004000, 0x00000000]),
    FOLLOW_CHECK_in_p_ICCollSequence17552: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_ICCollSequence17556: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_NODE_in_p_ICCollSequenceUnique17584: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_ICCollSequenceUnique17590: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_ICCollSequenceUnique17594: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00004000, 0x00000000]),
    FOLLOW_CHECK_in_p_ICCollSequenceUnique17600: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00800000, 0x00000000]),
    FOLLOW_UNIQUE_in_p_ICCollSequenceUnique17606: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00200000, 0x00000000]),
    FOLLOW_KEY_in_p_ICCollSequenceUnique17612: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_PathExpr_in_p_ICCollSequenceUnique17616: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FOREACH_in_p_ICCollNode17643: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000]),
    FOLLOW_NODE_in_p_ICCollNode17649: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_ICCollNode17655: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_ICCollNode17659: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00004000, 0x00000000]),
    FOLLOW_CHECK_in_p_ICCollNode17665: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E0F001,0x01F81320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_ExprSingle_in_p_ICCollNode17669: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FOREIGN_in_p_ICForeignKey17697: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00200000, 0x00000000]),
    FOLLOW_KEY_in_p_ICForeignKey17703: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000080]),
    FOLLOW_p_ICForeignKeySource_in_p_ICForeignKey17707: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000040]),
    FOLLOW_p_ICForeignKeyTarget_in_p_ICForeignKey17709: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FROM_in_p_ICForeignKeySource17736: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00008000, 0x00000000]),
    FOLLOW_p_ICForeignKeyValues_in_p_ICForeignKeySource17740: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TO_in_p_ICForeignKeyTarget17767: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00008000, 0x00000000]),
    FOLLOW_p_ICForeignKeyValues_in_p_ICForeignKeyTarget17771: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_COLLECTION_in_p_ICForeignKeyValues17798: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_ICForeignKeyValues17802: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000]),
    FOLLOW_NODE_in_p_ICForeignKeyValues17806: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_p_ICForeignKeyValues17812: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000000,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_p_ICForeignKeyValues17816: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00200000, 0x00000000]),
    FOLLOW_KEY_in_p_ICForeignKeyValues17822: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_PathExpr_in_p_ICForeignKeyValues17826: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred1_XQueryParser3535: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
    FOLLOW_DOLLAR_in_synpred1_XQueryParser3543: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_FOR_in_synpred1_XQueryParser3549: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000110, 0x00000000]),
    FOLLOW_set_in_synpred1_XQueryParser3551: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_IF_in_synpred2_XQueryParser3577: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_synpred2_XQueryParser3579: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SWITCH_in_synpred3_XQueryParser3607: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_synpred3_XQueryParser3609: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TYPESWITCH_in_synpred4_XQueryParser3633: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_synpred4_XQueryParser3635: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TRY_in_synpred5_XQueryParser3655: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_synpred5_XQueryParser3657: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_VALIDATE_in_synpred6_XQueryParser6185: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000008, 0x00000004,0x00000200, 0x00000000]),
    FOLLOW_p_ValidationMode_in_synpred6_XQueryParser6189: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_TYPE_in_synpred6_XQueryParser6193: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_SLASH_in_synpred7_XQueryParser6533: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xAFFFFFFF, 0x01E09001,0x01F01320, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_RelativePathExpr_in_synpred7_XQueryParser6535: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred8_XQueryParser6649: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred9_XQueryParser6702: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000001,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_QName_in_synpred9_XQueryParser6710: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_synpred9_XQueryParser6713: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred9_XQueryParser6731: new org.antlr.runtime.BitSet([0xFFFF0000, 0xFFFFFFFF,0xFFFFFFFF, 0xFFFFFFFF,0xF7FFFFFF, 0xFFFFFFFF,0x0FFFFFFF, 0x00000001,0x00001000, 0x00000000,0x00100000, 0x00000000]),
    FOLLOW_p_NCName_in_synpred9_XQueryParser6739: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_synpred9_XQueryParser6742: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_set_in_synpred9_XQueryParser6760: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000001]),
    FOLLOW_LBRACKET_in_synpred9_XQueryParser6772: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_KindTest_in_synpred10_XQueryParser6802: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_QName_in_synpred11_XQueryParser6821: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
    FOLLOW_LPAREN_in_synpred11_XQueryParser6823: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_PrimaryExpr_in_synpred12_XQueryParser6841: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_Wildcard_in_synpred13_XQueryParser7280: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NCName_in_synpred14_XQueryParser7299: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
    FOLLOW_COLON_in_synpred14_XQueryParser7301: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_NCName_in_synpred15_XQueryParser7319: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_LPAREN_in_synpred16_XQueryParser7575: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_OccurrenceIndicator_in_synpred17_XQueryParser9583: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
    FOLLOW_p_OccurrenceIndicator_in_synpred18_XQueryParser17157: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});

})();
exports.XQueryParser = XQueryParser;
});define('ace/mode/xquery/StringLexer', ['require', 'exports', 'module' , 'ace/mode/xquery/antlr3-all', 'ace/mode/xquery/XQDTLexer'], function(require, exports, module) {
// $ANTLR 3.3 Nov 30, 2010 12:50:56 xquery/StringLexer.g 2012-04-18 21:05:08

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
  var org =  require("./antlr3-all").org;
  var XQDTLexer = require("./XQDTLexer").XQDTLexer;


var StringLexer = function(input, state) {
// alternate constructor @todo
// public StringLexer(CharStream input)
// public StringLexer(CharStream input, RecognizerSharedState state) {
    if (!state) {
        state = new org.antlr.runtime.RecognizerSharedState();
    }

    (function(){


        this.inQuotStr = false;
        this.inAposStr = false;

        //boolean inQuotStr = false;
        //boolean inAposStr = false;

        //public StringLexer(CharStream input, boolean isAposStr) {
        //	this(input, new RecognizerSharedState());
        //	this.inAposStr = isAposStr;
        //	this.inQuotStr = !isAposStr;
        //	setIsWsExplicit(true);
        //}

    }).call(this);

    this.dfa8 = new StringLexer.DFA8(this);
    StringLexer.superclass.constructor.call(this, input, state);


};

org.antlr.lang.augmentObject(StringLexer, {
    EOF: -1,
    L_QuotAttrContentChar: 4,
    L_AposAttrContentChar: 5,
    L_ElementContentChar: 6,
    L_CDataSection: 7,
    L_PredefinedEntityRef: 8,
    L_CharRef: 9,
    ESCAPE_LBRACKET: 10,
    ESCAPE_RBRACKET: 11,
    ESCAPE_APOS: 12,
    ESCAPE_QUOT: 13,
    CDATA_START: 14,
    CDATA_END: 15,
    ANCESTOR: 16,
    ANCESTOR_OR_SELF: 17,
    AND: 18,
    AS: 19,
    ASCENDING: 20,
    AT: 21,
    ATTRIBUTE: 22,
    BASE_URI: 23,
    BOUNDARY_SPACE: 24,
    BY: 25,
    CASE: 26,
    CAST: 27,
    CASTABLE: 28,
    CHILD: 29,
    COLLATION: 30,
    COMMENT: 31,
    CONSTRUCTION: 32,
    COPY_NAMESPACES: 33,
    DECLARE: 34,
    DEFAULT: 35,
    DESCENDANT: 36,
    DESCENDANT_OR_SELF: 37,
    DESCENDING: 38,
    DIV: 39,
    DOCUMENT: 40,
    DOCUMENT_NODE: 41,
    ELEMENT: 42,
    ELSE: 43,
    EMPTY: 44,
    EMPTY_SEQUENCE: 45,
    ENCODING: 46,
    EQ: 47,
    EVERY: 48,
    EXCEPT: 49,
    EXTERNAL: 50,
    FOLLOWING: 51,
    FOLLOWING_SIBLING: 52,
    FOR: 53,
    FUNCTION: 54,
    GE: 55,
    GREATEST: 56,
    GT: 57,
    IDIV: 58,
    IF: 59,
    IMPORT: 60,
    IN: 61,
    INHERIT: 62,
    INSTANCE: 63,
    INTERSECT: 64,
    IS: 65,
    ITEM: 66,
    LAX: 67,
    LE: 68,
    LEAST: 69,
    LET: 70,
    LT: 71,
    MOD: 72,
    MODULE: 73,
    NAMESPACE: 74,
    NE: 75,
    NO_INHERIT: 76,
    NO_PRESERVE: 77,
    NODE: 78,
    OF: 79,
    OPTION: 80,
    OR: 81,
    ORDER: 82,
    ORDERED: 83,
    ORDERING: 84,
    PARENT: 85,
    PRECEDING: 86,
    PRECEDING_SIBLING: 87,
    PRESERVE: 88,
    PROCESSING_INSTRUCTION: 89,
    RETURN: 90,
    SATISFIES: 91,
    SCHEMA: 92,
    SCHEMA_ATTRIBUTE: 93,
    SCHEMA_ELEMENT: 94,
    SELF: 95,
    SOME: 96,
    STABLE: 97,
    STRICT: 98,
    STRIP: 99,
    TEXT: 100,
    THEN: 101,
    TO: 102,
    TREAT: 103,
    TYPESWITCH: 104,
    UNION: 105,
    UNORDERED: 106,
    VALIDATE: 107,
    VARIABLE: 108,
    VERSION: 109,
    WHERE: 110,
    XQUERY: 111,
    ALLOWING: 112,
    CATCH: 113,
    CONTEXT: 114,
    COUNT: 115,
    DECIMAL_FORMAT: 116,
    DECIMAL_SEPARATOR: 117,
    DIGIT: 118,
    END: 119,
    GROUP: 120,
    GROUPING_SEPARATOR: 121,
    INFINITY: 122,
    MINUS_SIGN: 123,
    NAMESPACE_NODE: 124,
    NAN: 125,
    NEXT: 126,
    ONLY: 127,
    PATTERN_SEPARATOR: 128,
    PERCENT: 129,
    PER_MILLE: 130,
    PREVIOUS: 131,
    SLIDING: 132,
    START: 133,
    SWITCH: 134,
    TRY: 135,
    TUMBLING: 136,
    TYPE: 137,
    WHEN: 138,
    WINDOW: 139,
    ZERO_DIGIT: 140,
    AFTER: 141,
    BEFORE: 142,
    COPY: 143,
    DELETE: 144,
    FIRST: 145,
    INSERT: 146,
    INTO: 147,
    LAST: 148,
    MODIFY: 149,
    NODES: 150,
    RENAME: 151,
    REPLACE: 152,
    REVALIDATION: 153,
    SKIP: 154,
    UPDATING: 155,
    VALUE: 156,
    WITH: 157,
    ALL: 158,
    ANY: 159,
    CONTAINS: 160,
    CONTENT: 161,
    DIACRITICS: 162,
    DIFFERENT: 163,
    DISTANCE: 164,
    ENTIRE: 165,
    EXACTLY: 166,
    FROM: 167,
    FT_OPTION: 168,
    FTAND: 169,
    FTNOT: 170,
    FTOR: 171,
    INSENSITIVE: 172,
    LANGUAGE: 173,
    LEVELS: 174,
    LOWERCASE: 175,
    MOST: 176,
    NO: 177,
    NOT: 178,
    OCCURS: 179,
    PARAGRAPH: 180,
    PARAGRAPHS: 181,
    PHRASE: 182,
    RELATIONSHIP: 183,
    SAME: 184,
    SCORE: 185,
    SENSITIVE: 186,
    SENTENCE: 187,
    SENTENCES: 188,
    STEMMING: 189,
    STOP: 190,
    THESAURUS: 191,
    TIMES: 192,
    UPPERCASE: 193,
    USING: 194,
    WEIGHT: 195,
    WILDCARDS: 196,
    WITHOUT: 197,
    WORD: 198,
    WORDS: 199,
    BREAK: 200,
    CONTINUE: 201,
    EXIT: 202,
    LOOP: 203,
    RETURNING: 204,
    WHILE: 205,
    CHECK: 206,
    COLLECTION: 207,
    CONSTRAINT: 208,
    FOREACH: 209,
    FOREIGN: 210,
    INDEX: 211,
    INTEGRITY: 212,
    KEY: 213,
    ON: 214,
    UNIQUE: 215,
    BINARY: 216,
    AMP_ER: 217,
    APOS_ER: 218,
    QUOT_ER: 219,
    CONCAT: 220,
    LPAREN: 221,
    RPAREN: 222,
    DOLLAR: 223,
    LBRACKET: 224,
    RBRACKET: 225,
    LSQUARE: 226,
    RSQUARE: 227,
    EQUAL: 228,
    BIND: 229,
    NOTEQUAL: 230,
    ANN_PERCENT: 231,
    HASH: 232,
    AMP: 233,
    COMMA: 234,
    QUESTION: 235,
    STAR: 236,
    PLUS: 237,
    MINUS: 238,
    SMALLER: 239,
    GREATER: 240,
    SMALLEREQ: 241,
    GREATEREQ: 242,
    SMALLER_SMALLER: 243,
    GREATER_GREATER: 244,
    SLASH: 245,
    SLASH_SLASH: 246,
    DOT: 247,
    DOT_DOT: 248,
    COLON: 249,
    COLON_COLON: 250,
    EMPTY_CLOSE_TAG: 251,
    CLOSE_TAG: 252,
    SEMICOLON: 253,
    VBAR: 254,
    PRAGMA_START: 255,
    PRAGMA_END: 256,
    XML_COMMENT_START: 257,
    XML_COMMENT_END: 258,
    PI_START: 259,
    PI_END: 260,
    ATTR_SIGN: 261,
    CHARREF_DEC: 262,
    CHARREF_HEX: 263,
    APOS: 264,
    QUOT: 265,
    NCNameStartChar: 266,
    NCNameChar: 267,
    L_NCName: 268,
    Letter: 269,
    HexLetter: 270,
    Digit: 271,
    Digits: 272,
    S: 273,
    SU: 274,
    L_Pragma: 275,
    L_DirCommentConstructor: 276,
    L_DirPIConstructor: 277,
    L_IntegerLiteral: 278,
    L_DecimalLiteral: 279,
    L_DoubleLiteral: 280,
    L_Comment: 281,
    L_AnyChar: 282,
    L_QuotStringLiteralChar: 283,
    L_AposStringLiteralChar: 284
});

(function(){
var HIDDEN = org.antlr.runtime.Token.HIDDEN_CHANNEL,
    EOF = org.antlr.runtime.Token.EOF;
org.antlr.lang.extend(StringLexer, XQDTLexer, {
    EOF : -1,
    L_QuotAttrContentChar : 4,
    L_AposAttrContentChar : 5,
    L_ElementContentChar : 6,
    L_CDataSection : 7,
    L_PredefinedEntityRef : 8,
    L_CharRef : 9,
    ESCAPE_LBRACKET : 10,
    ESCAPE_RBRACKET : 11,
    ESCAPE_APOS : 12,
    ESCAPE_QUOT : 13,
    CDATA_START : 14,
    CDATA_END : 15,
    ANCESTOR : 16,
    ANCESTOR_OR_SELF : 17,
    AND : 18,
    AS : 19,
    ASCENDING : 20,
    AT : 21,
    ATTRIBUTE : 22,
    BASE_URI : 23,
    BOUNDARY_SPACE : 24,
    BY : 25,
    CASE : 26,
    CAST : 27,
    CASTABLE : 28,
    CHILD : 29,
    COLLATION : 30,
    COMMENT : 31,
    CONSTRUCTION : 32,
    COPY_NAMESPACES : 33,
    DECLARE : 34,
    DEFAULT : 35,
    DESCENDANT : 36,
    DESCENDANT_OR_SELF : 37,
    DESCENDING : 38,
    DIV : 39,
    DOCUMENT : 40,
    DOCUMENT_NODE : 41,
    ELEMENT : 42,
    ELSE : 43,
    EMPTY : 44,
    EMPTY_SEQUENCE : 45,
    ENCODING : 46,
    EQ : 47,
    EVERY : 48,
    EXCEPT : 49,
    EXTERNAL : 50,
    FOLLOWING : 51,
    FOLLOWING_SIBLING : 52,
    FOR : 53,
    FUNCTION : 54,
    GE : 55,
    GREATEST : 56,
    GT : 57,
    IDIV : 58,
    IF : 59,
    IMPORT : 60,
    IN : 61,
    INHERIT : 62,
    INSTANCE : 63,
    INTERSECT : 64,
    IS : 65,
    ITEM : 66,
    LAX : 67,
    LE : 68,
    LEAST : 69,
    LET : 70,
    LT : 71,
    MOD : 72,
    MODULE : 73,
    NAMESPACE : 74,
    NE : 75,
    NO_INHERIT : 76,
    NO_PRESERVE : 77,
    NODE : 78,
    OF : 79,
    OPTION : 80,
    OR : 81,
    ORDER : 82,
    ORDERED : 83,
    ORDERING : 84,
    PARENT : 85,
    PRECEDING : 86,
    PRECEDING_SIBLING : 87,
    PRESERVE : 88,
    PROCESSING_INSTRUCTION : 89,
    RETURN : 90,
    SATISFIES : 91,
    SCHEMA : 92,
    SCHEMA_ATTRIBUTE : 93,
    SCHEMA_ELEMENT : 94,
    SELF : 95,
    SOME : 96,
    STABLE : 97,
    STRICT : 98,
    STRIP : 99,
    TEXT : 100,
    THEN : 101,
    TO : 102,
    TREAT : 103,
    TYPESWITCH : 104,
    UNION : 105,
    UNORDERED : 106,
    VALIDATE : 107,
    VARIABLE : 108,
    VERSION : 109,
    WHERE : 110,
    XQUERY : 111,
    ALLOWING : 112,
    CATCH : 113,
    CONTEXT : 114,
    COUNT : 115,
    DECIMAL_FORMAT : 116,
    DECIMAL_SEPARATOR : 117,
    DIGIT : 118,
    END : 119,
    GROUP : 120,
    GROUPING_SEPARATOR : 121,
    INFINITY : 122,
    MINUS_SIGN : 123,
    NAMESPACE_NODE : 124,
    NAN : 125,
    NEXT : 126,
    ONLY : 127,
    PATTERN_SEPARATOR : 128,
    PERCENT : 129,
    PER_MILLE : 130,
    PREVIOUS : 131,
    SLIDING : 132,
    START : 133,
    SWITCH : 134,
    TRY : 135,
    TUMBLING : 136,
    TYPE : 137,
    WHEN : 138,
    WINDOW : 139,
    ZERO_DIGIT : 140,
    AFTER : 141,
    BEFORE : 142,
    COPY : 143,
    DELETE : 144,
    FIRST : 145,
    INSERT : 146,
    INTO : 147,
    LAST : 148,
    MODIFY : 149,
    NODES : 150,
    RENAME : 151,
    REPLACE : 152,
    REVALIDATION : 153,
    SKIP : 154,
    UPDATING : 155,
    VALUE : 156,
    WITH : 157,
    ALL : 158,
    ANY : 159,
    CONTAINS : 160,
    CONTENT : 161,
    DIACRITICS : 162,
    DIFFERENT : 163,
    DISTANCE : 164,
    ENTIRE : 165,
    EXACTLY : 166,
    FROM : 167,
    FT_OPTION : 168,
    FTAND : 169,
    FTNOT : 170,
    FTOR : 171,
    INSENSITIVE : 172,
    LANGUAGE : 173,
    LEVELS : 174,
    LOWERCASE : 175,
    MOST : 176,
    NO : 177,
    NOT : 178,
    OCCURS : 179,
    PARAGRAPH : 180,
    PARAGRAPHS : 181,
    PHRASE : 182,
    RELATIONSHIP : 183,
    SAME : 184,
    SCORE : 185,
    SENSITIVE : 186,
    SENTENCE : 187,
    SENTENCES : 188,
    STEMMING : 189,
    STOP : 190,
    THESAURUS : 191,
    TIMES : 192,
    UPPERCASE : 193,
    USING : 194,
    WEIGHT : 195,
    WILDCARDS : 196,
    WITHOUT : 197,
    WORD : 198,
    WORDS : 199,
    BREAK : 200,
    CONTINUE : 201,
    EXIT : 202,
    LOOP : 203,
    RETURNING : 204,
    WHILE : 205,
    CHECK : 206,
    COLLECTION : 207,
    CONSTRAINT : 208,
    FOREACH : 209,
    FOREIGN : 210,
    INDEX : 211,
    INTEGRITY : 212,
    KEY : 213,
    ON : 214,
    UNIQUE : 215,
    BINARY : 216,
    AMP_ER : 217,
    APOS_ER : 218,
    QUOT_ER : 219,
    CONCAT : 220,
    LPAREN : 221,
    RPAREN : 222,
    DOLLAR : 223,
    LBRACKET : 224,
    RBRACKET : 225,
    LSQUARE : 226,
    RSQUARE : 227,
    EQUAL : 228,
    BIND : 229,
    NOTEQUAL : 230,
    ANN_PERCENT : 231,
    HASH : 232,
    AMP : 233,
    COMMA : 234,
    QUESTION : 235,
    STAR : 236,
    PLUS : 237,
    MINUS : 238,
    SMALLER : 239,
    GREATER : 240,
    SMALLEREQ : 241,
    GREATEREQ : 242,
    SMALLER_SMALLER : 243,
    GREATER_GREATER : 244,
    SLASH : 245,
    SLASH_SLASH : 246,
    DOT : 247,
    DOT_DOT : 248,
    COLON : 249,
    COLON_COLON : 250,
    EMPTY_CLOSE_TAG : 251,
    CLOSE_TAG : 252,
    SEMICOLON : 253,
    VBAR : 254,
    PRAGMA_START : 255,
    PRAGMA_END : 256,
    XML_COMMENT_START : 257,
    XML_COMMENT_END : 258,
    PI_START : 259,
    PI_END : 260,
    ATTR_SIGN : 261,
    CHARREF_DEC : 262,
    CHARREF_HEX : 263,
    APOS : 264,
    QUOT : 265,
    NCNameStartChar : 266,
    NCNameChar : 267,
    L_NCName : 268,
    Letter : 269,
    HexLetter : 270,
    Digit : 271,
    Digits : 272,
    S : 273,
    SU : 274,
    L_Pragma : 275,
    L_DirCommentConstructor : 276,
    L_DirPIConstructor : 277,
    L_IntegerLiteral : 278,
    L_DecimalLiteral : 279,
    L_DoubleLiteral : 280,
    L_Comment : 281,
    L_AnyChar : 282,
    L_QuotStringLiteralChar : 283,
    L_AposStringLiteralChar : 284,
    getGrammarFileName: function() { return "xquery/StringLexer.g"; }
});
org.antlr.lang.augmentObject(StringLexer.prototype, {
    // $ANTLR start QUOT
    mQUOT: function()  {
        try {
            var _type = this.QUOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:66:6: ({...}? => '\"' )
            // xquery/StringLexer.g:66:8: {...}? => '\"'
            if ( !(( this.inQuotStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "QUOT", " this.inQuotStr ");
            }
            this.match('\"'); 
             this.inQuotStr = !this.inQuotStr; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "QUOT",

    // $ANTLR start APOS
    mAPOS: function()  {
        try {
            var _type = this.APOS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:67:6: ({...}? => '\\'' )
            // xquery/StringLexer.g:67:8: {...}? => '\\''
            if ( !(( this.inAposStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "APOS", " this.inAposStr ");
            }
            this.match('\''); 
             this.inAposStr = !this.inAposStr; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "APOS",

    // $ANTLR start ESCAPE_QUOT
    mESCAPE_QUOT: function()  {
        try {
            var _type = this.ESCAPE_QUOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:68:13: ({...}? => '\"\"' )
            // xquery/StringLexer.g:68:15: {...}? => '\"\"'
            if ( !(( this.inQuotStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "ESCAPE_QUOT", " this.inQuotStr ");
            }
            this.match("\"\""); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ESCAPE_QUOT",

    // $ANTLR start ESCAPE_APOS
    mESCAPE_APOS: function()  {
        try {
            var _type = this.ESCAPE_APOS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:69:13: ({...}? => '\\'\\'' )
            // xquery/StringLexer.g:69:15: {...}? => '\\'\\''
            if ( !(( this.inAposStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "ESCAPE_APOS", " this.inAposStr ");
            }
            this.match("''"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ESCAPE_APOS",

    // $ANTLR start L_PredefinedEntityRef
    mL_PredefinedEntityRef: function()  {
        try {
            var _type = this.L_PredefinedEntityRef;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:73:2: ({...}? => '&' ( 'lt' | 'gt' | 'apos' | 'quot' | 'amp' ) ';' )
            // xquery/StringLexer.g:73:4: {...}? => '&' ( 'lt' | 'gt' | 'apos' | 'quot' | 'amp' ) ';'
            if ( !(( this.inQuotStr | this.inAposStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_PredefinedEntityRef", " this.inQuotStr | this.inAposStr ");
            }
            this.match('&'); 
            // xquery/StringLexer.g:73:48: ( 'lt' | 'gt' | 'apos' | 'quot' | 'amp' )
            var alt1=5;
            switch ( this.input.LA(1) ) {
            case 'l':
                alt1=1;
                break;
            case 'g':
                alt1=2;
                break;
            case 'a':
                var LA1_3 = this.input.LA(2);

                if ( (LA1_3=='p') ) {
                    alt1=3;
                }
                else if ( (LA1_3=='m') ) {
                    alt1=5;
                }
                else {
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 1, 3, this.input);

                    throw nvae;
                }
                break;
            case 'q':
                alt1=4;
                break;
            default:
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 1, 0, this.input);

                throw nvae;
            }

            switch (alt1) {
                case 1 :
                    // xquery/StringLexer.g:73:49: 'lt'
                    this.match("lt"); 



                    break;
                case 2 :
                    // xquery/StringLexer.g:73:56: 'gt'
                    this.match("gt"); 



                    break;
                case 3 :
                    // xquery/StringLexer.g:73:63: 'apos'
                    this.match("apos"); 



                    break;
                case 4 :
                    // xquery/StringLexer.g:73:72: 'quot'
                    this.match("quot"); 



                    break;
                case 5 :
                    // xquery/StringLexer.g:73:81: 'amp'
                    this.match("amp"); 



                    break;

            }

            this.match(';'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_PredefinedEntityRef",

    // $ANTLR start L_CharRef
    mL_CharRef: function()  {
        try {
            var _type = this.L_CharRef;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:78:2: ({...}? => '&#' ( '0' .. '9' )+ ';' | '&#x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ';' )
            var alt4=2;
            var LA4_0 = this.input.LA(1);

            if ( (LA4_0=='&') ) {
                var LA4_1 = this.input.LA(2);

                if ( (LA4_1=='#') ) {
                    var LA4_2 = this.input.LA(3);

                    if ( (LA4_2=='x') ) {
                        alt4=2;
                    }
                    else if ( ((LA4_2>='0' && LA4_2<='9')) && (( this.inQuotStr | this.inAposStr ))) {
                        alt4=1;
                    }
                    else {
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 4, 2, this.input);

                        throw nvae;
                    }
                }
                else {
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 4, 1, this.input);

                    throw nvae;
                }
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);

                throw nvae;
            }
            switch (alt4) {
                case 1 :
                    // xquery/StringLexer.g:78:4: {...}? => '&#' ( '0' .. '9' )+ ';'
                    if ( !(( this.inQuotStr | this.inAposStr )) ) {
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "L_CharRef", " this.inQuotStr | this.inAposStr ");
                    }
                    this.match("&#"); 

                    // xquery/StringLexer.g:78:49: ( '0' .. '9' )+
                    var cnt2=0;
                    loop2:
                    do {
                        var alt2=2;
                        var LA2_0 = this.input.LA(1);

                        if ( ((LA2_0>='0' && LA2_0<='9')) ) {
                            alt2=1;
                        }


                        switch (alt2) {
                        case 1 :
                            // xquery/StringLexer.g:78:49: '0' .. '9'
                            this.matchRange('0','9'); 


                            break;

                        default :
                            if ( cnt2 >= 1 ) {
                                break loop2;
                            }
                                var eee = new org.antlr.runtime.EarlyExitException(2, this.input);
                                throw eee;
                        }
                        cnt2++;
                    } while (true);

                    this.match(';'); 


                    break;
                case 2 :
                    // xquery/StringLexer.g:78:65: '&#x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ';'
                    this.match("&#x"); 

                    // xquery/StringLexer.g:78:71: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
                    var cnt3=0;
                    loop3:
                    do {
                        var alt3=2;
                        var LA3_0 = this.input.LA(1);

                        if ( ((LA3_0>='0' && LA3_0<='9')||(LA3_0>='A' && LA3_0<='F')||(LA3_0>='a' && LA3_0<='f')) ) {
                            alt3=1;
                        }


                        switch (alt3) {
                        case 1 :
                            // xquery/StringLexer.g:
                            if ( (this.input.LA(1)>='0' && this.input.LA(1)<='9')||(this.input.LA(1)>='A' && this.input.LA(1)<='F')||(this.input.LA(1)>='a' && this.input.LA(1)<='f') ) {
                                this.input.consume();

                            }
                            else {
                                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                                this.recover(mse);
                                throw mse;}



                            break;

                        default :
                            if ( cnt3 >= 1 ) {
                                break loop3;
                            }
                                var eee = new org.antlr.runtime.EarlyExitException(3, this.input);
                                throw eee;
                        }
                        cnt3++;
                    } while (true);

                    this.match(';'); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_CharRef",

    // $ANTLR start L_QuotStringLiteralChar
    mL_QuotStringLiteralChar: function()  {
        try {
            var _type = this.L_QuotStringLiteralChar;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:82:2: ({...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0027' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+ )
            // xquery/StringLexer.g:82:4: {...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0027' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            if ( !(( this.inQuotStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_QuotStringLiteralChar", " this.inQuotStr ");
            }
            // xquery/StringLexer.g:83:3: ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0027' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            var cnt5=0;
            loop5:
            do {
                var alt5=2;
                var LA5_0 = this.input.LA(1);

                if ( ((LA5_0>='\t' && LA5_0<='\n')||LA5_0=='\r'||(LA5_0>=' ' && LA5_0<='!')||(LA5_0>='#' && LA5_0<='%')||(LA5_0>='\'' && LA5_0<='\uD7FF')||(LA5_0>='\uE000' && LA5_0<='\uFFFD')) ) {
                    alt5=1;
                }


                switch (alt5) {
                case 1 :
                    // xquery/StringLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||(this.input.LA(1)>=' ' && this.input.LA(1)<='!')||(this.input.LA(1)>='#' && this.input.LA(1)<='%')||(this.input.LA(1)>='\'' && this.input.LA(1)<='\uD7FF')||(this.input.LA(1)>='\uE000' && this.input.LA(1)<='\uFFFD') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt5 >= 1 ) {
                        break loop5;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(5, this.input);
                        throw eee;
                }
                cnt5++;
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_QuotStringLiteralChar",

    // $ANTLR start L_AposStringLiteralChar
    mL_AposStringLiteralChar: function()  {
        try {
            var _type = this.L_AposStringLiteralChar;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:88:2: ({...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0028' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+ )
            // xquery/StringLexer.g:88:4: {...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0028' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            if ( !(( this.inAposStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_AposStringLiteralChar", " this.inAposStr ");
            }
            // xquery/StringLexer.g:89:3: ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0028' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            var cnt6=0;
            loop6:
            do {
                var alt6=2;
                var LA6_0 = this.input.LA(1);

                if ( ((LA6_0>='\t' && LA6_0<='\n')||LA6_0=='\r'||(LA6_0>=' ' && LA6_0<='%')||(LA6_0>='(' && LA6_0<='\uD7FF')||(LA6_0>='\uE000' && LA6_0<='\uFFFD')) ) {
                    alt6=1;
                }


                switch (alt6) {
                case 1 :
                    // xquery/StringLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||(this.input.LA(1)>=' ' && this.input.LA(1)<='%')||(this.input.LA(1)>='(' && this.input.LA(1)<='\uD7FF')||(this.input.LA(1)>='\uE000' && this.input.LA(1)<='\uFFFD') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt6 >= 1 ) {
                        break loop6;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(6, this.input);
                        throw eee;
                }
                cnt6++;
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_AposStringLiteralChar",

    // $ANTLR start L_AnyChar
    mL_AnyChar: function()  {
        try {
            var _type = this.L_AnyChar;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/StringLexer.g:98:5: ({...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+ )
            // xquery/StringLexer.g:98:9: {...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            if ( !(( !this.inQuotStr && !this.inAposStr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_AnyChar", " !this.inQuotStr && !this.inAposStr ");
            }
            // xquery/StringLexer.g:99:9: ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            var cnt7=0;
            loop7:
            do {
                var alt7=2;
                var LA7_0 = this.input.LA(1);

                if ( ((LA7_0>='\t' && LA7_0<='\n')||LA7_0=='\r'||(LA7_0>=' ' && LA7_0<='%')||(LA7_0>='\'' && LA7_0<=';')||(LA7_0>='=' && LA7_0<='z')||LA7_0=='|'||(LA7_0>='~' && LA7_0<='\uD7FF')||(LA7_0>='\uE000' && LA7_0<='\uFFFD')) ) {
                    alt7=1;
                }


                switch (alt7) {
                case 1 :
                    // xquery/StringLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||(this.input.LA(1)>=' ' && this.input.LA(1)<='%')||(this.input.LA(1)>='\'' && this.input.LA(1)<=';')||(this.input.LA(1)>='=' && this.input.LA(1)<='z')||this.input.LA(1)=='|'||(this.input.LA(1)>='~' && this.input.LA(1)<='\uD7FF')||(this.input.LA(1)>='\uE000' && this.input.LA(1)<='\uFFFD') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt7 >= 1 ) {
                        break loop7;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(7, this.input);
                        throw eee;
                }
                cnt7++;
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_AnyChar",

    mTokens: function() {
        // xquery/StringLexer.g:1:8: ( QUOT | APOS | ESCAPE_QUOT | ESCAPE_APOS | L_PredefinedEntityRef | L_CharRef | L_QuotStringLiteralChar | L_AposStringLiteralChar | L_AnyChar )
        var alt8=9;
        alt8 = this.dfa8.predict(this.input);
        switch (alt8) {
            case 1 :
                // xquery/StringLexer.g:1:10: QUOT
                this.mQUOT(); 


                break;
            case 2 :
                // xquery/StringLexer.g:1:15: APOS
                this.mAPOS(); 


                break;
            case 3 :
                // xquery/StringLexer.g:1:20: ESCAPE_QUOT
                this.mESCAPE_QUOT(); 


                break;
            case 4 :
                // xquery/StringLexer.g:1:32: ESCAPE_APOS
                this.mESCAPE_APOS(); 


                break;
            case 5 :
                // xquery/StringLexer.g:1:44: L_PredefinedEntityRef
                this.mL_PredefinedEntityRef(); 


                break;
            case 6 :
                // xquery/StringLexer.g:1:66: L_CharRef
                this.mL_CharRef(); 


                break;
            case 7 :
                // xquery/StringLexer.g:1:76: L_QuotStringLiteralChar
                this.mL_QuotStringLiteralChar(); 


                break;
            case 8 :
                // xquery/StringLexer.g:1:100: L_AposStringLiteralChar
                this.mL_AposStringLiteralChar(); 


                break;
            case 9 :
                // xquery/StringLexer.g:1:124: L_AnyChar
                this.mL_AnyChar(); 


                break;

        }

    }

}, true); // important to pass true to overwrite default implementations

org.antlr.lang.augmentObject(StringLexer, {
    DFA8_eotS:
        "\u0001\uffff\u0001\u0007\u0001\u000c\u0001\uffff\u0001\u0011\u0001"+
    "\u0012\u0001\u0013\u0001\uffff\u0001\u0015\u0002\uffff\u0001\u0016\u0001"+
    "\uffff\u0001\u0018\u000d\uffff",
    DFA8_eofS:
        "\u001b\uffff",
    DFA8_minS:
        "\u0003\u0009\u0001\u0023\u0003\u0009\u0001\u0000\u0001\u0009\u0002"+
    "\uffff\u0001\u0009\u0001\u0000\u0001\u0009\u0003\uffff\u0003\u0000\u0001"+
    "\uffff\u0002\u0000\u0001\uffff\u0001\u0000\u0002\uffff",
    DFA8_maxS:
        "\u0003\ufffd\u0001\u0071\u0003\ufffd\u0001\u0000\u0001\ufffd\u0002"+
    "\uffff\u0001\ufffd\u0001\u0000\u0001\ufffd\u0003\uffff\u0003\u0000\u0001"+
    "\uffff\u0002\u0000\u0001\uffff\u0001\u0000\u0002\uffff",
    DFA8_acceptS:
        "\u0009\uffff\u0001\u0008\u0001\u0009\u0003\uffff\u0001\u0007\u0001"+
    "\u0006\u0001\u0005\u0003\uffff\u0001\u0001\u0002\uffff\u0001\u0002\u0001"+
    "\uffff\u0001\u0003\u0001\u0004",
    DFA8_specialS:
        "\u0001\u0007\u0001\u000e\u0001\u0000\u0001\u0004\u0001\u0011\u0001"+
    "\u000a\u0001\u0005\u0001\u0009\u0001\u0010\u0002\uffff\u0001\u000f\u0001"+
    "\u0008\u0001\u0006\u0003\uffff\u0001\u000d\u0001\u0003\u0001\u000b\u0001"+
    "\uffff\u0001\u0001\u0001\u000c\u0001\uffff\u0001\u0002\u0002\uffff}>",
    DFA8_transitionS: [
            "\u0002\u0004\u0002\uffff\u0001\u0004\u0012\uffff\u0002\u0004"+
            "\u0001\u0001\u0003\u0004\u0001\u0003\u0001\u0002\u0014\u0004"+
            "\u0001\u0005\u003e\u0004\u0001\u0005\u0001\u0004\u0001\u0005"+
            "\ud782\u0004\u0800\uffff\u1ffe\u0004",
            "\u0002\u0008\u0002\uffff\u0001\u0008\u0012\uffff\u0002\u0008"+
            "\u0001\u0006\u0003\u0008\u0001\uffff\u0001\u000a\u0014\u0008"+
            "\u0001\u0009\u003e\u0008\u0001\u0009\u0001\u0008\u0001\u0009"+
            "\ud782\u0008\u0800\uffff\u1ffe\u0008",
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0012\uffff\u0002\u000d"+
            "\u0001\u000a\u0003\u000d\u0001\uffff\u0001\u000b\u0014\u000d"+
            "\u0001\u000e\u003e\u000d\u0001\u000e\u0001\u000d\u0001\u000e"+
            "\ud782\u000d\u0800\uffff\u1ffe\u000d",
            "\u0001\u000f\u003d\uffff\u0001\u0010\u0005\uffff\u0001\u0010"+
            "\u0004\uffff\u0001\u0010\u0004\uffff\u0001\u0010",
            "\u0002\u0004\u0002\uffff\u0001\u0004\u0012\uffff\u0002\u0004"+
            "\u0001\u0008\u0003\u0004\u0001\uffff\u0001\u000d\u0014\u0004"+
            "\u0001\u0005\u003e\u0004\u0001\u0005\u0001\u0004\u0001\u0005"+
            "\ud782\u0004\u0800\uffff\u1ffe\u0004",
            "\u0002\u0005\u0002\uffff\u0001\u0005\u0012\uffff\u0002\u0005"+
            "\u0001\u0009\u0003\u0005\u0001\uffff\u0001\u000e\ud7d8\u0005"+
            "\u0800\uffff\u1ffe\u0005",
            "\u0002\u0008\u0002\uffff\u0001\u0008\u0012\uffff\u0006\u0008"+
            "\u0001\uffff\u0001\u000a\u0014\u0008\u0001\u0009\u003e\u0008"+
            "\u0001\u0009\u0001\u0008\u0001\u0009\ud782\u0008\u0800\uffff"+
            "\u1ffe\u0008",
            "\u0001\uffff",
            "\u0002\u0008\u0002\uffff\u0001\u0008\u0012\uffff\u0006\u0008"+
            "\u0001\uffff\u0001\u000a\u0014\u0008\u0001\u0009\u003e\u0008"+
            "\u0001\u0009\u0001\u0008\u0001\u0009\ud782\u0008\u0800\uffff"+
            "\u1ffe\u0008",
            "",
            "",
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0012\uffff\u0002\u000d"+
            "\u0001\u000a\u0003\u000d\u0001\uffff\u0015\u000d\u0001\u000e"+
            "\u003e\u000d\u0001\u000e\u0001\u000d\u0001\u000e\ud782\u000d"+
            "\u0800\uffff\u1ffe\u000d",
            "\u0001\uffff",
            "\u0002\u000d\u0002\uffff\u0001\u000d\u0012\uffff\u0002\u000d"+
            "\u0001\u000a\u0003\u000d\u0001\uffff\u0015\u000d\u0001\u000e"+
            "\u003e\u000d\u0001\u000e\u0001\u000d\u0001\u000e\ud782\u000d"+
            "\u0800\uffff\u1ffe\u000d",
            "",
            "",
            "",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "",
            "\u0001\uffff",
            "\u0001\uffff",
            "",
            "\u0001\uffff",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(StringLexer, {
    DFA8_eot:
        org.antlr.runtime.DFA.unpackEncodedString(StringLexer.DFA8_eotS),
    DFA8_eof:
        org.antlr.runtime.DFA.unpackEncodedString(StringLexer.DFA8_eofS),
    DFA8_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(StringLexer.DFA8_minS),
    DFA8_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(StringLexer.DFA8_maxS),
    DFA8_accept:
        org.antlr.runtime.DFA.unpackEncodedString(StringLexer.DFA8_acceptS),
    DFA8_special:
        org.antlr.runtime.DFA.unpackEncodedString(StringLexer.DFA8_specialS),
    DFA8_transition: (function() {
        var a = [],
            i,
            numStates = StringLexer.DFA8_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(StringLexer.DFA8_transitionS[i]));
        }
        return a;
    })()
});

StringLexer.DFA8 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 8;
    this.eot = StringLexer.DFA8_eot;
    this.eof = StringLexer.DFA8_eof;
    this.min = StringLexer.DFA8_min;
    this.max = StringLexer.DFA8_max;
    this.accept = StringLexer.DFA8_accept;
    this.special = StringLexer.DFA8_special;
    this.transition = StringLexer.DFA8_transition;
};

org.antlr.lang.extend(StringLexer.DFA8, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1:1: Tokens : ( QUOT | APOS | ESCAPE_QUOT | ESCAPE_APOS | L_PredefinedEntityRef | L_CharRef | L_QuotStringLiteralChar | L_AposStringLiteralChar | L_AnyChar );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA8_2 = input.LA(1);

                             
                            var index8_2 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA8_2=='\'') && ((( this.inAposStr )||( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 11;}

                            else if ( ((LA8_2>='\t' && LA8_2<='\n')||LA8_2=='\r'||(LA8_2>=' ' && LA8_2<='!')||(LA8_2>='#' && LA8_2<='%')||(LA8_2>='(' && LA8_2<=';')||(LA8_2>='=' && LA8_2<='z')||LA8_2=='|'||(LA8_2>='~' && LA8_2<='\uD7FF')||(LA8_2>='\uE000' && LA8_2<='\uFFFD')) && ((( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 13;}

                            else if ( (LA8_2=='<'||LA8_2=='{'||LA8_2=='}') && (( this.inQuotStr ))) {s = 14;}

                            else if ( (LA8_2=='\"') && (( !this.inQuotStr && !this.inAposStr ))) {s = 10;}

                            else s = 12;

                             
                            input.seek(index8_2);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA8_21 = input.LA(1);

                             
                            var index8_21 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inAposStr )) ) {s = 9;}

                            else if ( (( !this.inQuotStr && !this.inAposStr )) ) {s = 10;}

                             
                            input.seek(index8_21);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA8_24 = input.LA(1);

                             
                            var index8_24 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotStr )) ) {s = 14;}

                            else if ( (( !this.inQuotStr && !this.inAposStr )) ) {s = 10;}

                             
                            input.seek(index8_24);
                            if ( s>=0 ) return s;
                            break;
                        case 3 : 
                            var LA8_18 = input.LA(1);

                             
                            var index8_18 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotStr )) ) {s = 14;}

                            else if ( (( this.inAposStr )) ) {s = 9;}

                             
                            input.seek(index8_18);
                            if ( s>=0 ) return s;
                            break;
                        case 4 : 
                            var LA8_3 = input.LA(1);

                             
                            var index8_3 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA8_3=='#') ) {s = 15;}

                            else if ( (LA8_3=='a'||LA8_3=='g'||LA8_3=='l'||LA8_3=='q') && (( this.inQuotStr | this.inAposStr ))) {s = 16;}

                             
                            input.seek(index8_3);
                            if ( s>=0 ) return s;
                            break;
                        case 5 : 
                            var LA8_6 = input.LA(1);

                             
                            var index8_6 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA8_6>='\t' && LA8_6<='\n')||LA8_6=='\r'||(LA8_6>=' ' && LA8_6<='%')||(LA8_6>='(' && LA8_6<=';')||(LA8_6>='=' && LA8_6<='z')||LA8_6=='|'||(LA8_6>='~' && LA8_6<='\uD7FF')||(LA8_6>='\uE000' && LA8_6<='\uFFFD')) && ((( this.inAposStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 8;}

                            else if ( (LA8_6=='<'||LA8_6=='{'||LA8_6=='}') && (( this.inAposStr ))) {s = 9;}

                            else if ( (LA8_6=='\'') && (( !this.inQuotStr && !this.inAposStr ))) {s = 10;}

                            else s = 19;

                             
                            input.seek(index8_6);
                            if ( s>=0 ) return s;
                            break;
                        case 6 : 
                            var LA8_13 = input.LA(1);

                             
                            var index8_13 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA8_13>='\t' && LA8_13<='\n')||LA8_13=='\r'||(LA8_13>=' ' && LA8_13<='!')||(LA8_13>='#' && LA8_13<='%')||(LA8_13>='\'' && LA8_13<=';')||(LA8_13>='=' && LA8_13<='z')||LA8_13=='|'||(LA8_13>='~' && LA8_13<='\uD7FF')||(LA8_13>='\uE000' && LA8_13<='\uFFFD')) && ((( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 13;}

                            else if ( (LA8_13=='<'||LA8_13=='{'||LA8_13=='}') && (( this.inQuotStr ))) {s = 14;}

                            else if ( (LA8_13=='\"') && (( !this.inQuotStr && !this.inAposStr ))) {s = 10;}

                            else s = 24;

                             
                            input.seek(index8_13);
                            if ( s>=0 ) return s;
                            break;
                        case 7 : 
                            var LA8_0 = input.LA(1);

                             
                            var index8_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA8_0=='\"') && ((( this.inAposStr )||( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 1;}

                            else if ( (LA8_0=='\'') && ((( this.inAposStr )||( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 2;}

                            else if ( (LA8_0=='&') ) {s = 3;}

                            else if ( ((LA8_0>='\t' && LA8_0<='\n')||LA8_0=='\r'||(LA8_0>=' ' && LA8_0<='!')||(LA8_0>='#' && LA8_0<='%')||(LA8_0>='(' && LA8_0<=';')||(LA8_0>='=' && LA8_0<='z')||LA8_0=='|'||(LA8_0>='~' && LA8_0<='\uD7FF')||(LA8_0>='\uE000' && LA8_0<='\uFFFD')) && ((( this.inAposStr )||( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 4;}

                            else if ( (LA8_0=='<'||LA8_0=='{'||LA8_0=='}') && ((( this.inAposStr )||( this.inQuotStr )))) {s = 5;}

                             
                            input.seek(index8_0);
                            if ( s>=0 ) return s;
                            break;
                        case 8 : 
                            var LA8_12 = input.LA(1);

                             
                            var index8_12 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inAposStr )) ) {s = 23;}

                            else if ( (( this.inQuotStr )) ) {s = 14;}

                            else if ( (( !this.inQuotStr && !this.inAposStr )) ) {s = 10;}

                             
                            input.seek(index8_12);
                            if ( s>=0 ) return s;
                            break;
                        case 9 : 
                            var LA8_7 = input.LA(1);

                             
                            var index8_7 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotStr )) ) {s = 20;}

                            else if ( (( this.inAposStr )) ) {s = 9;}

                            else if ( (( !this.inQuotStr && !this.inAposStr )) ) {s = 10;}

                             
                            input.seek(index8_7);
                            if ( s>=0 ) return s;
                            break;
                        case 10 : 
                            var LA8_5 = input.LA(1);

                             
                            var index8_5 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA8_5>='\t' && LA8_5<='\n')||LA8_5=='\r'||(LA8_5>=' ' && LA8_5<='!')||(LA8_5>='#' && LA8_5<='%')||(LA8_5>='(' && LA8_5<='\uD7FF')||(LA8_5>='\uE000' && LA8_5<='\uFFFD')) && ((( this.inAposStr )||( this.inQuotStr )))) {s = 5;}

                            else if ( (LA8_5=='\'') && (( this.inQuotStr ))) {s = 14;}

                            else if ( (LA8_5=='\"') && (( this.inAposStr ))) {s = 9;}

                            else s = 18;

                             
                            input.seek(index8_5);
                            if ( s>=0 ) return s;
                            break;
                        case 11 : 
                            var LA8_19 = input.LA(1);

                             
                            var index8_19 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotStr )) ) {s = 25;}

                            else if ( (( this.inAposStr )) ) {s = 9;}

                            else if ( (( !this.inQuotStr && !this.inAposStr )) ) {s = 10;}

                             
                            input.seek(index8_19);
                            if ( s>=0 ) return s;
                            break;
                        case 12 : 
                            var LA8_22 = input.LA(1);

                             
                            var index8_22 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inAposStr )) ) {s = 26;}

                            else if ( (( this.inQuotStr )) ) {s = 14;}

                            else if ( (( !this.inQuotStr && !this.inAposStr )) ) {s = 10;}

                             
                            input.seek(index8_22);
                            if ( s>=0 ) return s;
                            break;
                        case 13 : 
                            var LA8_17 = input.LA(1);

                             
                            var index8_17 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotStr )) ) {s = 14;}

                            else if ( (( this.inAposStr )) ) {s = 9;}

                            else if ( (( !this.inQuotStr && !this.inAposStr )) ) {s = 10;}

                             
                            input.seek(index8_17);
                            if ( s>=0 ) return s;
                            break;
                        case 14 : 
                            var LA8_1 = input.LA(1);

                             
                            var index8_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA8_1=='\"') && ((( this.inAposStr )||( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 6;}

                            else if ( ((LA8_1>='\t' && LA8_1<='\n')||LA8_1=='\r'||(LA8_1>=' ' && LA8_1<='!')||(LA8_1>='#' && LA8_1<='%')||(LA8_1>='(' && LA8_1<=';')||(LA8_1>='=' && LA8_1<='z')||LA8_1=='|'||(LA8_1>='~' && LA8_1<='\uD7FF')||(LA8_1>='\uE000' && LA8_1<='\uFFFD')) && ((( this.inAposStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 8;}

                            else if ( (LA8_1=='<'||LA8_1=='{'||LA8_1=='}') && (( this.inAposStr ))) {s = 9;}

                            else if ( (LA8_1=='\'') && (( !this.inQuotStr && !this.inAposStr ))) {s = 10;}

                            else s = 7;

                             
                            input.seek(index8_1);
                            if ( s>=0 ) return s;
                            break;
                        case 15 : 
                            var LA8_11 = input.LA(1);

                             
                            var index8_11 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA8_11>='\t' && LA8_11<='\n')||LA8_11=='\r'||(LA8_11>=' ' && LA8_11<='!')||(LA8_11>='#' && LA8_11<='%')||(LA8_11>='\'' && LA8_11<=';')||(LA8_11>='=' && LA8_11<='z')||LA8_11=='|'||(LA8_11>='~' && LA8_11<='\uD7FF')||(LA8_11>='\uE000' && LA8_11<='\uFFFD')) && ((( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 13;}

                            else if ( (LA8_11=='<'||LA8_11=='{'||LA8_11=='}') && (( this.inQuotStr ))) {s = 14;}

                            else if ( (LA8_11=='\"') && (( !this.inQuotStr && !this.inAposStr ))) {s = 10;}

                            else s = 22;

                             
                            input.seek(index8_11);
                            if ( s>=0 ) return s;
                            break;
                        case 16 : 
                            var LA8_8 = input.LA(1);

                             
                            var index8_8 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA8_8>='\t' && LA8_8<='\n')||LA8_8=='\r'||(LA8_8>=' ' && LA8_8<='%')||(LA8_8>='(' && LA8_8<=';')||(LA8_8>='=' && LA8_8<='z')||LA8_8=='|'||(LA8_8>='~' && LA8_8<='\uD7FF')||(LA8_8>='\uE000' && LA8_8<='\uFFFD')) && ((( this.inAposStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 8;}

                            else if ( (LA8_8=='<'||LA8_8=='{'||LA8_8=='}') && (( this.inAposStr ))) {s = 9;}

                            else if ( (LA8_8=='\'') && (( !this.inQuotStr && !this.inAposStr ))) {s = 10;}

                            else s = 21;

                             
                            input.seek(index8_8);
                            if ( s>=0 ) return s;
                            break;
                        case 17 : 
                            var LA8_4 = input.LA(1);

                             
                            var index8_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA8_4>='\t' && LA8_4<='\n')||LA8_4=='\r'||(LA8_4>=' ' && LA8_4<='!')||(LA8_4>='#' && LA8_4<='%')||(LA8_4>='(' && LA8_4<=';')||(LA8_4>='=' && LA8_4<='z')||LA8_4=='|'||(LA8_4>='~' && LA8_4<='\uD7FF')||(LA8_4>='\uE000' && LA8_4<='\uFFFD')) && ((( this.inAposStr )||( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 4;}

                            else if ( (LA8_4=='\'') && ((( this.inQuotStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 13;}

                            else if ( (LA8_4=='\"') && ((( this.inAposStr )||( !this.inQuotStr && !this.inAposStr )))) {s = 8;}

                            else if ( (LA8_4=='<'||LA8_4=='{'||LA8_4=='}') && ((( this.inAposStr )||( this.inQuotStr )))) {s = 5;}

                            else s = 17;

                             
                            input.seek(index8_4);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 8, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
 
})();
exports.StringLexer = StringLexer;
});define('ace/mode/xquery/XMLLexer', ['require', 'exports', 'module' , 'ace/mode/xquery/antlr3-all', 'ace/mode/xquery/XQDTLexer'], function(require, exports, module) {
// $ANTLR 3.3 Nov 30, 2010 12:50:56 xquery/XMLLexer.g 2012-04-18 21:05:09

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
var org =  require("./antlr3-all").org;
var XQDTLexer   = require("./XQDTLexer").XQDTLexer;


var XMLLexer = function(input, state) {
// alternate constructor @todo
// public XMLLexer(CharStream input)
// public XMLLexer(CharStream input, RecognizerSharedState state) {
    if (!state) {
        state = new org.antlr.runtime.RecognizerSharedState();
    }

    (function(){


        this.inElem = true;
        this.inAposAttr = false;
        this.inQuotAttr = false;

        this.isInElement = function()
        {
           return this.inElem;
        }

        this.isInAposAttribute = function()
        {
           return this.inAposAttr;
        }

        this.isInQuotAttr = function()
        {
           return this.inQuotAttr;
        }
            
        this.addToStack = function(stack) {
        	if (!this.inAposAttr && !this.inQuotAttr)
        		this.inElem = false;
        	stack.push(this);
        } 


        // dummy list for warning elimination
        //List<Stack<Object>> dummy = new ArrayList<Stack<Object>>();

        // when we start, the '<' has already been eaten by the other lexer
        //boolean inElem = true;
        //boolean inAposAttr = false;
        //boolean inQuotAttr = false;
        //
        //public boolean isInElement()
        //{
        //   return inElem;
        //}
        //
        //public boolean isInAposAttribute()
        //{
        //   return inAposAttr;
        //}
        //
        //public boolean isInQuotAttr()
        //{
        //   return inQuotAttr;
        //}
        //    
        //@Override
        //public void addToStack(List<XQDTLexer> stack) {
        //	if (!inAposAttr && !inQuotAttr)
        //		inElem = false;
        //	stack.add(this);
        //} 
        //
        //private boolean log() {
        //	System.out.println("inApos:\t" + inAposAttr);
        //	System.out.println("inQuot:\t" + inQuotAttr);
        //	System.out.println("inElem:\t" + inElem);
        //	System.out.println("---------------------");
        //	return false;
        //}


    }).call(this);

    this.dfa16 = new XMLLexer.DFA16(this);
    XMLLexer.superclass.constructor.call(this, input, state);


};

org.antlr.lang.augmentObject(XMLLexer, {
    EOF: -1,
    L_QuotAttrContentChar: 4,
    L_AposAttrContentChar: 5,
    L_ElementContentChar: 6,
    L_CDataSection: 7,
    L_PredefinedEntityRef: 8,
    L_CharRef: 9,
    ESCAPE_LBRACKET: 10,
    ESCAPE_RBRACKET: 11,
    ESCAPE_APOS: 12,
    ESCAPE_QUOT: 13,
    CDATA_START: 14,
    CDATA_END: 15,
    ANCESTOR: 16,
    ANCESTOR_OR_SELF: 17,
    AND: 18,
    AS: 19,
    ASCENDING: 20,
    AT: 21,
    ATTRIBUTE: 22,
    BASE_URI: 23,
    BOUNDARY_SPACE: 24,
    BY: 25,
    CASE: 26,
    CAST: 27,
    CASTABLE: 28,
    CHILD: 29,
    COLLATION: 30,
    COMMENT: 31,
    CONSTRUCTION: 32,
    COPY_NAMESPACES: 33,
    DECLARE: 34,
    DEFAULT: 35,
    DESCENDANT: 36,
    DESCENDANT_OR_SELF: 37,
    DESCENDING: 38,
    DIV: 39,
    DOCUMENT: 40,
    DOCUMENT_NODE: 41,
    ELEMENT: 42,
    ELSE: 43,
    EMPTY: 44,
    EMPTY_SEQUENCE: 45,
    ENCODING: 46,
    EQ: 47,
    EVERY: 48,
    EXCEPT: 49,
    EXTERNAL: 50,
    FOLLOWING: 51,
    FOLLOWING_SIBLING: 52,
    FOR: 53,
    FUNCTION: 54,
    GE: 55,
    GREATEST: 56,
    GT: 57,
    IDIV: 58,
    IF: 59,
    IMPORT: 60,
    IN: 61,
    INHERIT: 62,
    INSTANCE: 63,
    INTERSECT: 64,
    IS: 65,
    ITEM: 66,
    LAX: 67,
    LE: 68,
    LEAST: 69,
    LET: 70,
    LT: 71,
    MOD: 72,
    MODULE: 73,
    NAMESPACE: 74,
    NE: 75,
    NO_INHERIT: 76,
    NO_PRESERVE: 77,
    NODE: 78,
    OF: 79,
    OPTION: 80,
    OR: 81,
    ORDER: 82,
    ORDERED: 83,
    ORDERING: 84,
    PARENT: 85,
    PRECEDING: 86,
    PRECEDING_SIBLING: 87,
    PRESERVE: 88,
    PROCESSING_INSTRUCTION: 89,
    RETURN: 90,
    SATISFIES: 91,
    SCHEMA: 92,
    SCHEMA_ATTRIBUTE: 93,
    SCHEMA_ELEMENT: 94,
    SELF: 95,
    SOME: 96,
    STABLE: 97,
    STRICT: 98,
    STRIP: 99,
    TEXT: 100,
    THEN: 101,
    TO: 102,
    TREAT: 103,
    TYPESWITCH: 104,
    UNION: 105,
    UNORDERED: 106,
    VALIDATE: 107,
    VARIABLE: 108,
    VERSION: 109,
    WHERE: 110,
    XQUERY: 111,
    ALLOWING: 112,
    CATCH: 113,
    CONTEXT: 114,
    COUNT: 115,
    DECIMAL_FORMAT: 116,
    DECIMAL_SEPARATOR: 117,
    DIGIT: 118,
    END: 119,
    GROUP: 120,
    GROUPING_SEPARATOR: 121,
    INFINITY: 122,
    MINUS_SIGN: 123,
    NAMESPACE_NODE: 124,
    NAN: 125,
    NEXT: 126,
    ONLY: 127,
    PATTERN_SEPARATOR: 128,
    PERCENT: 129,
    PER_MILLE: 130,
    PREVIOUS: 131,
    SLIDING: 132,
    START: 133,
    SWITCH: 134,
    TRY: 135,
    TUMBLING: 136,
    TYPE: 137,
    WHEN: 138,
    WINDOW: 139,
    ZERO_DIGIT: 140,
    AFTER: 141,
    BEFORE: 142,
    COPY: 143,
    DELETE: 144,
    FIRST: 145,
    INSERT: 146,
    INTO: 147,
    LAST: 148,
    MODIFY: 149,
    NODES: 150,
    RENAME: 151,
    REPLACE: 152,
    REVALIDATION: 153,
    SKIP: 154,
    UPDATING: 155,
    VALUE: 156,
    WITH: 157,
    ALL: 158,
    ANY: 159,
    CONTAINS: 160,
    CONTENT: 161,
    DIACRITICS: 162,
    DIFFERENT: 163,
    DISTANCE: 164,
    ENTIRE: 165,
    EXACTLY: 166,
    FROM: 167,
    FT_OPTION: 168,
    FTAND: 169,
    FTNOT: 170,
    FTOR: 171,
    INSENSITIVE: 172,
    LANGUAGE: 173,
    LEVELS: 174,
    LOWERCASE: 175,
    MOST: 176,
    NO: 177,
    NOT: 178,
    OCCURS: 179,
    PARAGRAPH: 180,
    PARAGRAPHS: 181,
    PHRASE: 182,
    RELATIONSHIP: 183,
    SAME: 184,
    SCORE: 185,
    SENSITIVE: 186,
    SENTENCE: 187,
    SENTENCES: 188,
    STEMMING: 189,
    STOP: 190,
    THESAURUS: 191,
    TIMES: 192,
    UPPERCASE: 193,
    USING: 194,
    WEIGHT: 195,
    WILDCARDS: 196,
    WITHOUT: 197,
    WORD: 198,
    WORDS: 199,
    BREAK: 200,
    CONTINUE: 201,
    EXIT: 202,
    LOOP: 203,
    RETURNING: 204,
    WHILE: 205,
    CHECK: 206,
    COLLECTION: 207,
    CONSTRAINT: 208,
    FOREACH: 209,
    FOREIGN: 210,
    INDEX: 211,
    INTEGRITY: 212,
    KEY: 213,
    ON: 214,
    UNIQUE: 215,
    BINARY: 216,
    AMP_ER: 217,
    APOS_ER: 218,
    QUOT_ER: 219,
    CONCAT: 220,
    LPAREN: 221,
    RPAREN: 222,
    DOLLAR: 223,
    LBRACKET: 224,
    RBRACKET: 225,
    LSQUARE: 226,
    RSQUARE: 227,
    EQUAL: 228,
    BIND: 229,
    NOTEQUAL: 230,
    ANN_PERCENT: 231,
    HASH: 232,
    AMP: 233,
    COMMA: 234,
    QUESTION: 235,
    STAR: 236,
    PLUS: 237,
    MINUS: 238,
    SMALLER: 239,
    GREATER: 240,
    SMALLEREQ: 241,
    GREATEREQ: 242,
    SMALLER_SMALLER: 243,
    GREATER_GREATER: 244,
    SLASH: 245,
    SLASH_SLASH: 246,
    DOT: 247,
    DOT_DOT: 248,
    COLON: 249,
    COLON_COLON: 250,
    EMPTY_CLOSE_TAG: 251,
    CLOSE_TAG: 252,
    SEMICOLON: 253,
    VBAR: 254,
    PRAGMA_START: 255,
    PRAGMA_END: 256,
    XML_COMMENT_START: 257,
    XML_COMMENT_END: 258,
    PI_START: 259,
    PI_END: 260,
    ATTR_SIGN: 261,
    CHARREF_DEC: 262,
    CHARREF_HEX: 263,
    APOS: 264,
    QUOT: 265,
    NCNameStartChar: 266,
    NCNameChar: 267,
    L_NCName: 268,
    Letter: 269,
    HexLetter: 270,
    Digit: 271,
    Digits: 272,
    S: 273,
    SU: 274,
    L_Pragma: 275,
    L_DirCommentConstructor: 276,
    L_DirPIConstructor: 277,
    L_IntegerLiteral: 278,
    L_DecimalLiteral: 279,
    L_DoubleLiteral: 280,
    L_Comment: 281,
    L_AnyChar: 282,
    NCNameUnprotected: 283,
    XMLDigit: 284
});

(function(){
var HIDDEN = org.antlr.runtime.Token.HIDDEN_CHANNEL,
    EOF = org.antlr.runtime.Token.EOF;
org.antlr.lang.extend(XMLLexer, XQDTLexer, {
    EOF : -1,
    L_QuotAttrContentChar : 4,
    L_AposAttrContentChar : 5,
    L_ElementContentChar : 6,
    L_CDataSection : 7,
    L_PredefinedEntityRef : 8,
    L_CharRef : 9,
    ESCAPE_LBRACKET : 10,
    ESCAPE_RBRACKET : 11,
    ESCAPE_APOS : 12,
    ESCAPE_QUOT : 13,
    CDATA_START : 14,
    CDATA_END : 15,
    ANCESTOR : 16,
    ANCESTOR_OR_SELF : 17,
    AND : 18,
    AS : 19,
    ASCENDING : 20,
    AT : 21,
    ATTRIBUTE : 22,
    BASE_URI : 23,
    BOUNDARY_SPACE : 24,
    BY : 25,
    CASE : 26,
    CAST : 27,
    CASTABLE : 28,
    CHILD : 29,
    COLLATION : 30,
    COMMENT : 31,
    CONSTRUCTION : 32,
    COPY_NAMESPACES : 33,
    DECLARE : 34,
    DEFAULT : 35,
    DESCENDANT : 36,
    DESCENDANT_OR_SELF : 37,
    DESCENDING : 38,
    DIV : 39,
    DOCUMENT : 40,
    DOCUMENT_NODE : 41,
    ELEMENT : 42,
    ELSE : 43,
    EMPTY : 44,
    EMPTY_SEQUENCE : 45,
    ENCODING : 46,
    EQ : 47,
    EVERY : 48,
    EXCEPT : 49,
    EXTERNAL : 50,
    FOLLOWING : 51,
    FOLLOWING_SIBLING : 52,
    FOR : 53,
    FUNCTION : 54,
    GE : 55,
    GREATEST : 56,
    GT : 57,
    IDIV : 58,
    IF : 59,
    IMPORT : 60,
    IN : 61,
    INHERIT : 62,
    INSTANCE : 63,
    INTERSECT : 64,
    IS : 65,
    ITEM : 66,
    LAX : 67,
    LE : 68,
    LEAST : 69,
    LET : 70,
    LT : 71,
    MOD : 72,
    MODULE : 73,
    NAMESPACE : 74,
    NE : 75,
    NO_INHERIT : 76,
    NO_PRESERVE : 77,
    NODE : 78,
    OF : 79,
    OPTION : 80,
    OR : 81,
    ORDER : 82,
    ORDERED : 83,
    ORDERING : 84,
    PARENT : 85,
    PRECEDING : 86,
    PRECEDING_SIBLING : 87,
    PRESERVE : 88,
    PROCESSING_INSTRUCTION : 89,
    RETURN : 90,
    SATISFIES : 91,
    SCHEMA : 92,
    SCHEMA_ATTRIBUTE : 93,
    SCHEMA_ELEMENT : 94,
    SELF : 95,
    SOME : 96,
    STABLE : 97,
    STRICT : 98,
    STRIP : 99,
    TEXT : 100,
    THEN : 101,
    TO : 102,
    TREAT : 103,
    TYPESWITCH : 104,
    UNION : 105,
    UNORDERED : 106,
    VALIDATE : 107,
    VARIABLE : 108,
    VERSION : 109,
    WHERE : 110,
    XQUERY : 111,
    ALLOWING : 112,
    CATCH : 113,
    CONTEXT : 114,
    COUNT : 115,
    DECIMAL_FORMAT : 116,
    DECIMAL_SEPARATOR : 117,
    DIGIT : 118,
    END : 119,
    GROUP : 120,
    GROUPING_SEPARATOR : 121,
    INFINITY : 122,
    MINUS_SIGN : 123,
    NAMESPACE_NODE : 124,
    NAN : 125,
    NEXT : 126,
    ONLY : 127,
    PATTERN_SEPARATOR : 128,
    PERCENT : 129,
    PER_MILLE : 130,
    PREVIOUS : 131,
    SLIDING : 132,
    START : 133,
    SWITCH : 134,
    TRY : 135,
    TUMBLING : 136,
    TYPE : 137,
    WHEN : 138,
    WINDOW : 139,
    ZERO_DIGIT : 140,
    AFTER : 141,
    BEFORE : 142,
    COPY : 143,
    DELETE : 144,
    FIRST : 145,
    INSERT : 146,
    INTO : 147,
    LAST : 148,
    MODIFY : 149,
    NODES : 150,
    RENAME : 151,
    REPLACE : 152,
    REVALIDATION : 153,
    SKIP : 154,
    UPDATING : 155,
    VALUE : 156,
    WITH : 157,
    ALL : 158,
    ANY : 159,
    CONTAINS : 160,
    CONTENT : 161,
    DIACRITICS : 162,
    DIFFERENT : 163,
    DISTANCE : 164,
    ENTIRE : 165,
    EXACTLY : 166,
    FROM : 167,
    FT_OPTION : 168,
    FTAND : 169,
    FTNOT : 170,
    FTOR : 171,
    INSENSITIVE : 172,
    LANGUAGE : 173,
    LEVELS : 174,
    LOWERCASE : 175,
    MOST : 176,
    NO : 177,
    NOT : 178,
    OCCURS : 179,
    PARAGRAPH : 180,
    PARAGRAPHS : 181,
    PHRASE : 182,
    RELATIONSHIP : 183,
    SAME : 184,
    SCORE : 185,
    SENSITIVE : 186,
    SENTENCE : 187,
    SENTENCES : 188,
    STEMMING : 189,
    STOP : 190,
    THESAURUS : 191,
    TIMES : 192,
    UPPERCASE : 193,
    USING : 194,
    WEIGHT : 195,
    WILDCARDS : 196,
    WITHOUT : 197,
    WORD : 198,
    WORDS : 199,
    BREAK : 200,
    CONTINUE : 201,
    EXIT : 202,
    LOOP : 203,
    RETURNING : 204,
    WHILE : 205,
    CHECK : 206,
    COLLECTION : 207,
    CONSTRAINT : 208,
    FOREACH : 209,
    FOREIGN : 210,
    INDEX : 211,
    INTEGRITY : 212,
    KEY : 213,
    ON : 214,
    UNIQUE : 215,
    BINARY : 216,
    AMP_ER : 217,
    APOS_ER : 218,
    QUOT_ER : 219,
    CONCAT : 220,
    LPAREN : 221,
    RPAREN : 222,
    DOLLAR : 223,
    LBRACKET : 224,
    RBRACKET : 225,
    LSQUARE : 226,
    RSQUARE : 227,
    EQUAL : 228,
    BIND : 229,
    NOTEQUAL : 230,
    ANN_PERCENT : 231,
    HASH : 232,
    AMP : 233,
    COMMA : 234,
    QUESTION : 235,
    STAR : 236,
    PLUS : 237,
    MINUS : 238,
    SMALLER : 239,
    GREATER : 240,
    SMALLEREQ : 241,
    GREATEREQ : 242,
    SMALLER_SMALLER : 243,
    GREATER_GREATER : 244,
    SLASH : 245,
    SLASH_SLASH : 246,
    DOT : 247,
    DOT_DOT : 248,
    COLON : 249,
    COLON_COLON : 250,
    EMPTY_CLOSE_TAG : 251,
    CLOSE_TAG : 252,
    SEMICOLON : 253,
    VBAR : 254,
    PRAGMA_START : 255,
    PRAGMA_END : 256,
    XML_COMMENT_START : 257,
    XML_COMMENT_END : 258,
    PI_START : 259,
    PI_END : 260,
    ATTR_SIGN : 261,
    CHARREF_DEC : 262,
    CHARREF_HEX : 263,
    APOS : 264,
    QUOT : 265,
    NCNameStartChar : 266,
    NCNameChar : 267,
    L_NCName : 268,
    Letter : 269,
    HexLetter : 270,
    Digit : 271,
    Digits : 272,
    S : 273,
    SU : 274,
    L_Pragma : 275,
    L_DirCommentConstructor : 276,
    L_DirPIConstructor : 277,
    L_IntegerLiteral : 278,
    L_DecimalLiteral : 279,
    L_DoubleLiteral : 280,
    L_Comment : 281,
    L_AnyChar : 282,
    NCNameUnprotected : 283,
    XMLDigit : 284,
    getGrammarFileName: function() { return "xquery/XMLLexer.g"; }
});
org.antlr.lang.augmentObject(XMLLexer.prototype, {
    // $ANTLR start QUOT
    mQUOT: function()  {
        try {
            var _type = this.QUOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:132:6: ({...}? => '\"' )
            // xquery/XMLLexer.g:132:8: {...}? => '\"'
            if ( !(( this.inElem || this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "QUOT", " this.inElem || this.inQuotAttr ");
            }
            this.match('\"'); 
             if (!this.inAposAttr) this.inQuotAttr = (!this.inQuotAttr); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "QUOT",

    // $ANTLR start APOS
    mAPOS: function()  {
        try {
            var _type = this.APOS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:133:6: ({...}? => '\\'' )
            // xquery/XMLLexer.g:133:8: {...}? => '\\''
            if ( !(( this.inElem || this.inAposAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "APOS", " this.inElem || this.inAposAttr ");
            }
            this.match('\''); 
             if (!this.inQuotAttr) this.inAposAttr = !this.inAposAttr; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "APOS",

    // $ANTLR start L_QuotAttrContentChar
    mL_QuotAttrContentChar: function()  {
        try {
            var _type = this.L_QuotAttrContentChar;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:136:2: ({...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' | '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0028' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' .. '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+ )
            // xquery/XMLLexer.g:136:4: {...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' | '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0028' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' .. '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            if ( !(( this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_QuotAttrContentChar", " this.inQuotAttr ");
            }
            // xquery/XMLLexer.g:137:3: ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' | '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0028' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' .. '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            var cnt1=0;
            loop1:
            do {
                var alt1=2;
                var LA1_0 = this.input.LA(1);

                if ( ((LA1_0>='\t' && LA1_0<='\n')||LA1_0=='\r'||(LA1_0>=' ' && LA1_0<='!')||(LA1_0>='#' && LA1_0<='%')||(LA1_0>='(' && LA1_0<=';')||(LA1_0>='=' && LA1_0<='z')||LA1_0=='|'||(LA1_0>='~' && LA1_0<='\uD7FF')||(LA1_0>='\uE000' && LA1_0<='\uFFFD')) ) {
                    alt1=1;
                }


                switch (alt1) {
                case 1 :
                    // xquery/XMLLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||(this.input.LA(1)>=' ' && this.input.LA(1)<='!')||(this.input.LA(1)>='#' && this.input.LA(1)<='%')||(this.input.LA(1)>='(' && this.input.LA(1)<=';')||(this.input.LA(1)>='=' && this.input.LA(1)<='z')||this.input.LA(1)=='|'||(this.input.LA(1)>='~' && this.input.LA(1)<='\uD7FF')||(this.input.LA(1)>='\uE000' && this.input.LA(1)<='\uFFFD') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt1 >= 1 ) {
                        break loop1;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(1, this.input);
                        throw eee;
                }
                cnt1++;
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_QuotAttrContentChar",

    // $ANTLR start L_AposAttrContentChar
    mL_AposAttrContentChar: function()  {
        try {
            var _type = this.L_AposAttrContentChar;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:143:2: ({...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' | '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0028' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' .. '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+ )
            // xquery/XMLLexer.g:143:4: {...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' | '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0028' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' .. '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            if ( !(( this.inAposAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_AposAttrContentChar", " this.inAposAttr ");
            }
            // xquery/XMLLexer.g:144:3: ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' | '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0028' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' .. '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            var cnt2=0;
            loop2:
            do {
                var alt2=2;
                var LA2_0 = this.input.LA(1);

                if ( ((LA2_0>='\t' && LA2_0<='\n')||LA2_0=='\r'||(LA2_0>=' ' && LA2_0<='!')||(LA2_0>='#' && LA2_0<='%')||(LA2_0>='(' && LA2_0<=';')||(LA2_0>='=' && LA2_0<='z')||LA2_0=='|'||(LA2_0>='~' && LA2_0<='\uD7FF')||(LA2_0>='\uE000' && LA2_0<='\uFFFD')) ) {
                    alt2=1;
                }


                switch (alt2) {
                case 1 :
                    // xquery/XMLLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||(this.input.LA(1)>=' ' && this.input.LA(1)<='!')||(this.input.LA(1)>='#' && this.input.LA(1)<='%')||(this.input.LA(1)>='(' && this.input.LA(1)<=';')||(this.input.LA(1)>='=' && this.input.LA(1)<='z')||this.input.LA(1)=='|'||(this.input.LA(1)>='~' && this.input.LA(1)<='\uD7FF')||(this.input.LA(1)>='\uE000' && this.input.LA(1)<='\uFFFD') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt2 >= 1 ) {
                        break loop2;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(2, this.input);
                        throw eee;
                }
                cnt2++;
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_AposAttrContentChar",

    // $ANTLR start L_ElementContentChar
    mL_ElementContentChar: function()  {
        try {
            var _type = this.L_ElementContentChar;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:151:2: ({...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+ )
            // xquery/XMLLexer.g:151:4: {...}? => ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            if ( !(( !this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_ElementContentChar", " !this.inElem ");
            }
            // xquery/XMLLexer.g:152:3: ( '\\u0009' | '\\u000A' | '\\u000D' | '\\u0020' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' .. '\\u007A' | '\\u007C' | '\\u007E' .. '\\uD7FF' | '\\uE000' .. '\\uFFFD' )+
            var cnt3=0;
            loop3:
            do {
                var alt3=2;
                var LA3_0 = this.input.LA(1);

                if ( ((LA3_0>='\t' && LA3_0<='\n')||LA3_0=='\r'||(LA3_0>=' ' && LA3_0<='%')||(LA3_0>='\'' && LA3_0<=';')||(LA3_0>='=' && LA3_0<='z')||LA3_0=='|'||(LA3_0>='~' && LA3_0<='\uD7FF')||(LA3_0>='\uE000' && LA3_0<='\uFFFD')) ) {
                    alt3=1;
                }


                switch (alt3) {
                case 1 :
                    // xquery/XMLLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||(this.input.LA(1)>=' ' && this.input.LA(1)<='%')||(this.input.LA(1)>='\'' && this.input.LA(1)<=';')||(this.input.LA(1)>='=' && this.input.LA(1)<='z')||this.input.LA(1)=='|'||(this.input.LA(1)>='~' && this.input.LA(1)<='\uD7FF')||(this.input.LA(1)>='\uE000' && this.input.LA(1)<='\uFFFD') ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt3 >= 1 ) {
                        break loop3;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(3, this.input);
                        throw eee;
                }
                cnt3++;
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_ElementContentChar",

    // $ANTLR start GREATER
    mGREATER: function()  {
        try {
            var _type = this.GREATER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:158:2: ({...}? => '>' )
            // xquery/XMLLexer.g:158:4: {...}? => '>'
            if ( !(( this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "GREATER", " this.inElem ");
            }
            this.match('>'); 
             this.inElem = false; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "GREATER",

    // $ANTLR start EMPTY_CLOSE_TAG
    mEMPTY_CLOSE_TAG: function()  {
        try {
            var _type = this.EMPTY_CLOSE_TAG;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:162:2: ({...}? => '/>' )
            // xquery/XMLLexer.g:162:4: {...}? => '/>'
            if ( !(( this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "EMPTY_CLOSE_TAG", " this.inElem ");
            }
            this.match("/>"); 

             this.inElem = false; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EMPTY_CLOSE_TAG",

    // $ANTLR start S
    mS: function()  {
        try {
            var _type = this.S;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:166:2: ({...}? => ( ' ' | '\\t' | '\\r' | '\\n' )+ )
            // xquery/XMLLexer.g:166:4: {...}? => ( ' ' | '\\t' | '\\r' | '\\n' )+
            if ( !(( this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "S", " this.inElem ");
            }
            // xquery/XMLLexer.g:166:24: ( ' ' | '\\t' | '\\r' | '\\n' )+
            var cnt4=0;
            loop4:
            do {
                var alt4=2;
                var LA4_0 = this.input.LA(1);

                if ( ((LA4_0>='\t' && LA4_0<='\n')||LA4_0=='\r'||LA4_0==' ') ) {
                    alt4=1;
                }


                switch (alt4) {
                case 1 :
                    // xquery/XMLLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||this.input.LA(1)==' ' ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt4 >= 1 ) {
                        break loop4;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(4, this.input);
                        throw eee;
                }
                cnt4++;
            } while (true);




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "S",

    // $ANTLR start L_NCName
    mL_NCName: function()  {
        try {
            var _type = this.L_NCName;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:172:2: ({...}? => NCNameUnprotected )
            // xquery/XMLLexer.g:172:4: {...}? => NCNameUnprotected
            if ( !(( this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_NCName", " this.inElem ");
            }
            this.mNCNameUnprotected(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_NCName",

    // $ANTLR start NCNameUnprotected
    mNCNameUnprotected: function()  {
        try {
            // xquery/XMLLexer.g:176:2: ( NCNameStartChar ( NCNameChar )* )
            // xquery/XMLLexer.g:176:4: NCNameStartChar ( NCNameChar )*
            this.mNCNameStartChar(); 
            // xquery/XMLLexer.g:176:20: ( NCNameChar )*
            loop5:
            do {
                var alt5=2;
                var LA5_0 = this.input.LA(1);

                if ( ((LA5_0>='-' && LA5_0<='.')||(LA5_0>='0' && LA5_0<='9')||(LA5_0>='A' && LA5_0<='Z')||LA5_0=='_'||(LA5_0>='a' && LA5_0<='z')) ) {
                    alt5=1;
                }


                switch (alt5) {
                case 1 :
                    // xquery/XMLLexer.g:176:20: NCNameChar
                    this.mNCNameChar(); 


                    break;

                default :
                    break loop5;
                }
            } while (true);




        }
        finally {
        }
    },
    // $ANTLR end "NCNameUnprotected",

    // $ANTLR start NCNameStartChar
    mNCNameStartChar: function()  {
        try {
            // xquery/XMLLexer.g:180:2: ( Letter | '_' )
            // xquery/XMLLexer.g:
            if ( (this.input.LA(1)>='A' && this.input.LA(1)<='Z')||this.input.LA(1)=='_'||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "NCNameStartChar",

    // $ANTLR start NCNameChar
    mNCNameChar: function()  {
        try {
            // xquery/XMLLexer.g:184:2: ( Letter | XMLDigit | '.' | '-' | '_' )
            // xquery/XMLLexer.g:
            if ( (this.input.LA(1)>='-' && this.input.LA(1)<='.')||(this.input.LA(1)>='0' && this.input.LA(1)<='9')||(this.input.LA(1)>='A' && this.input.LA(1)<='Z')||this.input.LA(1)=='_'||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "NCNameChar",

    // $ANTLR start Letter
    mLetter: function()  {
        try {
            // xquery/XMLLexer.g:188:2: ( 'a' .. 'z' | 'A' .. 'Z' )
            // xquery/XMLLexer.g:
            if ( (this.input.LA(1)>='A' && this.input.LA(1)<='Z')||(this.input.LA(1)>='a' && this.input.LA(1)<='z') ) {
                this.input.consume();

            }
            else {
                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                this.recover(mse);
                throw mse;}




        }
        finally {
        }
    },
    // $ANTLR end "Letter",

    // $ANTLR start XMLDigit
    mXMLDigit: function()  {
        try {
            // xquery/XMLLexer.g:192:2: ( '0' .. '9' )
            // xquery/XMLLexer.g:192:4: '0' .. '9'
            this.matchRange('0','9'); 



        }
        finally {
        }
    },
    // $ANTLR end "XMLDigit",

    // $ANTLR start EQUAL
    mEQUAL: function()  {
        try {
            var _type = this.EQUAL;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:207:7: ({...}? => '=' )
            // xquery/XMLLexer.g:207:9: {...}? => '='
            if ( !(( this.inElem  )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "EQUAL", " this.inElem  ");
            }
            this.match('='); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "EQUAL",

    // $ANTLR start ESCAPE_APOS
    mESCAPE_APOS: function()  {
        try {
            var _type = this.ESCAPE_APOS;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:208:13: ({...}? => '\\'\\'' )
            // xquery/XMLLexer.g:208:15: {...}? => '\\'\\''
            if ( !(( this.inAposAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "ESCAPE_APOS", " this.inAposAttr ");
            }
            this.match("''"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ESCAPE_APOS",

    // $ANTLR start ESCAPE_QUOT
    mESCAPE_QUOT: function()  {
        try {
            var _type = this.ESCAPE_QUOT;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:209:13: ({...}? => '\"\"' )
            // xquery/XMLLexer.g:209:15: {...}? => '\"\"'
            if ( !(( this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "ESCAPE_QUOT", " this.inQuotAttr ");
            }
            this.match("\"\""); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ESCAPE_QUOT",

    // $ANTLR start ESCAPE_LBRACKET
    mESCAPE_LBRACKET: function()  {
        try {
            var _type = this.ESCAPE_LBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:212:2: ({...}? => '{{' )
            // xquery/XMLLexer.g:212:4: {...}? => '{{'
            if ( !(( !this.inElem || this.inAposAttr || this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "ESCAPE_LBRACKET", " !this.inElem || this.inAposAttr || this.inQuotAttr ");
            }
            this.match("{{"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ESCAPE_LBRACKET",

    // $ANTLR start ESCAPE_RBRACKET
    mESCAPE_RBRACKET: function()  {
        try {
            var _type = this.ESCAPE_RBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:216:2: ({...}? => '}}' )
            // xquery/XMLLexer.g:216:4: {...}? => '}}'
            if ( !(( !this.inElem || this.inAposAttr || this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "ESCAPE_RBRACKET", " !this.inElem || this.inAposAttr || this.inQuotAttr ");
            }
            this.match("}}"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "ESCAPE_RBRACKET",

    // $ANTLR start LBRACKET
    mLBRACKET: function()  {
        try {
            var _type = this.LBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:219:10: ({...}? => '{' )
            // xquery/XMLLexer.g:219:12: {...}? => '{'
            if ( !(( !this.inElem || this.inAposAttr || this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "LBRACKET", " !this.inElem || this.inAposAttr || this.inQuotAttr ");
            }
            this.match('{'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "LBRACKET",

    // $ANTLR start RBRACKET
    mRBRACKET: function()  {
        try {
            var _type = this.RBRACKET;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:220:10: ({...}? => '}' )
            // xquery/XMLLexer.g:220:12: {...}? => '}'
            if ( !(( !this.inElem || this.inAposAttr || this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "RBRACKET", " !this.inElem || this.inAposAttr || this.inQuotAttr ");
            }
            this.match('}'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "RBRACKET",

    // $ANTLR start SMALLER
    mSMALLER: function()  {
        try {
            var _type = this.SMALLER;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:221:9: ( '<' )
            // xquery/XMLLexer.g:221:11: '<'
            this.match('<'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "SMALLER",

    // $ANTLR start CLOSE_TAG
    mCLOSE_TAG: function()  {
        try {
            var _type = this.CLOSE_TAG;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:222:11: ({...}? => '</' )
            // xquery/XMLLexer.g:222:13: {...}? => '</'
            if ( !(( !this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "CLOSE_TAG", " !this.inElem ");
            }
            this.match("</"); 

             this.inElem = true; 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CLOSE_TAG",

    // $ANTLR start CDATA_START
    mCDATA_START: function()  {
        try {
            var _type = this.CDATA_START;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:224:13: ( '<![CDATA[' )
            // xquery/XMLLexer.g:224:15: '<![CDATA['
            this.match("<![CDATA["); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CDATA_START",

    // $ANTLR start CDATA_END
    mCDATA_END: function()  {
        try {
            var _type = this.CDATA_END;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:225:12: ( ']]>' )
            // xquery/XMLLexer.g:225:14: ']]>'
            this.match("]]>"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "CDATA_END",

    // $ANTLR start L_CDataSection
    mL_CDataSection: function()  {
        try {
            var _type = this.L_CDataSection;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:229:3: ({...}? => CDATA_START ( options {greedy=false; } : ( . )* ) CDATA_END )
            // xquery/XMLLexer.g:229:5: {...}? => CDATA_START ( options {greedy=false; } : ( . )* ) CDATA_END
            if ( !(( !this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_CDataSection", " !this.inElem ");
            }
            this.mCDATA_START(); 
            // xquery/XMLLexer.g:229:38: ( options {greedy=false; } : ( . )* )
            // xquery/XMLLexer.g:229:65: ( . )*
            // xquery/XMLLexer.g:229:65: ( . )*
            loop6:
            do {
                var alt6=2;
                var LA6_0 = this.input.LA(1);

                if ( (LA6_0==']') ) {
                    var LA6_1 = this.input.LA(2);

                    if ( (LA6_1==']') ) {
                        var LA6_3 = this.input.LA(3);

                        if ( (LA6_3=='>') ) {
                            alt6=2;
                        }
                        else if ( ((LA6_3>='\u0000' && LA6_3<='=')||(LA6_3>='?' && LA6_3<='\uFFFF')) ) {
                            alt6=1;
                        }


                    }
                    else if ( ((LA6_1>='\u0000' && LA6_1<='\\')||(LA6_1>='^' && LA6_1<='\uFFFF')) ) {
                        alt6=1;
                    }


                }
                else if ( ((LA6_0>='\u0000' && LA6_0<='\\')||(LA6_0>='^' && LA6_0<='\uFFFF')) ) {
                    alt6=1;
                }


                switch (alt6) {
                case 1 :
                    // xquery/XMLLexer.g:229:65: .
                    this.matchAny(); 


                    break;

                default :
                    break loop6;
                }
            } while (true);




            this.mCDATA_END(); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_CDataSection",

    // $ANTLR start L_PredefinedEntityRef
    mL_PredefinedEntityRef: function()  {
        try {
            var _type = this.L_PredefinedEntityRef;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:237:2: ({...}? => '&' ( 'lt' | 'gt' | 'apos' | 'quot' | 'amp' ) ';' )
            // xquery/XMLLexer.g:237:4: {...}? => '&' ( 'lt' | 'gt' | 'apos' | 'quot' | 'amp' ) ';'
            if ( !(( !this.inElem || this.inAposAttr || this.inQuotAttr )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_PredefinedEntityRef", " !this.inElem || this.inAposAttr || this.inQuotAttr ");
            }
            this.match('&'); 
            // xquery/XMLLexer.g:237:67: ( 'lt' | 'gt' | 'apos' | 'quot' | 'amp' )
            var alt7=5;
            switch ( this.input.LA(1) ) {
            case 'l':
                alt7=1;
                break;
            case 'g':
                alt7=2;
                break;
            case 'a':
                var LA7_3 = this.input.LA(2);

                if ( (LA7_3=='p') ) {
                    alt7=3;
                }
                else if ( (LA7_3=='m') ) {
                    alt7=5;
                }
                else {
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 7, 3, this.input);

                    throw nvae;
                }
                break;
            case 'q':
                alt7=4;
                break;
            default:
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 7, 0, this.input);

                throw nvae;
            }

            switch (alt7) {
                case 1 :
                    // xquery/XMLLexer.g:237:68: 'lt'
                    this.match("lt"); 



                    break;
                case 2 :
                    // xquery/XMLLexer.g:237:75: 'gt'
                    this.match("gt"); 



                    break;
                case 3 :
                    // xquery/XMLLexer.g:237:82: 'apos'
                    this.match("apos"); 



                    break;
                case 4 :
                    // xquery/XMLLexer.g:237:91: 'quot'
                    this.match("quot"); 



                    break;
                case 5 :
                    // xquery/XMLLexer.g:237:100: 'amp'
                    this.match("amp"); 



                    break;

            }

            this.match(';'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_PredefinedEntityRef",

    // $ANTLR start L_CharRef
    mL_CharRef: function()  {
        try {
            var _type = this.L_CharRef;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:242:2: ({...}? => '&#' ( '0' .. '9' )+ ';' | '&#x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ';' )
            var alt10=2;
            var LA10_0 = this.input.LA(1);

            if ( (LA10_0=='&') ) {
                var LA10_1 = this.input.LA(2);

                if ( (LA10_1=='#') ) {
                    var LA10_2 = this.input.LA(3);

                    if ( (LA10_2=='x') ) {
                        alt10=2;
                    }
                    else if ( ((LA10_2>='0' && LA10_2<='9')) && (( !this.inElem || this.inAposAttr || this.inQuotAttr ))) {
                        alt10=1;
                    }
                    else {
                        var nvae =
                            new org.antlr.runtime.NoViableAltException("", 10, 2, this.input);

                        throw nvae;
                    }
                }
                else {
                    var nvae =
                        new org.antlr.runtime.NoViableAltException("", 10, 1, this.input);

                    throw nvae;
                }
            }
            else {
                var nvae =
                    new org.antlr.runtime.NoViableAltException("", 10, 0, this.input);

                throw nvae;
            }
            switch (alt10) {
                case 1 :
                    // xquery/XMLLexer.g:242:4: {...}? => '&#' ( '0' .. '9' )+ ';'
                    if ( !(( !this.inElem || this.inAposAttr || this.inQuotAttr )) ) {
                        throw new org.antlr.runtime.FailedPredicateException(this.input, "L_CharRef", " !this.inElem || this.inAposAttr || this.inQuotAttr ");
                    }
                    this.match("&#"); 

                    // xquery/XMLLexer.g:242:68: ( '0' .. '9' )+
                    var cnt8=0;
                    loop8:
                    do {
                        var alt8=2;
                        var LA8_0 = this.input.LA(1);

                        if ( ((LA8_0>='0' && LA8_0<='9')) ) {
                            alt8=1;
                        }


                        switch (alt8) {
                        case 1 :
                            // xquery/XMLLexer.g:242:69: '0' .. '9'
                            this.matchRange('0','9'); 


                            break;

                        default :
                            if ( cnt8 >= 1 ) {
                                break loop8;
                            }
                                var eee = new org.antlr.runtime.EarlyExitException(8, this.input);
                                throw eee;
                        }
                        cnt8++;
                    } while (true);

                    this.match(';'); 


                    break;
                case 2 :
                    // xquery/XMLLexer.g:242:86: '&#x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ ';'
                    this.match("&#x"); 

                    // xquery/XMLLexer.g:242:92: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
                    var cnt9=0;
                    loop9:
                    do {
                        var alt9=2;
                        var LA9_0 = this.input.LA(1);

                        if ( ((LA9_0>='0' && LA9_0<='9')||(LA9_0>='A' && LA9_0<='F')||(LA9_0>='a' && LA9_0<='f')) ) {
                            alt9=1;
                        }


                        switch (alt9) {
                        case 1 :
                            // xquery/XMLLexer.g:
                            if ( (this.input.LA(1)>='0' && this.input.LA(1)<='9')||(this.input.LA(1)>='A' && this.input.LA(1)<='F')||(this.input.LA(1)>='a' && this.input.LA(1)<='f') ) {
                                this.input.consume();

                            }
                            else {
                                var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                                this.recover(mse);
                                throw mse;}



                            break;

                        default :
                            if ( cnt9 >= 1 ) {
                                break loop9;
                            }
                                var eee = new org.antlr.runtime.EarlyExitException(9, this.input);
                                throw eee;
                        }
                        cnt9++;
                    } while (true);

                    this.match(';'); 


                    break;

            }
            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_CharRef",

    // $ANTLR start L_DirCommentConstructor
    mL_DirCommentConstructor: function()  {
        try {
            var _type = this.L_DirCommentConstructor;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:246:2: ({...}? => '<!--' ( options {greedy=false; } : ( . )* ) '-->' )
            // xquery/XMLLexer.g:246:4: {...}? => '<!--' ( options {greedy=false; } : ( . )* ) '-->'
            if ( !(( !this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_DirCommentConstructor", " !this.inElem ");
            }
            this.match("<!--"); 

            // xquery/XMLLexer.g:246:32: ( options {greedy=false; } : ( . )* )
            // xquery/XMLLexer.g:246:59: ( . )*
            // xquery/XMLLexer.g:246:59: ( . )*
            loop11:
            do {
                var alt11=2;
                var LA11_0 = this.input.LA(1);

                if ( (LA11_0=='-') ) {
                    var LA11_1 = this.input.LA(2);

                    if ( (LA11_1=='-') ) {
                        var LA11_3 = this.input.LA(3);

                        if ( (LA11_3=='>') ) {
                            alt11=2;
                        }
                        else if ( ((LA11_3>='\u0000' && LA11_3<='=')||(LA11_3>='?' && LA11_3<='\uFFFF')) ) {
                            alt11=1;
                        }


                    }
                    else if ( ((LA11_1>='\u0000' && LA11_1<=',')||(LA11_1>='.' && LA11_1<='\uFFFF')) ) {
                        alt11=1;
                    }


                }
                else if ( ((LA11_0>='\u0000' && LA11_0<=',')||(LA11_0>='.' && LA11_0<='\uFFFF')) ) {
                    alt11=1;
                }


                switch (alt11) {
                case 1 :
                    // xquery/XMLLexer.g:246:59: .
                    this.matchAny(); 


                    break;

                default :
                    break loop11;
                }
            } while (true);




            this.match("-->"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_DirCommentConstructor",

    // $ANTLR start L_DirPIConstructor
    mL_DirPIConstructor: function()  {
        try {
            var _type = this.L_DirPIConstructor;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:249:2: ({...}? => '<?' ( SU )? NCNameUnprotected ( SU ( options {greedy=false; } : ( . )* ) )? '?>' )
            // xquery/XMLLexer.g:249:4: {...}? => '<?' ( SU )? NCNameUnprotected ( SU ( options {greedy=false; } : ( . )* ) )? '?>'
            if ( !(( !this.inElem )) ) {
                throw new org.antlr.runtime.FailedPredicateException(this.input, "L_DirPIConstructor", " !this.inElem ");
            }
            this.match("<?"); 

            // xquery/XMLLexer.g:250:8: ( SU )?
            var alt12=2;
            var LA12_0 = this.input.LA(1);

            if ( ((LA12_0>='\t' && LA12_0<='\n')||LA12_0=='\r'||LA12_0==' ') ) {
                alt12=1;
            }
            switch (alt12) {
                case 1 :
                    // xquery/XMLLexer.g:250:8: SU
                    this.mSU(); 


                    break;

            }

            this.mNCNameUnprotected(); 
            // xquery/XMLLexer.g:250:30: ( SU ( options {greedy=false; } : ( . )* ) )?
            var alt14=2;
            var LA14_0 = this.input.LA(1);

            if ( ((LA14_0>='\t' && LA14_0<='\n')||LA14_0=='\r'||LA14_0==' ') ) {
                alt14=1;
            }
            switch (alt14) {
                case 1 :
                    // xquery/XMLLexer.g:250:31: SU ( options {greedy=false; } : ( . )* )
                    this.mSU(); 
                    // xquery/XMLLexer.g:250:34: ( options {greedy=false; } : ( . )* )
                    // xquery/XMLLexer.g:250:61: ( . )*
                    // xquery/XMLLexer.g:250:61: ( . )*
                    loop13:
                    do {
                        var alt13=2;
                        var LA13_0 = this.input.LA(1);

                        if ( (LA13_0=='?') ) {
                            var LA13_1 = this.input.LA(2);

                            if ( (LA13_1=='>') ) {
                                alt13=2;
                            }
                            else if ( ((LA13_1>='\u0000' && LA13_1<='=')||(LA13_1>='?' && LA13_1<='\uFFFF')) ) {
                                alt13=1;
                            }


                        }
                        else if ( ((LA13_0>='\u0000' && LA13_0<='>')||(LA13_0>='@' && LA13_0<='\uFFFF')) ) {
                            alt13=1;
                        }


                        switch (alt13) {
                        case 1 :
                            // xquery/XMLLexer.g:250:61: .
                            this.matchAny(); 


                            break;

                        default :
                            break loop13;
                        }
                    } while (true);






                    break;

            }

            this.match("?>"); 




            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "L_DirPIConstructor",

    // $ANTLR start SU
    mSU: function()  {
        try {
            // xquery/XMLLexer.g:254:2: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
            // xquery/XMLLexer.g:254:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
            // xquery/XMLLexer.g:254:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
            var cnt15=0;
            loop15:
            do {
                var alt15=2;
                var LA15_0 = this.input.LA(1);

                if ( ((LA15_0>='\t' && LA15_0<='\n')||LA15_0=='\r'||LA15_0==' ') ) {
                    alt15=1;
                }


                switch (alt15) {
                case 1 :
                    // xquery/XMLLexer.g:
                    if ( (this.input.LA(1)>='\t' && this.input.LA(1)<='\n')||this.input.LA(1)=='\r'||this.input.LA(1)==' ' ) {
                        this.input.consume();

                    }
                    else {
                        var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
                        this.recover(mse);
                        throw mse;}



                    break;

                default :
                    if ( cnt15 >= 1 ) {
                        break loop15;
                    }
                        var eee = new org.antlr.runtime.EarlyExitException(15, this.input);
                        throw eee;
                }
                cnt15++;
            } while (true);




        }
        finally {
        }
    },
    // $ANTLR end "SU",

    // $ANTLR start COLON
    mCOLON: function()  {
        try {
            var _type = this.COLON;
            var _channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
            // xquery/XMLLexer.g:257:7: ( ':' )
            // xquery/XMLLexer.g:257:9: ':'
            this.match(':'); 



            this.state.type = _type;
            this.state.channel = _channel;
        }
        finally {
        }
    },
    // $ANTLR end "COLON",

    mTokens: function() {
        // xquery/XMLLexer.g:1:8: ( QUOT | APOS | L_QuotAttrContentChar | L_AposAttrContentChar | L_ElementContentChar | GREATER | EMPTY_CLOSE_TAG | S | L_NCName | EQUAL | ESCAPE_APOS | ESCAPE_QUOT | ESCAPE_LBRACKET | ESCAPE_RBRACKET | LBRACKET | RBRACKET | SMALLER | CLOSE_TAG | CDATA_START | CDATA_END | L_CDataSection | L_PredefinedEntityRef | L_CharRef | L_DirCommentConstructor | L_DirPIConstructor | COLON )
        var alt16=26;
        alt16 = this.dfa16.predict(this.input);
        switch (alt16) {
            case 1 :
                // xquery/XMLLexer.g:1:10: QUOT
                this.mQUOT(); 


                break;
            case 2 :
                // xquery/XMLLexer.g:1:15: APOS
                this.mAPOS(); 


                break;
            case 3 :
                // xquery/XMLLexer.g:1:20: L_QuotAttrContentChar
                this.mL_QuotAttrContentChar(); 


                break;
            case 4 :
                // xquery/XMLLexer.g:1:42: L_AposAttrContentChar
                this.mL_AposAttrContentChar(); 


                break;
            case 5 :
                // xquery/XMLLexer.g:1:64: L_ElementContentChar
                this.mL_ElementContentChar(); 


                break;
            case 6 :
                // xquery/XMLLexer.g:1:85: GREATER
                this.mGREATER(); 


                break;
            case 7 :
                // xquery/XMLLexer.g:1:93: EMPTY_CLOSE_TAG
                this.mEMPTY_CLOSE_TAG(); 


                break;
            case 8 :
                // xquery/XMLLexer.g:1:109: S
                this.mS(); 


                break;
            case 9 :
                // xquery/XMLLexer.g:1:111: L_NCName
                this.mL_NCName(); 


                break;
            case 10 :
                // xquery/XMLLexer.g:1:120: EQUAL
                this.mEQUAL(); 


                break;
            case 11 :
                // xquery/XMLLexer.g:1:126: ESCAPE_APOS
                this.mESCAPE_APOS(); 


                break;
            case 12 :
                // xquery/XMLLexer.g:1:138: ESCAPE_QUOT
                this.mESCAPE_QUOT(); 


                break;
            case 13 :
                // xquery/XMLLexer.g:1:150: ESCAPE_LBRACKET
                this.mESCAPE_LBRACKET(); 


                break;
            case 14 :
                // xquery/XMLLexer.g:1:166: ESCAPE_RBRACKET
                this.mESCAPE_RBRACKET(); 


                break;
            case 15 :
                // xquery/XMLLexer.g:1:182: LBRACKET
                this.mLBRACKET(); 


                break;
            case 16 :
                // xquery/XMLLexer.g:1:191: RBRACKET
                this.mRBRACKET(); 


                break;
            case 17 :
                // xquery/XMLLexer.g:1:200: SMALLER
                this.mSMALLER(); 


                break;
            case 18 :
                // xquery/XMLLexer.g:1:208: CLOSE_TAG
                this.mCLOSE_TAG(); 


                break;
            case 19 :
                // xquery/XMLLexer.g:1:218: CDATA_START
                this.mCDATA_START(); 


                break;
            case 20 :
                // xquery/XMLLexer.g:1:230: CDATA_END
                this.mCDATA_END(); 


                break;
            case 21 :
                // xquery/XMLLexer.g:1:240: L_CDataSection
                this.mL_CDataSection(); 


                break;
            case 22 :
                // xquery/XMLLexer.g:1:255: L_PredefinedEntityRef
                this.mL_PredefinedEntityRef(); 


                break;
            case 23 :
                // xquery/XMLLexer.g:1:277: L_CharRef
                this.mL_CharRef(); 


                break;
            case 24 :
                // xquery/XMLLexer.g:1:287: L_DirCommentConstructor
                this.mL_DirCommentConstructor(); 


                break;
            case 25 :
                // xquery/XMLLexer.g:1:311: L_DirPIConstructor
                this.mL_DirPIConstructor(); 


                break;
            case 26 :
                // xquery/XMLLexer.g:1:330: COLON
                this.mCOLON(); 


                break;

        }

    }

}, true); // important to pass true to overwrite default implementations

org.antlr.lang.augmentObject(XMLLexer, {
    DFA16_eotS:
        "\u0001\uffff\u0001\u0010\u0001\u0013\u0001\u0014\u0001\u0016\u0001"+
    "\u0017\u0001\u0018\u0001\u001a\u0001\u0016\u0001\u001d\u0001\u001f\u0001"+
    "\u0023\u0001\u0024\u0001\uffff\u0001\u0016\u0001\u0027\u0002\uffff\u0001"+
    "\u0029\u0002\uffff\u0001\u002e\u0003\uffff\u0001\u0018\u0001\uffff\u0001"+
    "\u0016\u0016\uffff\u0001\u0039\u000d\uffff\u0001\u0041\u0002\uffff",
    DFA16_eofS:
        "\u0043\uffff",
    DFA16_minS:
        "\u0009\u0009\u0001\u007b\u0001\u007d\u0001\u0021\u0001\u0009\u0001"+
    "\u0023\u0002\u0009\u0001\u0000\u0001\uffff\u0001\u0009\u0002\u0000\u0001"+
    "\u0009\u0003\u0000\u0001\u0009\u0001\u0000\u0001\u0009\u0005\uffff\u0001"+
    "\u002d\u0002\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u0001\uffff\u0001"+
    "\u0000\u0004\uffff\u0001\u0000\u0003\uffff\u0001\u0009\u0001\u0043\u0005"+
    "\uffff\u0001\u0000\u0001\u0044\u0001\uffff\u0001\u0041\u0001\u0054\u0001"+
    "\u0041\u0001\u005b\u0001\u0000\u0002\uffff",
    DFA16_maxS:
        "\u0009\ufffd\u0001\u007b\u0001\u007d\u0001\u003f\u0001\ufffd\u0001"+
    "\u0071\u0002\ufffd\u0001\u0000\u0001\uffff\u0001\ufffd\u0002\u0000\u0001"+
    "\ufffd\u0003\u0000\u0001\ufffd\u0001\u0000\u0001\ufffd\u0005\uffff\u0001"+
    "\u005b\u0002\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u0001\uffff\u0001"+
    "\u0000\u0004\uffff\u0001\u0000\u0003\uffff\u0001\ufffd\u0001\u0043\u0005"+
    "\uffff\u0001\u0000\u0001\u0044\u0001\uffff\u0001\u0041\u0001\u0054\u0001"+
    "\u0041\u0001\u005b\u0001\uffff\u0002\uffff",
    DFA16_acceptS:
        "\u0011\uffff\u0001\u0005\u000a\uffff\u0001\u000d\u0001\u000f\u0001"+
    "\u000e\u0001\u0010\u0001\u0012\u0001\uffff\u0001\u0019\u0001\u0011\u0001"+
    "\uffff\u0001\u0017\u0001\u0016\u0001\uffff\u0001\u0001\u0001\uffff\u0001"+
    "\u0002\u0001\u0003\u0001\u0004\u0001\u0006\u0001\uffff\u0001\u0008\u0001"+
    "\u0009\u0001\u000a\u0002\uffff\u0001\u0018\u0001\u001a\u0001\u000c\u0001"+
    "\u000b\u0001\u0007\u0002\uffff\u0001\u0014\u0005\uffff\u0001\u0013\u0001"+
    "\u0015",
    DFA16_specialS:
        "\u0001\u0000\u0001\u001f\u0001\u0022\u0001\u0004\u0001\u000d\u0001"+
    "\u001e\u0001\u0015\u0001\u0002\u0001\u000b\u0001\u0021\u0001\u0005\u0001"+
    "\u0011\u0001\u001b\u0001\u0020\u0001\u000c\u0001\u001a\u0001\u0009\u0001"+
    "\uffff\u0001\u0010\u0001\u000a\u0001\u001d\u0001\u0016\u0001\u000f\u0001"+
    "\u0018\u0001\u0019\u0001\u0003\u0001\u0017\u0001\u0008\u0005\uffff\u0001"+
    "\u0012\u0002\uffff\u0001\u000e\u0002\uffff\u0001\u0006\u0001\uffff\u0001"+
    "\u0007\u0004\uffff\u0001\u001c\u0003\uffff\u0001\u0013\u0006\uffff\u0001"+
    "\u0014\u0006\uffff\u0001\u0001\u0002\uffff}>",
    DFA16_transitionS: [
            "\u0002\u0005\u0002\uffff\u0001\u0005\u0012\uffff\u0001\u0005"+
            "\u0001\u000e\u0001\u0001\u0003\u000e\u0001\u000d\u0001\u0002"+
            "\u0007\u000e\u0001\u0004\u000a\u000e\u0001\u000c\u0001\u000e"+
            "\u0001\u000b\u0001\u0007\u0001\u0003\u0002\u000e\u001a\u0006"+
            "\u0002\u000e\u0001\u0008\u0001\u000e\u0001\u0006\u0001\u000e"+
            "\u001a\u0006\u0001\u0009\u0001\u000e\u0001\u000a\ud782\u000e"+
            "\u0800\uffff\u1ffe\u000e",
            "\u0002\u0011\u0002\uffff\u0001\u0011\u0012\uffff\u0002\u0011"+
            "\u0001\u000f\u0003\u0011\u0001\uffff\u0015\u0011\u0001\uffff"+
            "\u003e\u0011\u0001\uffff\u0001\u0011\u0001\uffff\ud782\u0011"+
            "\u0800\uffff\u1ffe\u0011",
            "\u0002\u0011\u0002\uffff\u0001\u0011\u0012\uffff\u0006\u0011"+
            "\u0001\uffff\u0001\u0012\u0014\u0011\u0001\uffff\u003e\u0011"+
            "\u0001\uffff\u0001\u0011\u0001\uffff\ud782\u0011\u0800\uffff"+
            "\u1ffe\u0011",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u003e\u000e\u0001\uffff\u0001\u000e\u0001\uffff"+
            "\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u0001\u000e\u0001\u0015\u003c\u000e\u0001\uffff"+
            "\u0001\u000e\u0001\uffff\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0002\u0005\u0002\uffff\u0001\u0005\u0012\uffff\u0001\u0005"+
            "\u0001\u000e\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011"+
            "\u0014\u000e\u0001\uffff\u003e\u000e\u0001\uffff\u0001\u000e"+
            "\u0001\uffff\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0005\u000e"+
            "\u0002\u0019\u0001\u000e\u000a\u0019\u0002\u000e\u0001\uffff"+
            "\u0004\u000e\u001a\u0019\u0004\u000e\u0001\u0019\u0001\u000e"+
            "\u001a\u0019\u0001\uffff\u0001\u000e\u0001\uffff\ud782\u000e"+
            "\u0800\uffff\u1ffe\u000e",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u003e\u000e\u0001\uffff\u0001\u000e\u0001\uffff"+
            "\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u0020\u000e\u0001\u001b\u001d\u000e\u0001\uffff"+
            "\u0001\u000e\u0001\uffff\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0001\u001c",
            "\u0001\u001e",
            "\u0001\u0021\u000d\uffff\u0001\u0020\u000f\uffff\u0001\u0022",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u003e\u000e\u0001\uffff\u0001\u000e\u0001\uffff"+
            "\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0001\u0025\u003d\uffff\u0001\u0026\u0005\uffff\u0001\u0026"+
            "\u0004\uffff\u0001\u0026\u0004\uffff\u0001\u0026",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u003e\u000e\u0001\uffff\u0001\u000e\u0001\uffff"+
            "\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0002\u0011\u0002\uffff\u0001\u0011\u0012\uffff\u0006\u0011"+
            "\u0001\uffff\u0015\u0011\u0001\uffff\u003e\u0011\u0001\uffff"+
            "\u0001\u0011\u0001\uffff\ud782\u0011\u0800\uffff\u1ffe\u0011",
            "\u0001\uffff",
            "",
            "\u0002\u0011\u0002\uffff\u0001\u0011\u0012\uffff\u0006\u0011"+
            "\u0001\uffff\u0015\u0011\u0001\uffff\u003e\u0011\u0001\uffff"+
            "\u0001\u0011\u0001\uffff\ud782\u0011\u0800\uffff\u1ffe\u0011",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u003e\u000e\u0001\uffff\u0001\u000e\u0001\uffff"+
            "\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0001\uffff",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0005\u000e"+
            "\u0002\u0019\u0001\u000e\u000a\u0019\u0002\u000e\u0001\uffff"+
            "\u0004\u000e\u001a\u0019\u0004\u000e\u0001\u0019\u0001\u000e"+
            "\u001a\u0019\u0001\uffff\u0001\u000e\u0001\uffff\ud782\u000e"+
            "\u0800\uffff\u1ffe\u000e",
            "\u0001\uffff",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u0001\u000e\u0001\u0032\u003c\u000e\u0001\uffff"+
            "\u0001\u000e\u0001\uffff\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "",
            "",
            "",
            "",
            "",
            "\u0001\u0034\u002d\uffff\u0001\u0033",
            "",
            "",
            "\u0001\uffff",
            "",
            "",
            "\u0001\uffff",
            "",
            "\u0001\uffff",
            "",
            "",
            "",
            "",
            "\u0001\uffff",
            "",
            "",
            "",
            "\u0002\u000e\u0002\uffff\u0001\u000e\u0012\uffff\u0002\u000e"+
            "\u0001\u0011\u0003\u000e\u0001\uffff\u0001\u0011\u0014\u000e"+
            "\u0001\uffff\u003e\u000e\u0001\uffff\u0001\u000e\u0001\uffff"+
            "\ud782\u000e\u0800\uffff\u1ffe\u000e",
            "\u0001\u003a",
            "",
            "",
            "",
            "",
            "",
            "\u0001\uffff",
            "\u0001\u003c",
            "",
            "\u0001\u003d",
            "\u0001\u003e",
            "\u0001\u003f",
            "\u0001\u0040",
            "\u0000\u0042",
            "",
            ""
    ]
});

org.antlr.lang.augmentObject(XMLLexer, {
    DFA16_eot:
        org.antlr.runtime.DFA.unpackEncodedString(XMLLexer.DFA16_eotS),
    DFA16_eof:
        org.antlr.runtime.DFA.unpackEncodedString(XMLLexer.DFA16_eofS),
    DFA16_min:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XMLLexer.DFA16_minS),
    DFA16_max:
        org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(XMLLexer.DFA16_maxS),
    DFA16_accept:
        org.antlr.runtime.DFA.unpackEncodedString(XMLLexer.DFA16_acceptS),
    DFA16_special:
        org.antlr.runtime.DFA.unpackEncodedString(XMLLexer.DFA16_specialS),
    DFA16_transition: (function() {
        var a = [],
            i,
            numStates = XMLLexer.DFA16_transitionS.length;
        for (i=0; i<numStates; i++) {
            a.push(org.antlr.runtime.DFA.unpackEncodedString(XMLLexer.DFA16_transitionS[i]));
        }
        return a;
    })()
});

XMLLexer.DFA16 = function(recognizer) {
    this.recognizer = recognizer;
    this.decisionNumber = 16;
    this.eot = XMLLexer.DFA16_eot;
    this.eof = XMLLexer.DFA16_eof;
    this.min = XMLLexer.DFA16_min;
    this.max = XMLLexer.DFA16_max;
    this.accept = XMLLexer.DFA16_accept;
    this.special = XMLLexer.DFA16_special;
    this.transition = XMLLexer.DFA16_transition;
};

org.antlr.lang.extend(XMLLexer.DFA16, org.antlr.runtime.DFA, {
    getDescription: function() {
        return "1:1: Tokens : ( QUOT | APOS | L_QuotAttrContentChar | L_AposAttrContentChar | L_ElementContentChar | GREATER | EMPTY_CLOSE_TAG | S | L_NCName | EQUAL | ESCAPE_APOS | ESCAPE_QUOT | ESCAPE_LBRACKET | ESCAPE_RBRACKET | LBRACKET | RBRACKET | SMALLER | CLOSE_TAG | CDATA_START | CDATA_END | L_CDataSection | L_PredefinedEntityRef | L_CharRef | L_DirCommentConstructor | L_DirPIConstructor | COLON );";
    },
    specialStateTransition: function(s, input) {
        var _s = s;
        /* bind to recognizer so semantic predicates can be evaluated */
        var retval = (function(s, input) {
            switch ( s ) {
                        case 0 : 
                            var LA16_0 = input.LA(1);

                             
                            var index16_0 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_0=='\"') && ((( this.inQuotAttr )||( this.inElem || this.inQuotAttr )||( !this.inElem )))) {s = 1;}

                            else if ( (LA16_0=='\'') && ((( this.inElem || this.inAposAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 2;}

                            else if ( (LA16_0=='>') && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 3;}

                            else if ( (LA16_0=='/') && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 4;}

                            else if ( ((LA16_0>='\t' && LA16_0<='\n')||LA16_0=='\r'||LA16_0==' ') && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 5;}

                            else if ( ((LA16_0>='A' && LA16_0<='Z')||LA16_0=='_'||(LA16_0>='a' && LA16_0<='z')) && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 6;}

                            else if ( (LA16_0=='=') && ((( this.inElem  )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 7;}

                            else if ( (LA16_0==']') ) {s = 8;}

                            else if ( (LA16_0=='{') && (( !this.inElem || this.inAposAttr || this.inQuotAttr ))) {s = 9;}

                            else if ( (LA16_0=='}') && (( !this.inElem || this.inAposAttr || this.inQuotAttr ))) {s = 10;}

                            else if ( (LA16_0=='<') ) {s = 11;}

                            else if ( (LA16_0==':') ) {s = 12;}

                            else if ( (LA16_0=='&') ) {s = 13;}

                            else if ( (LA16_0=='!'||(LA16_0>='#' && LA16_0<='%')||(LA16_0>='(' && LA16_0<='.')||(LA16_0>='0' && LA16_0<='9')||LA16_0==';'||(LA16_0>='?' && LA16_0<='@')||(LA16_0>='[' && LA16_0<='\\')||LA16_0=='^'||LA16_0=='`'||LA16_0=='|'||(LA16_0>='~' && LA16_0<='\uD7FF')||(LA16_0>='\uE000' && LA16_0<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                             
                            input.seek(index16_0);
                            if ( s>=0 ) return s;
                            break;
                        case 1 : 
                            var LA16_64 = input.LA(1);

                             
                            var index16_64 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_64>='\u0000' && LA16_64<='\uFFFF')) && (( !this.inElem ))) {s = 66;}

                            else s = 65;

                             
                            input.seek(index16_64);
                            if ( s>=0 ) return s;
                            break;
                        case 2 : 
                            var LA16_7 = input.LA(1);

                             
                            var index16_7 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_7>='\t' && LA16_7<='\n')||LA16_7=='\r'||(LA16_7>=' ' && LA16_7<='!')||(LA16_7>='#' && LA16_7<='%')||(LA16_7>='(' && LA16_7<=';')||(LA16_7>='=' && LA16_7<='z')||LA16_7=='|'||(LA16_7>='~' && LA16_7<='\uD7FF')||(LA16_7>='\uE000' && LA16_7<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_7=='\"'||LA16_7=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 26;

                             
                            input.seek(index16_7);
                            if ( s>=0 ) return s;
                            break;
                        case 3 : 
                            var LA16_25 = input.LA(1);

                             
                            var index16_25 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_25>='-' && LA16_25<='.')||(LA16_25>='0' && LA16_25<='9')||(LA16_25>='A' && LA16_25<='Z')||LA16_25=='_'||(LA16_25>='a' && LA16_25<='z')) && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 25;}

                            else if ( (LA16_25=='\"'||LA16_25=='\'') && (( !this.inElem ))) {s = 17;}

                            else if ( ((LA16_25>='\t' && LA16_25<='\n')||LA16_25=='\r'||(LA16_25>=' ' && LA16_25<='!')||(LA16_25>='#' && LA16_25<='%')||(LA16_25>='(' && LA16_25<=',')||LA16_25=='/'||(LA16_25>=':' && LA16_25<=';')||(LA16_25>='=' && LA16_25<='@')||(LA16_25>='[' && LA16_25<='^')||LA16_25=='`'||LA16_25=='|'||(LA16_25>='~' && LA16_25<='\uD7FF')||(LA16_25>='\uE000' && LA16_25<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else s = 24;

                             
                            input.seek(index16_25);
                            if ( s>=0 ) return s;
                            break;
                        case 4 : 
                            var LA16_3 = input.LA(1);

                             
                            var index16_3 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_3>='\t' && LA16_3<='\n')||LA16_3=='\r'||(LA16_3>=' ' && LA16_3<='!')||(LA16_3>='#' && LA16_3<='%')||(LA16_3>='(' && LA16_3<=';')||(LA16_3>='=' && LA16_3<='z')||LA16_3=='|'||(LA16_3>='~' && LA16_3<='\uD7FF')||(LA16_3>='\uE000' && LA16_3<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_3=='\"'||LA16_3=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 20;

                             
                            input.seek(index16_3);
                            if ( s>=0 ) return s;
                            break;
                        case 5 : 
                            var LA16_10 = input.LA(1);

                             
                            var index16_10 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_10=='}') && (( !this.inElem || this.inAposAttr || this.inQuotAttr ))) {s = 30;}

                            else s = 31;

                             
                            input.seek(index16_10);
                            if ( s>=0 ) return s;
                            break;
                        case 6 : 
                            var LA16_39 = input.LA(1);

                             
                            var index16_39 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (( this.inQuotAttr )) ) {s = 54;}

                             
                            input.seek(index16_39);
                            if ( s>=0 ) return s;
                            break;
                        case 7 : 
                            var LA16_41 = input.LA(1);

                             
                            var index16_41 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (( this.inAposAttr )) ) {s = 55;}

                             
                            input.seek(index16_41);
                            if ( s>=0 ) return s;
                            break;
                        case 8 : 
                            var LA16_27 = input.LA(1);

                             
                            var index16_27 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_27=='>') ) {s = 50;}

                            else if ( ((LA16_27>='\t' && LA16_27<='\n')||LA16_27=='\r'||(LA16_27>=' ' && LA16_27<='!')||(LA16_27>='#' && LA16_27<='%')||(LA16_27>='(' && LA16_27<=';')||LA16_27=='='||(LA16_27>='?' && LA16_27<='z')||LA16_27=='|'||(LA16_27>='~' && LA16_27<='\uD7FF')||(LA16_27>='\uE000' && LA16_27<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_27=='\"'||LA16_27=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 22;

                             
                            input.seek(index16_27);
                            if ( s>=0 ) return s;
                            break;
                        case 9 : 
                            var LA16_16 = input.LA(1);

                             
                            var index16_16 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inElem || this.inQuotAttr )) ) {s = 40;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                             
                            input.seek(index16_16);
                            if ( s>=0 ) return s;
                            break;
                        case 10 : 
                            var LA16_19 = input.LA(1);

                             
                            var index16_19 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inElem || this.inAposAttr )) ) {s = 42;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                             
                            input.seek(index16_19);
                            if ( s>=0 ) return s;
                            break;
                        case 11 : 
                            var LA16_8 = input.LA(1);

                             
                            var index16_8 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_8==']') ) {s = 27;}

                            else if ( ((LA16_8>='\t' && LA16_8<='\n')||LA16_8=='\r'||(LA16_8>=' ' && LA16_8<='!')||(LA16_8>='#' && LA16_8<='%')||(LA16_8>='(' && LA16_8<=';')||(LA16_8>='=' && LA16_8<='\\')||(LA16_8>='^' && LA16_8<='z')||LA16_8=='|'||(LA16_8>='~' && LA16_8<='\uD7FF')||(LA16_8>='\uE000' && LA16_8<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_8=='\"'||LA16_8=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 22;

                             
                            input.seek(index16_8);
                            if ( s>=0 ) return s;
                            break;
                        case 12 : 
                            var LA16_14 = input.LA(1);

                             
                            var index16_14 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_14>='\t' && LA16_14<='\n')||LA16_14=='\r'||(LA16_14>=' ' && LA16_14<='!')||(LA16_14>='#' && LA16_14<='%')||(LA16_14>='(' && LA16_14<=';')||(LA16_14>='=' && LA16_14<='z')||LA16_14=='|'||(LA16_14>='~' && LA16_14<='\uD7FF')||(LA16_14>='\uE000' && LA16_14<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_14=='\"'||LA16_14=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 22;

                             
                            input.seek(index16_14);
                            if ( s>=0 ) return s;
                            break;
                        case 13 : 
                            var LA16_4 = input.LA(1);

                             
                            var index16_4 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_4=='>') && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 21;}

                            else if ( ((LA16_4>='\t' && LA16_4<='\n')||LA16_4=='\r'||(LA16_4>=' ' && LA16_4<='!')||(LA16_4>='#' && LA16_4<='%')||(LA16_4>='(' && LA16_4<=';')||LA16_4=='='||(LA16_4>='?' && LA16_4<='z')||LA16_4=='|'||(LA16_4>='~' && LA16_4<='\uD7FF')||(LA16_4>='\uE000' && LA16_4<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_4=='\"'||LA16_4=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 22;

                             
                            input.seek(index16_4);
                            if ( s>=0 ) return s;
                            break;
                        case 14 : 
                            var LA16_36 = input.LA(1);

                             
                            var index16_36 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (true) ) {s = 53;}

                             
                            input.seek(index16_36);
                            if ( s>=0 ) return s;
                            break;
                        case 15 : 
                            var LA16_22 = input.LA(1);

                             
                            var index16_22 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                             
                            input.seek(index16_22);
                            if ( s>=0 ) return s;
                            break;
                        case 16 : 
                            var LA16_18 = input.LA(1);

                             
                            var index16_18 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_18>='\t' && LA16_18<='\n')||LA16_18=='\r'||(LA16_18>=' ' && LA16_18<='%')||(LA16_18>='\'' && LA16_18<=';')||(LA16_18>='=' && LA16_18<='z')||LA16_18=='|'||(LA16_18>='~' && LA16_18<='\uD7FF')||(LA16_18>='\uE000' && LA16_18<='\uFFFD')) && (( !this.inElem ))) {s = 17;}

                            else s = 41;

                             
                            input.seek(index16_18);
                            if ( s>=0 ) return s;
                            break;
                        case 17 : 
                            var LA16_11 = input.LA(1);

                             
                            var index16_11 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_11=='/') && (( !this.inElem ))) {s = 32;}

                            else if ( (LA16_11=='!') ) {s = 33;}

                            else if ( (LA16_11=='?') && (( !this.inElem ))) {s = 34;}

                            else s = 35;

                             
                            input.seek(index16_11);
                            if ( s>=0 ) return s;
                            break;
                        case 18 : 
                            var LA16_33 = input.LA(1);

                             
                            var index16_33 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_33=='[') ) {s = 51;}

                            else if ( (LA16_33=='-') && (( !this.inElem ))) {s = 52;}

                             
                            input.seek(index16_33);
                            if ( s>=0 ) return s;
                            break;
                        case 19 : 
                            var LA16_50 = input.LA(1);

                             
                            var index16_50 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_50>='\t' && LA16_50<='\n')||LA16_50=='\r'||(LA16_50>=' ' && LA16_50<='!')||(LA16_50>='#' && LA16_50<='%')||(LA16_50>='(' && LA16_50<=';')||(LA16_50>='=' && LA16_50<='z')||LA16_50=='|'||(LA16_50>='~' && LA16_50<='\uD7FF')||(LA16_50>='\uE000' && LA16_50<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_50=='\"'||LA16_50=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 57;

                             
                            input.seek(index16_50);
                            if ( s>=0 ) return s;
                            break;
                        case 20 : 
                            var LA16_57 = input.LA(1);

                             
                            var index16_57 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (true) ) {s = 59;}

                             
                            input.seek(index16_57);
                            if ( s>=0 ) return s;
                            break;
                        case 21 : 
                            var LA16_6 = input.LA(1);

                             
                            var index16_6 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_6>='-' && LA16_6<='.')||(LA16_6>='0' && LA16_6<='9')||(LA16_6>='A' && LA16_6<='Z')||LA16_6=='_'||(LA16_6>='a' && LA16_6<='z')) && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 25;}

                            else if ( (LA16_6=='\"'||LA16_6=='\'') && (( !this.inElem ))) {s = 17;}

                            else if ( ((LA16_6>='\t' && LA16_6<='\n')||LA16_6=='\r'||(LA16_6>=' ' && LA16_6<='!')||(LA16_6>='#' && LA16_6<='%')||(LA16_6>='(' && LA16_6<=',')||LA16_6=='/'||(LA16_6>=':' && LA16_6<=';')||(LA16_6>='=' && LA16_6<='@')||(LA16_6>='[' && LA16_6<='^')||LA16_6=='`'||LA16_6=='|'||(LA16_6>='~' && LA16_6<='\uD7FF')||(LA16_6>='\uE000' && LA16_6<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else s = 24;

                             
                            input.seek(index16_6);
                            if ( s>=0 ) return s;
                            break;
                        case 22 : 
                            var LA16_21 = input.LA(1);

                             
                            var index16_21 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_21>='\t' && LA16_21<='\n')||LA16_21=='\r'||(LA16_21>=' ' && LA16_21<='!')||(LA16_21>='#' && LA16_21<='%')||(LA16_21>='(' && LA16_21<=';')||(LA16_21>='=' && LA16_21<='z')||LA16_21=='|'||(LA16_21>='~' && LA16_21<='\uD7FF')||(LA16_21>='\uE000' && LA16_21<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_21=='\"'||LA16_21=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 46;

                             
                            input.seek(index16_21);
                            if ( s>=0 ) return s;
                            break;
                        case 23 : 
                            var LA16_26 = input.LA(1);

                             
                            var index16_26 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (( this.inElem  )) ) {s = 49;}

                             
                            input.seek(index16_26);
                            if ( s>=0 ) return s;
                            break;
                        case 24 : 
                            var LA16_23 = input.LA(1);

                             
                            var index16_23 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (( this.inElem )) ) {s = 47;}

                             
                            input.seek(index16_23);
                            if ( s>=0 ) return s;
                            break;
                        case 25 : 
                            var LA16_24 = input.LA(1);

                             
                            var index16_24 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (( this.inElem )) ) {s = 48;}

                             
                            input.seek(index16_24);
                            if ( s>=0 ) return s;
                            break;
                        case 26 : 
                            var LA16_15 = input.LA(1);

                             
                            var index16_15 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_15>='\t' && LA16_15<='\n')||LA16_15=='\r'||(LA16_15>=' ' && LA16_15<='%')||(LA16_15>='\'' && LA16_15<=';')||(LA16_15>='=' && LA16_15<='z')||LA16_15=='|'||(LA16_15>='~' && LA16_15<='\uD7FF')||(LA16_15>='\uE000' && LA16_15<='\uFFFD')) && (( !this.inElem ))) {s = 17;}

                            else s = 39;

                             
                            input.seek(index16_15);
                            if ( s>=0 ) return s;
                            break;
                        case 27 : 
                            var LA16_12 = input.LA(1);

                             
                            var index16_12 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_12>='\t' && LA16_12<='\n')||LA16_12=='\r'||(LA16_12>=' ' && LA16_12<='!')||(LA16_12>='#' && LA16_12<='%')||(LA16_12>='(' && LA16_12<=';')||(LA16_12>='=' && LA16_12<='z')||LA16_12=='|'||(LA16_12>='~' && LA16_12<='\uD7FF')||(LA16_12>='\uE000' && LA16_12<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else if ( (LA16_12=='\"'||LA16_12=='\'') && (( !this.inElem ))) {s = 17;}

                            else s = 36;

                             
                            input.seek(index16_12);
                            if ( s>=0 ) return s;
                            break;
                        case 28 : 
                            var LA16_46 = input.LA(1);

                             
                            var index16_46 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (( this.inElem )) ) {s = 56;}

                             
                            input.seek(index16_46);
                            if ( s>=0 ) return s;
                            break;
                        case 29 : 
                            var LA16_20 = input.LA(1);

                             
                            var index16_20 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (( this.inQuotAttr )) ) {s = 43;}

                            else if ( (( this.inAposAttr )) ) {s = 44;}

                            else if ( (( !this.inElem )) ) {s = 17;}

                            else if ( (( this.inElem )) ) {s = 45;}

                             
                            input.seek(index16_20);
                            if ( s>=0 ) return s;
                            break;
                        case 30 : 
                            var LA16_5 = input.LA(1);

                             
                            var index16_5 = input.index();
                            input.rewind();
                            s = -1;
                            if ( ((LA16_5>='\t' && LA16_5<='\n')||LA16_5=='\r'||LA16_5==' ') && ((( this.inElem )||( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 5;}

                            else if ( (LA16_5=='\"'||LA16_5=='\'') && (( !this.inElem ))) {s = 17;}

                            else if ( (LA16_5=='!'||(LA16_5>='#' && LA16_5<='%')||(LA16_5>='(' && LA16_5<=';')||(LA16_5>='=' && LA16_5<='z')||LA16_5=='|'||(LA16_5>='~' && LA16_5<='\uD7FF')||(LA16_5>='\uE000' && LA16_5<='\uFFFD')) && ((( this.inQuotAttr )||( this.inAposAttr )||( !this.inElem )))) {s = 14;}

                            else s = 23;

                             
                            input.seek(index16_5);
                            if ( s>=0 ) return s;
                            break;
                        case 31 : 
                            var LA16_1 = input.LA(1);

                             
                            var index16_1 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_1=='\"') && ((( this.inQuotAttr )||( !this.inElem )))) {s = 15;}

                            else if ( ((LA16_1>='\t' && LA16_1<='\n')||LA16_1=='\r'||(LA16_1>=' ' && LA16_1<='!')||(LA16_1>='#' && LA16_1<='%')||(LA16_1>='\'' && LA16_1<=';')||(LA16_1>='=' && LA16_1<='z')||LA16_1=='|'||(LA16_1>='~' && LA16_1<='\uD7FF')||(LA16_1>='\uE000' && LA16_1<='\uFFFD')) && (( !this.inElem ))) {s = 17;}

                            else s = 16;

                             
                            input.seek(index16_1);
                            if ( s>=0 ) return s;
                            break;
                        case 32 : 
                            var LA16_13 = input.LA(1);

                             
                            var index16_13 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_13=='#') ) {s = 37;}

                            else if ( (LA16_13=='a'||LA16_13=='g'||LA16_13=='l'||LA16_13=='q') && (( !this.inElem || this.inAposAttr || this.inQuotAttr ))) {s = 38;}

                             
                            input.seek(index16_13);
                            if ( s>=0 ) return s;
                            break;
                        case 33 : 
                            var LA16_9 = input.LA(1);

                             
                            var index16_9 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_9=='{') && (( !this.inElem || this.inAposAttr || this.inQuotAttr ))) {s = 28;}

                            else s = 29;

                             
                            input.seek(index16_9);
                            if ( s>=0 ) return s;
                            break;
                        case 34 : 
                            var LA16_2 = input.LA(1);

                             
                            var index16_2 = input.index();
                            input.rewind();
                            s = -1;
                            if ( (LA16_2=='\'') && ((( this.inAposAttr )||( !this.inElem )))) {s = 18;}

                            else if ( ((LA16_2>='\t' && LA16_2<='\n')||LA16_2=='\r'||(LA16_2>=' ' && LA16_2<='%')||(LA16_2>='(' && LA16_2<=';')||(LA16_2>='=' && LA16_2<='z')||LA16_2=='|'||(LA16_2>='~' && LA16_2<='\uD7FF')||(LA16_2>='\uE000' && LA16_2<='\uFFFD')) && (( !this.inElem ))) {s = 17;}

                            else s = 19;

                             
                            input.seek(index16_2);
                            if ( s>=0 ) return s;
                            break;
            }
        }).call(this.recognizer, s, input);
        if (!org.antlr.lang.isUndefined(retval)) {
            return retval;
        }
        var nvae =
            new org.antlr.runtime.NoViableAltException(this.getDescription(), 16, _s, input);
        this.error(nvae);
        throw nvae;
    },
    dummy: null
});
 
})();
exports.XMLLexer = XMLLexer;
});/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
define('ace/mode/xquery/XQDTParser', ['require', 'exports', 'module' , 'ace/mode/xquery/antlr3-all', 'ace/mode/xquery/XQuerySemanticHighlighter'], function(require, exports, module) {

var org =  require("./antlr3-all").org;
var XQuerySemanticHighlighter = require("./XQuerySemanticHighlighter").XQuerySemanticHighlighter;

var XQDTParser = exports.XQDTParser = function(input, state)
{
  this.highlighter = new XQuerySemanticHighlighter();
  var self = this;
  input.getTokenSource().addComment = function(start, stop) { self.highlighter.addToken(start, stop, "comment") };
  XQDTParser.superclass.constructor.call(this, input, state);
};

org.antlr.lang.extend(XQDTParser, org.antlr.runtime.Parser, {

});

});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
define('ace/mode/xquery/XQuerySemanticHighlighter', ['require', 'exports', 'module' , 'ace/mode/xquery/Position'], function(require, exports, module) {
  
  var Position = require("./Position").Position;
  var XQuerySemanticHighlighter = exports.XQuerySemanticHighlighter = function() {
    this.plain = null;
    this.source = [];
    this.lines = [];

    this.getTokens = function() {
      var result = [];
      var previousState = "start";
      for(i in this.source){
        var lineTokens = [];
        var tokens = [];
        if(this.lines[i]) {
          tokens = this.lines[i].sort(function(a, b){ return a.position.getOffset() - b.position.getOffset();  });
        }
        var sourceLine = this.source[i];
        var tokenizedLine = "";
        var cursor = 0;
        for(j in tokens)
        {
          var token = tokens[j];
          var position = token.position;
          if(position.getOffset() > cursor) {
            var value = sourceLine.substring(cursor, position.getOffset());
            tokenizedLine += value;
            lineTokens.push({
              type: "text",
              value: value
            });
          }
          cursor = position.getOffset() + position.getLength();
          value = sourceLine.substring(position.getOffset(), cursor);
          tokenizedLine += value;
          lineTokens.push({
            type: token.type,
            value: value 
          });
        }
        console.log(lineTokens);
        var nextState = "start";
        if(lineTokens.length > 0) {
          lineTokens[lineTokens.length - 1].type;
        }
        nextState = nextState != "comment" ? "start" : nextState;
        
        if(cursor < (sourceLine.length )) {
          value = sourceLine.substring(cursor);
          lineTokens.push({
             type: "text",
             value: value
          });
          tokenizedLine += value; 
        }
        //Check if the tokenized line is equal to the original one:
        if(sourceLine == tokenizedLine)
          result[i] = { line: sourceLine, startState: previousState, tokens: { tokens: lineTokens, state: nextState } };
        else {
          console.log(sourceLine);
          console.log(tokenizedLine);
        }
      }
      return result;
    };

    this.addToken = function(start, stop, type) {
      var before = this.plain.substring(0, start);
      var startLine = this.plain.substring(0, start).split("\n").length;
      startLine = startLine == 0 ? 0 : startLine - 1;
      
      var offset = before.lastIndexOf("\n");
      offset = offset == -1 ? start : start - before.lastIndexOf("\n") - 1;

      var cursor = start;

      var text = this.plain.substring(start, stop);

      var currentLine = startLine;
      for(var i in text)
      {
        var c = text[i];
        if(c == "\n") {
          var s = i;
          s = s < stop ? s : stop; 
          this.addPosition(new Position(currentLine, offset, s), type);
          currentLine++;
          offset = 0;
          cursor = i;
        } 
      };
      this.addPosition(new Position(currentLine, offset, stop - cursor + 1), type); 
    };
    
    this.addPosition = function(position, type)
    {
      var line = position.getLine();
      if(!this.lines[line]) {
        this.lines[line] = [];
      }
      this.lines[line].push({
        type: type,
        position: position
      });
    };

    this.setSource = function(source)
    {
      this.plain  = source.data;
      this.source = this.plain.split("\n");
    };
      //console.log("Line: " + token.getLine());
      //console.log(token.getText());
      //console.log(type);
  };
});
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *      William Candillon <wcandillon AT gmail DOT com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL. *
 * ***** END LICENSE BLOCK ***** */
define('ace/mode/xquery/Position', ['require', 'exports', 'module' ], function(require, exports, module) {
  var Position = exports.Position = function(line, offset, length)
  {
    this.line = line;
    this.offset = offset;
    this.length = length;
    
    this.getLine = function()
    {
      return this.line;
    };

    this.getOffset = function()
    {
      return this.offset;
    };

    this.getLength = function()
    {
      return this.length;
    };
  };

}); 
