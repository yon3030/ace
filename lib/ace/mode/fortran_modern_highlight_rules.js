/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2012, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/* This file was autogenerated from tm bundles\fortran.tmbundle\Syntaxes\Fortran - Modern.tmLanguage (uuid: ) */
/****************************************************************************************
 * IT MIGHT NOT BE PERFECT ...But it's a good start from an existing *.tmlanguage file. *
 * fileTypes                                                                            *
 ****************************************************************************************/

define(function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var FortranModernHighlightRules = function() {
    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used

    this.$rules = { start: 
       [ { include: 'source.fortran' },
         { todo: 
            { token: 
               [ 'meta.function.interface.operator.fortran.modern',
                 'storage.type.function.fortran',
                 'meta.function.interface.operator.fortran.modern',
                 'storage.type.fortran',
                 'meta.function.interface.operator.fortran.modern',
                 'keyword.operator.fortran',
                 'meta.function.interface.operator.fortran.modern' ],
              regex: '^(\\s*)(interface)(\\s+)(operator|assignment)(\\()(\\.[a-zA-Z0-9_]+\\.|[\\+\\-\\=\\/\\*]+)(\\))',
              caseInsensitive: true,
              push: 
               [ { token: 
                    [ 'keyword.other.fortran',
                      'meta.function.interface.operator.fortran.modern',
                      'storage.type.function.fortran' ],
                   regex: '(end)(\\s*)((?:interface)?)',
                   caseInsensitive: true,
                   next: 'pop' },
                 { include: '$self' },
                 { defaultToken: 'meta.function.interface.operator.fortran.modern' } ] },
           comment: 'Interface declaration of operator/assignments' },
         { todo: 
            { token: 
               [ 'meta.function.interface.fortran.modern',
                 'storage.type.function.fortran',
                 'meta.function.interface.fortran.modern',
                 'entity.name.function.fortran' ],
              regex: '^(\\s*)(interface)(\\s+)([A-Za-z_][A-Za-z0-9_]*)',
              caseInsensitive: true,
              push: 
               [ { token: 
                    [ 'keyword.other.fortran',
                      'meta.function.interface.fortran.modern',
                      'storage.type.function.fortran' ],
                   regex: '(end)(\\s*)((?:interface)?)',
                   caseInsensitive: true,
                   next: 'pop' },
                 { include: '$self' },
                 { defaultToken: 'meta.function.interface.fortran.modern' } ] },
           comment: 'Interface declaration of function/subroutines' },
         { todo: 
            { token: 
               [ 'meta.type-definition.fortran.modern',
                 'storage.type.fortran.modern',
                 'meta.type-definition.fortran.modern',
                 'entity.name.type.fortran.modern' ],
              regex: '^(\\s*)(type)(\\s+)([a-zA-Z_][a-zA-Z0-9_]*)',
              caseInsensitive: true,
              push: 
               [ { token: 
                    [ 'keyword.other.fortran',
                      'meta.type-definition.fortran.modern',
                      'storage.type.fortran.modern',
                      'entity.name.type.end.fortran.modern' ],
                   regex: '(end)(\\s*)(?:(type))?((?:\\s+[A-Za-z_][A-Za-z0-9_]*)?)',
                   caseInsensitive: true,
                   next: 'pop' },
                 { include: '$self' },
                 { defaultToken: 'meta.type-definition.fortran.modern' } ] },
           comment: 'Type definition' },
         { token: 'punctuation.definition.comment.fortran',
           regex: '!-',
           push: 
            [ { token: 'comment.line.exclamation.mark.fortran.modern',
                regex: '$',
                next: 'pop' },
              { token: 'text', regex: '\\\\\\s*$' },
              { defaultToken: 'comment.line.exclamation.mark.fortran.modern' } ] },
         { token: 'punctuation.definition.comment.fortran',
           regex: '!',
           push: 
            [ { token: 'comment.line.exclamation.fortran.modern',
                regex: '$',
                next: 'pop' },
              { token: 'text', regex: '\\\\\\s*$' },
              { defaultToken: 'comment.line.exclamation.fortran.modern' } ] },
         { token: 'keyword.control.fortran.modern',
           regex: '\\b(?:select\\s+case|case(?:\\s+default)?|end\\s+select|use|(?:end\\s+)?forall)\\b',
           caseInsensitive: true,
           comment: 'statements controling the flow of the program' },
         { token: 'keyword.control.io.fortran.modern',
           regex: '\\b(?:access|action|advance|append|apostrophe|asis|blank|delete|delim|direct|end|eor|err|exist|file|fmt|form|formatted|iolength|iostat|keep|name|named|nextrec|new|nml|no|null|number|old|opened|pad|position|quote|read|readwrite|rec|recl|replace|scratch|sequential|size|status|undefined|unformatted|unit|unknown|write|yes|zero|namelist)(?=\\()',
           caseInsensitive: true,
           comment: 'input/output instrinsics' },
         { token: 'keyword.operator.logical.fortran.modern',
           regex: '\\b(?:\\=\\=|\\/\\=|\\>\\=|\\>|\\<|\\<\\=)\\b',
           comment: 'logical operators in symbolic format' },
         { token: 'keyword.operator.fortran.modern',
           regex: '\\%|\\=\\>',
           comment: 'operators' },
         { token: 'keyword.other.instrinsic.numeric.fortran.modern',
           regex: '\\b(?:ceiling|floor|modulo)(?=\\()',
           caseInsensitive: true,
           comment: 'numeric instrinsics' },
         { token: 'keyword.other.instrinsic.array.fortran.modern',
           regex: '\\b(?:allocate|allocated|deallocate)(?=\\()',
           caseInsensitive: true,
           comment: 'matrix/vector/array instrinsics' },
         { token: 'keyword.other.instrinsic.pointer.fortran.modern',
           regex: '\\bassociated(?=\\()',
           caseInsensitive: true,
           comment: 'pointer instrinsics' },
         { token: 'keyword.other.programming-units.fortran.modern',
           regex: '\\b(?:end\\s*)?(?:interface|procedure|module)\\b',
           caseInsensitive: true,
           comment: 'programming units' },
         { token: 'storage.type.fortran.modern',
           regex: '\\btype(?=\\s*\\()\\b(?=.*::)',
           caseInsensitive: true,
           push: 
            [ { token: 'meta.specification.fortran.modern',
                regex: '(?=!)|$',
                next: 'pop' },
              { include: '$base' },
              { defaultToken: 'meta.specification.fortran.modern' } ],
           comment: 'Line of type specification' },
         { token: 'storage.type.fortran.modern',
           regex: '\\btype(?=\\s*\\()\\b',
           caseInsensitive: true },
         { token: 'storage.modifier.fortran.modern',
           regex: '\\b(?:optional|recursive|pointer|allocatable|target|private|public)\\b',
           caseInsensitive: true } ] }
    
    this.normalizeRules();
};

FortranModernHighlightRules.metaData = { comment: 'Specificities of Fortran >= 90',
      fileTypes: [ 'f90', 'F90', 'f95', 'F95', 'f03', 'F03', 'f08', 'F08' ],
      firstLineMatch: '(?i)-[*]- mode: f90 -[*]-',
      keyEquivalent: '^~F',
      name: 'Fortran - Modern',
      scopeName: 'source.fortran.modern' }


oop.inherits(FortranModernHighlightRules, TextHighlightRules);

exports.FortranModernHighlightRules = FortranModernHighlightRules;
});